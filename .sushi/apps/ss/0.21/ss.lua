jk = jk or {}

jk.lang = jk.lang or {}

jk.lang.CharacterObject = {}

jk.lang.StringObject = {}

jk.lang.VariableReference = {}
jk.lang.VariableReference.__index = jk.lang.VariableReference
_vm:set_metatable(jk.lang.VariableReference, {})

function jk.lang.VariableReference._create()
	local v = _vm:set_metatable({}, jk.lang.VariableReference)
	return v
end

function jk.lang.VariableReference:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.VariableReference'
	self['_isType.jk.lang.VariableReference'] = true
	self.setter = nil
	self.getter = nil
end

function jk.lang.VariableReference:_construct0()
	jk.lang.VariableReference._init(self)
	return self
end

function jk.lang.VariableReference:_construct2(setter, getter)
	jk.lang.VariableReference._init(self)
	self.setter = setter
	self.getter = getter
	return self
end

function jk.lang.VariableReference:set(value)
	do self.setter(value) end
	do return self end
end

function jk.lang.VariableReference:get()
	do return self.getter() end
end

jk.lang.Closable = {}

jk.lang.LongIntegerIterator = {}

jk.lang.Iterator = {}

jk.lang.StringIterator = {}

jk.lang.Matrix = {}
jk.lang.Matrix.__index = jk.lang.Matrix
_vm:set_metatable(jk.lang.Matrix, {})

function jk.lang.Matrix._create()
	local v = _vm:set_metatable({}, jk.lang.Matrix)
	return v
end

function jk.lang.Matrix:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Matrix'
	self['_isType.jk.lang.Matrix'] = true
	self.vector = nil
	self.columnCount = 0
end

function jk.lang.Matrix:_construct0()
	jk.lang.Matrix._init(self)
	return self
end

function jk.lang.Matrix:_construct2(rowSize, columnSize)
	jk.lang.Matrix._init(self)
	self.vector = {}
	do self:setSize(rowSize, columnSize) end
	return self
end

function jk.lang.Matrix:set(row, column, val)
	if not (self.vector ~= nil) then
		do return end
	end
	if not (row >= 0 or column >= 0) then
		do return end
	end
	do
		local size = row * self.columnCount + column
		if not (_g.jk.lang.Vector:getSize(self.vector) > size) then
			do return end
		end
		do _g.jk.lang.Vector:set(self.vector, size, val) end
	end
end

function jk.lang.Matrix:get(row, column)
	if not (self.vector ~= nil) then
		do return nil end
	end
	if not (row >= 0 or column >= 0) then
		do return nil end
	end
	do
		local size = row * self.columnCount + column
		if not (_g.jk.lang.Vector:getSize(self.vector) > size) then
			do return nil end
		end
		do return _g.jk.lang.Vector:get(self.vector, size) end
	end
end

function jk.lang.Matrix:setSize(rowSize, colSize)
	if not (self.vector ~= nil) then
		do return nil end
	end
	self.columnCount = colSize
	do _g.jk.lang.Vector:setSize(self.vector, rowSize * colSize) end
	do return self end
end

function jk.lang.Matrix:getRowCount()
	if not (self.vector ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.vector) / self.columnCount end
end

function jk.lang.Matrix:getColumnCount()
	if not (self.vector ~= nil) then
		do return 0 end
	end
	do return self.columnCount end
end

jk.lang.Task = {}

jk.lang.Stack = {}
jk.lang.Stack.__index = jk.lang.Stack
_vm:set_metatable(jk.lang.Stack, {})

function jk.lang.Stack._create()
	local v = _vm:set_metatable({}, jk.lang.Stack)
	return v
end

function jk.lang.Stack:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Stack'
	self['_isType.jk.lang.Stack'] = true
	self.data = nil
end

function jk.lang.Stack:_construct0()
	jk.lang.Stack._init(self)
	self.data = {}
	return self
end

function jk.lang.Stack:push(o)
	do _g.jk.lang.Vector:append(self.data, o) end
end

function jk.lang.Stack:pop()
	local sz = _g.jk.lang.Vector:getSize(self.data)
	if sz < 1 then
		do return nil end
	end
	do
		local v = _g.jk.lang.Vector:getAt(self.data, sz - 1)
		do _g.jk.lang.Vector:remove(self.data, sz - 1) end
		do return v end
	end
end

function jk.lang.Stack:peek()
	local sz = _g.jk.lang.Vector:getSize(self.data)
	if sz < 1 then
		do return nil end
	end
	do return _g.jk.lang.Vector:getAt(self.data, sz - 1) end
end

function jk.lang.Stack:isEmpty()
	do return self:getSize() < 1 end
end

function jk.lang.Stack:getSize()
	do return _g.jk.lang.Vector:getSize(self.data) end
end

function jk.lang.Stack:dupData()
	local v = {}
	if self.data ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.data)
		do
			n = 0
			while n < m do
				local o = self.data[n + 1]
				if o ~= nil then
					do _g.jk.lang.Vector:append(v, o) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.lang.Stack:dup()
	local v = _g.jk.lang.Stack._construct0(_g.jk.lang.Stack._create())
	do v:setData(self:dupData()) end
	do return v end
end

function jk.lang.Stack:getData()
	do return self.data end
end

function jk.lang.Stack:setData(v)
	self.data = v
	do return self end
end

jk.lang.IntegerObject = {}

jk.lang.Set = {}
jk.lang.Set.__index = jk.lang.Set
_vm:set_metatable(jk.lang.Set, {})

function jk.lang.Set._create()
	local v = _vm:set_metatable({}, jk.lang.Set)
	return v
end

function jk.lang.Set:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Set'
	self['_isType.jk.lang.Set'] = true
end

function jk.lang.Set:_construct0()
	jk.lang.Set._init(self)
	return self
end

function jk.lang.Set:add(set, value)
	if not (set ~= nil) then
		do return end
	end
	_io:write_to_stdout("[jk.lang.Set.add] (Set.sling:50:3): Not implemented" .. "\n")
end

function jk.lang.Set:remove(set, value)
	if not (set ~= nil) then
		do return end
	end
	_io:write_to_stdout("[jk.lang.Set.remove] (Set.sling:76:3): Not implemented" .. "\n")
end

function jk.lang.Set:clear(set)
	if not (set ~= nil) then
		do return end
	end
	_io:write_to_stdout("[jk.lang.Set.clear] (Set.sling:102:3): Not implemented" .. "\n")
end

function jk.lang.Set:getSize(set)
	if not (set ~= nil) then
		do return 0 end
	end
	_io:write_to_stdout("[jk.lang.Set.getSize] (Set.sling:128:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.lang.Set:contains(set, value)
	if not (set ~= nil) then
		do return false end
	end
	_io:write_to_stdout("[jk.lang.Set.contains] (Set.sling:155:3): Not implemented" .. "\n")
	do return false end
end

function jk.lang.Set:getValues(set)
	if not (set ~= nil) then
		do return nil end
	end
	_io:write_to_stdout("[jk.lang.Set.getValues] (Set.sling:214:3): Not implemented" .. "\n")
	do return nil end
end

jk.lang.LongIntegerObject = {}

jk.lang.Runnable = {}

jk.lang.StringObjectWithDebug = {}

jk.lang.DynamicMapObject = {}

jk.lang.Error = {}
jk.lang.Error.__index = jk.lang.Error
_vm:set_metatable(jk.lang.Error, {})

function jk.lang.Error._create()
	local v = _vm:set_metatable({}, jk.lang.Error)
	return v
end

function jk.lang.Error:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Error'
	self['_isType.jk.lang.Error'] = true
	self['_isType.jk.lang.StringObject'] = true
	self['_isType.jk.lang.StringObjectWithDebug'] = true
	self.code = nil
	self.detail = nil
end

function jk.lang.Error:_construct0()
	jk.lang.Error._init(self)
	return self
end

function jk.lang.Error:throw(code, detail)
	_vm:throw_error(_g.jk.lang.ExceptionWithError:forError(_g.jk.lang.Error:forCode(code, detail)))
end

function jk.lang.Error:forCode(code, detail)
	do return _g.jk.lang.Error._construct0(_g.jk.lang.Error._create()):setCode(code):setDetail(detail) end
end

function jk.lang.Error:asString(error)
	if not (error ~= nil) then
		do return "error" end
	end
	do return error:toString() end
end

function jk.lang.Error:set(error, code, detail)
	if not (error ~= nil) then
		do return nil end
	end
	do error:setCode(code) end
	do error:setDetail(detail) end
	do return error end
end

function jk.lang.Error:setErrorCode(error, code)
	do return _g.jk.lang.Error:set(error, code, nil) end
end

function jk.lang.Error:setErrorDetail(error, detail)
	do return _g.jk.lang.Error:set(error, nil, detail) end
end

function jk.lang.Error:isError(o)
	if not (o ~= nil) then
		do return false end
	end
	if not (_vm:to_table_with_key(o, '_isType.jk.lang.Error') ~= nil) then
		do return false end
	end
	do
		local e = o
		if _g.jk.lang.String:isEmpty(e:getCode()) then
			do return false end
		end
		do return true end
	end
end

function jk.lang.Error:clear()
	self.code = nil
	self.detail = nil
	do return self end
end

function jk.lang.Error:toStringWithDefault(debug, defaultError)
	local details = nil
	if (_vm:to_table_with_key(self.detail, '_isType.jk.lang.StringObjectWithDebug') ~= nil) then
		details = self.detail:toStringWithDebug(debug)
	else
		details = _g.jk.lang.String:asString(self.detail)
	end
	if _g.jk.lang.String:isEmpty(self.code) == false then
		if _g.jk.lang.String:isEmpty(details) == false then
			do return _g.jk.lang.String:safeString(self.code) .. ":" .. _g.jk.lang.String:safeString(details) end
		end
		do return self.code end
	end
	if _g.jk.lang.String:isEmpty(details) == false then
		do return "errorWithDetail:" .. _g.jk.lang.String:safeString(details) end
	end
	do return defaultError end
end

function jk.lang.Error:toStringWithDebug(debug)
	do return self:toStringWithDefault(debug, "unknownError") end
end

function jk.lang.Error:toString()
	do return self:toStringWithDebug(false) end
end

function jk.lang.Error:getCode()
	do return self.code end
end

function jk.lang.Error:setCode(v)
	self.code = v
	do return self end
end

function jk.lang.Error:getDetail()
	do return self.detail end
end

function jk.lang.Error:setDetail(v)
	self.detail = v
	do return self end
end

jk.lang.Integer = {}
jk.lang.Integer.__index = jk.lang.Integer
_vm:set_metatable(jk.lang.Integer, {})

function jk.lang.Integer._create()
	local v = _vm:set_metatable({}, jk.lang.Integer)
	return v
end

function jk.lang.Integer:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Integer'
	self['_isType.jk.lang.Integer'] = true
	self['_isType.jk.lang.IntegerObject'] = true
	self.value = 0
end

function jk.lang.Integer:_construct0()
	jk.lang.Integer._init(self)
	return self
end

function jk.lang.Integer:forValue(value)
	do return _g.jk.lang.Integer:asObject(value) end
end

function jk.lang.Integer:asObject(integer)
	local v = _g.jk.lang.Integer._construct0(_g.jk.lang.Integer._create())
	do v:setValue(integer) end
	do return v end
end

function jk.lang.Integer:asInteger(obj)
	if not (obj ~= nil) then
		do return 0 end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _util:convert_to_integer(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.IntegerObject') ~= nil) then
		local oi = obj
		do return oi:toInteger() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = _util:convert_to_integer(obj)
		do return v end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.LongIntegerObject') ~= nil) then
		local oi = obj
		do return oi:toLong() end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		do return _g.jk.lang.String:toInteger(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.StringObject') ~= nil) then
		do return _g.jk.lang.String:toInteger(obj:toString()) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = obj
		do return _util:convert_to_integer(v) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.DoubleObject') ~= nil) then
		local od = obj
		do return _util:convert_to_integer(od:toDouble()) end
	end
	if (_vm:get_variable_type(obj) == 'boolean') then
		if obj == true then
			do return 1 end
		end
		do return 0 end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BooleanObject') ~= nil) then
		if obj:toBoolean() then
			do return 1 end
		end
		do return 0 end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = obj
		do return _util:convert_to_integer(v) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.CharacterObject') ~= nil) then
		local oc = obj
		do return _util:convert_to_integer(oc:toCharacter()) end
	end
	do return 0 end
end

function jk.lang.Integer:add(amount)
	self.value = self.value + amount
end

function jk.lang.Integer:toInteger()
	do return self.value end
end

function jk.lang.Integer:getValue()
	do return self.value end
end

function jk.lang.Integer:setValue(v)
	self.value = v
	do return self end
end

jk.lang.KeyValueList = {}
jk.lang.KeyValueList.__index = jk.lang.KeyValueList
_vm:set_metatable(jk.lang.KeyValueList, {})

function jk.lang.KeyValueList._create()
	local v = _vm:set_metatable({}, jk.lang.KeyValueList)
	return v
end

function jk.lang.KeyValueList:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.KeyValueList'
	self['_isType.jk.lang.KeyValueList'] = true
	self.values = nil
end

function jk.lang.KeyValueList:_construct0()
	jk.lang.KeyValueList._init(self)
	return self
end

function jk.lang.KeyValueList:add(key, val)
	if self.values == nil then
		self.values = {}
	end
	do
		local kvp = _g.jk.lang.KeyValuePair._construct0(_g.jk.lang.KeyValuePair._create())
		kvp.key = key
		kvp.value = val
		do _g.jk.lang.Vector:append(self.values, kvp) end
	end
end

function jk.lang.KeyValueList:addPair(pair)
	if self.values == nil then
		self.values = {}
	end
	do _g.jk.lang.Vector:append(self.values, pair) end
end

function jk.lang.KeyValueList:prepend(key, val)
	if self.values == nil then
		self.values = {}
	end
	do
		local kvp = _g.jk.lang.KeyValuePair._construct0(_g.jk.lang.KeyValuePair._create())
		kvp.key = key
		kvp.value = val
		do _g.jk.lang.Vector:prepend(self.values, kvp) end
	end
end

function jk.lang.KeyValueList:prependPair(pair)
	if self.values == nil then
		self.values = {}
	end
	do _g.jk.lang.Vector:prepend(self.values, pair) end
end

function jk.lang.KeyValueList:iterate()
	local v = _g.jk.lang.Vector:iterate(self.values)
	do return v end
end

function jk.lang.KeyValueList:asVector()
	do return self.values end
end

function jk.lang.KeyValueList:dup()
	local v = _g.jk.lang.KeyValueList._construct0(_g.jk.lang.KeyValueList._create())
	local it = self:iterate()
	while true do
		local kvp = it:next()
		if kvp == nil then
			do break end
		end
		do v:add(kvp.key, kvp.value) end
	end
	do return v end
end

function jk.lang.KeyValueList:getKey(index)
	if self.values == nil then
		do return nil end
	end
	do
		local kvp = _g.jk.lang.Vector:get(self.values, index)
		if kvp == nil then
			do return nil end
		end
		do return kvp.key end
	end
end

function jk.lang.KeyValueList:getValue(index)
	if self.values == nil then
		do return nil end
	end
	do
		local kvp = _g.jk.lang.Vector:get(self.values, index)
		if kvp == nil then
			do return nil end
		end
		do return kvp.value end
	end
end

function jk.lang.KeyValueList:count()
	if self.values == nil then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.values) end
end

function jk.lang.KeyValueList:remove(index)
	do _g.jk.lang.Vector:remove(self.values, index) end
end

function jk.lang.KeyValueList:clear()
	self.values = nil
end

jk.lang.ObjectWithSize = {}

jk.lang.KeyValuePair = {}
jk.lang.KeyValuePair.__index = jk.lang.KeyValuePair
_vm:set_metatable(jk.lang.KeyValuePair, {})

function jk.lang.KeyValuePair._create()
	local v = _vm:set_metatable({}, jk.lang.KeyValuePair)
	return v
end

function jk.lang.KeyValuePair:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.KeyValuePair'
	self['_isType.jk.lang.KeyValuePair'] = true
	self.key = nil
	self.value = nil
end

function jk.lang.KeyValuePair:_construct0()
	jk.lang.KeyValuePair._init(self)
	return self
end

function jk.lang.KeyValuePair:_construct2(key, value)
	jk.lang.KeyValuePair._init(self)
	self.key = key
	self.value = value
	return self
end

jk.lang.ObjectWrapper = {}
jk.lang.ObjectWrapper.__index = jk.lang.ObjectWrapper
_vm:set_metatable(jk.lang.ObjectWrapper, {})

function jk.lang.ObjectWrapper._create()
	local v = _vm:set_metatable({}, jk.lang.ObjectWrapper)
	return v
end

function jk.lang.ObjectWrapper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.ObjectWrapper'
	self['_isType.jk.lang.ObjectWrapper'] = true
	self.value = nil
end

function jk.lang.ObjectWrapper:_construct0()
	jk.lang.ObjectWrapper._init(self)
	return self
end

function jk.lang.ObjectWrapper:getValue()
	do return self.value end
end

function jk.lang.ObjectWrapper:setValue(v)
	self.value = v
	do return self end
end

jk.lang.ArrayObject = {}

jk.lang.Iterateable = {}

jk.lang.MapObject = {}

jk.lang.VectorObject = {}

jk.lang.BitOp = {}
jk.lang.BitOp.__index = jk.lang.BitOp
_vm:set_metatable(jk.lang.BitOp, {})

function jk.lang.BitOp._create()
	local v = _vm:set_metatable({}, jk.lang.BitOp)
	return v
end

function jk.lang.BitOp:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.BitOp'
	self['_isType.jk.lang.BitOp'] = true
end

function jk.lang.BitOp:_construct0()
	jk.lang.BitOp._init(self)
	return self
end

function jk.lang.BitOp:_or(v1, v2)
	do return _vm:bitwise_or(v1, v2) end
end

function jk.lang.BitOp:_and(v1, v2)
	do return _vm:bitwise_and(v1, v2) end
end

function jk.lang.BitOp:xor(v1, v2)
	do return _vm:bitwise_xor(v1, v2) end
end

function jk.lang.BitOp:_not(v)
	do return _vm:bitwise_not(v) end
end

jk.lang.IntegerIterator = {}

jk.lang.CharacterIterator = {}

jk.lang.LongInteger = {}
jk.lang.LongInteger.__index = jk.lang.LongInteger
_vm:set_metatable(jk.lang.LongInteger, {})

function jk.lang.LongInteger._create()
	local v = _vm:set_metatable({}, jk.lang.LongInteger)
	return v
end

function jk.lang.LongInteger:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.LongInteger'
	self['_isType.jk.lang.LongInteger'] = true
	self['_isType.jk.lang.LongIntegerObject'] = true
	self.value = 0
end

function jk.lang.LongInteger:_construct0()
	jk.lang.LongInteger._init(self)
	return self
end

function jk.lang.LongInteger:forValue(value)
	do return _g.jk.lang.LongInteger:asObject(value) end
end

function jk.lang.LongInteger:asObject(value)
	local v = _g.jk.lang.LongInteger._construct0(_g.jk.lang.LongInteger._create())
	do v:setValue(value) end
	do return v end
end

function jk.lang.LongInteger:asLong(obj)
	if not (obj ~= nil) then
		do return 0 end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _util:convert_to_integer(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.LongIntegerObject') ~= nil) then
		local oi = obj
		do return oi:toLong() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = _util:convert_to_integer(obj)
		do return v end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.IntegerObject') ~= nil) then
		local oi = obj
		do return oi:toInteger() end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		do return _g.jk.lang.String:toLong(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.StringObject') ~= nil) then
		do return _g.jk.lang.String:toLong(obj:toString()) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = obj
		do return _util:convert_to_integer(v) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.DoubleObject') ~= nil) then
		local od = obj
		do return _util:convert_to_integer(od:toDouble()) end
	end
	if (_vm:get_variable_type(obj) == 'boolean') then
		if obj == true then
			do return 1 end
		end
		do return 0 end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BooleanObject') ~= nil) then
		if obj:toBoolean() then
			do return 1 end
		end
		do return 0 end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = obj
		do return _util:convert_to_integer(v) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.CharacterObject') ~= nil) then
		local oc = obj
		do return _util:convert_to_integer(oc:toCharacter()) end
	end
	do return 0 end
end

function jk.lang.LongInteger:add(amount)
	self.value = self.value + amount
end

function jk.lang.LongInteger:toLong()
	do return self.value end
end

function jk.lang.LongInteger:getValue()
	do return self.value end
end

function jk.lang.LongInteger:setValue(v)
	self.value = v
	do return self end
end

jk.lang.DoubleObject = {}

jk.lang.Duplicateable = {}

jk.lang.DoubleIterator = {}

jk.lang.BufferObject = {}

jk.lang.Range = {}
jk.lang.Range.__index = jk.lang.Range
_vm:set_metatable(jk.lang.Range, {})

jk.lang.Range.TYPE_NONE = 0
jk.lang.Range.TYPE_EXCLUDE_UPPER_BOUND = 1
jk.lang.Range.TYPE_EXCLUDE_LOWER_BOUND = 2
jk.lang.Range.TYPE_EXCLUDE_BOTH_BOUNDS = 3

function jk.lang.Range._create()
	local v = _vm:set_metatable({}, jk.lang.Range)
	return v
end

function jk.lang.Range:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Range'
	self['_isType.jk.lang.Range'] = true
	self['_isType.jk.lang.Iterateable'] = true
	self.lowerBound = 0.0
	self.upperBound = 0.0
	self.exclusionType = 0
end

function jk.lang.Range:forIntegerValues(lowerBound, upperBound, exclusionType)
	local v = _g.jk.lang.Range._construct0(_g.jk.lang.Range._create())
	do v:setLowerBound(lowerBound) end
	do v:setUpperBound(upperBound) end
	do v:setExclusionType(exclusionType) end
	do return v end
end

function jk.lang.Range:forDoubleValues(lowerBound, upperBound, exclusionType)
	local v = _g.jk.lang.Range._construct0(_g.jk.lang.Range._create())
	do v:setLowerBound(lowerBound) end
	do v:setUpperBound(upperBound) end
	do v:setExclusionType(exclusionType) end
	do return v end
end

function jk.lang.Range:forValues(lowerBound, upperBound, exclusionType)
	if (_vm:get_variable_type(lowerBound) == 'number') and (_vm:get_variable_type(upperBound) == 'number') then
		do return _g.jk.lang.Range:forDoubleValues(lowerBound, upperBound, exclusionType) end
	end
	if (_vm:get_variable_type(lowerBound) == 'number') and (_vm:get_variable_type(upperBound) == 'number') then
		do return _g.jk.lang.Range:forIntegerValues(_util:convert_to_integer(lowerBound), _util:convert_to_integer(upperBound), exclusionType) end
	end
	do return nil end
end

function jk.lang.Range:_construct0()
	jk.lang.Range._init(self)
	return self
end

function jk.lang.Range:setLowerBound(lowerBound)
	self.lowerBound = lowerBound
end

function jk.lang.Range:setUpperBound(upperBound)
	self.upperBound = upperBound
end

function jk.lang.Range:setExclusionType(exclusionType)
	self.exclusionType = exclusionType
end

function jk.lang.Range:getLowerBoundAsInteger()
	do return _util:convert_to_integer(self.lowerBound) end
end

function jk.lang.Range:getLowerBoundAsDouble()
	do return self.lowerBound end
end

function jk.lang.Range:getUpperBoundAsInteger()
	do return _util:convert_to_integer(self.upperBound) end
end

function jk.lang.Range:getUpperBoundAsDouble()
	do return self.upperBound end
end

function jk.lang.Range:containsIntegerValue(value)
	do return self:containsDoubleValue(value) end
end

function jk.lang.Range:containsDoubleValue(value)
	if self.exclusionType == _g.jk.lang.Range.TYPE_NONE then
		do return value >= self.lowerBound and value <= self.upperBound end
	elseif self.exclusionType == _g.jk.lang.Range.TYPE_EXCLUDE_UPPER_BOUND then
		do return value >= self.lowerBound and value < self.upperBound end
	elseif self.exclusionType == _g.jk.lang.Range.TYPE_EXCLUDE_LOWER_BOUND then
		do return value > self.lowerBound and value <= self.upperBound end
	elseif self.exclusionType == _g.jk.lang.Range.TYPE_EXCLUDE_BOTH_BOUNDS then
		do return value > self.lowerBound and value < self.upperBound end
	end
	do return false end
end

jk.lang.Range.RangeIterator = {}
jk.lang.Range.RangeIterator.__index = jk.lang.Range.RangeIterator
_vm:set_metatable(jk.lang.Range.RangeIterator, {})

function jk.lang.Range.RangeIterator._create()
	local v = _vm:set_metatable({}, jk.lang.Range.RangeIterator)
	return v
end

function jk.lang.Range.RangeIterator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Range.RangeIterator'
	self['_isType.jk.lang.Range.RangeIterator'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.lowerBound = 0
	self.upperBound = 0
	self.increment = 0
	self.current = nil
end

function jk.lang.Range.RangeIterator:_construct0()
	jk.lang.Range.RangeIterator._init(self)
	return self
end

function jk.lang.Range.RangeIterator:_construct2(lowerBound, upperBound)
	jk.lang.Range.RangeIterator._init(self)
	self.lowerBound = lowerBound
	self.upperBound = upperBound
	if lowerBound <= upperBound then
		self.increment = 1
	else
		self.increment = -1
	end
	return self
end

function jk.lang.Range.RangeIterator:next()
	if not (self.current ~= nil) then
		self.current = _g.jk.lang.Integer:forValue(self.lowerBound)
	else
		do self.current:add(self.increment) end
	end
	do return self.current:getValue() end
end

function jk.lang.Range.RangeIterator:hasNext()
	if not (self.current ~= nil) then
		do return true end
	end
	if self.increment > 0 then
		do return self.current:getValue() < self.upperBound end
	end
	do return self.current:getValue() > self.upperBound end
end

function jk.lang.Range:iterate()
	local lv = _util:convert_to_integer(self.lowerBound)
	local uv = _util:convert_to_integer(self.upperBound)
	if self.exclusionType == _g.jk.lang.Range.TYPE_NONE then
	end
	if self.exclusionType == _g.jk.lang.Range.TYPE_EXCLUDE_UPPER_BOUND then
		uv = uv - 1
	elseif self.exclusionType == _g.jk.lang.Range.TYPE_EXCLUDE_LOWER_BOUND then
		lv = lv + 1
	elseif self.exclusionType == _g.jk.lang.Range.TYPE_EXCLUDE_BOTH_BOUNDS then
		uv = uv - 1
		lv = lv + 1
	end
	do return _g.jk.lang.Range.RangeIterator._construct2(_g.jk.lang.Range.RangeIterator._create(), lv, uv) end
end

jk.lang.StringDataReceiver = {}

jk.lang.Array = {}
jk.lang.Array.__index = jk.lang.Array
_vm:set_metatable(jk.lang.Array, {})

function jk.lang.Array._create()
	local v = _vm:set_metatable({}, jk.lang.Array)
	return v
end

function jk.lang.Array:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Array'
	self['_isType.jk.lang.Array'] = true
end

function jk.lang.Array:_construct0()
	jk.lang.Array._init(self)
	return self
end

jk.lang.Array.MyArrayObject = {}
jk.lang.Array.MyArrayObject.__index = jk.lang.Array.MyArrayObject
_vm:set_metatable(jk.lang.Array.MyArrayObject, {})

function jk.lang.Array.MyArrayObject._create()
	local v = _vm:set_metatable({}, jk.lang.Array.MyArrayObject)
	return v
end

function jk.lang.Array.MyArrayObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Array.MyArrayObject'
	self['_isType.jk.lang.Array.MyArrayObject'] = true
	self['_isType.jk.lang.ArrayObject'] = true
	self['_isType.jk.lang.ObjectWithSize'] = true
	self.array = nil
end

function jk.lang.Array.MyArrayObject:_construct0()
	jk.lang.Array.MyArrayObject._init(self)
	return self
end

function jk.lang.Array.MyArrayObject:toArray()
	do return self.array end
end

function jk.lang.Array.MyArrayObject:getSize()
	do return #self.array end
end

function jk.lang.Array.MyArrayObject:getArray()
	do return self.array end
end

function jk.lang.Array.MyArrayObject:setArray(v)
	self.array = v
	do return self end
end

function jk.lang.Array:asObject(array)
	local v = _g.jk.lang.Array.MyArrayObject._construct0(_g.jk.lang.Array.MyArrayObject._create())
	do v:setArray(array) end
	do return v end
end

function jk.lang.Array:isEmpty(array)
	if array == nil then
		do return true end
	end
	if #array < 1 then
		do return true end
	end
	do return false end
end

function jk.lang.Array:isNotEmpty(array)
	do return not _g.jk.lang.Array:isEmpty(array) end
end

function jk.lang.Array:contains(array, element)
	if not (array ~= nil) then
		do return false end
	end
	if array ~= nil then
		local n = 0
		local m = #array
		do
			n = 0
			while n < m do
				local oo = array[n + 1]
				if oo ~= nil then
					if element == oo then
						do return true end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function jk.lang.Array:toVector(array)
	do return _g.jk.lang.Vector:forArray(array) end
end

function jk.lang.Array:copyFrom(array, src, soffset, doffset, size)
	if not (array ~= nil) then
		do return end
	end
	if not (src ~= nil) then
		do return end
	end
	do
		local n = 0
		while n < size do
			array[doffset + n + 1] = src[soffset + n + 1]
			do n = n + 1 end
		end
	end
end

jk.lang.DynamicVector = {}
jk.lang.DynamicVector.__index = jk.lang.DynamicVector
_vm:set_metatable(jk.lang.DynamicVector, {})

function jk.lang.DynamicVector._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicVector)
	return v
end

function jk.lang.DynamicVector:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicVector'
	self['_isType.jk.lang.DynamicVector'] = true
	self['_isType.jk.lang.Duplicateable'] = true
	self['_isType.jk.lang.Iterateable'] = true
	self['_isType.jk.lang.VectorObject'] = true
	self['_isType.jk.lang.ObjectWithSize'] = true
	self.vector = nil
end

function jk.lang.DynamicVector:asDynamicVector(object)
	if not (object ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(object, '_isType.jk.lang.DynamicVector') ~= nil) then
		do return object end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(object) then
		do return _g.jk.lang.DynamicVector:forArray(object) end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(object) then
		do return _g.jk.lang.DynamicVector:forObjectVector(object) end
	end
	do return nil end
end

function jk.lang.DynamicVector:forStringVector(vector)
	local v = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local item = vector[n + 1]
				if item ~= nil then
					do v:appendObject(item) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.lang.DynamicVector:forObjectVector(vector)
	local v = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local item = vector[n + 1]
				if item ~= nil then
					do v:appendObject(item) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.lang.DynamicVector:forArray(array)
	local v = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
	if array ~= nil then
		local n = 0
		local m = #array
		do
			n = 0
			while n < m do
				local item = array[n + 1]
				if item ~= nil then
					do v:appendObject(item) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.lang.DynamicVector:_construct0()
	jk.lang.DynamicVector._init(self)
	self.vector = {}
	return self
end

function jk.lang.DynamicVector:toVector()
	do return self.vector end
end

function jk.lang.DynamicVector:toVectorOfStrings()
	local v = {}
	if self.vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.vector)
		do
			n = 0
			while n < m do
				local o = self.vector[n + 1]
				if o ~= nil then
					local s = _g.jk.lang.String:asString(o)
					if s ~= nil then
						do _g.jk.lang.Vector:append(v, s) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.lang.DynamicVector:toVectorOfDynamicMaps()
	local v = {}
	if self.vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.vector)
		do
			n = 0
			while n < m do
				local o = _vm:to_table_with_key(self.vector[n + 1], '_isType.jk.lang.DynamicMap')
				if o ~= nil then
					do _g.jk.lang.Vector:append(v, o) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.lang.DynamicVector:duplicate()
	local v = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
	local it = self:iterate()
	while it ~= nil do
		local o = it:next()
		if o == nil then
			do break end
		end
		do v:appendObject(o) end
	end
	do return v end
end

function jk.lang.DynamicVector:mergeDynamicVector(dynamicVector)
	if not (dynamicVector ~= nil) or dynamicVector:getSize() < 1 then
		do return self end
	end
	do return self:mergeVector(dynamicVector:toVector()) end
end

function jk.lang.DynamicVector:mergeVector(vector)
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local item = vector[n + 1]
				if item ~= nil then
					do self:appendObject(item) end
				end
				do n = n + 1 end
			end
		end
	end
	do return self end
end

function jk.lang.DynamicVector:appendObject(object)
	do _g.jk.lang.Vector:append(self.vector, object) end
	do return self end
end

function jk.lang.DynamicVector:appendString(string)
	do _g.jk.lang.Vector:append(self.vector, string) end
	do return self end
end

function jk.lang.DynamicVector:appendInteger(value)
	do _g.jk.lang.Vector:append(self.vector, _g.jk.lang.Integer:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:appendLong(value)
	do _g.jk.lang.Vector:append(self.vector, _g.jk.lang.LongInteger:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:appendBoolean(value)
	do _g.jk.lang.Vector:append(self.vector, _g.jk.lang.Boolean:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:appendDouble(value)
	do _g.jk.lang.Vector:append(self.vector, _g.jk.lang.Double:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:setObject(index, object)
	do _g.jk.lang.Vector:set(self.vector, index, object) end
	do return self end
end

function jk.lang.DynamicVector:setInteger(index, value)
	do _g.jk.lang.Vector:set(self.vector, index, _g.jk.lang.Integer:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:setLong(index, value)
	do _g.jk.lang.Vector:set(self.vector, index, _g.jk.lang.LongInteger:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:setBoolean(index, value)
	do _g.jk.lang.Vector:set(self.vector, index, _g.jk.lang.Boolean:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:setDouble(index, value)
	do _g.jk.lang.Vector:set(self.vector, index, _g.jk.lang.Double:asObject(value)) end
	do return self end
end

function jk.lang.DynamicVector:get(index)
	do return _g.jk.lang.Vector:getAt(self.vector, index) end
end

function jk.lang.DynamicVector:getString(index, defval)
	local v = _g.jk.lang.String:asString(self:get(index))
	if v == nil then
		do return defval end
	end
	do return v end
end

function jk.lang.DynamicVector:getInteger(index, defval)
	local vv = self:get(index)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.Integer:asInteger(vv) end
end

function jk.lang.DynamicVector:getLongInteger(index, defval)
	local vv = self:get(index)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.LongInteger:asLong(vv) end
end

function jk.lang.DynamicVector:getBoolean(index, defval)
	local vv = self:get(index)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.Boolean:asBoolean(vv, false) end
end

function jk.lang.DynamicVector:getDouble(index, defval)
	local vv = self:get(index)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.Double:asDouble(vv) end
end

function jk.lang.DynamicVector:getMap(index)
	do return _vm:to_table_with_key(self:get(index), '_isType.jk.lang.DynamicMap') end
end

function jk.lang.DynamicVector:getVector(index)
	do return _vm:to_table_with_key(self:get(index), '_isType.jk.lang.DynamicVector') end
end

function jk.lang.DynamicVector:iterate()
	local v = _g.jk.lang.Vector:iterate(self.vector)
	do return v end
end

function jk.lang.DynamicVector:iterateReverse()
	local v = _g.jk.lang.Vector:iterateReverse(self.vector)
	do return v end
end

function jk.lang.DynamicVector:remove(index)
	do _g.jk.lang.Vector:remove(self.vector, index) end
end

function jk.lang.DynamicVector:removeValue(value)
	do _g.jk.lang.Vector:removeValue(self.vector, value) end
end

function jk.lang.DynamicVector:clear()
	do _g.jk.lang.Vector:clear(self.vector) end
end

function jk.lang.DynamicVector:contains(object)
	do return _g.jk.lang.Vector:contains(self.vector, object) end
end

function jk.lang.DynamicVector:getSize()
	do return _g.jk.lang.Vector:getSize(self.vector) end
end

function jk.lang.DynamicVector:setCapacity(capacity)
	do _g.jk.lang.Vector:setCapacity(self.vector, capacity) end
end

function jk.lang.DynamicVector:sort()
	do _g.jk.lang.Vector:sort(self.vector, function(a, b)
		do return _g.jk.lang.String:compare(_g.jk.lang.String:asString(a), _g.jk.lang.String:asString(b)) end
	end) end
end

function jk.lang.DynamicVector:sortWithComparer(comparer)
	if comparer == nil then
		do self:sort() end
		do return end
	end
	do _g.jk.lang.Vector:sort(self.vector, comparer) end
end

function jk.lang.DynamicVector:sortReverse()
	do _g.jk.lang.Vector:sortReverse(self.vector, function(a, b)
		do return _g.jk.lang.String:compare(_g.jk.lang.String:asString(a), _g.jk.lang.String:asString(b)) end
	end) end
end

function jk.lang.DynamicVector:sortReverseWithComparer(comparer)
	if comparer == nil then
		do self:sortReverse() end
		do return end
	end
	do _g.jk.lang.Vector:sortReverse(self.vector, comparer) end
end

jk.lang.Queue = {}
jk.lang.Queue.__index = jk.lang.Queue
_vm:set_metatable(jk.lang.Queue, {})

function jk.lang.Queue._create()
	local v = _vm:set_metatable({}, jk.lang.Queue)
	return v
end

function jk.lang.Queue:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Queue'
	self['_isType.jk.lang.Queue'] = true
	self.data = nil
end

function jk.lang.Queue:_construct0()
	jk.lang.Queue._init(self)
	self.data = {}
	return self
end

function jk.lang.Queue:clear()
	self.data = {}
end

function jk.lang.Queue:push(o)
	do _g.jk.lang.Vector:append(self.data, o) end
end

function jk.lang.Queue:pop()
	local sz = _g.jk.lang.Vector:getSize(self.data)
	if sz < 1 then
		do return nil end
	end
	do
		local v = _g.jk.lang.Vector:getAt(self.data, 0)
		do _g.jk.lang.Vector:remove(self.data, 0) end
		do return v end
	end
end

function jk.lang.Queue:peek()
	local sz = _g.jk.lang.Vector:getSize(self.data)
	if sz < 1 then
		do return nil end
	end
	do return _g.jk.lang.Vector:getAt(self.data, 0) end
end

function jk.lang.Queue:isEmpty()
	do return self:getSize() < 1 end
end

function jk.lang.Queue:getSize()
	do return _g.jk.lang.Vector:getSize(self.data) end
end

function jk.lang.Queue:getData()
	do return self.data end
end

function jk.lang.Queue:setData(v)
	self.data = v
	do return self end
end

jk.lang.Vector = {}
jk.lang.Vector.__index = jk.lang.Vector
_vm:set_metatable(jk.lang.Vector, {})

function jk.lang.Vector._create()
	local v = _vm:set_metatable({}, jk.lang.Vector)
	return v
end

function jk.lang.Vector:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Vector'
	self['_isType.jk.lang.Vector'] = true
end

function jk.lang.Vector:_construct0()
	jk.lang.Vector._init(self)
	return self
end

function jk.lang.Vector:asVector(obj)
	local vo = _vm:to_table_with_key(obj, '_isType.jk.lang.VectorObject')
	if not (vo ~= nil) then
		do return nil end
	end
	do return vo:toVector() end
end

function jk.lang.Vector:asObjectVector(o)
	local it = _g.jk.lang.DynamicObject:iterate(o)
	if not (it ~= nil) then
		do return nil end
	end
	do
		local v = {}
		while true do
			local oo = it:next()
			if not (oo ~= nil) then
				do break end
			end
			do _g.jk.lang.Vector:append(v, oo) end
		end
		do return v end
	end
end

function jk.lang.Vector:forIterator(iterator)
	if not (iterator ~= nil) then
		do return nil end
	end
	do
		local v = {}
		while true do
			local o = iterator:next()
			if o == nil then
				do break end
			end
			do _g.jk.lang.Vector:append(v, o) end
		end
		do return v end
	end
end

function jk.lang.Vector:forArray(array)
	if not (array ~= nil) then
		do return nil end
	end
	do
		local v = {}
		do
			local n = 0
			while n < #array do
				do _g.jk.lang.Vector:append(v, array[n + 1]) end
				do n = n + 1 end
			end
		end
		do return v end
	end
end

function jk.lang.Vector:toVectorOfObject(collection)
	if not (collection ~= nil) then
		do return nil end
	end
	do
		local nvec = {}
		if collection ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(collection)
			do
				n = 0
				while n < m do
					local item = collection[n + 1]
					if item ~= nil then
						do _g.jk.lang.Vector:append(nvec, item) end
					end
					do n = n + 1 end
				end
			end
		end
		do return nvec end
	end
end

function jk.lang.Vector:dupObjectVector(vector)
	if not (vector ~= nil) then
		do return nil end
	end
	do
		local v = {}
		if vector ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(vector)
			do
				n = 0
				while n < m do
					local o = vector[n + 1]
					if o ~= nil then
						do _g.jk.lang.Vector:append(v, o) end
					end
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function jk.lang.Vector:contains(vector, object)
	if not (vector ~= nil) then
		do return false end
	end
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local oo = vector[n + 1]
				if oo ~= nil then
					if object == oo then
						do return true end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function jk.lang.Vector:append(vector, object)
	do local sz = vector["n"] or 0 vector[sz + 1] = object vector["n"] = sz + 1 end
end

function jk.lang.Vector:prepend(vector, object)
	do _g.jk.lang.Vector:insert(vector, object, 0) end
end

function jk.lang.Vector:insert(vector, object, index)
	do local sz = vector["n"] or 0 _vm:insert_to_indexed_table(vector, index + 1, object) vector["n"] = sz + 1 end
end

function jk.lang.Vector:setCapacity(vector, capacity)
	if not (vector ~= nil) then
		do return end
	end
end

function jk.lang.Vector:setSize(vector, newSize)
	if not (vector ~= nil) then
		do return nil end
	end
	do
		local sz = newSize
		if sz < 0 then
			sz = 0
		end
		do
			local osz = _g.jk.lang.Vector:getSize(vector)
			if sz == osz then
				do return vector end
			end
			if sz < osz then
				do
					local n = osz - 1
					while n >= sz do
						do _g.jk.lang.Vector:remove(vector, n) end
						do n = n - 1 end
					end
				end
			else
				do
					local n = osz
					while n < sz do
						do _g.jk.lang.Vector:append(vector, nil) end
						do n = n + 1 end
					end
				end
			end
			do return vector end
		end
	end
end

function jk.lang.Vector:getSize(vector)
	if vector == nil then
		do return 0 end
	end
	do return vector["n"] or 0 end
end

function jk.lang.Vector:getAt(vector, index)
	do return _g.jk.lang.Vector:get(vector, index) end
end

function jk.lang.Vector:get(vector, index)
	if index < 0 or index >= _g.jk.lang.Vector:getSize(vector) then
		do return nil end
	end
	do return vector[index + 1] end
end

function jk.lang.Vector:getFirst(vector)
	do return _g.jk.lang.Vector:get(vector, 0) end
end

function jk.lang.Vector:getLast(vector)
	do return _g.jk.lang.Vector:get(vector, _g.jk.lang.Vector:getSize(vector) - 1) end
end

function jk.lang.Vector:set(vector, index, val)
	if index < 0 or index >= _g.jk.lang.Vector:getSize(vector) then
		do return end
	end
	do vector[index + 1]  = val end
end

function jk.lang.Vector:remove(vector, index)
	local sz = _g.jk.lang.Vector:getSize(vector)
	if index < 0 or index >= sz then
		do return nil end
	end
	do _vm:remove_from_indexed_table(vector, index+1) vector["n"] = sz - 1 end
end

function jk.lang.Vector:popFirst(vector)
	if vector == nil or _g.jk.lang.Vector:getSize(vector) < 1 then
		do return nil end
	end
	do
		local v = _g.jk.lang.Vector:get(vector, 0)
		do _g.jk.lang.Vector:removeFirst(vector) end
		do return v end
	end
end

function jk.lang.Vector:removeFirst(vector)
	if vector == nil or _g.jk.lang.Vector:getSize(vector) < 1 then
		do return end
	end
	do _g.jk.lang.Vector:remove(vector, 0) end
end

function jk.lang.Vector:popLast(vector)
	local sz = _g.jk.lang.Vector:getSize(vector)
	if vector == nil or sz < 1 then
		do return nil end
	end
	do
		local v = _g.jk.lang.Vector:get(vector, sz - 1)
		do _g.jk.lang.Vector:removeLast(vector) end
		do return v end
	end
end

function jk.lang.Vector:removeLast(vector)
	if vector == nil then
		do return end
	end
	do
		local sz = _g.jk.lang.Vector:getSize(vector)
		if sz < 1 then
			do return end
		end
		do _g.jk.lang.Vector:remove(vector, sz - 1) end
	end
end

function jk.lang.Vector:removeValue(vector, value)
	local n = 0
	do
		n = 0
		while n < _g.jk.lang.Vector:getSize(vector) do
			if vector[n + 1] == value then
				do _g.jk.lang.Vector:remove(vector, n) end
				do return n end
			end
			do n = n + 1 end
		end
	end
	do return -1 end
end

function jk.lang.Vector:clear(vector)
	do _vm:clear_table(vector) vector["n"] = 0 end
end

function jk.lang.Vector:isEmpty(vector)
	if vector == nil then
		do return true end
	end
	do
		local v = false
		do local sz = vector["n"] if sz == nil or sz < 1 then v = true end end
		do return v end
	end
end

function jk.lang.Vector:isNotEmpty(vector)
	do return not _g.jk.lang.Vector:isEmpty(vector) end
end

function jk.lang.Vector:removeRange(vector, index, count)
	do
		local n = 0
		while n < count do
			do _g.jk.lang.Vector:remove(vector, index) end
			do n = n + 1 end
		end
	end
end

jk.lang.Vector.VectorIterator = {}
jk.lang.Vector.VectorIterator.__index = jk.lang.Vector.VectorIterator
_vm:set_metatable(jk.lang.Vector.VectorIterator, {})

function jk.lang.Vector.VectorIterator._create()
	local v = _vm:set_metatable({}, jk.lang.Vector.VectorIterator)
	return v
end

function jk.lang.Vector.VectorIterator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Vector.VectorIterator'
	self['_isType.jk.lang.Vector.VectorIterator'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.vector = nil
	self.index = 0
	self.increment = 1
end

function jk.lang.Vector.VectorIterator:_construct0()
	jk.lang.Vector.VectorIterator._init(self)
	return self
end

function jk.lang.Vector.VectorIterator:_construct2(vector, increment)
	jk.lang.Vector.VectorIterator._init(self)
	self.vector = vector
	self.increment = increment
	if increment < 0 and vector ~= nil then
		self.index = _g.jk.lang.Vector:getSize(vector) - 1
	end
	return self
end

function jk.lang.Vector.VectorIterator:next()
	if self.vector == nil then
		do return nil end
	end
	if self.index < 0 or self.index >= _g.jk.lang.Vector:getSize(self.vector) then
		do return nil end
	end
	do
		local v = self.vector[self.index + 1]
		self.index = self.index + self.increment
		do return v end
	end
end

function jk.lang.Vector.VectorIterator:hasNext()
	if not (self.vector ~= nil) then
		do return false end
	end
	if not (self.index < _g.jk.lang.Vector:getSize(self.vector) - 1) then
		do return false end
	end
	do return true end
end

function jk.lang.Vector:iterate(vector)
	do return _g.jk.lang.Vector.VectorIterator._construct2(_g.jk.lang.Vector.VectorIterator._create(), vector, 1) end
end

function jk.lang.Vector:iterateReverse(vector)
	do return _g.jk.lang.Vector.VectorIterator._construct2(_g.jk.lang.Vector.VectorIterator._create(), vector, -1) end
end

function jk.lang.Vector:sort(vector, comparer)
	if not (vector ~= nil) then
		do return end
	end
	do _vm:sort_table(vector, comparer) end
end

function jk.lang.Vector:sortReverse(vector, comparer)
	local cc = comparer
	do _g.jk.lang.Vector:sort(vector, function(a, b)
		do return -cc(a, b) end
	end) end
end

function jk.lang.Vector:sortAsStrings(vector)
	do _g.jk.lang.Vector:sort(vector, function(a, b)
		do return _g.jk.lang.String:compare(_g.jk.lang.String:asString(a), _g.jk.lang.String:asString(b)) end
	end) end
end

function jk.lang.Vector:sortAsStringsReverse(vector)
	do _g.jk.lang.Vector:sortReverse(vector, function(a, b)
		do return _g.jk.lang.String:compare(_g.jk.lang.String:asString(a), _g.jk.lang.String:asString(b)) end
	end) end
end

function jk.lang.Vector:reverse(vector)
	if not (vector ~= nil) then
		do return end
	end
	do
		local a = 0
		local b = _g.jk.lang.Vector:getSize(vector) - 1
		while a < b do
			local t = _g.jk.lang.Vector:getAt(vector, b)
			do _g.jk.lang.Vector:set(vector, b, _g.jk.lang.Vector:getAt(vector, a)) end
			do _g.jk.lang.Vector:set(vector, a, t) end
			do a = a + 1 end
			do b = b - 1 end
		end
	end
end

jk.lang.BooleanObject = {}

jk.lang.Boolean = {}
jk.lang.Boolean.__index = jk.lang.Boolean
_vm:set_metatable(jk.lang.Boolean, {})

function jk.lang.Boolean._create()
	local v = _vm:set_metatable({}, jk.lang.Boolean)
	return v
end

function jk.lang.Boolean:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Boolean'
	self['_isType.jk.lang.Boolean'] = true
	self['_isType.jk.lang.BooleanObject'] = true
	self.value = false
end

function jk.lang.Boolean:_construct0()
	jk.lang.Boolean._init(self)
	return self
end

function jk.lang.Boolean:asObject(value)
	local v = _g.jk.lang.Boolean._construct0(_g.jk.lang.Boolean._create())
	do v:setValue(value) end
	do return v end
end

function jk.lang.Boolean:asBoolean(obj, default)
	if obj == nil then
		do return false end
	end
	if (_vm:get_variable_type(obj) == 'boolean') then
		do return obj end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BooleanObject') ~= nil) then
		local bo = obj
		do return bo:toBoolean() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		if _util:convert_to_integer(obj) == 0 then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.IntegerObject') ~= nil) then
		if obj:toInteger() == 0 then
			do return false end
		end
		do return true end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		if _util:convert_to_integer(obj) == 0 then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.LongIntegerObject') ~= nil) then
		if obj:toLong() == 0 then
			do return false end
		end
		do return true end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		local str = _g.jk.lang.String:toLowerCase(obj)
		if str == "yes" or str == "true" or str == "1" then
			do return true end
		end
		if str == "no" or str == "false" or str == "0" then
			do return false end
		end
		do return default end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.StringObject') ~= nil) then
		local str = obj:toString()
		if str ~= nil then
			str = _g.jk.lang.String:toLowerCase(str)
			if str == "yes" or str == "true" or str == "1" then
				do return true end
			end
			if str == "no" or str == "false" or str == "0" then
				do return false end
			end
		end
		do return default end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		if obj == 0.0 then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.DoubleObject') ~= nil) then
		if obj:toDouble() == 0.0 then
			do return false end
		end
		do return true end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		if _util:convert_to_integer(obj) == 0 then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.CharacterObject') ~= nil) then
		if _util:convert_to_integer(obj:toCharacter()) == 0 then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.ObjectWithSize') ~= nil) then
		local sz = obj:getSize()
		if sz == 0 then
			do return false end
		end
		do return true end
	end
	do return default end
end

function jk.lang.Boolean:toBoolean()
	do return self.value end
end

function jk.lang.Boolean:getValue()
	do return self.value end
end

function jk.lang.Boolean:setValue(v)
	self.value = v
	do return self end
end

jk.lang.TimeValue = {}
jk.lang.TimeValue.__index = jk.lang.TimeValue
_vm:set_metatable(jk.lang.TimeValue, {})

function jk.lang.TimeValue._create()
	local v = _vm:set_metatable({}, jk.lang.TimeValue)
	return v
end

function jk.lang.TimeValue:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.TimeValue'
	self['_isType.jk.lang.TimeValue'] = true
	self.seconds = 0
	self.microSeconds = 0
end

function jk.lang.TimeValue:_construct0()
	jk.lang.TimeValue._init(self)
	return self
end

function jk.lang.TimeValue:forSeconds(seconds)
	local v = _g.jk.lang.TimeValue._construct0(_g.jk.lang.TimeValue._create())
	v.seconds = seconds
	do return v end
end

function jk.lang.TimeValue:toString()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(_g.jk.lang.String:forLongInteger(self.seconds)) end
	do sb:appendCharacter(46) end
	do sb:appendString(_g.jk.lang.String:forLongInteger(self.microSeconds)) end
	do return sb:toString() end
end

function jk.lang.TimeValue:dup()
	local v = _g.jk.lang.TimeValue._construct0(_g.jk.lang.TimeValue._create())
	do v:copyFrom(self) end
	do return v end
end

function jk.lang.TimeValue:reset()
	self.seconds = 0
	self.microSeconds = 0
end

function jk.lang.TimeValue:copyFrom(tv)
	self.seconds = tv.seconds
	self.microSeconds = tv.microSeconds
end

function jk.lang.TimeValue:set(tv)
	self.seconds = tv:getSeconds()
	self.microSeconds = tv:getMicroSeconds()
end

function jk.lang.TimeValue:setSeconds(value)
	self.seconds = value
end

function jk.lang.TimeValue:setMilliSeconds(value)
	self.microSeconds = value * 1000
end

function jk.lang.TimeValue:setMicroSeconds(value)
	self.microSeconds = value
end

function jk.lang.TimeValue:add(s, us)
	local ts = self:getSeconds() + s
	local tus = self:getMicroSeconds() + us
	if tus > 1000000 then
		ts = ts + _util:convert_to_integer(tus / 1000000)
		tus = _util:convert_to_integer(tus % 1000000)
	end
	while tus < 0 do
		do ts = ts - 1 end
		tus = tus + 1000000
	end
	do
		local v = _g.jk.lang.TimeValue._construct0(_g.jk.lang.TimeValue._create())
		v.seconds = ts
		v.microSeconds = tus
		do return v end
	end
end

function jk.lang.TimeValue:addTimeValue(tv)
	if tv == nil then
		do return self end
	end
	do return self:add(tv:getSeconds(), tv:getMicroSeconds()) end
end

function jk.lang.TimeValue:subtract(tv)
	if tv == nil then
		do return self end
	end
	do return self:add(-tv:getSeconds(), -tv:getMicroSeconds()) end
end

function jk.lang.TimeValue:asMicroSeconds()
	do return self:getSeconds() * 1000000 + self:getMicroSeconds() end
end

function jk.lang.TimeValue:diff(a, b)
	if a == nil and b == nil then
		do return 0 end
	end
	if a == nil then
		do return b:asMicroSeconds() end
	end
	if b == nil then
		do return a:asMicroSeconds() end
	end
	do
		local r = (a.seconds - b.seconds) * 1000000 + (a.microSeconds - b.microSeconds)
		do return r end
	end
end

function jk.lang.TimeValue:diffDouble(a, b)
	do return _g.jk.lang.TimeValue:diff(a, b) / 1000000.0 end
end

function jk.lang.TimeValue:getSeconds()
	do return self.seconds end
end

function jk.lang.TimeValue:getMicroSeconds()
	do return self.microSeconds end
end

jk.lang.DynamicIterator = {}

jk.lang.String = {}
jk.lang.String.__index = jk.lang.String
_vm:set_metatable(jk.lang.String, {})

function jk.lang.String._create()
	local v = _vm:set_metatable({}, jk.lang.String)
	return v
end

function jk.lang.String:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.String'
	self['_isType.jk.lang.String'] = true
end

function jk.lang.String:_construct0()
	jk.lang.String._init(self)
	return self
end

function jk.lang.String:asString(obj)
	if not (obj ~= nil) then
		do return nil end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		do return obj end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.StringObject') ~= nil) then
		local os = obj
		do return os:toString() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.String:forInteger(_util:convert_to_integer(obj)) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.IntegerObject') ~= nil) then
		do return _g.jk.lang.String:forInteger(obj:toInteger()) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.String:forLongInteger(_util:convert_to_integer(obj)) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.LongIntegerObject') ~= nil) then
		do return _g.jk.lang.String:forLongInteger(obj:toLong()) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.String:forDouble(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.DoubleObject') ~= nil) then
		do return _g.jk.lang.String:forDouble(obj:toDouble()) end
	end
	if (_vm:get_variable_type(obj) == 'boolean') then
		do return _g.jk.lang.String:forBoolean(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BooleanObject') ~= nil) then
		do return _g.jk.lang.String:forBoolean(obj:toBoolean()) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.String:forCharacter(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.CharacterObject') ~= nil) then
		do return _g.jk.lang.String:forCharacter(obj:toCharacter()) end
	end
	if _util:is_buffer(obj) then
		do return _g.jk.lang.String:forBufferHex(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BufferObject') ~= nil) then
		local v = obj:toBuffer()
		if not (v ~= nil) then
			do return "" end
		end
		do return _g.jk.lang.String:forBufferHex(v) end
	end
	do return nil end
end

function jk.lang.String:forObject(obj)
	do return _g.jk.lang.String:asString(obj) end
end

function jk.lang.String:safeString(str)
	if not (str ~= nil) then
		do return "" end
	end
	do return str end
end

function jk.lang.String:isEmpty(str)
	if not (str ~= nil) then
		do return true end
	end
	if _util:get_string_length(str) < 1 then
		do return true end
	end
	do return false end
end

function jk.lang.String:isNotEmpty(str)
	do return not _g.jk.lang.String:isEmpty(str) end
end

function jk.lang.String:forBuffer(data, encoding)
	if not (data ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:equalsIgnoreCase("UTF8", encoding) or _g.jk.lang.String:equalsIgnoreCase("UTF-8", encoding) then
		do return _g.jk.lang.String:forUTF8Buffer(data) end
	end
	if _g.jk.lang.String:equalsIgnoreCase("UCS2", encoding) or _g.jk.lang.String:equalsIgnoreCase("UCS-2", encoding) then
		do return _g.jk.lang.String:forUCS2Buffer(data) end
	end
	if _g.jk.lang.String:equalsIgnoreCase("ASCII", encoding) then
		do return _g.jk.lang.String:forASCIIBuffer(data) end
	end
	do return nil end
end

function jk.lang.String:forASCIIBuffer(data)
	if not (data ~= nil) then
		do return nil end
	end
	do return _util:convert_buffer_ascii_to_string(data) end
end

function jk.lang.String:forUTF8Buffer(data)
	if not (data ~= nil) then
		do return nil end
	end
	do return _util:convert_buffer_to_string(data) end
end

function jk.lang.String:forUCS2Buffer(data)
	if data == nil then
		do return nil end
	end
	_io:write_to_stdout("[jk.lang.String.forUCS2Buffer] (String.sling:312:3): Not implemented." .. "\n")
	do return nil end
end

function jk.lang.String:forCharArray(chars, offset, count)
	if not (chars ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local sz = #chars
		do
			local n = 0
			while n < count and n + offset < sz do
				do sb:appendCharacter(chars[n + offset + 1]) end
				do n = n + 1 end
			end
		end
		do return sb:toString() end
	end
end

function jk.lang.String:forBoolean(vv)
	if vv == true then
		do return "true" end
	end
	do return "false" end
end

function jk.lang.String:forInteger(vv)
	do return _util:create_decimal_string_for_integer(vv) end
end

function jk.lang.String:forLongInteger(vv)
	do return _util:create_decimal_string_for_integer(vv) end
end

function jk.lang.String:forIntegerWithPadding(vv, length, paddingString)
	local r = _g.jk.lang.String:forInteger(vv)
	if not (r ~= nil) then
		do return nil end
	end
	do
		local ll = _g.jk.lang.String:getLength(r)
		if ll >= length then
			do return r end
		end
		do
			local ps = paddingString
			if ps == nil then
				ps = "0"
			end
			do
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				local n = 0
				do
					n = 0
					while n < length - ll do
						do sb:appendString(ps) end
						do n = n + 1 end
					end
				end
				do sb:appendString(r) end
				do return sb:toString() end
			end
		end
	end
end

function jk.lang.String:forIntegerHex(vv, minlength)
	local v = nil
	v = _util:create_hex_string_for_integer(vv)
	if not (v ~= nil) then
		do return nil end
	end
	if minlength > 0 then
		while _g.jk.lang.String:getLength(v) < minlength do
			v = "0" .. _g.jk.lang.String:safeString(v)
		end
	end
	do return v end
end

function jk.lang.String:forLongIntegerHex(vv, minlength)
	local v = nil
	v = _util:create_hex_string_for_integer(vv)
	if not (v ~= nil) then
		do return nil end
	end
	if minlength > 0 then
		while _g.jk.lang.String:getLength(v) < minlength do
			v = "0" .. _g.jk.lang.String:safeString(v)
		end
	end
	do return v end
end

function jk.lang.String:forIntegerOctal(vv)
	local v = nil
	v = _util:create_octal_string_for_integer(vv)
	do return v end
end

function jk.lang.String:forIntegerBinary(vv)
	local v = nil
	_io:write_to_stdout("[jk.lang.String.forIntegerBinary] (String.sling:606:3): Not implemented" .. "\n")
	do return nil end
end

function jk.lang.String:forBufferHex(buffer)
	local size = _g.jk.lang.Buffer:getSize(buffer)
	if not (size ~= 0) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local p = 0
		while p < size do
			local s = _g.jk.lang.String:forIntegerHex(_g.jk.lang.Buffer:getByte(buffer, p), 0)
			if _g.jk.lang.String:getLength(s) < 2 then
				do sb:appendCharacter(48) end
			end
			do sb:appendString(s) end
			do p = p + 1 end
		end
		do return sb:toString() end
	end
end

function jk.lang.String:forCharacter(vv)
	if vv < 128 then
		do return _util:create_string_for_byte(vv) end
	end
	if vv < 2048 then
		local v1 = _vm:bitwise_or(192, _vm:bitwise_right_shift(vv, 6))
		local v2 = _vm:bitwise_or(128, _vm:bitwise_and(vv, 63))
		do return _util:create_string_for_byte(v1) .. _util:create_string_for_byte(v2) end
	end
	if vv < 65536 then
		local v1 = _vm:bitwise_or(224, _vm:bitwise_right_shift(vv, 12))
		local v2 = _vm:bitwise_or(128, _vm:bitwise_and(_vm:bitwise_right_shift(vv, 6), 63))
		local v3 = _vm:bitwise_or(128, _vm:bitwise_and(vv, 63))
		do return _util:create_string_for_byte(v1) .. _util:create_string_for_byte(v2) .. _util:create_string_for_byte(v3) end
	end
	do
		local v1 = _vm:bitwise_or(240, _vm:bitwise_right_shift(vv, 18))
		local v2 = _vm:bitwise_or(128, _vm:bitwise_and(_vm:bitwise_right_shift(vv, 12), 63))
		local v3 = _vm:bitwise_or(128, _vm:bitwise_and(_vm:bitwise_right_shift(vv, 6), 63))
		local v4 = _vm:bitwise_or(128, _vm:bitwise_and(vv, 63))
		do return _util:create_string_for_byte(v1) .. _util:create_string_for_byte(v2) .. _util:create_string_for_byte(v3) .. _util:create_string_for_byte(v4) end
	end
end

function jk.lang.String:forFloat(vv)
	do return _util:create_string_for_float(vv) end
end

function jk.lang.String:forDouble(vv)
	do return _util:create_string_for_float(vv) end
end

function jk.lang.String:toUTF8Buffer(str)
	if not (str ~= nil) then
		do return nil end
	end
	do return _util:convert_string_to_buffer(str) end
end

function jk.lang.String:toBuffer(str, charset)
	if not (str ~= nil) then
		do return nil end
	end
	if not (charset ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:equalsIgnoreCase("UTF8", charset) or _g.jk.lang.String:equalsIgnoreCase("UTF-8", charset) then
		do return _g.jk.lang.String:toUTF8Buffer(str) end
	end
	do
		local bytes = _g.jk.lang.String:getBytesUnsigned(str, charset)
		if not (bytes ~= nil) then
			do return nil end
		end
		do
			local c = #bytes
			local bb = _util:allocate_buffer(c)
			local n = 0
			do
				n = 0
				while n < c do
					do _g.jk.lang.Buffer:setByte(bb, n, bytes[n + 1]) end
					do n = n + 1 end
				end
			end
			do return bb end
		end
	end
end

function jk.lang.String:getBytesUnsignedUTF8(str)
	do return _g.jk.lang.String:getBytesUnsigned(str, "UTF-8") end
end

function jk.lang.String:getBytesUnsigned(str, charset)
	if not (str ~= nil) then
		do return nil end
	end
	if not (charset ~= nil) then
		do return nil end
	end
	_io:write_to_stdout("[jk.lang.String.getBytesUnsigned] (String.sling:938:3): Not implemented" .. "\n")
	do return nil end
end

function jk.lang.String:getBytesSignedUTF8(str)
	do return _g.jk.lang.String:getBytesSigned(str, "UTF-8") end
end

function jk.lang.String:getBytesSigned(str, charset)
	if str == nil or charset == nil then
		do return nil end
	end
	_io:write_to_stdout("[jk.lang.String.getBytesSigned] (String.sling:988:3): Not implemented" .. "\n")
	do return nil end
end

function jk.lang.String:getLength(str)
	if str == nil then
		do return 0 end
	end
	do return _util:get_utf8_character_count(str) end
end

function jk.lang.String:appendString(str1, str2)
	if str1 == nil then
		do return str2 end
	end
	if str2 == nil then
		do return str1 end
	end
	do return str1 .. str2 end
end

function jk.lang.String:appendInteger(str, intvalue)
	do return _g.jk.lang.String:appendString(str, _g.jk.lang.String:forInteger(intvalue)) end
end

function jk.lang.String:appendCharacter(str, charvalue)
	do return _g.jk.lang.String:appendString(str, _g.jk.lang.String:forCharacter(charvalue)) end
end

function jk.lang.String:appendFloat(str, floatvalue)
	do return _g.jk.lang.String:appendString(str, _g.jk.lang.String:forFloat(floatvalue)) end
end

function jk.lang.String:appendDouble(str, doublevalue)
	do return _g.jk.lang.String:appendString(str, _g.jk.lang.String:forDouble(doublevalue)) end
end

function jk.lang.String:appendBoolean(str, boolvalue)
	do return _g.jk.lang.String:appendString(str, _g.jk.lang.String:forBoolean(boolvalue)) end
end

function jk.lang.String:toLowerCase(str)
	if not (str ~= nil) then
		do return nil end
	end
	do return _util:change_string_to_lowercase(str) end
end

function jk.lang.String:toUpperCase(str)
	if not (str ~= nil) then
		do return nil end
	end
	do return _util:change_string_to_uppercase(str) end
end

function jk.lang.String:capitalize(str)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local c = _g.jk.lang.String:getChar(str, 0)
		if _g.jk.lang.Character:isLowercaseAlpha(c) == false then
			do return str end
		end
		do return _g.jk.lang.String:safeString(_g.jk.lang.String:forCharacter(_g.jk.lang.Character:toUppercase(c))) .. _g.jk.lang.String:safeString(_g.jk.lang.String:getEndOfString(str, 1)) end
	end
end

function jk.lang.String:getChar(str, index)
	if str == nil or index < 0 then
		do return 0 end
	end
	do
		local it = _g.jk.lang.String:iterate(str)
		local n = 0
		while it ~= nil do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if n == index then
				do return c end
			end
			do n = n + 1 end
		end
		do return 0 end
	end
end

function jk.lang.String:equals(str1, str2)
	if str1 == nil and str2 == nil then
		do return true end
	end
	if not (str1 ~= nil and str2 ~= nil) then
		do return false end
	end
	do return str1 == str2 end
end

function jk.lang.String:isNotEqual(str1, str2)
	do return not _g.jk.lang.String:equals(str1, str2) end
end

function jk.lang.String:equalsIgnoreCase(str1, str2)
	if str1 == nil and str2 == nil then
		do return true end
	end
	if not (str1 ~= nil and str2 ~= nil) then
		do return false end
	end
	do return 0 == _util:compare_string_ignore_case(str1, str2) end
end

function jk.lang.String:compare(str1, str2)
	if str1 == nil or str2 == nil then
		do return 0 end
	end
	do
		local it1 = _g.jk.lang.String:iterate(str1)
		local it2 = _g.jk.lang.String:iterate(str2)
		if it1 == nil or it2 == nil then
			do return 0 end
		end
		while true do
			if it1:hasEnded() and it2:hasEnded() then
				do break end
			end
			if it1:hasEnded() then
				do return -1 end
			end
			if it2:hasEnded() then
				do return 1 end
			end
			do
				local c1 = it1:getNextChar()
				local c2 = it2:getNextChar()
				if c1 < c2 then
					do return -1 end
				end
				if c1 > c2 then
					do return 1 end
				end
			end
		end
		do return 0 end
	end
end

function jk.lang.String:compareToIgnoreCase(str1, str2)
	if str1 == nil or str2 == nil then
		do return 0 end
	end
	do
		local it1 = _g.jk.lang.String:iterate(str1)
		local it2 = _g.jk.lang.String:iterate(str2)
		if it1 == nil or it2 == nil then
			do return 0 end
		end
		while true do
			if it1:hasEnded() and it2:hasEnded() then
				do break end
			end
			if it1:hasEnded() then
				do return -1 end
			end
			if it2:hasEnded() then
				do return 1 end
			end
			do
				local c1 = _g.jk.lang.Character:toLowercase(it1:getNextChar())
				local c2 = _g.jk.lang.Character:toLowercase(it2:getNextChar())
				if c1 < c2 then
					do return -1 end
				end
				if c1 > c2 then
					do return 1 end
				end
			end
		end
		do return 0 end
	end
end

function jk.lang.String:getHashCode(str)
	if str == nil then
		do return 0 end
	end
	do
		local hash = 0
		local it = _g.jk.lang.String:iterate(str)
		while it ~= nil do
			local ch = it:getNextChar()
			if _g.jk.lang.Character:isEOF(ch) then
				do break end
			end
			hash = _vm:bitwise_left_shift(hash, 5) - hash + ch
			hash = _vm:bitwise_and(hash, hash)
		end
		do return hash end
	end
end

function jk.lang.String:getIndexOfCharacter(str, c, start)
	if str == nil or c == 0 then
		do return -1 end
	end
	do return _util:get_index_of_character(str, c, start) end
end

function jk.lang.String:getIndexOfString(str, s, start)
	if str == nil or s == nil then
		do return -1 end
	end
	if _g.jk.lang.String:isEmpty(s) then
		do return 0 end
	end
	do return _util:get_index_of_substring(str, s, start) end
end

function jk.lang.String:getLastIndexOfCharacter(str, c, start)
	if str == nil then
		do return -1 end
	end
	do
		local ss = start
		if ss < 0 then
			ss = 0
		end
		do
			local ii = _g.jk.lang.String:getIndexOfCharacter(str, c, ss)
			if ii >= 0 then
				while true do
					local ix = _g.jk.lang.String:getIndexOfCharacter(str, c, ii + 1)
					if ix < 0 then
						do break end
					end
					ii = ix
				end
			end
			do return ii end
		end
	end
end

function jk.lang.String:getLastIndexOfString(str, s, start)
	if str == nil then
		do return -1 end
	end
	do
		local ss = start
		if ss < 0 then
			ss = 0
		end
		do
			local ii = _g.jk.lang.String:getIndexOfString(str, s, ss)
			if ii >= 0 then
				while true do
					local ix = _g.jk.lang.String:getIndexOfString(str, s, ii + 1)
					if ix < 0 then
						do break end
					end
					ii = ix
				end
			end
			do return ii end
		end
	end
end

function jk.lang.String:getEndOfString(str, start)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local ss = start
		if ss < 0 then
			ss = 0
		end
		do return _util:get_substring(str, ss, #str) end
	end
end

function jk.lang.String:getSubString(str, start, length)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local ss = start
		if ss < 0 then
			ss = 0
		end
		do
			local v = _util:get_substring(str, ss, ss+length)
			if not (v ~= nil) then
				v = ""
			end
			do return v end
		end
	end
end

function jk.lang.String:contains(str1, str2)
	if not (str1 ~= nil) then
		do return false end
	end
	if not (str2 ~= nil) then
		do return false end
	end
	if _g.jk.lang.String:getIndexOfString(str1, str2, 0) >= 0 then
		do return true end
	end
	do return false end
end

function jk.lang.String:startsWith(str1, str2, offset)
	if not (str1 ~= nil) then
		do return false end
	end
	if not (str2 ~= nil) then
		do return false end
	end
	do
		local nstr = nil
		if offset > 0 then
			nstr = _g.jk.lang.String:getEndOfString(str1, offset)
		else
			nstr = str1
		end
		do return _util:string_starts_with(str1, str2, offset) end
	end
end

function jk.lang.String:startsWithAny(str, strings)
	if strings ~= nil then
		local n = 0
		local m = #strings
		do
			n = 0
			while n < m do
				local str2 = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(strings[n + 1])
				if str2 ~= nil then
					if _g.jk.lang.String:startsWith(str, str2, 0) then
						do return str2 end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function jk.lang.String:startsWithIgnoreCase(str1, str2, offset)
	do return _g.jk.lang.String:startsWith(_g.jk.lang.String:toLowerCase(str1), _g.jk.lang.String:toLowerCase(str2), offset) end
end

function jk.lang.String:startsWithAnyIgnoreCase(str, strings)
	local ostr = _g.jk.lang.String:toLowerCase(str)
	if strings ~= nil then
		local n = 0
		local m = #strings
		do
			n = 0
			while n < m do
				local str2 = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(strings[n + 1])
				if str2 ~= nil then
					if _g.jk.lang.String:startsWith(ostr, _g.jk.lang.String:toLowerCase(str2), 0) then
						do return str2 end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function jk.lang.String:endsWith(str1, str2)
	if not (str1 ~= nil) then
		do return false end
	end
	if not (str2 ~= nil) then
		do return false end
	end
	do
		local s1 = _util:get_utf8_character_count(str1)
		do return _util:get_substring(str1, s1 -_util:get_utf8_character_count(str2), s1) == str2 end
	end
end

function jk.lang.String:endsWithAny(str, strings)
	if strings ~= nil then
		local n = 0
		local m = #strings
		do
			n = 0
			while n < m do
				local str2 = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(strings[n + 1])
				if str2 ~= nil then
					if _g.jk.lang.String:endsWith(str, str2) then
						do return str2 end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function jk.lang.String:endsWithIgnoreCase(str1, str2)
	do return _g.jk.lang.String:endsWith(_g.jk.lang.String:toLowerCase(str1), _g.jk.lang.String:toLowerCase(str2)) end
end

function jk.lang.String:endsWithAnyIgnoreCase(str, strings)
	local ostr = _g.jk.lang.String:toLowerCase(str)
	if strings ~= nil then
		local n = 0
		local m = #strings
		do
			n = 0
			while n < m do
				local str2 = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(strings[n + 1])
				if str2 ~= nil then
					if _g.jk.lang.String:endsWith(ostr, _g.jk.lang.String:toLowerCase(str2)) then
						do return str2 end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function jk.lang.String:strip(str)
	if not (str ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.String:stripFromStart(_g.jk.lang.String:stripFromEnd(str)) end
end

function jk.lang.String:stripFromEnd(str)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local ll = _g.jk.lang.String:getLength(str)
		if ll < 1 then
			do return str end
		end
		do
			local n = 0
			while true do
				local c = _g.jk.lang.String:getChar(str, ll - 1 - n)
				if c == 32 or c == 9 or c == 13 or c == 10 then
					do n = n + 1 end
				else
					do break end
				end
			end
			if n < 1 then
				do return str end
			end
			do return _g.jk.lang.String:getSubString(str, 0, ll - n) end
		end
	end
end

function jk.lang.String:stripFromStart(str)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local n = 0
		while true do
			local c = _g.jk.lang.String:getChar(str, n)
			if c == 32 or c == 9 or c == 13 or c == 10 then
				do n = n + 1 end
			else
				do break end
			end
		end
		if n < 1 then
			do return str end
		end
		do return _g.jk.lang.String:getEndOfString(str, n) end
	end
end

function jk.lang.String:replaceCharacter(str, oldChar, newChar)
	if not (str ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.String:replaceString(str, _g.jk.lang.String:forCharacter(oldChar), _g.jk.lang.String:forCharacter(newChar)) end
end

function jk.lang.String:replaceString(str, target, replacement)
	if not (str ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:isEmpty(target) then
		do return str end
	end
	do
		local rr = replacement
		if not (rr ~= nil) then
			rr = ""
		end
		do
			local v = str
			while true do
				local p = _g.jk.lang.String:getIndexOfString(v, target, 0)
				if p < 0 then
					do break end
				end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendString(_g.jk.lang.String:getSubString(v, 0, p)) end
					do sb:appendString(rr) end
					do sb:appendString(_g.jk.lang.String:getEndOfString(v, p + _g.jk.lang.String:getLength(target))) end
					v = sb:toString()
				end
			end
			do return v end
		end
	end
end

function jk.lang.String:toCharArray(str)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local it = _g.jk.lang.String:iterate(str)
		local v = nil
		do v = {} end
		do
			local n = 0
			while it ~= nil do
				local c = it:getNextChar()
				if _g.jk.lang.Character:isEOF(c) then
					do break end
				end
				do v[n + 1] = c end
				do n = n + 1 end
			end
			do return v end
		end
	end
end

function jk.lang.String:split(str, delim, max)
	local v = {}
	if str == nil then
		do return v end
	end
	do
		local it = _g.jk.lang.String:iterate(str)
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local n = 0
		while true do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if c == delim and (max < 1 or n < max - 1) then
				local s = sb:toString()
				if not (s ~= nil) then
					s = ""
				end
				do _g.jk.lang.Vector:append(v, s) end
				do sb:clear() end
				do n = n + 1 end
			else
				do sb:appendCharacter(c) end
			end
		end
		do
			local s = sb:toString()
			if not (s ~= nil) then
				s = ""
			end
			do _g.jk.lang.Vector:append(v, s) end
			do return v end
		end
	end
end

function jk.lang.String:isInteger(str)
	if not (str ~= nil) then
		do return false end
	end
	do
		local it = _g.jk.lang.String:iterate(str)
		if not (it ~= nil) then
			do return false end
		end
		while true do
			local c = it:getNextChar()
			if c < 1 then
				do break end
			end
			if c < 48 or c > 57 then
				do return false end
			end
		end
		do return true end
	end
end

function jk.lang.String:toInteger(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return 0 end
	end
	do
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return 0 end
		end
		do
			local v = 0
			local first = true
			local negative = false
			while true do
				local c = iter:getNextChar()
				if first and c == 45 then
					negative = true
					first = false
					goto _continue2
				end
				if c >= 48 and c <= 57 then
					v = v * 10
					v = v + _util:convert_to_integer(c - 48)
				else
					do break end
				end
				first = false
				::_continue2::
			end
			if negative then
				v = v * -1
			end
			do return v end
		end
	end
end

function jk.lang.String:toLong(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return 0 end
	end
	do
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return 0 end
		end
		do
			local v = 0
			local first = true
			local negative = false
			while true do
				local c = iter:getNextChar()
				if first and c == 45 then
					negative = true
					first = false
					goto _continue3
				end
				if c >= 48 and c <= 57 then
					v = v * 10
					v = v + _util:convert_to_integer(c - 48)
				else
					do break end
				end
				first = false
				::_continue3::
			end
			if negative then
				v = v * -1
			end
			do return v end
		end
	end
end

function jk.lang.String:toIntegerFromHex(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return 0 end
	end
	do
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return 0 end
		end
		do
			local v = 0
			while true do
				local c = iter:getNextChar()
				if c >= 48 and c <= 57 then
					v = v * 16
					v = v + _util:convert_to_integer(c - 48)
				elseif c >= 97 and c <= 102 then
					v = v * 16
					v = v + (10 + c - 97)
				elseif c >= 65 and c <= 70 then
					v = v * 16
					v = v + (10 + c - 65)
				else
					do break end
				end
			end
			do return v end
		end
	end
end

function jk.lang.String:toLongIntegerFromHex(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return 0 end
	end
	do
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return 0 end
		end
		do
			local v = 0
			while true do
				local c = iter:getNextChar()
				if c >= 48 and c <= 57 then
					v = v * 16
					v = v + _util:convert_to_integer(c - 48)
				elseif c >= 97 and c <= 102 then
					v = v * 16
					v = v + (10 + c - 97)
				elseif c >= 65 and c <= 70 then
					v = v * 16
					v = v + (10 + c - 65)
				else
					do break end
				end
			end
			do return v end
		end
	end
end

function jk.lang.String:toIntegerFromOctal(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return 0 end
	end
	do
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return 0 end
		end
		do
			local v = 0
			while true do
				local c = iter:getNextChar()
				if c >= 48 and c <= 55 then
					v = v * 8
					v = v + _util:convert_to_integer(c - 48)
				else
					do break end
				end
			end
			do return v end
		end
	end
end

function jk.lang.String:toIntegerFromBinary(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return 0 end
	end
	do
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return 0 end
		end
		do
			local v = 0
			while true do
				local c = iter:getNextChar()
				if c >= 48 and c <= 49 then
					v = v * 2
					v = v + _util:convert_to_integer(c - 48)
				else
					do break end
				end
			end
			do return v end
		end
	end
end

function jk.lang.String:toDouble(str)
	if str == nil then
		do return 0.0 end
	end
	do return _util:to_number(str) end
end

function jk.lang.String:iterate(string)
	do return _g.jk.lang.CharacterIteratorForString:forString(string) end
end

function jk.lang.String:reverse(string)
	if not (string ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local it = _g.jk.lang.String:iterate(string)
		local c = 0
		while (function()
			c = it:getNextChar()
			do return c end
		end)() > 0 do
			do sb:insertCharacter(0, c) end
		end
		do return sb:toString() end
	end
end

function jk.lang.String:iterateReverse(string)
	do return _g.jk.lang.String:iterate(_g.jk.lang.String:reverse(string)) end
end

jk.lang.StringSet = {}
jk.lang.StringSet.__index = jk.lang.StringSet
_vm:set_metatable(jk.lang.StringSet, {})

function jk.lang.StringSet._create()
	local v = _vm:set_metatable({}, jk.lang.StringSet)
	return v
end

function jk.lang.StringSet:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.StringSet'
	self['_isType.jk.lang.StringSet'] = true
	self.data = nil
end

function jk.lang.StringSet:_construct0()
	jk.lang.StringSet._init(self)
	self.data = {}
	return self
end

function jk.lang.StringSet:add(string)
	do _g.jk.lang.Map:setValue(self.data, string, _g.jk.lang.Boolean:asObject(true)) end
end

function jk.lang.StringSet:remove(string)
	do _g.jk.lang.Map:remove(self.data, string) end
end

function jk.lang.StringSet:count()
	do return _g.jk.lang.Map:count(self.data) end
end

function jk.lang.StringSet:contains(string)
	if _g.jk.lang.Map:getValue(self.data, string) ~= nil then
		do return true end
	end
	do return false end
end

function jk.lang.StringSet:getAll()
	local v = _g.jk.lang.Map:getKeys(self.data)
	do return v end
end

function jk.lang.StringSet:clear()
	do _g.jk.lang.Map:clear(self.data) end
end

jk.lang.Exception = {}
jk.lang.Exception.__index = jk.lang.Exception
_vm:set_metatable(jk.lang.Exception, {})

function jk.lang.Exception._create()
	local v = _vm:set_metatable({}, jk.lang.Exception)
	return v
end

function jk.lang.Exception:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Exception'
	self['_isType.jk.lang.Exception'] = true
end

function jk.lang.Exception:_construct0()
	jk.lang.Exception._init(self)
	return self
end

jk.lang.CharacterDecoder = {}
jk.lang.CharacterDecoder.__index = jk.lang.CharacterDecoder
_vm:set_metatable(jk.lang.CharacterDecoder, {})

jk.lang.CharacterDecoder.UTF8 = 0
jk.lang.CharacterDecoder.ASCII = 1
jk.lang.CharacterDecoder.UCS2 = 2

function jk.lang.CharacterDecoder._create()
	local v = _vm:set_metatable({}, jk.lang.CharacterDecoder)
	return v
end

function jk.lang.CharacterDecoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.CharacterDecoder'
	self['_isType.jk.lang.CharacterDecoder'] = true
	self['_isType.jk.lang.CharacterIterator'] = true
	self.encoding = 0
	self.current = 0
	self.surrogatePair = nil
	self.counter = 0
	self.currentSize = 0
	self.ended = false
end

function jk.lang.CharacterDecoder:_construct0()
	jk.lang.CharacterDecoder._init(self)
	return self
end

function jk.lang.CharacterDecoder:resetDecoder()
	self.current = 0
	self.surrogatePair = nil
	self.counter = 0
	self.currentSize = 0
	self.ended = false
end

function jk.lang.CharacterDecoder:copyTo(o)
	o.encoding = self.encoding
	o.current = self.current
	o.currentSize = self.currentSize
	o.ended = self.ended
end

function jk.lang.CharacterDecoder:moveToPreviousByte()
	do return false end
end

function jk.lang.CharacterDecoder:moveToNextByte()
	do return false end
end

function jk.lang.CharacterDecoder:getCurrentByte()
	do return 0 end
end

function jk.lang.CharacterDecoder:setEncoding(ee)
	if _g.jk.lang.String:equalsIgnoreCase(ee, "UTF8") or _g.jk.lang.String:equalsIgnoreCase(ee, "UTF-8") then
		self.encoding = _g.jk.lang.CharacterDecoder.UTF8
		self.currentSize = 1
		do return self end
	end
	if _g.jk.lang.String:equalsIgnoreCase(ee, "ASCII") then
		self.encoding = _g.jk.lang.CharacterDecoder.ASCII
		self.currentSize = 1
		do return self end
	end
	if _g.jk.lang.String:equalsIgnoreCase(ee, "UCS2") or _g.jk.lang.String:equalsIgnoreCase(ee, "UCS-2") then
		self.encoding = _g.jk.lang.CharacterDecoder.UCS2
		self.currentSize = 2
		do return self end
	end
	do return nil end
end

function jk.lang.CharacterDecoder:getEncoding()
	do return self.encoding end
end

function jk.lang.CharacterDecoder:moveToPreviousChar()
	local op = self:getCurrentPosition()
	local cs = self.currentSize
	if cs > 1 then
		local n = 0
		do
			n = 0
			while n < cs - 1 do
				if not self:moveToPreviousByte() then
					do return false end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local v = self:doMoveToPreviousChar()
		if not v then
			do self:setCurrentPosition(op) end
		end
		if v and self.ended then
			self.ended = false
		end
		do return v end
	end
end

function jk.lang.CharacterDecoder:convertToChar(v)
	do return v end
end

function jk.lang.CharacterDecoder:getSurrogatePair()
	if not (self.surrogatePair ~= nil) then
		do return 0 end
	end
	do
		local c = self.surrogatePair[self.counter + 1]
		do self.counter = self.counter + 1 end
		if self.counter == 2 then
			self.counter = 0
			self.surrogatePair = nil
		end
		do return c end
	end
end

function jk.lang.CharacterDecoder:doMoveToPreviousChar()
	if self.encoding == _g.jk.lang.CharacterDecoder.UTF8 then
		if not self:moveToPreviousByte() then
			do return false end
		end
		do
			local c2 = self:getCurrentByte()
			if c2 <= 127 then
				self.current = c2
				self.currentSize = 1
				do return true end
			end
			if not self:moveToPreviousByte() then
				do return false end
			end
			do
				local c1 = self:getCurrentByte()
				if _vm:bitwise_and(c1, 192) == 192 then
					if not self:moveToNextByte() then
						do return false end
					end
					do
						local v = _vm:bitwise_left_shift(_vm:bitwise_and(c1, 31), 6)
						v = v + _vm:bitwise_and(c2, 63)
						self.current = self:convertToChar(v)
						self.currentSize = 2
						do return true end
					end
				end
				if not self:moveToPreviousByte() then
					do return false end
				end
				do
					local c0 = self:getCurrentByte()
					if _vm:bitwise_and(c0, 224) == 224 then
						if not self:moveToNextByte() then
							do return false end
						end
						if not self:moveToNextByte() then
							do return false end
						end
						do
							local v = _vm:bitwise_left_shift(_vm:bitwise_and(c0, 15), 12)
							v = v + _vm:bitwise_left_shift(_vm:bitwise_and(c1, 63), 6)
							v = v + _vm:bitwise_and(c2, 63)
							self.current = self:convertToChar(v)
							self.currentSize = 3
							do return true end
						end
					end
					if not self:moveToPreviousByte() then
						do return false end
					end
					do
						local cm1 = self:getCurrentByte()
						if _vm:bitwise_and(cm1, 240) == 240 then
							if not self:moveToNextByte() then
								do return false end
							end
							if not self:moveToNextByte() then
								do return false end
							end
							if not self:moveToNextByte() then
								do return false end
							end
							do
								local v = _vm:bitwise_left_shift(_vm:bitwise_and(cm1, 7), 18)
								v = v + _vm:bitwise_left_shift(_vm:bitwise_and(c0, 63), 12)
								v = v + _vm:bitwise_left_shift(_vm:bitwise_and(c1, 63), 6)
								v = v + _vm:bitwise_and(c2, 63)
								self.current = self:convertToChar(v)
								self.currentSize = 4
								do return true end
							end
						end
						do self:moveToNextByte() end
						do self:moveToNextByte() end
						do self:moveToNextByte() end
						self.current = 63
						self.currentSize = 1
						do return true end
					end
				end
			end
		end
	end
	if self.encoding == _g.jk.lang.CharacterDecoder.ASCII then
		if not self:moveToPreviousByte() then
			do return false end
		end
		self.current = self:getCurrentByte()
		do return true end
	end
	if self.encoding == _g.jk.lang.CharacterDecoder.UCS2 then
		if not self:moveToPreviousByte() then
			do return false end
		end
		do
			local c1 = self:getCurrentByte()
			if not self:moveToPreviousByte() then
				do return false end
			end
			do
				local c0 = self:getCurrentByte()
				if not self:moveToNextByte() then
					do return false end
				end
				self.current = _vm:bitwise_and(_vm:bitwise_left_shift(c0, 8), c1)
				do return true end
			end
		end
	end
	_io:write_to_stdout("Unsupported encoding in CharacterDecoder: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.encoding)) .. "\n")
	do return false end
end

function jk.lang.CharacterDecoder:moveToNextChar()
	local v = self:doMoveToNextChar()
	if v == false then
		self.current = 0
		self.ended = true
	end
	do return v end
end

function jk.lang.CharacterDecoder:doMoveToNextChar()
	if self.encoding == _g.jk.lang.CharacterDecoder.UTF8 then
		if self.surrogatePair ~= nil then
			self.current = self:getSurrogatePair()
			do return true end
		end
		if not self:moveToNextByte() then
			do return false end
		end
		do
			local b1 = self:getCurrentByte()
			local v = -1
			if b1 <= 127 then
				v = b1
				self.currentSize = 1
			elseif b1 >= 240 then
				v = _vm:bitwise_left_shift(_vm:bitwise_and(b1, 7), 18)
				if not self:moveToNextByte() then
					do return false end
				end
				do
					local b2 = self:getCurrentByte()
					v = v + _vm:bitwise_left_shift(_vm:bitwise_and(b2, 63), 12)
					if not self:moveToNextByte() then
						do return false end
					end
					do
						local b3 = self:getCurrentByte()
						v = v + _vm:bitwise_left_shift(_vm:bitwise_and(b3, 63), 6)
						if not self:moveToNextByte() then
							do return false end
						end
						do
							local b4 = self:getCurrentByte()
							v = v + _vm:bitwise_and(b4, 63)
							self.currentSize = 4
						end
					end
				end
			elseif b1 >= 224 then
				v = _vm:bitwise_left_shift(_vm:bitwise_and(b1, 15), 12)
				if not self:moveToNextByte() then
					do return false end
				end
				do
					local b2 = self:getCurrentByte()
					v = v + _vm:bitwise_left_shift(_vm:bitwise_and(b2, 63), 6)
					if not self:moveToNextByte() then
						do return false end
					end
					do
						local b3 = self:getCurrentByte()
						v = v + _vm:bitwise_and(b3, 63)
						self.currentSize = 3
					end
				end
			elseif b1 >= 192 then
				v = _vm:bitwise_left_shift(_vm:bitwise_and(b1, 31), 6)
				if not self:moveToNextByte() then
					do return false end
				end
				do
					local b2 = self:getCurrentByte()
					v = v + _vm:bitwise_and(b2, 63)
					self.currentSize = 2
				end
			else
				v = _util:convert_to_integer(63)
				self.currentSize = 1
			end
			self.current = self:convertToChar(v)
			do return true end
		end
	end
	if self.encoding == _g.jk.lang.CharacterDecoder.ASCII then
		if not self:moveToNextByte() then
			do return false end
		end
		self.current = self:getCurrentByte()
		do return true end
	end
	if self.encoding == _g.jk.lang.CharacterDecoder.UCS2 then
		if not self:moveToNextByte() then
			do return false end
		end
		do
			local c0 = self:getCurrentByte()
			if not self:moveToNextByte() then
				do return false end
			end
			do
				local c1 = self:getCurrentByte()
				self.current = _vm:bitwise_and(_vm:bitwise_left_shift(c0, 8), c1)
				do return true end
			end
		end
	end
	_io:write_to_stdout("Unsupported encoding in CharacterDecoder: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.encoding)) .. "\n")
	do return false end
end

function jk.lang.CharacterDecoder:getCurrentChar()
	do return self.current end
end

function jk.lang.CharacterDecoder:getNextChar()
	if self:moveToNextChar() == false then
		do return 0 end
	end
	do return self.current end
end

function jk.lang.CharacterDecoder:hasEnded()
	do return self.ended end
end

function jk.lang.CharacterDecoder:getCurrentPosition()
end

function jk.lang.CharacterDecoder:setCurrentPosition(position)
end

jk.lang.LogicOp = {}
jk.lang.LogicOp.__index = jk.lang.LogicOp
_vm:set_metatable(jk.lang.LogicOp, {})

function jk.lang.LogicOp._create()
	local v = _vm:set_metatable({}, jk.lang.LogicOp)
	return v
end

function jk.lang.LogicOp:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.LogicOp'
	self['_isType.jk.lang.LogicOp'] = true
end

function jk.lang.LogicOp:_construct0()
	jk.lang.LogicOp._init(self)
	return self
end

function jk.lang.LogicOp:_or(v1, v2)
	do return v1 or v2 end
end

function jk.lang.LogicOp:_and(v1, v2)
	do return v1 and v2 end
end

function jk.lang.LogicOp:_not(v)
	do return not v end
end

jk.lang.StackTrace = {}
jk.lang.StackTrace.__index = jk.lang.StackTrace
_vm:set_metatable(jk.lang.StackTrace, {})

function jk.lang.StackTrace._create()
	local v = _vm:set_metatable({}, jk.lang.StackTrace)
	return v
end

function jk.lang.StackTrace:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.StackTrace'
	self['_isType.jk.lang.StackTrace'] = true
end

function jk.lang.StackTrace:_construct0()
	jk.lang.StackTrace._init(self)
	return self
end

function jk.lang.StackTrace:generate()
	do return _vm:get_stack_trace() end
end

jk.lang.CharacterIteratorForBuffer = _g.jk.lang.CharacterDecoder._create()
jk.lang.CharacterIteratorForBuffer.__index = jk.lang.CharacterIteratorForBuffer
_vm:set_metatable(jk.lang.CharacterIteratorForBuffer, {
	__index = _g.jk.lang.CharacterDecoder
})

function jk.lang.CharacterIteratorForBuffer._create()
	local v = _vm:set_metatable({}, jk.lang.CharacterIteratorForBuffer)
	return v
end

function jk.lang.CharacterIteratorForBuffer:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.CharacterIteratorForBuffer'
	self['_isType.jk.lang.CharacterIteratorForBuffer'] = true
	self['_isType.jk.lang.Duplicateable'] = true
	self.buffer = nil
	self.bufferSize = 0
	self.currentPosition = -1
end

function jk.lang.CharacterIteratorForBuffer:_construct0()
	jk.lang.CharacterIteratorForBuffer._init(self)
	do _g.jk.lang.CharacterDecoder._construct0(self) end
	return self
end

function jk.lang.CharacterIteratorForBuffer:forBuffer(buffer)
	local v = _g.jk.lang.CharacterIteratorForBuffer._construct0(_g.jk.lang.CharacterIteratorForBuffer._create())
	do v:setBuffer(buffer) end
	do return v end
end

function jk.lang.CharacterIteratorForBuffer:setBuffer(buffer)
	do self:resetDecoder() end
	self.buffer = buffer
	self.bufferSize = _g.jk.lang.Buffer:getSize(buffer)
	self.currentPosition = -1
end

function jk.lang.CharacterIteratorForBuffer:moveToPreviousByte()
	if self.currentPosition < 1 then
		do return false end
	end
	do self.currentPosition = self.currentPosition - 1 end
	do return true end
end

function jk.lang.CharacterIteratorForBuffer:moveToNextByte()
	local n = self.currentPosition + 1
	if n >= self.bufferSize then
		do return false end
	end
	self.currentPosition = n
	do return true end
end

function jk.lang.CharacterIteratorForBuffer:getCurrentByte()
	local v = _vm:bitwise_and(self.buffer[self.currentPosition + 1], 255)
	do return v end
end

function jk.lang.CharacterIteratorForBuffer:getCurrentPosition()
	do return self.currentPosition end
end

function jk.lang.CharacterIteratorForBuffer:setCurrentPosition(position)
	if position < 0 then
		self.current = 0
		self.currentPosition = -1
	else
		self.currentPosition = position + 1
		do self:doMoveToPreviousChar() end
	end
end

function jk.lang.CharacterIteratorForBuffer:duplicate()
	local v = _g.jk.lang.CharacterIteratorForBuffer._construct0(_g.jk.lang.CharacterIteratorForBuffer._create())
	do _g.jk.lang.CharacterDecoder.copyTo(self, v) end
	v.buffer = self.buffer
	v.bufferSize = self.bufferSize
	v.currentPosition = self.currentPosition
	do return v end
end

jk.lang.ExceptionWithString = _g.jk.lang.Exception._create()
jk.lang.ExceptionWithString.__index = jk.lang.ExceptionWithString
_vm:set_metatable(jk.lang.ExceptionWithString, {
	__index = _g.jk.lang.Exception
})

function jk.lang.ExceptionWithString._create()
	local v = _vm:set_metatable({}, jk.lang.ExceptionWithString)
	return v
end

function jk.lang.ExceptionWithString:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.ExceptionWithString'
	self['_isType.jk.lang.ExceptionWithString'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.exceptionMessage = nil
	self.stackTraceString = nil
end

function jk.lang.ExceptionWithString:_construct0()
	jk.lang.ExceptionWithString._init(self)
	do _g.jk.lang.Exception._construct0(self) end
	return self
end

function jk.lang.ExceptionWithString:forString(string, allowStackTrace)
	local v = _g.jk.lang.ExceptionWithString._construct0(_g.jk.lang.ExceptionWithString._create())
	do v:setExceptionMessage(string) end
	if allowStackTrace then
		do v:updateStackTrace() end
	end
	do return v end
end

function jk.lang.ExceptionWithString:updateStackTrace()
	do self:setStackTraceString(_g.jk.lang.StackTrace:generate()) end
end

function jk.lang.ExceptionWithString:toString()
	if not (self.stackTraceString ~= nil) then
		do return self.exceptionMessage end
	end
	do
		local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do v:appendString(self.exceptionMessage) end
		do
			local ss = self.stackTraceString
			if _g.jk.lang.String:getLength(ss) > 0 then
				if v:count() > 0 then
					do v:appendCharacter(10) end
				end
				do v:appendString(ss) end
			end
			do return v:toString() end
		end
	end
end

function jk.lang.ExceptionWithString:getExceptionMessage()
	do return self.exceptionMessage end
end

function jk.lang.ExceptionWithString:setExceptionMessage(v)
	self.exceptionMessage = v
	do return self end
end

function jk.lang.ExceptionWithString:getStackTraceString()
	do return self.stackTraceString end
end

function jk.lang.ExceptionWithString:setStackTraceString(v)
	self.stackTraceString = v
	do return self end
end

jk.lang.ExceptionWithError = _g.jk.lang.Exception._create()
jk.lang.ExceptionWithError.__index = jk.lang.ExceptionWithError
_vm:set_metatable(jk.lang.ExceptionWithError, {
	__index = _g.jk.lang.Exception
})

function jk.lang.ExceptionWithError._create()
	local v = _vm:set_metatable({}, jk.lang.ExceptionWithError)
	return v
end

function jk.lang.ExceptionWithError:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.ExceptionWithError'
	self['_isType.jk.lang.ExceptionWithError'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.error = nil
end

function jk.lang.ExceptionWithError:_construct0()
	jk.lang.ExceptionWithError._init(self)
	do _g.jk.lang.Exception._construct0(self) end
	return self
end

function jk.lang.ExceptionWithError:forError(error)
	local v = _g.jk.lang.ExceptionWithError._construct0(_g.jk.lang.ExceptionWithError._create())
	do v:setError(error) end
	do return v end
end

function jk.lang.ExceptionWithError:forCode(code, detail)
	do return _g.jk.lang.ExceptionWithError:forError(_g.jk.lang.Error:forCode(code, detail)) end
end

function jk.lang.ExceptionWithError:getErrorCode()
	if not (self.error ~= nil) then
		do return nil end
	end
	do return self.error:getCode() end
end

function jk.lang.ExceptionWithError:getErrorDetail()
	if not (self.error ~= nil) then
		do return nil end
	end
	do return self.error:getDetail() end
end

function jk.lang.ExceptionWithError:toString()
	do return _g.jk.lang.Error:asString(self.error) end
end

function jk.lang.ExceptionWithError:getError()
	do return self.error end
end

function jk.lang.ExceptionWithError:setError(v)
	self.error = v
	do return self end
end

jk.lang.Serializer = {}
jk.lang.Serializer.__index = jk.lang.Serializer
_vm:set_metatable(jk.lang.Serializer, {})

function jk.lang.Serializer._create()
	local v = _vm:set_metatable({}, jk.lang.Serializer)
	return v
end

function jk.lang.Serializer:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Serializer'
	self['_isType.jk.lang.Serializer'] = true
end

function jk.lang.Serializer:_construct0()
	jk.lang.Serializer._init(self)
	return self
end

function jk.lang.Serializer:toBuffer(object)
	if not (object ~= nil) then
		do return nil end
	end
	do return _vm:serialize_object(object) end
end

function jk.lang.Serializer:fromBuffer(buffer)
	if not (buffer ~= nil) then
		do return nil end
	end
	do
		local oo = nil
		do oo = _vm:unserialize_object(buffer) end
		if not (oo ~= nil) then
			do return nil end
		end
		do _vm:set_metatable(oo, _vm:get_global(oo._qualifiedClassName)) end
		do return oo end
	end
end

jk.lang.Reflection = {}
jk.lang.Reflection.__index = jk.lang.Reflection
_vm:set_metatable(jk.lang.Reflection, {})

function jk.lang.Reflection._create()
	local v = _vm:set_metatable({}, jk.lang.Reflection)
	return v
end

function jk.lang.Reflection:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Reflection'
	self['_isType.jk.lang.Reflection'] = true
end

function jk.lang.Reflection:_construct0()
	jk.lang.Reflection._init(self)
	return self
end

function jk.lang.Reflection:createClassInstanceByName(qualifiedName)
	if not _g.jk.lang.String:isNotEmpty(qualifiedName) then
		do return nil end
	end
	do
		local code = " return _g." .. _g.jk.lang.String:safeString(qualifiedName) .. "._construct0(_g." .. _g.jk.lang.String:safeString(qualifiedName) .. "._create())"
		local ff = _vm:parse_to_function(code)
		if not (ff ~= nil) then
			do return nil end
		end
		do return ff() end
	end
end

function jk.lang.Reflection:createClassInstanceByTypeinfo(type)
	local typename = type
	if not _g.jk.lang.String:startsWith(typename, "class:", 0) then
		do return nil end
	end
	typename = _g.jk.lang.String:getEndOfString(typename, 6)
	do return _g.jk.lang.Reflection:createClassInstanceByName(typename) end
end

function jk.lang.Reflection:callMethod(object, methodName, arguments)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString("return function(object, arguments) return object:") end
	do sb:appendString(methodName) end
	do sb:appendString("(") end
	do
		local sz = #arguments
		do
			local n = 0
			while n < sz do
				if n > 0 then
					do sb:appendString(",") end
				end
				do sb:appendString("arguments[") end
				do sb:appendInteger(n + 1) end
				do sb:appendString("]") end
				do n = n + 1 end
			end
		end
		do sb:appendString(") end") end
		do
			local code = sb:toString()
			local ff = _vm:parse_to_function(code)
			if not (ff ~= nil) then
				do return nil end
			end
			do
				local ffx = ff()
				if not (ffx ~= nil) then
					do return nil end
				end
				do return ffx(object, arguments) end
			end
		end
	end
end

function jk.lang.Reflection:getDataTypeInfo(variable)
	do return _vm:get_datatype_info(variable) end
end

function jk.lang.Reflection:isSameType(primary, other)
	if primary == nil and other == nil then
		do return true end
	end
	if primary == nil or other == nil then
		do return false end
	end
	do
		local ta = _vm:get_datatype_info(primary)
		local tb = _vm:get_datatype_info(other)
		if ta == tb then
			do return true end
		end
		do return false end
	end
end

function jk.lang.Reflection:isInstanceOf(object, type)
	if not (object ~= nil) then
		do return false end
	end
	do return _vm:is_instance_of(object, type) end
end

jk.lang.BufferDataReceiver = {}

jk.lang.StringBuilder = {}
jk.lang.StringBuilder.__index = jk.lang.StringBuilder
_vm:set_metatable(jk.lang.StringBuilder, {})

function jk.lang.StringBuilder._create()
	local v = _vm:set_metatable({}, jk.lang.StringBuilder)
	return v
end

function jk.lang.StringBuilder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.StringBuilder'
	self['_isType.jk.lang.StringBuilder'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.buffer = nil
	self.position = 0
end

function jk.lang.StringBuilder:forString(initial)
	local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do v:appendString(initial) end
	do return v end
end

function jk.lang.StringBuilder:dup(initial)
	local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if initial ~= nil then
		do v:appendString(initial:toString()) end
	end
	do return v end
end

function jk.lang.StringBuilder:resizeTo(size)
	local osz = #self.buffer
	if osz < size then
		while osz < size do
			osz = osz + 1024
		end
		self.buffer = _g.jk.lang.Buffer:resize(self.buffer, osz)
	end
end

function jk.lang.StringBuilder:_construct0()
	jk.lang.StringBuilder._init(self)
	do self:initialize() end
	return self
end

function jk.lang.StringBuilder:initialize()
	self.buffer = _util:allocate_buffer(1024)
end

function jk.lang.StringBuilder:clear()
	self.buffer = _util:allocate_buffer(1024)
	self.position = 0
end

function jk.lang.StringBuilder:count()
	do return self.position end
end

function jk.lang.StringBuilder:appendLong(c)
	do return self:appendString(_g.jk.lang.String:forLongInteger(c)) end
end

function jk.lang.StringBuilder:appendInteger(c)
	do return self:appendString(_g.jk.lang.String:forInteger(c)) end
end

function jk.lang.StringBuilder:appendDouble(c)
	do return self:appendString(_g.jk.lang.String:forDouble(c)) end
end

function jk.lang.StringBuilder:appendFloat(c)
	do return self:appendString(_g.jk.lang.String:forFloat(c)) end
end

function jk.lang.StringBuilder:appendCharacter(c)
	if c == 0 or c == -1 then
		do return self end
	end
	if c <= 127 then
		do self:resizeTo(self.position + 1) end
		self.buffer[self.position + 1] = _util:convert_to_integer(c)
		do self.position = self.position + 1 end
	else
		do self:appendString(_g.jk.lang.String:forCharacter(c)) end
	end
	do return self end
end

function jk.lang.StringBuilder:appendString(str)
	if str == nil then
		do return self end
	end
	do
		local nbuf = _g.jk.lang.String:toUTF8Buffer(str)
		if nbuf ~= nil then
			local nsz = #nbuf
			do self:resizeTo(self.position + nsz) end
			do _g.jk.lang.Buffer:copyFrom(self.buffer, nbuf, 0, self.position, nsz) end
			self.position = self.position + nsz
		end
		do return self end
	end
end

function jk.lang.StringBuilder:insertInteger(index, c)
	do return self:insertString(index, _g.jk.lang.String:forInteger(c)) end
end

function jk.lang.StringBuilder:insertCharacter(index, c)
	if c == 0 then
		do return self end
	end
	do return self:insertString(index, _g.jk.lang.String:forCharacter(c)) end
end

function jk.lang.StringBuilder:insertDouble(index, c)
	do return self:insertString(index, _g.jk.lang.String:forDouble(c)) end
end

function jk.lang.StringBuilder:insertFloat(index, c)
	do return self:insertString(index, _g.jk.lang.String:forFloat(c)) end
end

function jk.lang.StringBuilder:insertString(index, str)
	if str == nil then
		do return self end
	end
	do
		local nbuf = _g.jk.lang.String:toUTF8Buffer(str)
		if nbuf ~= nil then
			local nsz = #nbuf
			do self:resizeTo(self.position + nsz) end
			do _g.jk.lang.Buffer:copyFrom(self.buffer, self.buffer, index, index + nsz, self.position - index) end
			do _g.jk.lang.Buffer:copyFrom(self.buffer, nbuf, 0, index, nsz) end
			self.position = self.position + nsz
		end
		do return self end
	end
end

function jk.lang.StringBuilder:remove(index, length)
	if length < 1 then
		do return self end
	end
	if index < self.position then
		local ll = length
		local limit = self.position - index
		if ll > limit then
			ll = limit
		end
		do _g.jk.lang.Buffer:copyFrom(self.buffer, self.buffer, index + ll, index, self.position - index - ll) end
		self.position = self.position - ll
	end
	do return self end
end

function jk.lang.StringBuilder:removeLastCharacter()
	local c = self:count()
	if c > 0 then
		do self:remove(c - 1, 1) end
	end
	do return self end
end

function jk.lang.StringBuilder:toString()
	if not (self.buffer ~= nil) or self.position < 1 then
		do return "" end
	end
	do
		local bb = self.buffer
		if self.position < #bb then
			bb = _g.jk.lang.Buffer:getSubBuffer(bb, 0, self.position, false)
		end
		do return _g.jk.lang.String:forUTF8Buffer(bb) end
	end
end

jk.lang.CharacterIteratorForString = _g.jk.lang.CharacterDecoder._create()
jk.lang.CharacterIteratorForString.__index = jk.lang.CharacterIteratorForString
_vm:set_metatable(jk.lang.CharacterIteratorForString, {
	__index = _g.jk.lang.CharacterDecoder
})

function jk.lang.CharacterIteratorForString._create()
	local v = _vm:set_metatable({}, jk.lang.CharacterIteratorForString)
	return v
end

function jk.lang.CharacterIteratorForString:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.CharacterIteratorForString'
	self['_isType.jk.lang.CharacterIteratorForString'] = true
	self['_isType.jk.lang.Duplicateable'] = true
	self.string = nil
	self.stringSize = 0
	self.currentPosition = -1
end

function jk.lang.CharacterIteratorForString:_construct0()
	jk.lang.CharacterIteratorForString._init(self)
	do _g.jk.lang.CharacterDecoder._construct0(self) end
	return self
end

function jk.lang.CharacterIteratorForString:forString(string)
	local v = _g.jk.lang.CharacterIteratorForString._construct0(_g.jk.lang.CharacterIteratorForString._create())
	do v:setString(string) end
	do return v end
end

function jk.lang.CharacterIteratorForString:moveToPreviousByte()
	if self.currentPosition < 1 then
		do return false end
	end
	do self.currentPosition = self.currentPosition - 1 end
	do return true end
end

function jk.lang.CharacterIteratorForString:moveToNextByte()
	local n = self.currentPosition + 1
	self.currentPosition = n
	if n >= self.stringSize then
		do return false end
	end
	do return true end
end

function jk.lang.CharacterIteratorForString:getCurrentByte()
	do return _util:get_byte_from_string(self.string, self.currentPosition) end
end

function jk.lang.CharacterIteratorForString:getCurrentPosition()
	do return self.currentPosition end
end

function jk.lang.CharacterIteratorForString:setCurrentPosition(position)
	if position < 0 then
		self.current = 0
		self.currentPosition = -1
	else
		self.currentPosition = position + 1
		do self:doMoveToPreviousChar() end
	end
end

function jk.lang.CharacterIteratorForString:duplicate()
	local v = _g.jk.lang.CharacterIteratorForString._construct0(_g.jk.lang.CharacterIteratorForString._create())
	do _g.jk.lang.CharacterDecoder.copyTo(self, v) end
	v.string = self.string
	v.stringSize = self.stringSize
	v.currentPosition = self.currentPosition
	do return v end
end

function jk.lang.CharacterIteratorForString:setString(string)
	do self:resetDecoder() end
	self.string = string
	self.stringSize = _util:get_string_length(string)
	self.currentPosition = -1
end

jk.lang.Buffer = {}
jk.lang.Buffer.__index = jk.lang.Buffer
_vm:set_metatable(jk.lang.Buffer, {})

function jk.lang.Buffer._create()
	local v = _vm:set_metatable({}, jk.lang.Buffer)
	return v
end

function jk.lang.Buffer:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Buffer'
	self['_isType.jk.lang.Buffer'] = true
end

function jk.lang.Buffer:_construct0()
	jk.lang.Buffer._init(self)
	return self
end

jk.lang.Buffer.MyBufferObject = {}
jk.lang.Buffer.MyBufferObject.__index = jk.lang.Buffer.MyBufferObject
_vm:set_metatable(jk.lang.Buffer.MyBufferObject, {})

function jk.lang.Buffer.MyBufferObject._create()
	local v = _vm:set_metatable({}, jk.lang.Buffer.MyBufferObject)
	return v
end

function jk.lang.Buffer.MyBufferObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Buffer.MyBufferObject'
	self['_isType.jk.lang.Buffer.MyBufferObject'] = true
	self['_isType.jk.lang.BufferObject'] = true
	self.buffer = nil
end

function jk.lang.Buffer.MyBufferObject:_construct0()
	jk.lang.Buffer.MyBufferObject._init(self)
	return self
end

function jk.lang.Buffer.MyBufferObject:toBuffer()
	do return self.buffer end
end

function jk.lang.Buffer.MyBufferObject:getBuffer()
	do return self.buffer end
end

function jk.lang.Buffer.MyBufferObject:setBuffer(v)
	self.buffer = v
	do return self end
end

function jk.lang.Buffer:asObject(buffer)
	local v = _g.jk.lang.Buffer.MyBufferObject._construct0(_g.jk.lang.Buffer.MyBufferObject._create())
	do v:setBuffer(buffer) end
	do return v end
end

function jk.lang.Buffer:asBuffer(obj)
	if not (obj ~= nil) then
		do return nil end
	end
	if _util:is_buffer(obj) then
		do return obj end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BufferObject') ~= nil) then
		local bo = obj
		do return bo:toBuffer() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.Buffer:forInt32BE(_util:convert_to_integer(obj)) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.Buffer:forInt64BE(_util:convert_to_integer(obj)) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return _g.jk.lang.Buffer:forDouble64BE(obj) end
	end
	do return nil end
end

function jk.lang.Buffer:forInt8Array(buf)
	if not (buf ~= nil) then
		do return nil end
	end
	do
		local sz = #buf
		local v = _util:allocate_buffer(sz)
		do
			local n = 0
			while n < sz do
				v[n + 1] = buf[n + 1]
				do n = n + 1 end
			end
		end
		do return v end
	end
end

function jk.lang.Buffer:toInt8Array(buf)
	if not (buf ~= nil) then
		do return nil end
	end
	do
		local sz = #buf
		local v = _vm:allocate_array(sz)
		do
			local n = 0
			while n < sz do
				v[n + 1] = buf[n + 1]
				do n = n + 1 end
			end
		end
		do return v end
	end
end

function jk.lang.Buffer:getSubBuffer(buffer, offset, size, alwaysNewBuffer)
	if alwaysNewBuffer == false and offset == 0 and size < 0 then
		do return buffer end
	end
	do
		local bsz = _g.jk.lang.Buffer:getSize(buffer)
		local sz = size
		if sz < 0 then
			sz = bsz - offset
		end
		if alwaysNewBuffer == false and offset == 0 and sz == bsz then
			do return buffer end
		end
		if sz < 1 then
			do return nil end
		end
		do
			local v = _util:allocate_buffer(sz)
			do _g.jk.lang.Buffer:copyFrom(v, buffer, offset, 0, sz) end
			do return v end
		end
	end
end

function jk.lang.Buffer:getInt8(buffer, offset)
	if not (buffer ~= nil) then
		do return 0 end
	end
	do return buffer[offset+1] end
end

function jk.lang.Buffer:copyFrom(array, src, soffset, doffset, size)
	if not (array ~= nil) then
		do return end
	end
	if not (src ~= nil) then
		do return end
	end
	do _util:copy_buffer_bytes(src, array, soffset, doffset, size) end
end

function jk.lang.Buffer:getInt16LE(buffer, offset)
	if not (buffer ~= nil) then
		do return 0 end
	end
	do
		local b1 = buffer[offset + 1]
		local b2 = buffer[offset + 1 + 1]
		do return _util:network_bytes_to_host16(b2, b1) end
	end
end

function jk.lang.Buffer:getInt16BE(buffer, offset)
	if not (buffer ~= nil) then
		do return 0 end
	end
	do
		local b1 = buffer[offset + 1]
		local b2 = buffer[offset + 1 + 1]
		do return _util:network_bytes_to_host16(b1, b2) end
	end
end

function jk.lang.Buffer:getInt32LE(buffer, offset)
	local b1 = buffer[offset + 1]
	local b2 = buffer[offset + 1 + 1]
	local b3 = buffer[offset + 2 + 1]
	local b4 = buffer[offset + 3 + 1]
	do return _util:network_bytes_to_host32(b4, b3, b2, b1) end
end

function jk.lang.Buffer:getInt32BE(buffer, offset)
	local b1 = buffer[offset + 1]
	local b2 = buffer[offset + 1 + 1]
	local b3 = buffer[offset + 2 + 1]
	local b4 = buffer[offset + 3 + 1]
	do return _util:network_bytes_to_host32(b1, b2, b3, b4) end
end

function jk.lang.Buffer:getInt64LE(buffer, offset)
	local b1 = buffer[offset + 1]
	local b2 = buffer[offset + 1 + 1]
	local b3 = buffer[offset + 2 + 1]
	local b4 = buffer[offset + 3 + 1]
	local b5 = buffer[offset + 4 + 1]
	local b6 = buffer[offset + 5 + 1]
	local b7 = buffer[offset + 6 + 1]
	local b8 = buffer[offset + 7 + 1]
	do return _util:network_bytes_to_host64(b8, b7, b6, b5, b4, b3, b2, b1) end
end

function jk.lang.Buffer:getInt64BE(buffer, offset)
	_io:write_to_stdout("[jk.lang.Buffer.getInt64BE] (Buffer.sling:514:2): Not implemented" .. "\n")
	do return 0 end
end

function jk.lang.Buffer:getFloatLE(buffer, offset)
	_io:write_to_stdout("[jk.lang.Buffer.getFloatLE] (Buffer.sling:521:2): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.lang.Buffer:getFloatBE(buffer, offset)
	_io:write_to_stdout("[jk.lang.Buffer.getFloatBE] (Buffer.sling:528:2): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.lang.Buffer:getDoubleLE(buffer, offset)
	_io:write_to_stdout("[jk.lang.Buffer.getDoubleLE] (Buffer.sling:535:2): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.lang.Buffer:getDoubleBE(buffer, offset)
	_io:write_to_stdout("[jk.lang.Buffer.getDoubleBE] (Buffer.sling:542:2): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.lang.Buffer:forInt8(number)
	local v = _util:allocate_buffer(1)
	v[0 + 1] = _vm:bitwise_and(number, 255)
	do return v end
end

function jk.lang.Buffer:forInt16BE(number)
	do return _util:integer_to_buffer16(number, 0) end
end

function jk.lang.Buffer:forInt16LE(number)
	do return _util:integer_to_buffer16(number, 1) end
end

function jk.lang.Buffer:forInt32BE(number)
	do return _util:integer_to_buffer32(number, 0) end
end

function jk.lang.Buffer:forInt32LE(number)
	do return _util:integer_to_buffer32(number, 1) end
end

function jk.lang.Buffer:forInt64BE(number)
	do return _util:integer_to_buffer64(number, 0) end
end

function jk.lang.Buffer:forInt64LE(number)
	do return _util:integer_to_buffer64(number, 1) end
end

function jk.lang.Buffer:forFloat32BE(number)
	do return _util:float_to_buffer32(number, 0) end
end

function jk.lang.Buffer:forFloat32LE(number)
	do return _util:float_to_buffer32(number, 1) end
end

function jk.lang.Buffer:forDouble64BE(number)
	do return _util:double_to_buffer64(number, 0) end
end

function jk.lang.Buffer:forDouble64LE(number)
	do return _util:double_to_buffer64(number, 1) end
end

function jk.lang.Buffer:getSize(buffer)
	if buffer == nil then
		do return 0 end
	end
	do return #buffer end
end

function jk.lang.Buffer:getByte(buffer, offset)
	do return _g.jk.lang.Buffer:getInt8(buffer, offset) end
end

function jk.lang.Buffer:setByte(buffer, offset, value)
	if not (buffer ~= nil) then
		do return end
	end
	do buffer[offset+1] = value end
end

function jk.lang.Buffer:allocate(size)
	do return _util:allocate_buffer(size) end
end

function jk.lang.Buffer:fill(buffer, value)
	local s = _g.jk.lang.Buffer:getSize(buffer)
	do
		local i = 0
		while i < s do
			do _g.jk.lang.Buffer:setByte(buffer, i, value) end
			do i = i + 1 end
		end
	end
end

function jk.lang.Buffer:resize(buffer, newSize)
	if newSize < 1 then
		do return nil end
	end
	if not (buffer ~= nil) then
		do return _g.jk.lang.Buffer:allocate(newSize) end
	end
	if #buffer == newSize then
		do return buffer end
	end
	do
		local oldSize = 0
		if buffer ~= nil then
			oldSize = #buffer
		end
		do
			local v = _util:allocate_buffer(newSize)
			if newSize >= oldSize then
				if oldSize > 0 then
					do _g.jk.lang.Buffer:copyFrom(v, buffer, 0, 0, oldSize) end
				end
			else
				do _g.jk.lang.Buffer:copyFrom(v, buffer, 0, 0, newSize) end
			end
			do return v end
		end
	end
end

function jk.lang.Buffer:append(original, toAppend, size)
	if toAppend == nil or size == 0 then
		do return original end
	end
	do
		local sz = size
		local os = _g.jk.lang.Buffer:getSize(original)
		local oas = _g.jk.lang.Buffer:getSize(toAppend)
		if sz >= 0 then
			oas = sz
		end
		do
			local nl = os + oas
			local nb = _g.jk.lang.Buffer:resize(original, nl)
			do _g.jk.lang.Buffer:copyFrom(nb, toAppend, 0, os, oas) end
			do return nb end
		end
	end
end

function jk.lang.Buffer:forHexString(str)
	if str == nil or _util:convert_to_integer(_g.jk.lang.String:getLength(str) % 2) ~= 0 then
		do return nil end
	end
	do
		local sb = nil
		local b = _g.jk.lang.Buffer:allocate(_util:convert_to_integer(_g.jk.lang.String:getLength(str) / 2))
		local n = 0
		local it = _g.jk.lang.String:iterate(str)
		while it ~= nil do
			local c = it:getNextChar()
			if c < 1 then
				do break end
			end
			if sb == nil then
				sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			end
			if c >= 97 and c <= 102 or (c >= 65 and c <= 70) or (c >= 48 and c <= 57) then
				do sb:appendCharacter(c) end
				if sb:count() == 2 then
					do _g.jk.lang.Buffer:setByte(b, (function() local v = n n = n + 1 return v end)(), _g.jk.lang.String:toIntegerFromHex(sb:toString())) end
					do sb:clear() end
				end
			else
				do return nil end
			end
		end
		do return b end
	end
end

jk.lang.BooleanIterator = {}

jk.lang.Double = {}
jk.lang.Double.__index = jk.lang.Double
_vm:set_metatable(jk.lang.Double, {})

function jk.lang.Double._create()
	local v = _vm:set_metatable({}, jk.lang.Double)
	return v
end

function jk.lang.Double:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Double'
	self['_isType.jk.lang.Double'] = true
	self['_isType.jk.lang.DoubleObject'] = true
	self.value = 0.0
end

function jk.lang.Double:_construct0()
	jk.lang.Double._init(self)
	return self
end

function jk.lang.Double:forValue(value)
	do return _g.jk.lang.Double:asObject(value) end
end

function jk.lang.Double:asObject(value)
	local v = _g.jk.lang.Double._construct0(_g.jk.lang.Double._create())
	do v:setValue(value) end
	do return v end
end

function jk.lang.Double:asDouble(obj)
	if not (obj ~= nil) then
		do return 0.0 end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		do return obj end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.DoubleObject') ~= nil) then
		local od = obj
		do return od:toDouble() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = _util:convert_to_integer(obj)
		do return v end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.IntegerObject') ~= nil) then
		local oi = obj
		do return oi:toInteger() end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = _util:convert_to_integer(obj)
		do return v end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.LongIntegerObject') ~= nil) then
		local oi = obj
		do return oi:toLong() end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		do return _g.jk.lang.String:toDouble(obj) end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.StringObject') ~= nil) then
		do return _g.jk.lang.String:toDouble(obj:toString()) end
	end
	if (_vm:get_variable_type(obj) == 'number') then
		local v = obj
		do return v end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.CharacterObject') ~= nil) then
		local oc = obj
		do return oc:toCharacter() end
	end
	if (_vm:get_variable_type(obj) == 'boolean') then
		if obj == true then
			do return 1.0 end
		end
		do return 0.0 end
	end
	if (_vm:to_table_with_key(obj, '_isType.jk.lang.BooleanObject') ~= nil) then
		if obj:toBoolean() then
			do return 1.0 end
		end
		do return 0.0 end
	end
	do return 0.0 end
end

function jk.lang.Double:longBitsToDouble(vv)
	_io:write_to_stdout("[jk.lang.Double.longBitsToDouble] (Double.sling:98:3): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.lang.Double:doubleToLongBits(vv)
	_io:write_to_stdout("[jk.lang.Double.doubleToLongBits] (Double.sling:112:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.lang.Double:add(amount)
	self.value = self.value + amount
end

function jk.lang.Double:toDouble()
	do return self.value end
end

function jk.lang.Double:getValue()
	do return self.value end
end

function jk.lang.Double:setValue(v)
	self.value = v
	do return self end
end

jk.lang.Character = {}
jk.lang.Character.__index = jk.lang.Character
_vm:set_metatable(jk.lang.Character, {})

function jk.lang.Character._create()
	local v = _vm:set_metatable({}, jk.lang.Character)
	return v
end

function jk.lang.Character:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Character'
	self['_isType.jk.lang.Character'] = true
	self['_isType.jk.lang.CharacterObject'] = true
	self.character = 0
end

function jk.lang.Character:_construct0()
	jk.lang.Character._init(self)
	return self
end

function jk.lang.Character:asObject(character)
	local v = _g.jk.lang.Character._construct0(_g.jk.lang.Character._create())
	do v:setCharacter(character) end
	do return v end
end

function jk.lang.Character:toUppercase(c)
	if c >= 97 and c <= 122 then
		do return c - 97 + 65 end
	end
	do return c end
end

function jk.lang.Character:toLowercase(c)
	if c >= 65 and c <= 90 then
		do return c - 65 + 97 end
	end
	do return c end
end

function jk.lang.Character:isDigit(c)
	do return c >= 48 and c <= 57 end
end

function jk.lang.Character:isLowercaseAlpha(c)
	do return c >= 97 and c <= 122 end
end

function jk.lang.Character:isUppercaseAlpha(c)
	do return c >= 65 and c <= 90 end
end

function jk.lang.Character:isHexDigit(c)
	local v = c >= 97 and c <= 102 or (c >= 65 and c <= 70) or (c >= 48 and c <= 57)
	do return v end
end

function jk.lang.Character:isAlnum(c)
	local v = c >= 97 and c <= 122 or (c >= 65 and c <= 90) or (c >= 48 and c <= 57)
	do return v end
end

function jk.lang.Character:isAlpha(c)
	local v = c >= 97 and c <= 122 or (c >= 65 and c <= 90)
	do return v end
end

function jk.lang.Character:isAlphaNumeric(c)
	local v = c >= 97 and c <= 122 or (c >= 65 and c <= 90) or (c >= 48 and c <= 57)
	do return v end
end

function jk.lang.Character:isLowercaseAlphaNumeric(c)
	local v = c >= 97 and c <= 122 or (c >= 48 and c <= 57)
	do return v end
end

function jk.lang.Character:isUppercaseAlphaNumeric(c)
	local v = c >= 65 and c <= 90 or (c >= 48 and c <= 57)
	do return v end
end

function jk.lang.Character:toCharacter()
	do return self.character end
end

function jk.lang.Character:isEOF(c)
	do return c == 0 or c == -1 end
end

function jk.lang.Character:getHexDigit(c)
	local v = 0
	if c >= 48 and c <= 57 then
		v = _util:convert_to_integer(c - 48)
	elseif c >= 97 and c <= 102 then
		v = 10 + c - 97
	elseif c >= 65 and c <= 70 then
		v = 10 + c - 65
	else
		do return 0 end
	end
	do return v end
end

function jk.lang.Character:getCharacter()
	do return self.character end
end

function jk.lang.Character:setCharacter(v)
	self.character = v
	do return self end
end

jk.lang.Map = {}
jk.lang.Map.__index = jk.lang.Map
_vm:set_metatable(jk.lang.Map, {})

function jk.lang.Map._create()
	local v = _vm:set_metatable({}, jk.lang.Map)
	return v
end

function jk.lang.Map:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Map'
	self['_isType.jk.lang.Map'] = true
end

function jk.lang.Map:_construct0()
	jk.lang.Map._init(self)
	return self
end

jk.lang.Map.MyMapObject = {}
jk.lang.Map.MyMapObject.__index = jk.lang.Map.MyMapObject
_vm:set_metatable(jk.lang.Map.MyMapObject, {})

function jk.lang.Map.MyMapObject._create()
	local v = _vm:set_metatable({}, jk.lang.Map.MyMapObject)
	return v
end

function jk.lang.Map.MyMapObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.Map.MyMapObject'
	self['_isType.jk.lang.Map.MyMapObject'] = true
	self['_isType.jk.lang.MapObject'] = true
	self.map = nil
end

function jk.lang.Map.MyMapObject:_construct0()
	jk.lang.Map.MyMapObject._init(self)
	return self
end

function jk.lang.Map.MyMapObject:toMap()
	do return self.map end
end

function jk.lang.Map.MyMapObject:getMap()
	do return self.map end
end

function jk.lang.Map.MyMapObject:setMap(v)
	self.map = v
	do return self end
end

function jk.lang.Map:asObject(map)
	if not (map ~= nil) then
		do return nil end
	end
	do
		local v = _g.jk.lang.Map.MyMapObject._construct0(_g.jk.lang.Map.MyMapObject._create())
		do v:setMap(map) end
		do return v end
	end
end

function jk.lang.Map:asMap(o)
	if not (o ~= nil) then
		do return nil end
	end
	do return nil end
end

function jk.lang.Map:getWithDefault(map, key, ddf)
	if map == nil or key == nil then
		do return ddf end
	end
	if _g.jk.lang.Map:containsKey(map, key) == false then
		do return ddf end
	end
	do return _g.jk.lang.Map:getValue(map, key) end
end

function jk.lang.Map:get(map, key)
	do return _g.jk.lang.Map:getValue(map, key) end
end

function jk.lang.Map:getValue(map, key)
	if map == nil or key == nil then
		do return nil end
	end
	do return map[key] end
end

function jk.lang.Map:set(data, key, val)
	if not (data ~= nil) then
		do return false end
	end
	if not (key ~= nil) then
		do return false end
	end
	data[key] = val
	do return true end
end

function jk.lang.Map:setValue(data, key, val)
	do return _g.jk.lang.Map:set(data, key, val) end
end

function jk.lang.Map:remove(data, key)
	if not (data ~= nil) then
		do return end
	end
	if not (key ~= nil) then
		do return end
	end
	do data[key] = nil end
end

function jk.lang.Map:count(data)
	if data == nil then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(_g.jk.lang.Map:getKeys(data)) end
end

function jk.lang.Map:containsKey(data, key)
	if not (data ~= nil) then
		do return false end
	end
	if not (key ~= nil) then
		do return false end
	end
	do
		local array = _g.jk.lang.Map:getKeys(data)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local kk = array[n + 1]
					if kk ~= nil then
						if key == kk then
							do return true end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function jk.lang.Map:containsValue(data, val)
	if not (data ~= nil) then
		do return false end
	end
	if not (val ~= nil) then
		do return false end
	end
	do
		local array = _g.jk.lang.Map:getValues(data)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local vv = array[n + 1]
					if vv ~= nil then
						if val == vv then
							do return true end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function jk.lang.Map:clear(data)
	if not (data ~= nil) then
		do return end
	end
	do _vm:clear_table(data) end
end

function jk.lang.Map:dup(data)
	if not (data ~= nil) then
		do return nil end
	end
	_io:write_to_stdout("[jk.lang.Map.dup] (Map.sling:372:3): Not implemented" .. "\n")
	do return nil end
end

function jk.lang.Map:getKeys(data)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local v = nil
		do v = _vm:get_table_keys(data) end
		do return v end
	end
end

function jk.lang.Map:getValues(data)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local v = nil
		do v = _vm:get_table_values(data) end
		do return v end
	end
end

function jk.lang.Map:iterateKeys(data)
	do return _g.jk.lang.Vector:iterate(_g.jk.lang.Map:getKeys(data)) end
end

function jk.lang.Map:iterateValues(data)
	do return _g.jk.lang.Vector:iterate(_g.jk.lang.Map:getValues(data)) end
end

jk.lang.DynamicObject = {}
jk.lang.DynamicObject.__index = jk.lang.DynamicObject
_vm:set_metatable(jk.lang.DynamicObject, {})

function jk.lang.DynamicObject._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicObject)
	return v
end

function jk.lang.DynamicObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicObject'
	self['_isType.jk.lang.DynamicObject'] = true
end

function jk.lang.DynamicObject:_construct0()
	jk.lang.DynamicObject._init(self)
	return self
end

jk.lang.DynamicObject.StringIteratorWrapper = {}
jk.lang.DynamicObject.StringIteratorWrapper.__index = jk.lang.DynamicObject.StringIteratorWrapper
_vm:set_metatable(jk.lang.DynamicObject.StringIteratorWrapper, {})

function jk.lang.DynamicObject.StringIteratorWrapper._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicObject.StringIteratorWrapper)
	return v
end

function jk.lang.DynamicObject.StringIteratorWrapper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicObject.StringIteratorWrapper'
	self['_isType.jk.lang.DynamicObject.StringIteratorWrapper'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.iterator = nil
end

function jk.lang.DynamicObject.StringIteratorWrapper:_construct0()
	jk.lang.DynamicObject.StringIteratorWrapper._init(self)
	return self
end

function jk.lang.DynamicObject.StringIteratorWrapper:next()
	if not (self.iterator ~= nil) then
		do return nil end
	end
	do
		local c = self.iterator:getNextChar()
		if _g.jk.lang.Character:isEOF(c) then
			self.iterator = nil
			do return nil end
		end
		do return c end
	end
end

function jk.lang.DynamicObject.StringIteratorWrapper:hasNext()
	if not (self.iterator ~= nil) then
		do return false end
	end
	do return not self.iterator:hasEnded() end
end

function jk.lang.DynamicObject.StringIteratorWrapper:getIterator()
	do return self.iterator end
end

function jk.lang.DynamicObject.StringIteratorWrapper:setIterator(v)
	self.iterator = v
	do return self end
end

jk.lang.DynamicObject.BufferIteratorWrapper = {}
jk.lang.DynamicObject.BufferIteratorWrapper.__index = jk.lang.DynamicObject.BufferIteratorWrapper
_vm:set_metatable(jk.lang.DynamicObject.BufferIteratorWrapper, {})

function jk.lang.DynamicObject.BufferIteratorWrapper._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicObject.BufferIteratorWrapper)
	return v
end

function jk.lang.DynamicObject.BufferIteratorWrapper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicObject.BufferIteratorWrapper'
	self['_isType.jk.lang.DynamicObject.BufferIteratorWrapper'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.buffer = nil
	self.size = 0
	self.position = 0
end

function jk.lang.DynamicObject.BufferIteratorWrapper:_construct0()
	jk.lang.DynamicObject.BufferIteratorWrapper._init(self)
	return self
end

function jk.lang.DynamicObject.BufferIteratorWrapper:next()
	if not (self.buffer ~= nil) then
		do return nil end
	end
	if self.position >= self.size then
		do return nil end
	end
	do
		local v = self.buffer[self.position + 1]
		do self.position = self.position + 1 end
		do return v end
	end
end

function jk.lang.DynamicObject.BufferIteratorWrapper:hasNext()
	if not (self.buffer ~= nil) then
		do return false end
	end
	if not (self.position < self.size - 1) then
		do return false end
	end
	do return true end
end

function jk.lang.DynamicObject.BufferIteratorWrapper:getBuffer()
	do return self.buffer end
end

function jk.lang.DynamicObject.BufferIteratorWrapper:setBuffer(v)
	self.buffer = v
	do return self end
end

function jk.lang.DynamicObject.BufferIteratorWrapper:getSize()
	do return self.size end
end

function jk.lang.DynamicObject.BufferIteratorWrapper:setSize(v)
	self.size = v
	do return self end
end

jk.lang.DynamicObject.ArrayIteratorWrapper = {}
jk.lang.DynamicObject.ArrayIteratorWrapper.__index = jk.lang.DynamicObject.ArrayIteratorWrapper
_vm:set_metatable(jk.lang.DynamicObject.ArrayIteratorWrapper, {})

function jk.lang.DynamicObject.ArrayIteratorWrapper._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicObject.ArrayIteratorWrapper)
	return v
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicObject.ArrayIteratorWrapper'
	self['_isType.jk.lang.DynamicObject.ArrayIteratorWrapper'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.array = nil
	self.size = 0
	self.position = 0
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:_construct0()
	jk.lang.DynamicObject.ArrayIteratorWrapper._init(self)
	return self
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:next()
	if not (self.array ~= nil) then
		do return nil end
	end
	if self.position >= self.size then
		do return nil end
	end
	do
		local v = self.array[self.position + 1]
		do self.position = self.position + 1 end
		do return v end
	end
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:hasNext()
	if not (self.array ~= nil) then
		do return false end
	end
	if not (self.position < self.size - 1) then
		do return false end
	end
	do return true end
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:getArray()
	do return self.array end
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:setArray(v)
	self.array = v
	do return self end
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:getSize()
	do return self.size end
end

function jk.lang.DynamicObject.ArrayIteratorWrapper:setSize(v)
	self.size = v
	do return self end
end

jk.lang.DynamicObject.VectorIteratorWrapper = {}
jk.lang.DynamicObject.VectorIteratorWrapper.__index = jk.lang.DynamicObject.VectorIteratorWrapper
_vm:set_metatable(jk.lang.DynamicObject.VectorIteratorWrapper, {})

function jk.lang.DynamicObject.VectorIteratorWrapper._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicObject.VectorIteratorWrapper)
	return v
end

function jk.lang.DynamicObject.VectorIteratorWrapper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicObject.VectorIteratorWrapper'
	self['_isType.jk.lang.DynamicObject.VectorIteratorWrapper'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.vector = nil
	self.size = 0
	self.position = 0
end

function jk.lang.DynamicObject.VectorIteratorWrapper:_construct0()
	jk.lang.DynamicObject.VectorIteratorWrapper._init(self)
	return self
end

function jk.lang.DynamicObject.VectorIteratorWrapper:next()
	if not (self.vector ~= nil) then
		do return nil end
	end
	if self.position >= self.size then
		do return nil end
	end
	do
		local v = self.vector[self.position + 1]
		do self.position = self.position + 1 end
		do return v end
	end
end

function jk.lang.DynamicObject.VectorIteratorWrapper:hasNext()
	if not (self.vector ~= nil) then
		do return false end
	end
	if not (self.position < self.size - 1) then
		do return false end
	end
	do return true end
end

function jk.lang.DynamicObject.VectorIteratorWrapper:getVector()
	do return self.vector end
end

function jk.lang.DynamicObject.VectorIteratorWrapper:setVector(v)
	self.vector = v
	do return self end
end

function jk.lang.DynamicObject.VectorIteratorWrapper:getSize()
	do return self.size end
end

function jk.lang.DynamicObject.VectorIteratorWrapper:setSize(v)
	self.size = v
	do return self end
end

function jk.lang.DynamicObject:iterate(object)
	if (_vm:get_variable_type(object) == 'string') then
		local v = _g.jk.lang.DynamicObject.StringIteratorWrapper._construct0(_g.jk.lang.DynamicObject.StringIteratorWrapper._create())
		do v:setIterator(_g.jk.lang.String:iterate(object)) end
		do return v end
	end
	if _util:is_buffer(object) then
		local v = _g.jk.lang.DynamicObject.BufferIteratorWrapper._construct0(_g.jk.lang.DynamicObject.BufferIteratorWrapper._create())
		do v:setBuffer(object) end
		do v:setSize(#object) end
		do return v end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(object) then
		local v = _g.jk.lang.DynamicObject.ArrayIteratorWrapper._construct0(_g.jk.lang.DynamicObject.ArrayIteratorWrapper._create())
		do v:setArray(object) end
		do v:setSize(#object) end
		do return v end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(object) then
		local v = _g.jk.lang.DynamicObject.VectorIteratorWrapper._construct0(_g.jk.lang.DynamicObject.VectorIteratorWrapper._create())
		do v:setVector(object) end
		do v:setSize(_g.jk.lang.Vector:getSize(object)) end
		do return v end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x < 1 end)(object) then
		do return _g.jk.lang.DynamicObject:iterate(_g.jk.lang.Map:getValues(object)) end
	end
	do return nil end
end

jk.lang.DynamicMap = {}
jk.lang.DynamicMap.__index = jk.lang.DynamicMap
_vm:set_metatable(jk.lang.DynamicMap, {})

jk.lang.DynamicMap.nullObject = "null"

function jk.lang.DynamicMap._create()
	local v = _vm:set_metatable({}, jk.lang.DynamicMap)
	return v
end

function jk.lang.DynamicMap:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DynamicMap'
	self['_isType.jk.lang.DynamicMap'] = true
	self['_isType.jk.lang.Duplicateable'] = true
	self['_isType.jk.lang.Iterateable'] = true
	self.map = nil
end

function jk.lang.DynamicMap:asDynamicMap(object)
	if not (object ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(object, '_isType.jk.lang.DynamicMap') ~= nil) then
		do return object end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x < 1 end)(object) then
		do return _g.jk.lang.DynamicMap:forObjectMap(object) end
	end
	do return nil end
end

function jk.lang.DynamicMap:forObjectMap(map)
	local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	if map ~= nil then
		local it = _g.jk.lang.Map:iterateKeys(map)
		while it ~= nil do
			local key = it:next()
			if key == nil then
				do break end
			end
			if (_vm:get_variable_type(key) == 'string') == false then
				goto _continue1
			end
			do v:setObject(key, _g.jk.lang.Map:getValue(map, key)) end
			::_continue1::
		end
	end
	do return v end
end

function jk.lang.DynamicMap:forStringMap(map)
	local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	if map ~= nil then
		local it = _g.jk.lang.Map:iterateKeys(map)
		while it ~= nil do
			local key = it:next()
			if key == nil then
				do break end
			end
			do v:setString(key, _g.jk.lang.Map:getValue(map, key)) end
		end
	end
	do return v end
end

function jk.lang.DynamicMap:forDynamicMaps(map1, map2)
	local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	do v:mergeFrom(map1) end
	do v:mergeFrom(map2) end
	do return v end
end

function jk.lang.DynamicMap:forDynamicMap(map)
	if not (map ~= nil) then
		do return nil end
	end
	do return map:duplicateMap() end
end

function jk.lang.DynamicMap:_construct0()
	jk.lang.DynamicMap._init(self)
	self.map = {}
	return self
end

function jk.lang.DynamicMap:asMap()
	local v = {}
	local it = self:iterateKeys()
	while it ~= nil do
		local key = it:next()
		if not (key ~= nil) then
			do break end
		end
		do _g.jk.lang.Map:set(v, key, self:get(key)) end
	end
	do return v end
end

function jk.lang.DynamicMap:asStringMap()
	do return self:toStringMap() end
end

function jk.lang.DynamicMap:toStringMap()
	local v = {}
	local it = self:iterateKeys()
	while it ~= nil do
		local key = it:next()
		if not (key ~= nil) then
			do break end
		end
		do _g.jk.lang.Map:set(v, key, self:getString(key, nil)) end
	end
	do return v end
end

function jk.lang.DynamicMap:toObjectMap()
	local v = {}
	local it = self:iterateKeys()
	while it ~= nil do
		local key = it:next()
		if not (key ~= nil) then
			do break end
		end
		do _g.jk.lang.Map:set(v, key, self:getString(key, nil)) end
	end
	do return v end
end

function jk.lang.DynamicMap:duplicate()
	do return self:duplicateMap() end
end

function jk.lang.DynamicMap:duplicateMap()
	local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	local it = self:iterateKeys()
	while it ~= nil do
		local key = it:next()
		if key == nil then
			do break end
		end
		do v:setObject(key, self:get(key)) end
	end
	do return v end
end

function jk.lang.DynamicMap:mergeFrom(other)
	if other == nil then
		do return self end
	end
	do
		local it = other:iterateKeys()
		while it ~= nil do
			local key = it:next()
			if key == nil then
				do break end
			end
			do self:setObject(key, other:get(key)) end
		end
		do return self end
	end
end

function jk.lang.DynamicMap:setObject(key, value)
	if key ~= nil then
		if value == nil then
			self.map[key] = _g.jk.lang.DynamicMap.nullObject
		else
			self.map[key] = value
		end
	end
	do return self end
end

function jk.lang.DynamicMap:setString(key, value)
	if key ~= nil then
		if value == nil then
			self.map[key] = _g.jk.lang.DynamicMap.nullObject
		else
			self.map[key] = value
		end
	end
	do return self end
end

function jk.lang.DynamicMap:setBuffer(key, value)
	if not (key == nil) and value == nil then
		self.map[key] = _g.jk.lang.DynamicMap.nullObject
		do return self end
	end
	do return self:setObject(key, _g.jk.lang.Buffer:asObject(value)) end
end

function jk.lang.DynamicMap:setInteger(key, value)
	do return self:setObject(key, _g.jk.lang.Integer:asObject(value)) end
end

function jk.lang.DynamicMap:setLong(key, value)
	do return self:setObject(key, _g.jk.lang.LongInteger:asObject(value)) end
end

function jk.lang.DynamicMap:setLongInteger(key, value)
	do return self:setObject(key, _g.jk.lang.LongInteger:asObject(value)) end
end

function jk.lang.DynamicMap:setBoolean(key, value)
	do return self:setObject(key, _g.jk.lang.Boolean:asObject(value)) end
end

function jk.lang.DynamicMap:setDouble(key, value)
	do return self:setObject(key, _g.jk.lang.Double:asObject(value)) end
end

function jk.lang.DynamicMap:get(key)
	local v = _g.jk.lang.Map:getValue(self.map, key)
	if v == _g.jk.lang.DynamicMap.nullObject then
		v = nil
	end
	do return v end
end

function jk.lang.DynamicMap:getString(key, defval)
	local v = _g.jk.lang.String:asString(self:get(key))
	if v == nil then
		do return defval end
	end
	do return v end
end

function jk.lang.DynamicMap:getInteger(key, defval)
	local vv = self:get(key)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.Integer:asInteger(vv) end
end

function jk.lang.DynamicMap:getLongInteger(key, defval)
	local vv = self:get(key)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.LongInteger:asLong(vv) end
end

function jk.lang.DynamicMap:getBoolean(key, defval)
	local vv = self:get(key)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.Boolean:asBoolean(vv, false) end
end

function jk.lang.DynamicMap:getDouble(key, defval)
	local vv = self:get(key)
	if vv == nil then
		do return defval end
	end
	do return _g.jk.lang.Double:asDouble(vv) end
end

function jk.lang.DynamicMap:getBuffer(key)
	local vv = self:get(key)
	if not (vv ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Buffer:asBuffer(vv) end
end

function jk.lang.DynamicMap:getDynamicVector(key)
	local vv = _vm:to_table_with_key(self:get(key), '_isType.jk.lang.DynamicVector')
	if vv ~= nil then
		do return vv end
	end
	do
		local v = self:getVector(key)
		if v ~= nil then
			do return _g.jk.lang.DynamicVector:forObjectVector(v) end
		end
		do return nil end
	end
end

function jk.lang.DynamicMap:getVector(key)
	local val = self:get(key)
	if not (val ~= nil) then
		do return nil end
	end
	if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(val) then
		do return val end
	end
	if (_vm:to_table_with_key(val, '_isType.jk.lang.VectorObject') ~= nil) then
		local vo = val
		local vv = vo:toVector()
		do return vv end
	end
	do return nil end
end

function jk.lang.DynamicMap:getDynamicMap(key)
	do return _vm:to_table_with_key(self:get(key), '_isType.jk.lang.DynamicMap') end
end

function jk.lang.DynamicMap:getKeys()
	local v = _g.jk.lang.Map:getKeys(self.map)
	do return v end
end

function jk.lang.DynamicMap:getValues()
	local v = _g.jk.lang.Map:getValues(self.map)
	local v2 = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local o = v[n + 1]
				if o ~= nil then
					if o ~= _g.jk.lang.DynamicMap.nullObject then
						do _g.jk.lang.Vector:append(v2, o) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	v = v2
	do return v end
end

function jk.lang.DynamicMap:iterate()
	local v = _g.jk.lang.Map:iterateKeys(self.map)
	do return v end
end

function jk.lang.DynamicMap:iterateKeys()
	local v = _g.jk.lang.Map:iterateKeys(self.map)
	do return v end
end

function jk.lang.DynamicMap:iterateValues()
	do return _g.jk.lang.Vector:iterate(self:getValues()) end
end

function jk.lang.DynamicMap:remove(key)
	do _g.jk.lang.Map:remove(self.map, key) end
end

function jk.lang.DynamicMap:clear()
	do _g.jk.lang.Map:clear(self.map) end
end

function jk.lang.DynamicMap:getCount()
	do return _g.jk.lang.Map:count(self.map) end
end

function jk.lang.DynamicMap:containsKey(key)
	do return _g.jk.lang.Map:containsKey(self.map, key) end
end

function jk.lang.DynamicMap:removeNullValues()
	local keys = self:getKeys()
	if keys ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(keys)
		do
			n = 0
			while n < m do
				local key = keys[n + 1]
				if key ~= nil then
					local value = self:get(key)
					if value == nil then
						do self:remove(key) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return self end
end

jk.lang.KeyValueListForStrings = _g.jk.lang.KeyValueList._create()
jk.lang.KeyValueListForStrings.__index = jk.lang.KeyValueListForStrings
_vm:set_metatable(jk.lang.KeyValueListForStrings, {
	__index = _g.jk.lang.KeyValueList
})

function jk.lang.KeyValueListForStrings._create()
	local v = _vm:set_metatable({}, jk.lang.KeyValueListForStrings)
	return v
end

function jk.lang.KeyValueListForStrings:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.KeyValueListForStrings'
	self['_isType.jk.lang.KeyValueListForStrings'] = true
end

function jk.lang.KeyValueListForStrings:_construct0()
	jk.lang.KeyValueListForStrings._init(self)
	do _g.jk.lang.KeyValueList._construct0(self) end
	return self
end

jk.lang.RunnableFunction = {}
jk.lang.RunnableFunction.__index = jk.lang.RunnableFunction
_vm:set_metatable(jk.lang.RunnableFunction, {})

function jk.lang.RunnableFunction._create()
	local v = _vm:set_metatable({}, jk.lang.RunnableFunction)
	return v
end

function jk.lang.RunnableFunction:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.RunnableFunction'
	self['_isType.jk.lang.RunnableFunction'] = true
	self['_isType.jk.lang.Runnable'] = true
	self._function = nil
end

function jk.lang.RunnableFunction:_construct0()
	jk.lang.RunnableFunction._init(self)
	return self
end

function jk.lang.RunnableFunction:forFunction(_function)
	local v = _g.jk.lang.RunnableFunction._construct0(_g.jk.lang.RunnableFunction._create())
	do v:setFunction(_function) end
	do return v end
end

function jk.lang.RunnableFunction:run()
	if self._function ~= nil then
		do self._function() end
	end
end

function jk.lang.RunnableFunction:getFunction()
	do return self._function end
end

function jk.lang.RunnableFunction:setFunction(v)
	self._function = v
	do return self end
end

jk.lang.DateTime = {}
jk.lang.DateTime.__index = jk.lang.DateTime
_vm:set_metatable(jk.lang.DateTime, {})

function jk.lang.DateTime._create()
	local v = _vm:set_metatable({}, jk.lang.DateTime)
	return v
end

function jk.lang.DateTime:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.DateTime'
	self['_isType.jk.lang.DateTime'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.timezoneOffset = 0
	self.weekDay = 0
	self.dayOfMonth = 0
	self.month = 0
	self.year = 0
	self.hours = 0
	self.minutes = 0
	self.seconds = 0
end

function jk.lang.DateTime:_construct0()
	jk.lang.DateTime._init(self)
	return self
end

function jk.lang.DateTime:forSeconds(seconds)
	local v = _g.jk.lang.DateTime._construct0(_g.jk.lang.DateTime._create())
	do v:updateFromTimestamp(seconds) end
	do return v end
end

function jk.lang.DateTime:forTimeValue(tv)
	if not (tv ~= nil) then
		do return nil end
	end
	do
		local v = _g.jk.lang.DateTime._construct0(_g.jk.lang.DateTime._create())
		do v:updateFromTimestamp(tv:getSeconds()) end
		do return v end
	end
end

function jk.lang.DateTime:forString(string)
	if not (string ~= nil) then
		do return nil end
	end
	do
		local comps = _g.jk.lang.String:split(string, 32, 2)
		if not (comps ~= nil) then
			do return nil end
		end
		do
			local c0 = _g.jk.lang.Vector:get(comps, 0)
			local c1 = _g.jk.lang.Vector:get(comps, 1)
			if not _g.jk.lang.String:isNotEmpty(c0) then
				do return nil end
			end
			do
				local comps2 = _g.jk.lang.String:split(c0, 45, 3)
				if not (comps2 ~= nil) then
					do return nil end
				end
				if not (_g.jk.lang.Vector:getSize(comps2) == 3) then
					do return nil end
				end
				do
					local v = _g.jk.lang.DateTime._construct0(_g.jk.lang.DateTime._create())
					do v:setYear(_g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(comps2, 0))) end
					do v:setMonth(_g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(comps2, 1))) end
					do v:setDayOfMonth(_g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(comps2, 2))) end
					if _g.jk.lang.String:isNotEmpty(c1) then
						local tcs = _g.jk.lang.String:split(c1, 58, 3)
						if _g.jk.lang.Vector:getSize(tcs) == 3 then
							do v:setHours(_g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(tcs, 0))) end
							do v:setMinutes(_g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(tcs, 1))) end
							do v:setSeconds(_g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(tcs, 2))) end
						end
					end
					do return v end
				end
			end
		end
	end
end

function jk.lang.DateTime:updateFromTimestamp(seconds)
	local o = self
	do o.weekDay, o.dayOfMonth, o.month, o.year, o.hours, o.minutes, o.seconds = _os:get_timestamp_details_utc(seconds) end
end

function jk.lang.DateTime:toStringDate(delim)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(self:getYear(), 4, nil)) end
	if delim > 0 then
		do sb:appendCharacter(delim) end
	end
	do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(self:getMonth(), 2, nil)) end
	if delim > 0 then
		do sb:appendCharacter(delim) end
	end
	do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(self:getDayOfMonth(), 2, nil)) end
	do return sb:toString() end
end

function jk.lang.DateTime:toStringTime(delim)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(self:getHours(), 2, nil)) end
	if delim > 0 then
		do sb:appendCharacter(delim) end
	end
	do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(self:getMinutes(), 2, nil)) end
	if delim > 0 then
		do sb:appendCharacter(delim) end
	end
	do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(self:getSeconds(), 2, nil)) end
	do return sb:toString() end
end

function jk.lang.DateTime:toStringDateTime()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(self:toStringDate(45)) end
	do sb:appendString(" ") end
	do sb:appendString(self:toStringTime(58)) end
	do return sb:toString() end
end

function jk.lang.DateTime:toString()
	do return self:toStringDateTime() end
end

function jk.lang.DateTime:getTimezoneOffset()
	do return self.timezoneOffset end
end

function jk.lang.DateTime:setTimezoneOffset(v)
	self.timezoneOffset = v
	do return self end
end

function jk.lang.DateTime:getWeekDay()
	do return self.weekDay end
end

function jk.lang.DateTime:setWeekDay(v)
	self.weekDay = v
	do return self end
end

function jk.lang.DateTime:getDayOfMonth()
	do return self.dayOfMonth end
end

function jk.lang.DateTime:setDayOfMonth(v)
	self.dayOfMonth = v
	do return self end
end

function jk.lang.DateTime:getMonth()
	do return self.month end
end

function jk.lang.DateTime:setMonth(v)
	self.month = v
	do return self end
end

function jk.lang.DateTime:getYear()
	do return self.year end
end

function jk.lang.DateTime:setYear(v)
	self.year = v
	do return self end
end

function jk.lang.DateTime:getHours()
	do return self.hours end
end

function jk.lang.DateTime:setHours(v)
	self.hours = v
	do return self end
end

function jk.lang.DateTime:getMinutes()
	do return self.minutes end
end

function jk.lang.DateTime:setMinutes(v)
	self.minutes = v
	do return self end
end

function jk.lang.DateTime:getSeconds()
	do return self.seconds end
end

function jk.lang.DateTime:setSeconds(v)
	self.seconds = v
	do return self end
end

jk.lang.EventLoop = {}

jk.lang.BufferBuilder = {}
jk.lang.BufferBuilder.__index = jk.lang.BufferBuilder
_vm:set_metatable(jk.lang.BufferBuilder, {})

function jk.lang.BufferBuilder._create()
	local v = _vm:set_metatable({}, jk.lang.BufferBuilder)
	return v
end

function jk.lang.BufferBuilder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.lang.BufferBuilder'
	self['_isType.jk.lang.BufferBuilder'] = true
	self.buffer = nil
	self.pointer = 0
end

function jk.lang.BufferBuilder:_construct0()
	jk.lang.BufferBuilder._init(self)
	return self
end

function jk.lang.BufferBuilder:allocate(sz)
	if self.buffer == nil then
		self.buffer = _util:allocate_buffer(8192)
		do return end
	end
	do
		local needed = self.pointer + sz
		local csz = _g.jk.lang.Buffer:getSize(self.buffer)
		if csz >= needed then
			do return end
		end
		do
			local nsz = csz
			while nsz < needed do
				nsz = nsz + 1024
			end
			self.buffer = _g.jk.lang.Buffer:resize(self.buffer, nsz)
		end
	end
end

function jk.lang.BufferBuilder:getSize()
	do return self.pointer end
end

function jk.lang.BufferBuilder:appendInteger(value)
	do self:allocate(self.pointer + 1) end
	do _g.jk.lang.Buffer:setByte(self.buffer, self.pointer, value) end
	do self.pointer = self.pointer + 1 end
end

function jk.lang.BufferBuilder:appendBuffer(sbuffer)
	do self:appendSubBuffer(sbuffer, 0, _g.jk.lang.Buffer:getSize(sbuffer)) end
end

function jk.lang.BufferBuilder:appendSubBuffer(sbuffer, offset, size)
	if not (sbuffer ~= nil) then
		do return end
	end
	if not (offset >= 0) then
		do return end
	end
	if not (size >= 0) then
		do return end
	end
	do self:allocate(self.pointer + size) end
	do _g.jk.lang.Buffer:copyFrom(self.buffer, sbuffer, offset, self.pointer, size) end
	self.pointer = self.pointer + size
end

function jk.lang.BufferBuilder:toBuffer()
	do return _g.jk.lang.Buffer:getSubBuffer(self.buffer, 0, self.pointer, false) end
end
jk = jk or {}

jk.os = jk.os or {}

jk.os.OS = {}
jk.os.OS.__index = jk.os.OS
_vm:set_metatable(jk.os.OS, {})

jk.os.OS.isWindowsFlag = nil
jk.os.OS.isLinuxFlag = nil
jk.os.OS.isMacOSFlag = nil
jk.os.OS.isAndroidFlag = nil
jk.os.OS.isIOSFlag = nil

function jk.os.OS._create()
	local v = _vm:set_metatable({}, jk.os.OS)
	return v
end

function jk.os.OS:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.os.OS'
	self['_isType.jk.os.OS'] = true
end

function jk.os.OS:_construct0()
	jk.os.OS._init(self)
	return self
end

function jk.os.OS:getCurrentPlatformName()
	do return "Sushi" end
end

function jk.os.OS:is32Bit()
	local cpu = _g.jk.os.OS:getProcessorType()
	if cpu == "x86" or cpu == "arm" then
		do return true end
	end
	do return false end
end

function jk.os.OS:is64Bit()
	local cpu = _g.jk.os.OS:getProcessorType()
	if cpu == "x64" or cpu == "arm64" then
		do return true end
	end
	do return false end
end

function jk.os.OS:getProcessorType()
	do return nil end
end

function jk.os.OS:isWindows()
	if _g.jk.os.OS.isWindowsFlag ~= nil then
		do return _g.jk.os.OS.isWindowsFlag:toBoolean() end
	end
	do
		local v = _g.jk.os.OS:isSystemType("windows")
		_g.jk.os.OS.isWindowsFlag = _g.jk.lang.Boolean:asObject(v)
		do return v end
	end
end

function jk.os.OS:isLinux()
	if _g.jk.os.OS.isLinuxFlag ~= nil then
		do return _g.jk.os.OS.isLinuxFlag:toBoolean() end
	end
	do
		local v = _g.jk.os.OS:isSystemType("linux")
		_g.jk.os.OS.isLinuxFlag = _g.jk.lang.Boolean:asObject(v)
		do return v end
	end
end

function jk.os.OS:isMacOS()
	if _g.jk.os.OS.isMacOSFlag ~= nil then
		do return _g.jk.os.OS.isMacOSFlag:toBoolean() end
	end
	do
		local v = _g.jk.os.OS:isSystemType("macos")
		_g.jk.os.OS.isMacOSFlag = _g.jk.lang.Boolean:asObject(v)
		do return v end
	end
end

function jk.os.OS:isOSX()
	do return _g.jk.os.OS:isMacOS() end
end

function jk.os.OS:isAndroid()
	if _g.jk.os.OS.isAndroidFlag ~= nil then
		do return _g.jk.os.OS.isAndroidFlag:toBoolean() end
	end
	do
		local v = _g.jk.os.OS:isSystemType("android")
		_g.jk.os.OS.isAndroidFlag = _g.jk.lang.Boolean:asObject(v)
		do return v end
	end
end

function jk.os.OS:isIOS()
	if _g.jk.os.OS.isIOSFlag ~= nil then
		do return _g.jk.os.OS.isIOSFlag:toBoolean() end
	end
	do
		local v = _g.jk.os.OS:isSystemType("ios")
		_g.jk.os.OS.isIOSFlag = _g.jk.lang.Boolean:asObject(v)
		do return v end
	end
end

function jk.os.OS:isSystemType(ida)
	local id = ida
	if id == "osx" then
		id = "macos"
	end
	do
		local type = _os:get_system_type()
		do return type == id end
	end
end

function jk.os.OS:isDirectory(path)
	if not _g.jk.lang.String:isNotEmpty(path) then
		do return false end
	end
	_io:write_to_stdout("[jk.os.OS.isDirectory] (OS.sling:386:3): Not implemented" .. "\n")
	do return false end
end

function jk.os.OS:isFile(path)
	if not _g.jk.lang.String:isNotEmpty(path) then
		do return false end
	end
	_io:write_to_stdout("[jk.os.OS.isFile] (OS.sling:424:3): Not implemented" .. "\n")
	do return false end
end
jk = jk or {}

jk.log = jk.log or {}

jk.log.Log = {}
jk.log.Log.__index = jk.log.Log
_vm:set_metatable(jk.log.Log, {})

function jk.log.Log._create()
	local v = _vm:set_metatable({}, jk.log.Log)
	return v
end

function jk.log.Log:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.log.Log'
	self['_isType.jk.log.Log'] = true
end

function jk.log.Log:_construct0()
	jk.log.Log._init(self)
	return self
end

function jk.log.Log:asString(context, object)
	if context ~= nil and (_vm:to_table_with_key(object, '_isType.jk.lang.StringObjectWithDebug') ~= nil) then
		do return object:toStringWithDebug(context:isInDebugMode()) end
	end
	do return _g.jk.lang.String:asString(object) end
end

function jk.log.Log:error(context, message)
	if context ~= nil then
		do context:logError(message) end
	end
end

function jk.log.Log:warning(context, message)
	if context ~= nil then
		do context:logWarning(message) end
	end
end

function jk.log.Log:info(context, message)
	if context ~= nil then
		do context:logInfo(message) end
	end
end

function jk.log.Log:debug(context, message)
	if context ~= nil then
		do context:logDebug(message) end
	end
end

function jk.log.Log:status(context, message)
	if context ~= nil then
		do context:logStatus(message) end
	end
end

jk.log.LoggingContext = {}
jk = jk or {}

jk.io = jk.io or {}

jk.io.Reader = {}

jk.io.LineReader = {}

jk.io.SeekableReader = {}

jk.io.CharacterIteratorForReader = _g.jk.lang.CharacterDecoder._create()
jk.io.CharacterIteratorForReader.__index = jk.io.CharacterIteratorForReader
_vm:set_metatable(jk.io.CharacterIteratorForReader, {
	__index = _g.jk.lang.CharacterDecoder
})

function jk.io.CharacterIteratorForReader._create()
	local v = _vm:set_metatable({}, jk.io.CharacterIteratorForReader)
	return v
end

function jk.io.CharacterIteratorForReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.CharacterIteratorForReader'
	self['_isType.jk.io.CharacterIteratorForReader'] = true
	self.reader = nil
	self.buffer = nil
	self.bufferStart = -1
	self.bufferSize = 0
	self.bufferDataSize = 0
	self.currentPos = -1
	self.readPos = 0
end

function jk.io.CharacterIteratorForReader:_construct0()
	jk.io.CharacterIteratorForReader._init(self)
	do _g.jk.lang.CharacterDecoder._construct0(self) end
	return self
end

function jk.io.CharacterIteratorForReader:forReader(reader)
	do return _g.jk.io.CharacterIteratorForReader._construct1(_g.jk.io.CharacterIteratorForReader._create(), reader) end
end

function jk.io.CharacterIteratorForReader:forReaderWithBufferSize(reader, bufferSize)
	do return _g.jk.io.CharacterIteratorForReader._construct2(_g.jk.io.CharacterIteratorForReader._create(), reader, bufferSize) end
end

function jk.io.CharacterIteratorForReader:_construct1(reader)
	jk.io.CharacterIteratorForReader._init(self)
	do _g.jk.lang.CharacterDecoder._construct0(self) end
	self.reader = reader
	self.buffer = _util:allocate_buffer(1024)
	self.bufferSize = 1024
	return self
end

function jk.io.CharacterIteratorForReader:_construct2(reader, bufferSize)
	jk.io.CharacterIteratorForReader._init(self)
	do _g.jk.lang.CharacterDecoder._construct0(self) end
	self.reader = reader
	self.buffer = _util:allocate_buffer(bufferSize)
	self.bufferSize = bufferSize
	return self
end

function jk.io.CharacterIteratorForReader:makeDataAvailable(n)
	if n >= self.bufferStart and n < self.bufferStart + self.bufferDataSize then
		do return true end
	end
	if (_vm:to_table_with_key(self.reader, '_isType.jk.io.SeekableReader') ~= nil) then
		local rs = self.reader
		local block = _util:convert_to_integer(n / self.bufferSize)
		local blockPos = block * self.bufferSize
		if self.readPos ~= blockPos then
			if not rs:setCurrentPosition(blockPos) then
				do return false end
			end
			self.readPos = blockPos
		end
	end
	self.bufferDataSize = self.reader:read(self.buffer)
	self.bufferStart = self.readPos
	self.readPos = self.readPos + self.bufferDataSize
	if n >= self.bufferStart and n < self.bufferStart + self.bufferDataSize then
		do return true end
	end
	do return false end
end

function jk.io.CharacterIteratorForReader:moveToPreviousByte()
	if not self:makeDataAvailable(self.currentPos - 1) then
		do return false end
	end
	do self.currentPos = self.currentPos - 1 end
	do return true end
end

function jk.io.CharacterIteratorForReader:moveToNextByte()
	if not self:makeDataAvailable(self.currentPos + 1) then
		do return false end
	end
	do self.currentPos = self.currentPos + 1 end
	do return true end
end

function jk.io.CharacterIteratorForReader:getCurrentByte()
	do return _g.jk.lang.Buffer:getByte(self.buffer, self.currentPos - self.bufferStart) end
end

function jk.io.CharacterIteratorForReader:getCurrentPosition()
	do return self.currentPos end
end

function jk.io.CharacterIteratorForReader:setCurrentPosition(position)
	self.currentPos = position
end

jk.io.Writer = {}

jk.io.PrintReader = {}
jk.io.PrintReader.__index = jk.io.PrintReader
_vm:set_metatable(jk.io.PrintReader, {})

function jk.io.PrintReader._create()
	local v = _vm:set_metatable({}, jk.io.PrintReader)
	return v
end

function jk.io.PrintReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.PrintReader'
	self['_isType.jk.io.PrintReader'] = true
	self['_isType.jk.io.Reader'] = true
	self['_isType.jk.io.LineReader'] = true
	self['_isType.jk.lang.Closable'] = true
	self.reader = nil
	self.iterator = nil
end

function jk.io.PrintReader:_construct0()
	jk.io.PrintReader._init(self)
	return self
end

function jk.io.PrintReader:forReader(reader)
	if not (reader ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(reader, '_isType.jk.io.PrintReader') ~= nil) then
		do return reader end
	end
	do
		local v = _g.jk.io.PrintReader._construct0(_g.jk.io.PrintReader._create())
		do v:setReader(reader, nil) end
		do return v end
	end
end

function jk.io.PrintReader:forReaderAndEncoding(reader, encoding)
	if not (reader ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(reader, '_isType.jk.io.PrintReader') ~= nil) then
		do return reader end
	end
	do
		local v = _g.jk.io.PrintReader._construct0(_g.jk.io.PrintReader._create())
		do v:setReader(reader, encoding) end
		do return v end
	end
end

function jk.io.PrintReader:setReader(reader, encoding)
	self.reader = reader
	if reader == nil then
		self.iterator = nil
	else
		self.iterator = _g.jk.io.CharacterIteratorForReader:forReader(reader)
		if encoding ~= nil then
			do self.iterator:setEncoding(encoding) end
		end
	end
end

function jk.io.PrintReader:readLine()
	if not (self.iterator ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		while true do
			local c = self.iterator:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				if sb:count() < 1 then
					do return nil end
				end
				do break end
			end
			if c == 13 then
				goto _continue1
			end
			if c == 10 then
				do break end
			end
			do sb:appendCharacter(c) end
			::_continue1::
		end
		if sb:count() < 1 then
			do return "" end
		end
		do return sb:toString() end
	end
end

function jk.io.PrintReader:readAll()
	if not (self.iterator ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		while true do
			local c = self.iterator:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			do sb:appendCharacter(c) end
		end
		if sb:count() < 1 then
			do return nil end
		end
		do return sb:toString() end
	end
end

function jk.io.PrintReader:hasEnded()
	if not (self.iterator ~= nil) then
		do return true end
	end
	do return self.iterator:hasEnded() end
end

function jk.io.PrintReader:read(buffer)
	if self.reader == nil then
		do return -1 end
	end
	do return self.reader:read(buffer) end
end

function jk.io.PrintReader:close()
	local rc = _vm:to_table_with_key(self.reader, '_isType.jk.lang.Closable')
	if rc ~= nil then
		do rc:close() end
	end
end

jk.io.PrintWriter = {}

jk.io.FileDescriptor = {}

jk.io.StaticFileDescriptor = {}
jk.io.StaticFileDescriptor.__index = jk.io.StaticFileDescriptor
_vm:set_metatable(jk.io.StaticFileDescriptor, {})

function jk.io.StaticFileDescriptor._create()
	local v = _vm:set_metatable({}, jk.io.StaticFileDescriptor)
	return v
end

function jk.io.StaticFileDescriptor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.StaticFileDescriptor'
	self['_isType.jk.io.StaticFileDescriptor'] = true
	self['_isType.jk.io.FileDescriptor'] = true
	self.fileDescriptor = 0
end

function jk.io.StaticFileDescriptor:_construct0()
	jk.io.StaticFileDescriptor._init(self)
	return self
end

function jk.io.StaticFileDescriptor:forFileDescriptor(fd)
	do return _g.jk.io.StaticFileDescriptor._construct0(_g.jk.io.StaticFileDescriptor._create()):setFileDescriptor(fd) end
end

function jk.io.StaticFileDescriptor:getFileDescriptor()
	do return self.fileDescriptor end
end

function jk.io.StaticFileDescriptor:setFileDescriptor(v)
	self.fileDescriptor = v
	do return self end
end

jk.io.FlushableWriter = {}

jk.io.FileDescriptorReader = {}
jk.io.FileDescriptorReader.__index = jk.io.FileDescriptorReader
_vm:set_metatable(jk.io.FileDescriptorReader, {})

function jk.io.FileDescriptorReader._create()
	local v = _vm:set_metatable({}, jk.io.FileDescriptorReader)
	return v
end

function jk.io.FileDescriptorReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.FileDescriptorReader'
	self['_isType.jk.io.FileDescriptorReader'] = true
	self['_isType.jk.io.Reader'] = true
	self['_isType.jk.lang.Closable'] = true
	self['_isType.jk.io.FileDescriptor'] = true
	self.fd = -1
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function jk.io.FileDescriptorReader:_construct0()
	jk.io.FileDescriptorReader._init(self)
	return self
end

function jk.io.FileDescriptorReader:forFileDescriptor(fd)
	local v = _g.jk.io.FileDescriptorReader._construct0(_g.jk.io.FileDescriptorReader._create())
	do v:setFd(fd) end
	do return v end
end

function jk.io.FileDescriptorReader:_destruct()
	do self:close() end
end

function jk.io.FileDescriptorReader:getFileDescriptor()
	do return self.fd end
end

function jk.io.FileDescriptorReader:read(buffer)
	local v = -1
	local handle = self.fd
	if handle >= 0 then
		do v = _io:read_from_handle(handle, buffer) end
	end
	do return v end
end

function jk.io.FileDescriptorReader:close()
	local handle = self.fd
	if handle >= 0 then
		do _io:close_handle(handle) end
		self.fd = -1
	end
end

function jk.io.FileDescriptorReader:getFd()
	do return self.fd end
end

function jk.io.FileDescriptorReader:setFd(v)
	self.fd = v
	do return self end
end

jk.io.SizedReader = {}

jk.io.DataStream = {}

jk.io.SeekableWriter = {}

jk.io.BinaryReader = {}
jk.io.BinaryReader.__index = jk.io.BinaryReader
_vm:set_metatable(jk.io.BinaryReader, {})

function jk.io.BinaryReader._create()
	local v = _vm:set_metatable({}, jk.io.BinaryReader)
	return v
end

function jk.io.BinaryReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.BinaryReader'
	self['_isType.jk.io.BinaryReader'] = true
	self['_isType.jk.lang.Closable'] = true
	self.reader = nil
	self.buffer1 = nil
	self.buffer2 = nil
	self.buffer4 = nil
end

function jk.io.BinaryReader:_construct0()
	jk.io.BinaryReader._init(self)
	return self
end

function jk.io.BinaryReader:forReader(reader)
	local v = _g.jk.io.BinaryReader._construct0(_g.jk.io.BinaryReader._create())
	do v:setReader(reader) end
	do return v end
end

function jk.io.BinaryReader:isOK()
	if not (self.reader ~= nil) then
		do return false end
	end
	do return true end
end

function jk.io.BinaryReader:close()
	local rc = _vm:to_table_with_key(self.reader, '_isType.jk.lang.Closable')
	if rc ~= nil then
		do rc:close() end
	end
	self.reader = nil
end

function jk.io.BinaryReader:seek(position)
	local sr = _vm:to_table_with_key(self.reader, '_isType.jk.io.SeekableReader')
	if not (sr ~= nil) then
		do return false end
	end
	do return sr:setCurrentPosition(position) end
end

function jk.io.BinaryReader:read1()
	if not (self.reader ~= nil) then
		do return nil end
	end
	if not (self.buffer1 ~= nil) then
		self.buffer1 = _util:allocate_buffer(1)
	end
	do
		local r = self.reader:read(self.buffer1)
		if not (r == 1) then
			do self:close() end
			do return nil end
		end
		do return self.buffer1 end
	end
end

function jk.io.BinaryReader:read2()
	if not (self.reader ~= nil) then
		do return nil end
	end
	if not (self.buffer2 ~= nil) then
		self.buffer2 = _util:allocate_buffer(2)
	end
	do
		local r = self.reader:read(self.buffer2)
		if not (r == 2) then
			do self:close() end
			do return nil end
		end
		do return self.buffer2 end
	end
end

function jk.io.BinaryReader:read4()
	if not (self.reader ~= nil) then
		do return nil end
	end
	if not (self.buffer4 ~= nil) then
		self.buffer4 = _util:allocate_buffer(4)
	end
	do
		local r = self.reader:read(self.buffer4)
		if not (r == 4) then
			do self:close() end
			do return nil end
		end
		do return self.buffer4 end
	end
end

function jk.io.BinaryReader:readBuffer(size)
	if not (self.reader ~= nil) then
		do return nil end
	end
	if not (size > 0) then
		do return nil end
	end
	do
		local b = _util:allocate_buffer(size)
		local r = self.reader:read(b)
		if not (r == size) then
			do self:close() end
			do return nil end
		end
		do return b end
	end
end

function jk.io.BinaryReader:readInt8()
	local b = self:read1()
	if not (b ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Buffer:getInt8(b, 0) end
end

function jk.io.BinaryReader:readInt16LE()
	local b = self:read2()
	if not (b ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Buffer:getInt16LE(b, 0) end
end

function jk.io.BinaryReader:readInt16BE()
	local b = self:read2()
	if not (b ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Buffer:getInt16BE(b, 0) end
end

function jk.io.BinaryReader:readInt32LE()
	local b = self:read4()
	if not (b ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Buffer:getInt32LE(b, 0) end
end

function jk.io.BinaryReader:readInt32BE()
	local b = self:read4()
	if not (b ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Buffer:getInt32BE(b, 0) end
end

function jk.io.BinaryReader:getReader()
	do return self.reader end
end

function jk.io.BinaryReader:setReader(v)
	self.reader = v
	do return self end
end

jk.io.ByteReader = {}

jk.io.FileDescriptorWriter = {}
jk.io.FileDescriptorWriter.__index = jk.io.FileDescriptorWriter
_vm:set_metatable(jk.io.FileDescriptorWriter, {})

function jk.io.FileDescriptorWriter._create()
	local v = _vm:set_metatable({}, jk.io.FileDescriptorWriter)
	return v
end

function jk.io.FileDescriptorWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.FileDescriptorWriter'
	self['_isType.jk.io.FileDescriptorWriter'] = true
	self['_isType.jk.io.Writer'] = true
	self['_isType.jk.lang.Closable'] = true
	self['_isType.jk.io.FileDescriptor'] = true
	self.fd = -1
	self.owned = true
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function jk.io.FileDescriptorWriter:_construct0()
	jk.io.FileDescriptorWriter._init(self)
	return self
end

function jk.io.FileDescriptorWriter:forFileDescriptor(fd)
	local v = _g.jk.io.FileDescriptorWriter._construct0(_g.jk.io.FileDescriptorWriter._create())
	do v:setFd(fd) end
	do return v end
end

function jk.io.FileDescriptorWriter:forUnownedFileDescriptor(fd)
	local v = _g.jk.io.FileDescriptorWriter._construct0(_g.jk.io.FileDescriptorWriter._create())
	do v:setFd(fd) end
	do v:setOwned(false) end
	do return v end
end

function jk.io.FileDescriptorWriter:_destruct()
	do self:close() end
end

function jk.io.FileDescriptorWriter:getFileDescriptor()
	do return self.fd end
end

function jk.io.FileDescriptorWriter:write(buf, size)
	local v = -1
	local handle = self.fd
	if handle >= 0 then
		do v = _io:write_to_handle(handle, buf, size) end
	end
	do return v end
end

function jk.io.FileDescriptorWriter:close()
	if not self.owned then
		do return end
	end
	do
		local handle = self.fd
		if handle >= 0 then
			do _io:close_handle(handle) end
			self.fd = -1
		end
	end
end

function jk.io.FileDescriptorWriter:getFd()
	do return self.fd end
end

function jk.io.FileDescriptorWriter:setFd(v)
	self.fd = v
	do return self end
end

function jk.io.FileDescriptorWriter:getOwned()
	do return self.owned end
end

function jk.io.FileDescriptorWriter:setOwned(v)
	self.owned = v
	do return self end
end

jk.io.StringLineReader = {}
jk.io.StringLineReader.__index = jk.io.StringLineReader
_vm:set_metatable(jk.io.StringLineReader, {})

function jk.io.StringLineReader._create()
	local v = _vm:set_metatable({}, jk.io.StringLineReader)
	return v
end

function jk.io.StringLineReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.StringLineReader'
	self['_isType.jk.io.StringLineReader'] = true
	self['_isType.jk.io.LineReader'] = true
	self.iterator = nil
end

function jk.io.StringLineReader:_construct0()
	jk.io.StringLineReader._init(self)
	return self
end

function jk.io.StringLineReader:_construct1(str)
	jk.io.StringLineReader._init(self)
	self.iterator = _g.jk.lang.CharacterIteratorForString:forString(str)
	return self
end

function jk.io.StringLineReader:readLine()
	if not (self.iterator ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		while true do
			local c = self.iterator:getNextChar()
			if c < 1 then
				if sb:count() < 1 then
					do return nil end
				end
				do break end
			end
			if c == 13 then
				goto _continue2
			end
			if c == 10 then
				do break end
			end
			do sb:appendCharacter(c) end
			::_continue2::
		end
		if sb:count() < 1 then
			do return "" end
		end
		do return sb:toString() end
	end
end

jk.io.PrintWriterWrapper = {}
jk.io.PrintWriterWrapper.__index = jk.io.PrintWriterWrapper
_vm:set_metatable(jk.io.PrintWriterWrapper, {})

function jk.io.PrintWriterWrapper._create()
	local v = _vm:set_metatable({}, jk.io.PrintWriterWrapper)
	return v
end

function jk.io.PrintWriterWrapper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.PrintWriterWrapper'
	self['_isType.jk.io.PrintWriterWrapper'] = true
	self['_isType.jk.io.Writer'] = true
	self['_isType.jk.io.PrintWriter'] = true
	self['_isType.jk.lang.Closable'] = true
	self['_isType.jk.io.FlushableWriter'] = true
	self.writer = nil
end

function jk.io.PrintWriterWrapper:_construct0()
	jk.io.PrintWriterWrapper._init(self)
	return self
end

function jk.io.PrintWriterWrapper:forWriter(writer)
	if writer == nil then
		do return nil end
	end
	if (_vm:to_table_with_key(writer, '_isType.jk.io.PrintWriter') ~= nil) then
		do return writer end
	end
	do
		local v = _g.jk.io.PrintWriterWrapper._construct0(_g.jk.io.PrintWriterWrapper._create())
		do v:setWriter(writer) end
		do return v end
	end
end

function jk.io.PrintWriterWrapper:closeWriter(writer)
	local wc = _vm:to_table_with_key(writer, '_isType.jk.lang.Closable')
	if not (wc ~= nil) then
		do return nil end
	end
	do wc:close() end
	do return nil end
end

function jk.io.PrintWriterWrapper:print(str)
	if str == nil then
		do return false end
	end
	do
		local buffer = _g.jk.lang.String:toUTF8Buffer(str)
		if buffer == nil then
			do return false end
		end
		do
			local sz = _g.jk.lang.Buffer:getSize(buffer)
			if self.writer:write(buffer, -1) ~= sz then
				do return false end
			end
			do return true end
		end
	end
end

function jk.io.PrintWriterWrapper:println(str)
	do return self:print(_g.jk.lang.String:safeString(str) .. "\n") end
end

function jk.io.PrintWriterWrapper:writeWholeBuffer(buf)
	do return self:write(buf, -1) end
end

function jk.io.PrintWriterWrapper:write(buf, size)
	if self.writer == nil then
		do return -1 end
	end
	do return self.writer:write(buf, size) end
end

function jk.io.PrintWriterWrapper:close()
	local cw = _vm:to_table_with_key(self.writer, '_isType.jk.lang.Closable')
	if cw ~= nil then
		do cw:close() end
	end
end

function jk.io.PrintWriterWrapper:flush()
	local cw = _vm:to_table_with_key(self.writer, '_isType.jk.io.FlushableWriter')
	if cw ~= nil then
		do cw:flush() end
	end
end

function jk.io.PrintWriterWrapper:getWriter()
	do return self.writer end
end

function jk.io.PrintWriterWrapper:setWriter(v)
	self.writer = v
	do return self end
end

jk.io.DataStreamSource = {}

jk.io.BufferWriter = {}
jk.io.BufferWriter.__index = jk.io.BufferWriter
_vm:set_metatable(jk.io.BufferWriter, {})

function jk.io.BufferWriter._create()
	local v = _vm:set_metatable({}, jk.io.BufferWriter)
	return v
end

function jk.io.BufferWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.BufferWriter'
	self['_isType.jk.io.BufferWriter'] = true
	self['_isType.jk.io.Writer'] = true
	self.buffer = nil
	self.pos = 0
end

function jk.io.BufferWriter:_construct0()
	jk.io.BufferWriter._init(self)
	return self
end

function jk.io.BufferWriter:forBuffer(buf)
	local v = _g.jk.io.BufferWriter._construct0(_g.jk.io.BufferWriter._create())
	v.buffer = buf
	do return v end
end

function jk.io.BufferWriter:getBufferSize()
	do return _g.jk.lang.Buffer:getSize(self.buffer) end
end

function jk.io.BufferWriter:getBufferPos()
	do return 0 end
end

function jk.io.BufferWriter:getBuffer()
	do return self.buffer end
end

function jk.io.BufferWriter:write(src, ssize)
	if src == nil then
		do return 0 end
	end
	do
		local size = ssize
		if size < 0 then
			size = _g.jk.lang.Buffer:getSize(src)
		end
		if size < 1 then
			do return 0 end
		end
		if self.buffer == nil then
			self.buffer = _util:allocate_buffer(size)
			if self.buffer == nil then
				do return 0 end
			end
			do _g.jk.lang.Buffer:copyFrom(self.buffer, src, 0, 0, size) end
			self.pos = size
		elseif self.pos + size <= _g.jk.lang.Buffer:getSize(self.buffer) then
			do _g.jk.lang.Buffer:copyFrom(self.buffer, src, 0, self.pos, size) end
			self.pos = self.pos + size
		else
			local nb = _g.jk.lang.Buffer:resize(self.buffer, self.pos + size)
			if nb == nil then
				do return 0 end
			end
			self.buffer = nb
			do _g.jk.lang.Buffer:copyFrom(self.buffer, src, 0, self.pos, size) end
			self.pos = self.pos + size
		end
		do return size end
	end
end

jk.io.BufferReader = {}
jk.io.BufferReader.__index = jk.io.BufferReader
_vm:set_metatable(jk.io.BufferReader, {})

function jk.io.BufferReader._create()
	local v = _vm:set_metatable({}, jk.io.BufferReader)
	return v
end

function jk.io.BufferReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.io.BufferReader'
	self['_isType.jk.io.BufferReader'] = true
	self['_isType.jk.io.Reader'] = true
	self['_isType.jk.io.SizedReader'] = true
	self['_isType.jk.io.SeekableReader'] = true
	self.buffer = nil
	self.pos = 0
end

function jk.io.BufferReader:_construct0()
	jk.io.BufferReader._init(self)
	return self
end

function jk.io.BufferReader:readFrom(reader)
	if not (reader ~= nil) then
		do return nil end
	end
	do
		local v = nil
		local tmp = _util:allocate_buffer(1024)
		while true do
			local r = reader:read(tmp)
			if r < 1 then
				do break end
			end
			v = _g.jk.lang.Buffer:append(v, tmp, r)
			if v == nil then
				do break end
			end
		end
		do return v end
	end
end

function jk.io.BufferReader:forBuffer(buf)
	do return _g.jk.io.BufferReader._construct0(_g.jk.io.BufferReader._create()):setBuffer(buf) end
end

function jk.io.BufferReader:setCurrentPosition(n)
	self.pos = n
	do return true end
end

function jk.io.BufferReader:getCurrentPosition()
	do return self.pos end
end

function jk.io.BufferReader:getBuffer()
	do return self.buffer end
end

function jk.io.BufferReader:setBuffer(buf)
	self.buffer = buf
	self.pos = 0
	do return self end
end

function jk.io.BufferReader:rewind()
	self.pos = 0
end

function jk.io.BufferReader:getSize()
	if self.buffer == nil then
		do return 0 end
	end
	do return #self.buffer end
end

function jk.io.BufferReader:read(buf)
	if buf == nil or self.buffer == nil then
		do return 0 end
	end
	do
		local buffersz = #self.buffer
		if self.pos >= buffersz then
			do return 0 end
		end
		do
			local size = #buf
			if size > buffersz - self.pos then
				size = buffersz - self.pos
			end
			do _g.jk.lang.Buffer:copyFrom(buf, self.buffer, self.pos, 0, size) end
			self.pos = self.pos + size
			do return size end
		end
	end
end

function jk.io.BufferReader:getPos()
	do return self.pos end
end

function jk.io.BufferReader:setPos(v)
	self.pos = v
	do return self end
end
jk = jk or {}

jk.time = jk.time or {}

jk.time.SystemClock = {}
jk.time.SystemClock.__index = jk.time.SystemClock
_vm:set_metatable(jk.time.SystemClock, {})

function jk.time.SystemClock._create()
	local v = _vm:set_metatable({}, jk.time.SystemClock)
	return v
end

function jk.time.SystemClock:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.time.SystemClock'
	self['_isType.jk.time.SystemClock'] = true
end

function jk.time.SystemClock:_construct0()
	jk.time.SystemClock._init(self)
	return self
end

function jk.time.SystemClock:asDateTimeUTC()
	do return _g.jk.lang.DateTime:forSeconds(_g.jk.time.SystemClock:asUTCSeconds()) end
end

function jk.time.SystemClock:asDateTimeLocal()
	local v = _g.jk.lang.DateTime:forSeconds(_g.jk.time.SystemClock:asSeconds())
	do v:setTimezoneOffset(_g.jk.time.SystemClock:getTimezoneOffsetAsSeconds()) end
	do return v end
end

function jk.time.SystemClock:getTimezoneOffsetAsSeconds()
	do return _os:get_system_timezone_seconds() end
end

function jk.time.SystemClock:asUTCSeconds()
	do return _g.jk.time.SystemClock:asSeconds() + _g.jk.time.SystemClock:getTimezoneOffsetAsSeconds() end
end

function jk.time.SystemClock:asSeconds()
	do return _os:get_system_time_seconds() end
end

function jk.time.SystemClock:asTimeValue()
	local v = _g.jk.lang.TimeValue._construct0(_g.jk.lang.TimeValue._create())
	do _g.jk.time.SystemClock:update(v) end
	do return v end
end

function jk.time.SystemClock:update(v)
	if not (v ~= nil) then
		do return end
	end
	do
		local millis = _os:get_system_time_milliseconds()
		local secs = _util:convert_to_integer(millis / 1000)
		local micros = (millis - secs * 1000) * 1000
		do v:setSeconds(secs) end
		do v:setMicroSeconds(micros) end
	end
end
jk = jk or {}

jk.fs = jk.fs or {}

jk.fs.FileWriter = {}

jk.fs.FileFinder = {}
jk.fs.FileFinder.__index = jk.fs.FileFinder
_vm:set_metatable(jk.fs.FileFinder, {})

function jk.fs.FileFinder._create()
	local v = _vm:set_metatable({}, jk.fs.FileFinder)
	return v
end

function jk.fs.FileFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileFinder'
	self['_isType.jk.fs.FileFinder'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.root = nil
	self.patterns = nil
	self.excludePatterns = nil
	self.stack = nil
	self.includeMatchingDirectories = false
	self.includeDirectories = false
end

function jk.fs.FileFinder:forRoot(root)
	do return _g.jk.fs.FileFinder._construct0(_g.jk.fs.FileFinder._create()):setRoot(root) end
end

jk.fs.FileFinder.Pattern = {}
jk.fs.FileFinder.Pattern.__index = jk.fs.FileFinder.Pattern
_vm:set_metatable(jk.fs.FileFinder.Pattern, {})

function jk.fs.FileFinder.Pattern._create()
	local v = _vm:set_metatable({}, jk.fs.FileFinder.Pattern)
	return v
end

function jk.fs.FileFinder.Pattern:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileFinder.Pattern'
	self['_isType.jk.fs.FileFinder.Pattern'] = true
	self.pattern = nil
	self.suffix = nil
	self.prefix = nil
end

function jk.fs.FileFinder.Pattern:_construct0()
	jk.fs.FileFinder.Pattern._init(self)
	return self
end

function jk.fs.FileFinder.Pattern:setPattern(pattern)
	self.pattern = pattern
	if pattern ~= nil then
		if _g.jk.lang.String:startsWith(pattern, "*", 0) then
			self.suffix = _g.jk.lang.String:getEndOfString(pattern, 1)
		end
		if _g.jk.lang.String:endsWith(pattern, "*") then
			self.prefix = _g.jk.lang.String:getSubString(pattern, 0, _g.jk.lang.String:getLength(pattern) - 1)
		end
	end
	do return self end
end

function jk.fs.FileFinder.Pattern:match(check)
	if not (check ~= nil) then
		do return false end
	end
	if self.pattern == check then
		do return true end
	end
	if self.suffix ~= nil and _g.jk.lang.String:endsWith(check, self.suffix) then
		do return true end
	end
	if self.prefix ~= nil and _g.jk.lang.String:startsWith(check, self.prefix, 0) then
		do return true end
	end
	do return false end
end

function jk.fs.FileFinder:_construct0()
	jk.fs.FileFinder._init(self)
	self.patterns = {}
	self.excludePatterns = {}
	return self
end

function jk.fs.FileFinder:setRoot(root)
	self.root = root
	self.stack = nil
	do return self end
end

function jk.fs.FileFinder:addPattern(pattern)
	do _g.jk.lang.Vector:append(self.patterns, _g.jk.fs.FileFinder.Pattern._construct0(_g.jk.fs.FileFinder.Pattern._create()):setPattern(pattern)) end
	do return self end
end

function jk.fs.FileFinder:addExcludePattern(pattern)
	do _g.jk.lang.Vector:append(self.excludePatterns, _g.jk.fs.FileFinder.Pattern._construct0(_g.jk.fs.FileFinder.Pattern._create()):setPattern(pattern)) end
	do return self end
end

function jk.fs.FileFinder:matchPattern(file)
	if not (file ~= nil) then
		do return false end
	end
	if _g.jk.lang.Vector:getSize(self.patterns) < 1 then
		do return true end
	end
	do
		local filename = file:getBasename()
		if self.patterns ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.patterns)
			do
				n = 0
				while n < m do
					local pattern = self.patterns[n + 1]
					if pattern ~= nil then
						if pattern:match(filename) then
							do return true end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function jk.fs.FileFinder:matchExcludePattern(file)
	if not (file ~= nil) then
		do return false end
	end
	if _g.jk.lang.Vector:getSize(self.excludePatterns) < 1 then
		do return false end
	end
	do
		local filename = file:getBasename()
		if self.excludePatterns ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.excludePatterns)
			do
				n = 0
				while n < m do
					local pattern = self.excludePatterns[n + 1]
					if pattern ~= nil then
						if pattern:match(filename) then
							do return true end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function jk.fs.FileFinder:next()
	while true do
		if not (self.stack ~= nil) then
			if not (self.root ~= nil) then
				do break end
			end
			do
				local es = self.root:entries()
				self.root = nil
				if not (es ~= nil) then
					do break end
				end
				self.stack = _g.jk.lang.Stack._construct0(_g.jk.lang.Stack._create())
				do self.stack:push(es) end
			end
		end
		do
			local entries = self.stack:peek()
			if not (entries ~= nil) then
				self.stack = nil
				do break end
			end
			do
				local e = entries:next()
				if not (e ~= nil) then
					do self.stack:pop() end
				elseif self:matchExcludePattern(e) then
				elseif e:isFile() then
					if self:matchPattern(e) then
						do return e end
					end
				elseif self.includeMatchingDirectories and e:isDirectory() and self:matchPattern(e) then
					do return e end
				elseif e:isDirectory() and e:isLink() == false then
					local ees = e:entries()
					if ees ~= nil then
						do self.stack:push(ees) end
					end
					if self.includeDirectories then
						do return e end
					end
				end
			end
		end
	end
	do return nil end
end

function jk.fs.FileFinder:hasNext()
	if not (self.stack ~= nil) then
		do return false end
	end
	do
		local it = self.stack:peek()
		if not (it ~= nil) then
			do return false end
		end
		do return it:hasNext() end
	end
end

function jk.fs.FileFinder:getIncludeMatchingDirectories()
	do return self.includeMatchingDirectories end
end

function jk.fs.FileFinder:setIncludeMatchingDirectories(v)
	self.includeMatchingDirectories = v
	do return self end
end

function jk.fs.FileFinder:getIncludeDirectories()
	do return self.includeDirectories end
end

function jk.fs.FileFinder:setIncludeDirectories(v)
	self.includeDirectories = v
	do return self end
end

jk.fs.FileKit = {}
jk.fs.FileKit.__index = jk.fs.FileKit
_vm:set_metatable(jk.fs.FileKit, {})

function jk.fs.FileKit._create()
	local v = _vm:set_metatable({}, jk.fs.FileKit)
	return v
end

function jk.fs.FileKit:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileKit'
	self['_isType.jk.fs.FileKit'] = true
	self.ctx = nil
end

function jk.fs.FileKit:_construct0()
	jk.fs.FileKit._init(self)
	return self
end

function jk.fs.FileKit:_construct1(ctx)
	jk.fs.FileKit._init(self)
	self.ctx = ctx
	return self
end

function jk.fs.FileKit:asFile(file)
	local fo = _g.jk.fs.File:asFile(file)
	if not (fo ~= nil) then
		do _g.jk.lang.Error:throw("invalidParameter", _g.jk.lang.String:asString(file)) end
	end
	do return fo end
end

function jk.fs.FileKit:copy(src, dst)
	local srcf = self:asFile(src)
	local dstf = self:asFile(dst)
	if dstf:isDirectory() then
		dstf = dstf:entry(srcf:getBasename())
	end
	if not srcf:copyFileOrDirectoryTo(dstf) then
		do _g.jk.lang.Error:throw("failedToCopy", srcf:getPath()) end
	end
	do return dstf end
end

function jk.fs.FileKit:remove(file)
	local fo = self:asFile(file)
	if not fo:removeRecursive() then
		do _g.jk.lang.Error:throw("failedToRemove", fo:getPath()) end
	end
end

function jk.fs.FileKit:readAsBuffer(file)
	local fo = self:asFile(file)
	local v = fo:getContentsBuffer()
	if not (v ~= nil) then
		do _g.jk.lang.Error:throw("failedToRead", fo:getPath()) end
	end
	do return v end
end

function jk.fs.FileKit:readAsString(file)
	local fo = self:asFile(file)
	local v = fo:getContentsUTF8()
	if not (v ~= nil) then
		do _g.jk.lang.Error:throw("failedToRead", fo:getPath()) end
	end
	do return v end
end

function jk.fs.FileKit:writeBuffer(file, data)
	local fo = self:asFile(file)
	if not fo:setContentsBuffer(data) then
		do _g.jk.lang.Error:throw("failedToWrite", fo:getPath()) end
	end
end

function jk.fs.FileKit:writeString(file, data)
	local fo = self:asFile(file)
	if not fo:setContentsUTF8(_g.jk.lang.String:asString(data)) then
		do _g.jk.lang.Error:throw("failedToWrite", fo:getPath()) end
	end
end

jk.fs.PathInfo = {}
jk.fs.PathInfo.__index = jk.fs.PathInfo
_vm:set_metatable(jk.fs.PathInfo, {})

function jk.fs.PathInfo._create()
	local v = _vm:set_metatable({}, jk.fs.PathInfo)
	return v
end

function jk.fs.PathInfo:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.PathInfo'
	self['_isType.jk.fs.PathInfo'] = true
end

function jk.fs.PathInfo:_construct0()
	jk.fs.PathInfo._init(self)
	return self
end

function jk.fs.PathInfo:getPathSeparator()
	if _g.jk.os.OS:isWindows() then
		do return 92 end
	end
	do return 47 end
end

function jk.fs.PathInfo:isAbsolutePath(path)
	if not (path ~= nil) then
		do return false end
	end
	do
		local c0 = _g.jk.lang.String:getChar(path, 0)
		if c0 == 47 then
			do return true end
		end
		if _g.jk.os.OS:isWindows() then
			if c0 == 92 then
				do return true end
			end
			if _g.jk.lang.Character:isAlpha(c0) and _g.jk.lang.String:getChar(path, 1) == 58 then
				local d = _g.jk.lang.String:getChar(path, 2)
				if d == 92 or d == 47 then
					do return true end
				end
			end
		end
		do return false end
	end
end

jk.fs.File = {}
jk.fs.File.__index = jk.fs.File
_vm:set_metatable(jk.fs.File, {})

function jk.fs.File._create()
	local v = _vm:set_metatable({}, jk.fs.File)
	return v
end

function jk.fs.File:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.File'
	self['_isType.jk.fs.File'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.lastErrorDescription = nil
end

function jk.fs.File:_construct0()
	jk.fs.File._init(self)
	return self
end

function jk.fs.File:asFile(o)
	if not (o ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(o, '_isType.jk.fs.File') ~= nil) then
		do return o end
	end
	do
		local ss = _g.jk.lang.String:asString(o)
		if ss ~= nil then
			do return _g.jk.fs.File:forPath(ss) end
		end
		do return nil end
	end
end

function jk.fs.File:asFileVector(o)
	local it = _g.jk.lang.DynamicObject:iterate(o)
	if not (it ~= nil) then
		do return nil end
	end
	do
		local v = {}
		while true do
			local oo = it:next()
			if not (oo ~= nil) then
				do break end
			end
			do
				local ff = _g.jk.fs.File:asFile(oo)
				if ff ~= nil then
					do _g.jk.lang.Vector:append(v, ff) end
				end
			end
		end
		do return v end
	end
end

function jk.fs.File:forPath(path)
	if path == nil or _g.jk.lang.String:getLength(path) < 1 then
		do return _g.jk.fs.FileInvalid._construct0(_g.jk.fs.FileInvalid._create()) end
	end
	do return _g.jk.fs.FileForSushi:forPath(path) end
end

function jk.fs.File:forRawPath(path)
	do return _g.jk.fs.FileForSushi:forRawPath(path) end
end

function jk.fs.File:forRelativePath(path, relativeTo, alwaysSupportWindowsPathnames)
	if relativeTo == nil then
		do return _g.jk.fs.File:forPath(path) end
	end
	if path == nil then
		do return _g.jk.fs.FileInvalid._construct0(_g.jk.fs.FileInvalid._create()) end
	end
	if _g.jk.fs.PathInfo:isAbsolutePath(path) then
		do return _g.jk.fs.File:forPath(path) end
	end
	do
		local sep = _g.jk.fs.PathInfo:getPathSeparator()
		if sep ~= 47 then
			if _g.jk.lang.String:getIndexOfCharacter(path, sep, 0) < 0 and _g.jk.lang.String:getIndexOfCharacter(path, 47, 0) >= 0 then
				sep = 47
			end
		elseif alwaysSupportWindowsPathnames then
			if _g.jk.lang.String:getIndexOfCharacter(path, sep, 0) < 0 and _g.jk.lang.String:getIndexOfCharacter(path, 92, 0) >= 0 then
				sep = 92
			end
		end
		do
			local f = relativeTo
			local comps = _g.jk.lang.String:split(path, sep, 0)
			if comps ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(comps)
				do
					n = 0
					while n < m do
						local comp = comps[n + 1]
						if comp ~= nil then
							if _g.jk.lang.String:isEmpty(comp) then
								goto _continue1
							end
							f = f:entry(comp)
						end
						::_continue1::
						do n = n + 1 end
					end
				end
			end
			do return f end
		end
	end
end

function jk.fs.File:entry(name)
end

function jk.fs.File:rawEntry(name)
	do return self:entry(name) end
end

function jk.fs.File:entries()
end

function jk.fs.File:move(dest, replace)
end

function jk.fs.File:touch()
end

function jk.fs.File:read()
end

function jk.fs.File:write()
end

function jk.fs.File:append()
end

function jk.fs.File:stat()
end

function jk.fs.File:createDirectory()
end

function jk.fs.File:createDirectoryRecursive()
end

function jk.fs.File:removeDirectory()
end

function jk.fs.File:getPath()
end

function jk.fs.File:remove()
end

function jk.fs.File:makeExecutable()
end

function jk.fs.File:getRelativePath(baseFile, prefix)
	if not (baseFile ~= nil) then
		do return nil end
	end
	do
		local vp = self:getPath()
		local bp = baseFile:getPath()
		while _g.jk.lang.String:endsWith(bp, "/") or _g.jk.lang.String:endsWith(bp, "\\") do
			bp = _g.jk.lang.String:getSubString(bp, 0, _g.jk.lang.String:getLength(bp) - 1)
		end
		if _g.jk.lang.String:startsWith(vp, _g.jk.lang.String:safeString(bp) .. "/", 0) or _g.jk.lang.String:startsWith(vp, _g.jk.lang.String:safeString(bp) .. "\\", 0) then
			if prefix ~= nil then
				do return _g.jk.lang.String:safeString(prefix) .. _g.jk.lang.String:safeString(_g.jk.lang.String:getEndOfString(vp, _g.jk.lang.String:getLength(bp))) end
			end
			do return _g.jk.lang.String:getEndOfString(vp, _g.jk.lang.String:getLength(bp) + 1) end
		end
		do return nil end
	end
end

function jk.fs.File:getRelativePathOrBasename(baseFile, prefix)
	local v = self:getRelativePath(baseFile, prefix)
	if v ~= nil then
		do return v end
	end
	do return self:getBasename() end
end

function jk.fs.File:rename(newname, replace)
	do return self:move(_g.jk.fs.File:forPath(newname), replace) end
end

function jk.fs.File:writeFromReader(reader, doAppend)
	do self:onError(nil) end
	if not (reader ~= nil) then
		do return false end
	end
	do
		local buffer = _util:allocate_buffer(1024)
		if not (buffer ~= nil) then
			do return false end
		end
		do
			local writer = nil
			if doAppend then
				writer = self:append()
			else
				writer = self:write()
			end
			if not (writer ~= nil) then
				do return false end
			end
			do
				local v = true
				while true do
					local r = reader:read(buffer)
					if r < 1 then
						do break end
					end
					do
						local w = writer:write(buffer, r)
						if w < r then
							v = false
							do break end
						end
					end
				end
				do writer:close() end
				do return v end
			end
		end
	end
end

function jk.fs.File:createFifo()
	do self:onError("Not supported") end
	do return false end
end

function jk.fs.File:isExecutable()
	if _g.jk.os.OS:isWindows() then
		do return self:hasExtension("exe") or self:hasExtension("bat") or self:hasExtension("cmd") or self:hasExtension("com") end
	end
	do return self:stat():getExecutable() end
end

function jk.fs.File:exists()
	do self:onError(nil) end
	do
		local fi = self:stat()
		do return fi:getType() ~= _g.jk.fs.FileInfo.FILE_TYPE_UNKNOWN end
	end
end

function jk.fs.File:isIdentical(file)
	if not (file ~= nil) then
		do return false end
	end
	do
		local myrd = self:read()
		if not (myrd ~= nil) then
			do return false end
		end
		do
			local oord = file:read()
			if not (oord ~= nil) then
				do return false end
			end
			do
				local mybuf = _util:allocate_buffer(1024)
				if not (mybuf ~= nil) then
					do return false end
				end
				do
					local oobuf = _util:allocate_buffer(1024)
					if not (oobuf ~= nil) then
						do return false end
					end
					do
						local v = true
						while v do
							local myr = myrd:read(mybuf)
							local oor = oord:read(oobuf)
							if myr ~= oor then
								v = false
							else
								if myr < 1 then
									do break end
								end
								do
									local n = 0
									while n < myr do
										if mybuf[n + 1] ~= oobuf[n + 1] then
											v = false
										end
										do n = n + 1 end
									end
								end
							end
						end
						do myrd:close() end
						do oord:close() end
						do return v end
					end
				end
			end
		end
	end
end

jk.fs.File.ReadLineIterator = {}
jk.fs.File.ReadLineIterator.__index = jk.fs.File.ReadLineIterator
_vm:set_metatable(jk.fs.File.ReadLineIterator, {})

function jk.fs.File.ReadLineIterator._create()
	local v = _vm:set_metatable({}, jk.fs.File.ReadLineIterator)
	return v
end

function jk.fs.File.ReadLineIterator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.File.ReadLineIterator'
	self['_isType.jk.fs.File.ReadLineIterator'] = true
	self['_isType.jk.lang.Iterator'] = true
	self.reader = nil
end

function jk.fs.File.ReadLineIterator:_construct0()
	jk.fs.File.ReadLineIterator._init(self)
	return self
end

function jk.fs.File.ReadLineIterator:next()
	if not (self.reader ~= nil) then
		do return nil end
	end
	do
		local v = self.reader:readLine()
		if v == nil then
			do self.reader:close() end
			self.reader = nil
		end
		do return v end
	end
end

function jk.fs.File.ReadLineIterator:hasNext()
	if not (self.reader ~= nil) then
		do return false end
	end
	do return not self.reader:hasEnded() end
end

function jk.fs.File.ReadLineIterator:getReader()
	do return self.reader end
end

function jk.fs.File.ReadLineIterator:setReader(v)
	self.reader = v
	do return self end
end

function jk.fs.File:getLastErrorDescription()
	do return self.lastErrorDescription end
end

function jk.fs.File:onError(v)
	local pp = self:getPath()
	if not (v ~= nil) then
		self.lastErrorDescription = nil
	elseif pp ~= nil then
		self.lastErrorDescription = _g.jk.lang.String:safeString(pp) .. ": " .. _g.jk.lang.String:safeString(v)
	else
		self.lastErrorDescription = v
	end
end

function jk.fs.File:readLines()
	local rd = _g.jk.io.PrintReader:forReader(self:read())
	if not (rd ~= nil) then
		do return nil end
	end
	do return _g.jk.fs.File.ReadLineIterator._construct0(_g.jk.fs.File.ReadLineIterator._create()):setReader(rd) end
end

function jk.fs.File:readLinesVector()
	local it = self:readLines()
	if not (it ~= nil) then
		do return nil end
	end
	do
		local v = {}
		while true do
			local line = it:next()
			if not (line ~= nil) then
				do break end
			end
			do _g.jk.lang.Vector:append(v, line) end
		end
		do return v end
	end
end

function jk.fs.File:hasChangedSince(originalTimeStamp)
	local nts = self:getLastModifiedTimeStamp()
	if nts > originalTimeStamp then
		do return true end
	end
	do return false end
end

function jk.fs.File:getLastModifiedTimeStamp()
	if self:isFile() == false then
		do return 0 end
	end
	do
		local st = self:stat()
		if st == nil then
			do return 0 end
		end
		do return st:getModifyTime() end
	end
end

function jk.fs.File:compareModificationTime(bf)
	if bf == nil then
		do return 1 end
	end
	do
		local myts = self:getLastModifiedTimeStamp()
		local bfts = bf:getLastModifiedTimeStamp()
		if myts < bfts then
			do return -1 end
		end
		if myts > bfts then
			do return 1 end
		end
		do return 0 end
	end
end

function jk.fs.File:isNewerThan(bf)
	do return self:compareModificationTime(bf) > 0 end
end

function jk.fs.File:isOlderThan(bf)
	do return self:compareModificationTime(bf) < 0 end
end

function jk.fs.File:isSame(file)
	do self:onError(nil) end
	if not (file ~= nil) then
		do return false end
	end
	do
		local path = self:getPath()
		if path ~= nil and path == file:getPath() then
			do return true end
		end
		do return false end
	end
end

function jk.fs.File:removeRecursive()
	do self:onError(nil) end
	do
		local finfo = self:stat()
		if not (finfo ~= nil) then
			do return true end
		end
		if finfo:isDirectory() == false or finfo:isLink() == true then
			do return self:remove() end
		end
		do
			local it = self:entries()
			if not (it ~= nil) then
				do return false end
			end
			while it ~= nil do
				local f = it:next()
				if not (f ~= nil) then
					do break end
				end
				if not f:removeRecursive() then
					do self:onError(f:getLastErrorDescription()) end
					do return false end
				end
			end
			do return self:removeDirectory() end
		end
	end
end

function jk.fs.File:isFile()
	local st = self:stat()
	if not (st ~= nil) then
		do return false end
	end
	do return st:isFile() end
end

function jk.fs.File:isDirectory()
	local st = self:stat()
	if not (st ~= nil) then
		do return false end
	end
	do return st:isDirectory() end
end

function jk.fs.File:isLink()
	local st = self:stat()
	if not (st ~= nil) then
		do return false end
	end
	do return st:isLink() end
end

function jk.fs.File:getSize()
	local st = self:stat()
	if st == nil then
		do return 0 end
	end
	do return st:getSize() end
end

function jk.fs.File:setMode(mode)
	do self:onError("Not supported") end
	do return false end
end

function jk.fs.File:setOwnerUser(uid)
	do self:onError("Not supported") end
	do return false end
end

function jk.fs.File:setOwnerGroup(gid)
	do self:onError("Not supported") end
	do return false end
end

function jk.fs.File:withExtension(ext)
	if not (ext ~= nil) then
		do return self end
	end
	do
		local bn = self:getBasename()
		do return self:getSibling(_g.jk.lang.String:safeString(bn) .. "." .. _g.jk.lang.String:safeString(ext)) end
	end
end

function jk.fs.File:asExecutable()
	if _g.jk.os.OS:isWindows() then
		if self:hasExtension("exe") == false and self:hasExtension("bat") == false and self:hasExtension("cmd") == false and self:hasExtension("com") == false then
			local exe = self:withExtension("exe")
			if exe:isFile() then
				do return exe end
			end
			do
				local bat = self:withExtension("bat")
				if bat:isFile() then
					do return bat end
				end
				do
					local cmd = self:withExtension("cmd")
					if cmd:isFile() then
						do return cmd end
					end
					do
						local com = self:withExtension("com")
						if com:isFile() then
							do return com end
						end
						do return exe end
					end
				end
			end
		end
	end
	do return self end
end

function jk.fs.File:getParent()
	do self:onError(nil) end
	do
		local path = self:directoryName()
		if path == nil then
			do return _g.jk.fs.FileInvalid._construct0(_g.jk.fs.FileInvalid._create()) end
		end
		do return _g.jk.fs.File:forPath(path) end
	end
end

function jk.fs.File:getSibling(name)
	local pp = self:getParent()
	if not (pp ~= nil) then
		do return nil end
	end
	if name == nil then
		do return pp end
	end
	do return pp:entry(name) end
end

function jk.fs.File:hasExtension(ext)
	local xx = self:extension()
	if not (xx ~= nil) then
		do return false end
	end
	do return _g.jk.lang.String:equalsIgnoreCase(xx, ext) end
end

function jk.fs.File:extension()
	local bn = self:getBasename()
	if not (bn ~= nil) then
		do return nil end
	end
	do
		local dot = _g.jk.lang.String:getLastIndexOfCharacter(bn, 46, -1)
		if dot < 0 then
			do return nil end
		end
		do return _g.jk.lang.String:getEndOfString(bn, dot + 1) end
	end
end

function jk.fs.File:directoryName()
	local path = self:getPath()
	if not (path ~= nil) then
		do return nil end
	end
	do
		local delim = _g.jk.fs.PathInfo:getPathSeparator()
		local dp = _g.jk.lang.String:getLastIndexOfCharacter(path, delim, -1)
		if delim ~= 47 then
			local sdp = _g.jk.lang.String:getLastIndexOfCharacter(path, 47, -1)
			if sdp > dp then
				dp = sdp
			end
		end
		if dp < 0 then
			do return "." end
		end
		do return _g.jk.lang.String:getSubString(path, 0, dp) end
	end
end

function jk.fs.File:getBasename()
	local path = self:getPath()
	if not (path ~= nil) then
		do return nil end
	end
	do
		local delim = _g.jk.fs.PathInfo:getPathSeparator()
		if _g.jk.lang.String:endsWith(path, _g.jk.lang.String:forCharacter(delim)) then
			path = _g.jk.lang.String:getSubString(path, 0, _g.jk.lang.String:getLength(path) - 1)
		end
		if delim ~= 47 and _g.jk.lang.String:endsWith(path, "/") then
			path = _g.jk.lang.String:getSubString(path, 0, _g.jk.lang.String:getLength(path) - 1)
		end
		do
			local dp = _g.jk.lang.String:getLastIndexOfCharacter(path, delim, -1)
			if delim ~= 47 then
				local sdp = _g.jk.lang.String:getLastIndexOfCharacter(path, 47, -1)
				if sdp > dp then
					dp = sdp
				end
			end
			if dp < 0 then
				do return path end
			end
			do return _g.jk.lang.String:getEndOfString(path, dp + 1) end
		end
	end
end

function jk.fs.File:getBasenameWithoutExtension()
	local bn = self:getBasename()
	if not (bn ~= nil) then
		do return nil end
	end
	do
		local dot = _g.jk.lang.String:getLastIndexOfCharacter(bn, 46, -1)
		if dot < 0 then
			do return bn end
		end
		do return _g.jk.lang.String:getSubString(bn, 0, dot) end
	end
end

function jk.fs.File:baseName()
	do return self:getBasename() end
end

function jk.fs.File:baseNameWithoutExtension()
	do return self:getBasenameWithoutExtension() end
end

function jk.fs.File:copyFileTo(dest)
	do self:onError(nil) end
	if not (dest ~= nil) then
		do return false end
	end
	if self:isSame(dest) then
		do return true end
	end
	do
		local buf = _util:allocate_buffer(4096 * 4)
		if not (buf ~= nil) then
			do return false end
		end
		do
			local reader = self:read()
			if not (reader ~= nil) then
				do return false end
			end
			do
				local writer = dest:write()
				if not (writer ~= nil) then
					if (_vm:to_table_with_key(reader, '_isType.jk.lang.Closable') ~= nil) then
						do reader:close() end
					end
					do self:onError(dest:getLastErrorDescription()) end
					do return false end
				end
				do
					local v = true
					local n = 0
					while (function()
						n = reader:read(buf)
						do return n end
					end)() > 0 do
						local nr = writer:write(buf, n)
						if nr ~= n then
							v = false
							do break end
						end
					end
					if v then
						local fi = self:stat()
						if fi ~= nil then
							local mode = fi:getMode()
							if mode ~= 0 then
								do dest:setMode(mode) end
							end
						end
					else
						do dest:remove() end
					end
					if reader ~= nil and (_vm:to_table_with_key(reader, '_isType.jk.lang.Closable') ~= nil) then
						do reader:close() end
					end
					if writer ~= nil and (_vm:to_table_with_key(writer, '_isType.jk.lang.Closable') ~= nil) then
						do writer:close() end
					end
					do return v end
				end
			end
		end
	end
end

function jk.fs.File:copyFileOrDirectoryTo(dest)
	if not (dest ~= nil) then
		do return false end
	end
	if self:isFile() then
		do return self:copyFileTo(dest) end
	end
	if not self:isDirectory() then
		do return false end
	end
	if not dest:createDirectoryRecursive() then
		do return false end
	end
	do
		local it = self:entries()
		if not (it ~= nil) then
			do return false end
		end
		while true do
			local nsrc = it:next()
			if not (nsrc ~= nil) then
				do break end
			end
			do
				local ndest = dest:entry(nsrc:getBasename())
				if not nsrc:copyFileOrDirectoryTo(ndest) then
					do return false end
				end
			end
		end
		do return true end
	end
end

function jk.fs.File:setContentsString(str, encoding)
	if _g.jk.lang.String:isEmpty(encoding) then
		do return false end
	end
	do return self:setContentsBuffer(_g.jk.lang.String:toBuffer(str, encoding)) end
end

function jk.fs.File:setContentsUTF8(str)
	do return self:setContentsBuffer(_g.jk.lang.String:toUTF8Buffer(str)) end
end

function jk.fs.File:setContentsBuffer(buffer)
	do self:onError(nil) end
	if not (buffer ~= nil) then
		do return false end
	end
	do
		local writer = self:write()
		if not (writer ~= nil) then
			do return false end
		end
		if writer:write(buffer, #buffer) < 0 then
			do return false end
		end
		do writer:close() end
		do return true end
	end
end

function jk.fs.File:getContentsString(encoding)
	if _g.jk.lang.String:isEmpty(encoding) then
		do return nil end
	end
	do
		local b = self:getContentsBuffer()
		if not (b ~= nil) then
			if self:isFile() and self:getSize() == 0 then
				do return "" end
			end
			do return nil end
		end
		do return _g.jk.lang.String:forBuffer(b, encoding) end
	end
end

function jk.fs.File:getContentsUTF8()
	local b = self:getContentsBuffer()
	if not (b ~= nil) then
		if self:isFile() and self:getSize() == 0 then
			do return "" end
		end
		do return nil end
	end
	do return _g.jk.lang.String:forUTF8Buffer(b) end
end

function jk.fs.File:getContentsWithBOM()
	local buf = self:getContentsBuffer()
	if not (buf ~= nil) then
		if self:isFile() and self:getSize() == 0 then
			do return "" end
		end
		do return nil end
	end
	if _g.jk.lang.Buffer:getByte(buf, 0) == 239 and _g.jk.lang.Buffer:getByte(buf, 1) == 187 and _g.jk.lang.Buffer:getByte(buf, 2) == 191 then
		do return _g.jk.lang.String:forUTF8Buffer(_g.jk.lang.Buffer:getSubBuffer(buf, 3, _g.jk.lang.Buffer:getSize(buf) - 3, false)) end
	elseif _g.jk.lang.Buffer:getByte(buf, 0) == 255 and _g.jk.lang.Buffer:getByte(buf, 1) == 254 then
		do self:onError("Not supported encoding, UTF-16 little endian") end
		do return nil end
	elseif _g.jk.lang.Buffer:getByte(buf, 0) == 254 and _g.jk.lang.Buffer:getByte(buf, 1) == 255 then
		do self:onError("Not supported encoding, UTF-16 big-endian") end
		do return nil end
	elseif _g.jk.lang.Buffer:getByte(buf, 0) == 255 and _g.jk.lang.Buffer:getByte(buf, 1) == 254 and _g.jk.lang.Buffer:getByte(buf, 2) == 0 and _g.jk.lang.Buffer:getByte(buf, 3) == 0 then
		do self:onError("Not supported encoding, UTF-32 little endian") end
		do return nil end
	elseif _g.jk.lang.Buffer:getByte(buf, 0) == 0 and _g.jk.lang.Buffer:getByte(buf, 1) == 0 and _g.jk.lang.Buffer:getByte(buf, 2) == 254 and _g.jk.lang.Buffer:getByte(buf, 3) == 255 then
		do self:onError("Not supported encoding, UTF-32 big endian") end
		do return nil end
	end
	do return _g.jk.lang.String:forUTF8Buffer(buf) end
end

function jk.fs.File:getContentsBuffer()
	do self:onError(nil) end
	do
		local reader = self:read()
		if not (reader ~= nil) then
			do return nil end
		end
		do
			local sz = reader:getSize()
			if sz < 1 then
				do reader:close() end
				do return nil end
			end
			do
				local b = _util:allocate_buffer(sz)
				local rsz = reader:read(b)
				do reader:close() end
				if rsz < sz then
					do return nil end
				end
				do return b end
			end
		end
	end
end

function jk.fs.File:toString()
	do return self:getPath() end
end

jk.fs.FileInvalid = _g.jk.fs.File._create()
jk.fs.FileInvalid.__index = jk.fs.FileInvalid
_vm:set_metatable(jk.fs.FileInvalid, {
	__index = _g.jk.fs.File
})

function jk.fs.FileInvalid._create()
	local v = _vm:set_metatable({}, jk.fs.FileInvalid)
	return v
end

function jk.fs.FileInvalid:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileInvalid'
	self['_isType.jk.fs.FileInvalid'] = true
end

function jk.fs.FileInvalid:_construct0()
	jk.fs.FileInvalid._init(self)
	do _g.jk.fs.File._construct0(self) end
	return self
end

function jk.fs.FileInvalid:entry(name)
	do return _g.jk.fs.FileInvalid._construct0(_g.jk.fs.FileInvalid._create()) end
end

function jk.fs.FileInvalid:makeExecutable()
	do return false end
end

function jk.fs.FileInvalid:move(dest, replace)
	do return false end
end

function jk.fs.FileInvalid:touch()
	do return false end
end

function jk.fs.FileInvalid:read()
	do return nil end
end

function jk.fs.FileInvalid:write()
	do return nil end
end

function jk.fs.FileInvalid:append()
	do return nil end
end

function jk.fs.FileInvalid:stat()
	do return nil end
end

function jk.fs.FileInvalid:exists()
	do return false end
end

function jk.fs.FileInvalid:isExecutable()
	do return false end
end

function jk.fs.FileInvalid:createFifo()
	do return false end
end

function jk.fs.FileInvalid:createDirectory()
	do return false end
end

function jk.fs.FileInvalid:createDirectoryRecursive()
	do return false end
end

function jk.fs.FileInvalid:removeDirectory()
	do return false end
end

function jk.fs.FileInvalid:getPath()
	do return nil end
end

function jk.fs.FileInvalid:isSame(file)
	do return false end
end

function jk.fs.FileInvalid:remove()
	do return false end
end

function jk.fs.FileInvalid:removeRecursive()
	do return false end
end

function jk.fs.FileInvalid:getBasename()
	do return nil end
end

function jk.fs.FileInvalid:isIdentical(file)
	do return false end
end

function jk.fs.FileInvalid:getContentsBuffer()
	do return nil end
end

function jk.fs.FileInvalid:getContentsString(encoding)
	do return nil end
end

function jk.fs.FileInvalid:setContentsBuffer(buffer)
	do return false end
end

function jk.fs.FileInvalid:setContentsString(str, encoding)
	do return false end
end

function jk.fs.FileInvalid:entries()
	do return nil end
end

jk.fs.FileReader = {}

jk.fs.FileInfo = {}
jk.fs.FileInfo.__index = jk.fs.FileInfo
_vm:set_metatable(jk.fs.FileInfo, {})

jk.fs.FileInfo.FILE_TYPE_UNKNOWN = 0
jk.fs.FileInfo.FILE_TYPE_FILE = 1
jk.fs.FileInfo.FILE_TYPE_DIR = 2

function jk.fs.FileInfo._create()
	local v = _vm:set_metatable({}, jk.fs.FileInfo)
	return v
end

function jk.fs.FileInfo:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileInfo'
	self['_isType.jk.fs.FileInfo'] = true
	self.file = nil
	self.size = 0
	self.createTime = 0
	self.accessTime = 0
	self.modifyTime = 0
	self.ownerUser = 0
	self.ownerGroup = 0
	self.mode = 0
	self.executable = false
	self.type = 0
	self.link = false
end

function jk.fs.FileInfo:_construct0()
	jk.fs.FileInfo._init(self)
	return self
end

function jk.fs.FileInfo:forFile(file)
	if file == nil then
		do return _g.jk.fs.FileInfo._construct0(_g.jk.fs.FileInfo._create()) end
	end
	do return file:stat() end
end

function jk.fs.FileInfo:setFile(v)
	self.file = v
end

function jk.fs.FileInfo:setSize(v)
	self.size = v
end

function jk.fs.FileInfo:setCreateTime(v)
	self.createTime = v
end

function jk.fs.FileInfo:setAccessTime(v)
	self.accessTime = v
end

function jk.fs.FileInfo:setModifyTime(v)
	self.modifyTime = v
end

function jk.fs.FileInfo:setOwnerUser(v)
	self.ownerUser = v
end

function jk.fs.FileInfo:setOwnerGroup(v)
	self.ownerGroup = v
end

function jk.fs.FileInfo:setMode(v)
	self.mode = v
end

function jk.fs.FileInfo:setExecutable(v)
	self.executable = v
end

function jk.fs.FileInfo:setType(v)
	self.type = v
end

function jk.fs.FileInfo:setLink(v)
	self.link = v
end

function jk.fs.FileInfo:getFile()
	do return self.file end
end

function jk.fs.FileInfo:getSize()
	do return self.size end
end

function jk.fs.FileInfo:getCreateTime()
	do return self.createTime end
end

function jk.fs.FileInfo:getCreateTimeUTC()
	do return self.createTime + _g.jk.time.SystemClock:getTimezoneOffsetAsSeconds() end
end

function jk.fs.FileInfo:getAccessTime()
	do return self.accessTime end
end

function jk.fs.FileInfo:getAccessTimeUTC()
	do return self.accessTime + _g.jk.time.SystemClock:getTimezoneOffsetAsSeconds() end
end

function jk.fs.FileInfo:getModifyTime()
	do return self.modifyTime end
end

function jk.fs.FileInfo:getModifyTimeUTC()
	do return self.modifyTime + _g.jk.time.SystemClock:getTimezoneOffsetAsSeconds() end
end

function jk.fs.FileInfo:getOwnerUser()
	do return self.ownerUser end
end

function jk.fs.FileInfo:getOwnerGroup()
	do return self.ownerGroup end
end

function jk.fs.FileInfo:getMode()
	do return self.mode end
end

function jk.fs.FileInfo:getExecutable()
	do return self.executable end
end

function jk.fs.FileInfo:getType()
	do return self.type end
end

function jk.fs.FileInfo:getLink()
	do return self.link end
end

function jk.fs.FileInfo:isFile()
	if self.type == _g.jk.fs.FileInfo.FILE_TYPE_FILE then
		do return true end
	end
	do return false end
end

function jk.fs.FileInfo:isLink()
	do return self.link end
end

function jk.fs.FileInfo:isDirectory()
	if self.type == _g.jk.fs.FileInfo.FILE_TYPE_DIR then
		do return true end
	end
	do return false end
end

function jk.fs.FileInfo:exists()
	do return self:isFile() or self:isDirectory() or self:isLink() end
end

jk.fs.FileForSushi = _g.jk.fs.File._create()
jk.fs.FileForSushi.__index = jk.fs.FileForSushi
_vm:set_metatable(jk.fs.FileForSushi, {
	__index = _g.jk.fs.File
})

function jk.fs.FileForSushi._create()
	local v = _vm:set_metatable({}, jk.fs.FileForSushi)
	return v
end

function jk.fs.FileForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileForSushi'
	self['_isType.jk.fs.FileForSushi'] = true
	self.path = nil
end

function jk.fs.FileForSushi:_construct0()
	jk.fs.FileForSushi._init(self)
	do _g.jk.fs.File._construct0(self) end
	return self
end

jk.fs.FileForSushi.MyFileReader = {}
jk.fs.FileForSushi.MyFileReader.__index = jk.fs.FileForSushi.MyFileReader
_vm:set_metatable(jk.fs.FileForSushi.MyFileReader, {})

function jk.fs.FileForSushi.MyFileReader._create()
	local v = _vm:set_metatable({}, jk.fs.FileForSushi.MyFileReader)
	return v
end

function jk.fs.FileForSushi.MyFileReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileForSushi.MyFileReader'
	self['_isType.jk.fs.FileForSushi.MyFileReader'] = true
	self['_isType.jk.fs.FileReader'] = true
	self['_isType.jk.io.SizedReader'] = true
	self['_isType.jk.io.Reader'] = true
	self['_isType.jk.lang.Closable'] = true
	self['_isType.jk.io.SeekableReader'] = true
	self.handle = -1
	self.file = nil
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function jk.fs.FileForSushi.MyFileReader:_construct0()
	jk.fs.FileForSushi.MyFileReader._init(self)
	return self
end

function jk.fs.FileForSushi.MyFileReader:_destruct()
	do self:close() end
end

function jk.fs.FileForSushi.MyFileReader:read(buffer)
	local v = -1
	local handle = self.handle
	if handle >= 0 then
		do v = _io:read_from_handle(handle, buffer) end
	end
	do return v end
end

function jk.fs.FileForSushi.MyFileReader:getSize()
	local v = -1
	local handle = self.handle
	if handle >= 0 then
		do v = _io:get_size_for_handle(handle) end
	end
	do return v end
end

function jk.fs.FileForSushi.MyFileReader:close()
	local handle = self.handle
	if handle >= 0 then
		do _io:close_handle(handle) end
		self.handle = -1
	end
end

function jk.fs.FileForSushi.MyFileReader:setCurrentPosition(n)
	local handle = self.handle
	if handle < 0 then
		do return false end
	end
	if _io:set_current_position(handle, n) < 0 then
		do return false end
	end
	do return true end
end

function jk.fs.FileForSushi.MyFileReader:getCurrentPosition()
	local handle = self.handle
	if handle < 0 then
		do return 0 end
	end
	do return _io:get_current_position(handle) end
end

function jk.fs.FileForSushi.MyFileReader:getHandle()
	do return self.handle end
end

function jk.fs.FileForSushi.MyFileReader:setHandle(v)
	self.handle = v
	do return self end
end

function jk.fs.FileForSushi.MyFileReader:getFile()
	do return self.file end
end

function jk.fs.FileForSushi.MyFileReader:setFile(v)
	self.file = v
	do return self end
end

jk.fs.FileForSushi.MyFileWriter = {}
jk.fs.FileForSushi.MyFileWriter.__index = jk.fs.FileForSushi.MyFileWriter
_vm:set_metatable(jk.fs.FileForSushi.MyFileWriter, {})

function jk.fs.FileForSushi.MyFileWriter._create()
	local v = _vm:set_metatable({}, jk.fs.FileForSushi.MyFileWriter)
	return v
end

function jk.fs.FileForSushi.MyFileWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileForSushi.MyFileWriter'
	self['_isType.jk.fs.FileForSushi.MyFileWriter'] = true
	self['_isType.jk.fs.FileWriter'] = true
	self['_isType.jk.io.Writer'] = true
	self['_isType.jk.lang.Closable'] = true
	self['_isType.jk.io.SeekableWriter'] = true
	self.handle = -1
	self.file = nil
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function jk.fs.FileForSushi.MyFileWriter:_construct0()
	jk.fs.FileForSushi.MyFileWriter._init(self)
	return self
end

function jk.fs.FileForSushi.MyFileWriter:_destruct()
	do self:close() end
end

function jk.fs.FileForSushi.MyFileWriter:write(buf, size)
	local v = -1
	local handle = self.handle
	if handle >= 0 then
		do v = _io:write_to_handle(handle, buf, size) end
	end
	do return v end
end

function jk.fs.FileForSushi.MyFileWriter:close()
	local handle = self.handle
	if handle >= 0 then
		do _io:close_handle(handle) end
		self.handle = -1
	end
end

function jk.fs.FileForSushi.MyFileWriter:setCurrentPosition(n)
	local handle = self.handle
	if handle < 0 then
		do return false end
	end
	if _io:set_current_position(handle, n) < 0 then
		do return false end
	end
	do return true end
end

function jk.fs.FileForSushi.MyFileWriter:getCurrentPosition()
	local handle = self.handle
	if handle < 0 then
		do return 0 end
	end
	do return _io:get_current_position(handle) end
end

function jk.fs.FileForSushi.MyFileWriter:getHandle()
	do return self.handle end
end

function jk.fs.FileForSushi.MyFileWriter:setHandle(v)
	self.handle = v
	do return self end
end

function jk.fs.FileForSushi.MyFileWriter:getFile()
	do return self.file end
end

function jk.fs.FileForSushi.MyFileWriter:setFile(v)
	self.file = v
	do return self end
end

function jk.fs.FileForSushi:forPath(path)
	local v = _g.jk.fs.FileForSushi._construct0(_g.jk.fs.FileForSushi._create())
	do v:setPath(path, true) end
	do return v end
end

function jk.fs.FileForSushi:forRawPath(path)
	local v = _g.jk.fs.FileForSushi._construct0(_g.jk.fs.FileForSushi._create())
	do v:setPath(path, false) end
	do return v end
end

function jk.fs.FileForSushi:entry(name)
	local pp = self.path
	if _g.jk.lang.String:isNotEmpty(name) then
		if pp ~= nil then
			pp = _g.jk.lang.String:safeString(pp) .. "/" .. _g.jk.lang.String:safeString(name)
		else
			pp = name
		end
	end
	do return _g.jk.fs.FileForSushi:forPath(pp) end
end

function jk.fs.FileForSushi:rawEntry(name)
	local pp = self.path
	if _g.jk.lang.String:isNotEmpty(name) then
		if pp ~= nil then
			pp = _g.jk.lang.String:safeString(pp) .. "/" .. _g.jk.lang.String:safeString(name)
		else
			pp = name
		end
	end
	do return _g.jk.fs.FileForSushi:forRawPath(pp) end
end

function jk.fs.FileForSushi:move(dest, replace)
	_io:write_to_stdout("--- stub --- jk.fs.FileForSushi :: move" .. "\n")
	do return false end
end

function jk.fs.FileForSushi:touch()
	local path = self.path
	local r = _io:touch_file(path)
	if r == 1 then
		do return true end
	end
	do return false end
end

function jk.fs.FileForSushi:read()
	local handle = 0
	local path = self.path
	do handle = _io:open_file_for_reading(path) end
	if not (handle >= 0) then
		do return nil end
	end
	do
		local v = _g.jk.fs.FileForSushi.MyFileReader._construct0(_g.jk.fs.FileForSushi.MyFileReader._create())
		do v:setFile(self) end
		do v:setHandle(handle) end
		do return v end
	end
end

function jk.fs.FileForSushi:write()
	local handle = 0
	local path = self.path
	do handle = _io:open_file_for_writing(path) end
	if not (handle >= 0) then
		do return nil end
	end
	do
		local v = _g.jk.fs.FileForSushi.MyFileWriter._construct0(_g.jk.fs.FileForSushi.MyFileWriter._create())
		do v:setFile(self) end
		do v:setHandle(handle) end
		do return v end
	end
end

function jk.fs.FileForSushi:append()
	local handle = 0
	local path = self.path
	do handle = _io:open_file_for_appending(path) end
	if not (handle >= 0) then
		do return nil end
	end
	do
		local v = _g.jk.fs.FileForSushi.MyFileWriter._construct0(_g.jk.fs.FileForSushi.MyFileWriter._create())
		do v:setFile(self) end
		do v:setHandle(handle) end
		do return v end
	end
end

function jk.fs.FileForSushi:stat()
	local path = self.path
	local valid = true
	local size = 0
	local ctim = 0
	local atim = 0
	local mtim = 0
	local uid = 0
	local gid = 0
	local mode = 0
	do size, ctim, atim, mtim, uid, gid, mode = _io:get_file_info(path) if size == nil then valid = false end end
	do
		local v = _g.jk.fs.FileInfo._construct0(_g.jk.fs.FileInfo._create())
		do v:setFile(self) end
		if not valid then
			do v:setType(_g.jk.fs.FileInfo.FILE_TYPE_UNKNOWN) end
			do return v end
		end
		do v:setSize(size) end
		do v:setCreateTime(ctim) end
		do v:setAccessTime(ctim) end
		do v:setModifyTime(mtim) end
		do v:setOwnerUser(uid) end
		do v:setOwnerGroup(gid) end
		do v:setMode(_vm:bitwise_and(mode, 511)) end
		if _vm:bitwise_and(mode, 32768) ~= 0 then
			do v:setType(_g.jk.fs.FileInfo.FILE_TYPE_FILE) end
		elseif _vm:bitwise_and(mode, 16384) ~= 0 then
			do v:setType(_g.jk.fs.FileInfo.FILE_TYPE_DIR) end
		else
			do v:setType(_g.jk.fs.FileInfo.FILE_TYPE_UNKNOWN) end
		end
		if _vm:bitwise_and(mode, 40960) ~= 0 then
			do v:setLink(true) end
		end
		if _vm:bitwise_and(mode, 64) ~= 0 or _vm:bitwise_and(mode, 8) ~= 0 or _vm:bitwise_and(mode, 1) ~= 0 then
			do v:setExecutable(true) end
		end
		do return v end
	end
end

function jk.fs.FileForSushi:createDirectory()
	local path = self.path
	local r = _io:create_directory(path)
	if r == 1 then
		do return true end
	end
	do return false end
end

function jk.fs.FileForSushi:createDirectoryRecursive()
	if self:isDirectory() then
		do return true end
	end
	do
		local parent = self:getParent()
		if parent ~= nil then
			if not parent:createDirectoryRecursive() then
				do return false end
			end
		end
		do return self:createDirectory() end
	end
end

function jk.fs.FileForSushi:removeDirectory()
	local path = self.path
	local r = _io:remove_directory(path)
	if r == 1 then
		do return true end
	end
	do return false end
end

function jk.fs.FileForSushi:normalizePath(apath)
	local path = apath
	if not (path ~= nil) then
		do return nil end
	end
	if _g.jk.os.OS:isWindows() then
		path = _g.jk.lang.String:replaceCharacter(path, 92, 47)
	end
	do
		local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local comps = _g.jk.lang.String:split(path, 47, 0)
		if comps ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(comps)
			do
				n = 0
				while n < m do
					local comp = comps[n + 1]
					if comp ~= nil then
						if _g.jk.lang.String:isEmpty(comp) then
						elseif comp == "." then
						elseif comp == ".." then
							local str = v:toString()
							do v:clear() end
							if str ~= nil then
								local slash = _g.jk.lang.String:getLastIndexOfCharacter(str, 47, -1)
								if slash > 0 then
									do v:appendString(_g.jk.lang.String:getSubString(str, 0, slash)) end
								end
							end
						else
							if v:count() > 0 then
								do v:appendCharacter(47) end
							end
							do v:appendString(comp) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		if _g.jk.lang.String:startsWith(path, "/", 0) then
			do return "/" .. _g.jk.lang.String:safeString(v:toString()) end
		end
		do return v:toString() end
	end
end

function jk.fs.FileForSushi:setPath(v, useRealPath)
	if _g.jk.lang.String:isEmpty(v) then
		self.path = nil
		do return end
	end
	if _g.jk.os.OS:isWindows() then
		local l = _g.jk.lang.String:getLength(v)
		local c1 = _g.jk.lang.String:getChar(v, 1)
		if l == 2 and c1 == 58 then
			self.path = _g.jk.lang.String:safeString(v) .. "/"
			do return end
		end
		do
			local c2 = _g.jk.lang.String:getChar(v, 2)
			if l == 3 and c1 == 58 and (c2 == 92 or c2 == 47) then
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendCharacter(_g.jk.lang.String:getChar(v, 0)) end
				do sb:appendCharacter(58) end
				do sb:appendCharacter(47) end
				self.path = sb:toString()
				do return end
			end
		end
	end
	if useRealPath then
		local realpath = nil
		do realpath = _io:get_real_path(v) end
		if _g.jk.lang.String:isNotEmpty(realpath) then
			self.path = realpath
			if _g.jk.os.OS:isWindows() then
				self.path = _g.jk.lang.String:replaceCharacter(self.path, 92, 47)
			end
			do return end
		end
	end
	if _g.jk.fs.PathInfo:isAbsolutePath(v) then
		self.path = self:normalizePath(v)
	else
		self.path = self:normalizePath(_g.jk.lang.String:safeString(_io:get_current_directory()) .. "/" .. _g.jk.lang.String:safeString(v))
	end
end

function jk.fs.FileForSushi:getPath()
	do return self.path end
end

function jk.fs.FileForSushi:remove()
	local path = self.path
	if _io:remove_file(path) == 1 then
		do return true end
	end
	do return false end
end

function jk.fs.FileForSushi:makeExecutable()
	local path = self.path
	local mode = _vm:bitwise_or(_vm:bitwise_or(_vm:bitwise_or(_vm:bitwise_or(_vm:bitwise_or(_vm:bitwise_or(1, 4), 8), 32), 64), 128), 256)
	do return _io:set_file_mode(path, mode ) end
end

function jk.fs.FileForSushi:setMode(mode)
	local path = self.path
	do return _io:set_file_mode(path, mode ) end
end

jk.fs.FileForSushi.MyDirectoryIterator = {}
jk.fs.FileForSushi.MyDirectoryIterator.__index = jk.fs.FileForSushi.MyDirectoryIterator
_vm:set_metatable(jk.fs.FileForSushi.MyDirectoryIterator, {})

function jk.fs.FileForSushi.MyDirectoryIterator._create()
	local v = _vm:set_metatable({}, jk.fs.FileForSushi.MyDirectoryIterator)
	return v
end

function jk.fs.FileForSushi.MyDirectoryIterator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.FileForSushi.MyDirectoryIterator'
	self['_isType.jk.fs.FileForSushi.MyDirectoryIterator'] = true
	self['_isType.jk.lang.Iterator'] = true
	self['_isType.jk.lang.Closable'] = true
	self.parent = nil
	self.handle = nil
	self.current = nil
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function jk.fs.FileForSushi.MyDirectoryIterator:_construct0()
	jk.fs.FileForSushi.MyDirectoryIterator._init(self)
	return self
end

function jk.fs.FileForSushi.MyDirectoryIterator:_destruct()
	do self:close() end
end

function jk.fs.FileForSushi.MyDirectoryIterator:close()
	local handle = self.handle
	if handle ~= nil then
		do _io:close_directory(handle) end
		self.handle = nil
	end
end

function jk.fs.FileForSushi.MyDirectoryIterator:doNext()
	local handle = self.handle
	if not (handle ~= nil) then
		do return nil end
	end
	do
		local name = _io:read_directory(handle)
		if not (name ~= nil) then
			do self:close() end
			do return nil end
		end
		do return _g.jk.fs.File:forRelativePath(name, self.parent, false) end
	end
end

function jk.fs.FileForSushi.MyDirectoryIterator:next()
	if self.current ~= nil then
		local vv = self.current
		self.current = nil
		do return vv end
	end
	do return self:doNext() end
end

function jk.fs.FileForSushi.MyDirectoryIterator:hasNext()
	if self.current ~= nil then
		do return true end
	end
	do
		local v = self:doNext()
		if v ~= nil then
			self.current = v
			do return true end
		end
		do return false end
	end
end

function jk.fs.FileForSushi.MyDirectoryIterator:getParent()
	do return self.parent end
end

function jk.fs.FileForSushi.MyDirectoryIterator:setParent(v)
	self.parent = v
	do return self end
end

function jk.fs.FileForSushi.MyDirectoryIterator:getHandle()
	do return self.handle end
end

function jk.fs.FileForSushi.MyDirectoryIterator:setHandle(v)
	self.handle = v
	do return self end
end

function jk.fs.FileForSushi:entries()
	local pp = self.path
	if not _g.jk.lang.String:isNotEmpty(pp) then
		do return nil end
	end
	do
		local handle = _io:open_directory(pp)
		if not (handle ~= nil) then
			do return nil end
		end
		do
			local v = _g.jk.fs.FileForSushi.MyDirectoryIterator._construct0(_g.jk.fs.FileForSushi.MyDirectoryIterator._create())
			do v:setParent(self) end
			do v:setHandle(handle) end
			do return v end
		end
	end
end

jk.fs.CurrentDirectory = {}
jk.fs.CurrentDirectory.__index = jk.fs.CurrentDirectory
_vm:set_metatable(jk.fs.CurrentDirectory, {})

function jk.fs.CurrentDirectory._create()
	local v = _vm:set_metatable({}, jk.fs.CurrentDirectory)
	return v
end

function jk.fs.CurrentDirectory:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.fs.CurrentDirectory'
	self['_isType.jk.fs.CurrentDirectory'] = true
end

function jk.fs.CurrentDirectory:_construct0()
	jk.fs.CurrentDirectory._init(self)
	return self
end

function jk.fs.CurrentDirectory:set(dir)
	if not (dir ~= nil) then
		do return end
	end
	do _io:set_current_directory(dir:getPath()) end
end

function jk.fs.CurrentDirectory:get()
	do return _g.jk.fs.File:forPath(_io:get_current_directory()) end
end
jk = jk or {}

jk.app = jk.app or {}

jk.app.ApplicationContext = {}
jk = jk or {}

jk.posix = jk.posix or {}

jk.posix.PosixSignal = {}
jk.posix.PosixSignal.__index = jk.posix.PosixSignal
_vm:set_metatable(jk.posix.PosixSignal, {})

jk.posix.PosixSignal.SIGHUP = 1
jk.posix.PosixSignal.SIGINT = 2
jk.posix.PosixSignal.SIGQUIT = 3
jk.posix.PosixSignal.SIGILL = 4
jk.posix.PosixSignal.SIGTRAP = 5
jk.posix.PosixSignal.SIGABRT = 6
jk.posix.PosixSignal.SIGFPE = 8
jk.posix.PosixSignal.SIGKILL = 9
jk.posix.PosixSignal.SIGSEGV = 11
jk.posix.PosixSignal.SIGPIPE = 13
jk.posix.PosixSignal.SIGALRM = 14
jk.posix.PosixSignal.SIGTERM = 15

function jk.posix.PosixSignal._create()
	local v = _vm:set_metatable({}, jk.posix.PosixSignal)
	return v
end

function jk.posix.PosixSignal:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.posix.PosixSignal'
	self['_isType.jk.posix.PosixSignal'] = true
end

function jk.posix.PosixSignal:_construct0()
	jk.posix.PosixSignal._init(self)
	return self
end

function jk.posix.PosixSignal:trapSignal(signum, enabled)
	local n = (function(a, b, c)
		if a then
			do return b() end
		end
		do return c() end
	end)(enabled, function()
		do return 1 end
	end, function()
		do return 0 end
	end)
	local o = _os:trap_signal(signum, n)
	if o == 1 then
		do return true end
	end
	do return false end
end

function jk.posix.PosixSignal:checkSignalState(signum)
	local n = _os:check_signal_state(signum, n)
	if n == 1 then
		do return true end
	end
	do return false end
end

jk.posix.PosixEnvironment = {}
jk.posix.PosixEnvironment.__index = jk.posix.PosixEnvironment
_vm:set_metatable(jk.posix.PosixEnvironment, {})

function jk.posix.PosixEnvironment._create()
	local v = _vm:set_metatable({}, jk.posix.PosixEnvironment)
	return v
end

function jk.posix.PosixEnvironment:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.posix.PosixEnvironment'
	self['_isType.jk.posix.PosixEnvironment'] = true
end

function jk.posix.PosixEnvironment:_construct0()
	jk.posix.PosixEnvironment._init(self)
	return self
end

jk.posix.PosixEnvironment.PosixUser = {}
jk.posix.PosixEnvironment.PosixUser.__index = jk.posix.PosixEnvironment.PosixUser
_vm:set_metatable(jk.posix.PosixEnvironment.PosixUser, {})

function jk.posix.PosixEnvironment.PosixUser._create()
	local v = _vm:set_metatable({}, jk.posix.PosixEnvironment.PosixUser)
	return v
end

function jk.posix.PosixEnvironment.PosixUser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.posix.PosixEnvironment.PosixUser'
	self['_isType.jk.posix.PosixEnvironment.PosixUser'] = true
	self.pwName = nil
	self.pwUid = 0
	self.pwGid = 0
	self.pwGecos = nil
	self.pwDir = nil
	self.pwShell = nil
end

function jk.posix.PosixEnvironment.PosixUser:_construct0()
	jk.posix.PosixEnvironment.PosixUser._init(self)
	return self
end

function jk.posix.PosixEnvironment.PosixUser:getPwName()
	do return self.pwName end
end

function jk.posix.PosixEnvironment.PosixUser:setPwName(v)
	self.pwName = v
	do return self end
end

function jk.posix.PosixEnvironment.PosixUser:getPwUid()
	do return self.pwUid end
end

function jk.posix.PosixEnvironment.PosixUser:setPwUid(v)
	self.pwUid = v
	do return self end
end

function jk.posix.PosixEnvironment.PosixUser:getPwGid()
	do return self.pwGid end
end

function jk.posix.PosixEnvironment.PosixUser:setPwGid(v)
	self.pwGid = v
	do return self end
end

function jk.posix.PosixEnvironment.PosixUser:getPwGecos()
	do return self.pwGecos end
end

function jk.posix.PosixEnvironment.PosixUser:setPwGecos(v)
	self.pwGecos = v
	do return self end
end

function jk.posix.PosixEnvironment.PosixUser:getPwDir()
	do return self.pwDir end
end

function jk.posix.PosixEnvironment.PosixUser:setPwDir(v)
	self.pwDir = v
	do return self end
end

function jk.posix.PosixEnvironment.PosixUser:getPwShell()
	do return self.pwShell end
end

function jk.posix.PosixEnvironment.PosixUser:setPwShell(v)
	self.pwShell = v
	do return self end
end

function jk.posix.PosixEnvironment:getpwnam(username)
	do return nil end
end

function jk.posix.PosixEnvironment:getpwuid(uid)
	do return nil end
end

function jk.posix.PosixEnvironment:setuid(gid)
	do return false end
end

function jk.posix.PosixEnvironment:setgid(gid)
	do return false end
end

function jk.posix.PosixEnvironment:seteuid(uid)
	do return false end
end

function jk.posix.PosixEnvironment:setegid(gid)
	do return false end
end

function jk.posix.PosixEnvironment:getuid()
	do return -1 end
end

function jk.posix.PosixEnvironment:geteuid()
	do return -1 end
end

function jk.posix.PosixEnvironment:getgid()
	do return -1 end
end

function jk.posix.PosixEnvironment:getegid()
	do return -1 end
end
jk = jk or {}

jk.math = jk.math or {}

jk.math.Vector2 = {}
jk.math.Vector2.__index = jk.math.Vector2
_vm:set_metatable(jk.math.Vector2, {})

function jk.math.Vector2._create()
	local v = _vm:set_metatable({}, jk.math.Vector2)
	return v
end

function jk.math.Vector2:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.math.Vector2'
	self['_isType.jk.math.Vector2'] = true
	self.x = 0.0
	self.y = 0.0
end

function jk.math.Vector2:_construct0()
	jk.math.Vector2._init(self)
	return self
end

function jk.math.Vector2:create(x, y)
	local v = _g.jk.math.Vector2._construct0(_g.jk.math.Vector2._create())
	v.x = x
	v.y = y
	do return v end
end

function jk.math.Vector2:add(b)
	self.x = self.x + b.x
	self.y = self.y + b.y
	do return self end
end

function jk.math.Vector2:subtract(b)
	self.x = self.x - b.x
	self.y = self.y - b.y
	do return self end
end

function jk.math.Vector2:multiply(b)
	self.x = self.x * b.x
	self.y = self.y * b.y
	do return self end
end

function jk.math.Vector2:multiplyScalar(a)
	self.x = self.x + a
	self.y = self.y + a
	do return self end
end

function jk.math.Vector2:distance(b)
	local dist = (self.y - b.y) * (self.y - b.y) + (self.x - b.x) * (self.x - b.x)
	do return _g.jk.math.Math:sqrt(dist) end
end

function jk.math.Vector2:getLength()
	do return _g.jk.math.Math:sqrt(self.x * self.x + self.y * self.y) end
end

jk.math.Vector3 = {}
jk.math.Vector3.__index = jk.math.Vector3
_vm:set_metatable(jk.math.Vector3, {})

function jk.math.Vector3._create()
	local v = _vm:set_metatable({}, jk.math.Vector3)
	return v
end

function jk.math.Vector3:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.math.Vector3'
	self['_isType.jk.math.Vector3'] = true
	self.x = 0.0
	self.y = 0.0
	self.z = 0.0
end

function jk.math.Vector3:_construct0()
	jk.math.Vector3._init(self)
	return self
end

function jk.math.Vector3:create(x, y, z)
	local v = _g.jk.math.Vector3._construct0(_g.jk.math.Vector3._create())
	v.x = x
	v.y = y
	v.z = z
	do return v end
end

function jk.math.Vector3:add(b)
	self.x = self.x + b.x
	self.y = self.y + b.y
	self.z = self.z + b.z
	do return self end
end

function jk.math.Vector3:subtract(b)
	self.x = self.x - b.x
	self.y = self.y - b.y
	self.z = self.z - b.z
	do return self end
end

function jk.math.Vector3:multiply(b)
	self.x = self.x * b.x
	self.y = self.y * b.y
	self.z = self.z * b.z
	do return self end
end

function jk.math.Vector3:multiplyScalar(a)
	self.x = self.x * a
	self.y = self.y * a
	self.z = self.z * a
	do return self end
end

function jk.math.Vector3:distance(b)
	local dist = (self.y - b.y) * (self.y - b.y) + (self.x - b.x) * (self.x - b.x) + (self.z - b.z) * (self.z - b.z)
	do return _g.jk.math.Math:sqrt(dist) end
end

function jk.math.Vector3:getLength()
	do return _g.jk.math.Math:sqrt(self.x * self.x + self.y * self.y + self.z * self.z) end
end

jk.math.Matrix44 = {}
jk.math.Matrix44.__index = jk.math.Matrix44
_vm:set_metatable(jk.math.Matrix44, {})

function jk.math.Matrix44._create()
	local v = _vm:set_metatable({}, jk.math.Matrix44)
	return v
end

function jk.math.Matrix44:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.math.Matrix44'
	self['_isType.jk.math.Matrix44'] = true
	self.v = _vm:allocate_array(16)
end

function jk.math.Matrix44:_construct0()
	jk.math.Matrix44._init(self)
	return self
end

function jk.math.Matrix44:forZero()
	do return _g.jk.math.Matrix44:forValues({
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0
	}) end
end

function jk.math.Matrix44:forIdentity()
	do return _g.jk.math.Matrix44:forValues({
		1.0,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forTranslate(translateX, translateY, translateZ)
	do return _g.jk.math.Matrix44:forValues({
		1.0,
		0.0,
		0.0,
		translateX,
		0.0,
		1.0,
		0.0,
		translateY,
		0.0,
		0.0,
		1.0,
		translateZ,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forXRotation(angle)
	local c = _g.jk.math.Math:cos(angle)
	local s = _g.jk.math.Math:sin(angle)
	do return _g.jk.math.Matrix44:forValues({
		1.0,
		0.0,
		0.0,
		0.0,
		0.0,
		c,
		-s,
		0.0,
		0.0,
		s,
		c,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forYRotation(angle)
	local c = _g.jk.math.Math:cos(angle)
	local s = _g.jk.math.Math:sin(angle)
	do return _g.jk.math.Matrix44:forValues({
		c,
		0.0,
		s,
		0.0,
		0.0,
		1.0,
		0.0,
		0.0,
		-s,
		0.0,
		c,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forZRotation(angle)
	local c = _g.jk.math.Math:cos(angle)
	local s = _g.jk.math.Math:sin(angle)
	do return _g.jk.math.Matrix44:forValues({
		c,
		-s,
		0.0,
		0.0,
		s,
		c,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forSkew(vx, vy, vz)
	do return _g.jk.math.Matrix44:forValues({
		1.0,
		vx,
		vx,
		0.0,
		vy,
		1.0,
		vy,
		0.0,
		vz,
		vz,
		1.0,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forXRotationWithCenter(angle, centerX, centerY, centerZ)
	local translate = _g.jk.math.Matrix44:forTranslate(centerX, centerY, centerZ)
	local rotate = _g.jk.math.Matrix44:forXRotation(angle)
	local translateBack = _g.jk.math.Matrix44:forTranslate(-centerX, -centerY, -centerZ)
	local translatedRotated = _g.jk.math.Matrix44:multiplyMatrix(translate, rotate)
	do return _g.jk.math.Matrix44:multiplyMatrix(translatedRotated, translateBack) end
end

function jk.math.Matrix44:forYRotationWithCenter(angle, centerX, centerY, centerZ)
	local translate = _g.jk.math.Matrix44:forTranslate(centerX, centerY, centerZ)
	local rotate = _g.jk.math.Matrix44:forYRotation(angle)
	local translateBack = _g.jk.math.Matrix44:forTranslate(-centerX, -centerY, -centerZ)
	local translatedRotated = _g.jk.math.Matrix44:multiplyMatrix(translate, rotate)
	do return _g.jk.math.Matrix44:multiplyMatrix(translatedRotated, translateBack) end
end

function jk.math.Matrix44:forZRotationWithCenter(angle, centerX, centerY, centerZ)
	local translate = _g.jk.math.Matrix44:forTranslate(centerX, centerY, centerZ)
	local rotate = _g.jk.math.Matrix44:forZRotation(angle)
	local translateBack = _g.jk.math.Matrix44:forTranslate(-centerX, -centerY, -centerZ)
	local translatedRotated = _g.jk.math.Matrix44:multiplyMatrix(translate, rotate)
	do return _g.jk.math.Matrix44:multiplyMatrix(translatedRotated, translateBack) end
end

function jk.math.Matrix44:forScale(scaleX, scaleY, scaleZ)
	do return _g.jk.math.Matrix44:forValues({
		scaleX,
		0.0,
		0.0,
		0.0,
		0.0,
		scaleY,
		0.0,
		0.0,
		0.0,
		0.0,
		scaleZ,
		0.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix44:forFlipXY(flipXY)
	if flipXY then
		do return _g.jk.math.Matrix44:forValues({
			1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			-1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0
		}) end
	end
	do return _g.jk.math.Matrix44:forIdentity() end
end

function jk.math.Matrix44:forFlipXZ(flipXZ)
	if flipXZ then
		do return _g.jk.math.Matrix44:forValues({
			1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			-1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0
		}) end
	end
	do return _g.jk.math.Matrix44:forIdentity() end
end

function jk.math.Matrix44:forFlipYZ(flipYZ)
	if flipYZ then
		do return _g.jk.math.Matrix44:forValues({
			-1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0,
			0.0,
			0.0,
			0.0,
			0.0,
			1.0
		}) end
	end
	do return _g.jk.math.Matrix44:forIdentity() end
end

function jk.math.Matrix44:forValues(mv)
	local v = _g.jk.math.Matrix44._construct0(_g.jk.math.Matrix44._create())
	local i = 0
	do
		i = 0
		while i < 16 do
			if i >= #mv then
				v.v[i + 1] = 0.0
			else
				v.v[i + 1] = mv[i + 1]
			end
			do i = i + 1 end
		end
	end
	do return v end
end

function jk.math.Matrix44:multiplyScalar(v, mm)
	do return _g.jk.math.Matrix44:forValues({
		mm.v[0 + 1] * v,
		mm.v[1 + 1] * v,
		mm.v[2 + 1] * v,
		mm.v[3 + 1] * v,
		mm.v[4 + 1] * v,
		mm.v[5 + 1] * v,
		mm.v[6 + 1] * v,
		mm.v[7 + 1] * v,
		mm.v[8 + 1] * v,
		mm.v[9 + 1] * v,
		mm.v[10 + 1] * v,
		mm.v[11 + 1] * v,
		mm.v[12 + 1] * v,
		mm.v[3 + 1] * v,
		mm.v[14 + 1] * v,
		mm.v[15 + 1] * v
	}) end
end

function jk.math.Matrix44:multiplyMatrix(a, b)
	local matrix44 = _g.jk.math.Matrix44._construct0(_g.jk.math.Matrix44._create())
	matrix44.v[0 + 1] = a.v[0 + 1] * b.v[0 + 1] + a.v[1 + 1] * b.v[4 + 1] + a.v[2 + 1] * b.v[8 + 1] + a.v[3 + 1] * b.v[12 + 1]
	matrix44.v[1 + 1] = a.v[0 + 1] * b.v[1 + 1] + a.v[1 + 1] * b.v[5 + 1] + a.v[2 + 1] * b.v[9 + 1] + a.v[3 + 1] * b.v[13 + 1]
	matrix44.v[2 + 1] = a.v[0 + 1] * b.v[2 + 1] + a.v[1 + 1] * b.v[6 + 1] + a.v[2 + 1] * b.v[10 + 1] + a.v[3 + 1] * b.v[14 + 1]
	matrix44.v[3 + 1] = a.v[0 + 1] * b.v[3 + 1] + a.v[1 + 1] * b.v[7 + 1] + a.v[2 + 1] * b.v[11 + 1] + a.v[3 + 1] * b.v[15 + 1]
	matrix44.v[4 + 1] = a.v[4 + 1] * b.v[0 + 1] + a.v[5 + 1] * b.v[4 + 1] + a.v[6 + 1] * b.v[8 + 1] + a.v[7 + 1] * b.v[12 + 1]
	matrix44.v[5 + 1] = a.v[4 + 1] * b.v[1 + 1] + a.v[5 + 1] * b.v[5 + 1] + a.v[6 + 1] * b.v[9 + 1] + a.v[7 + 1] * b.v[13 + 1]
	matrix44.v[6 + 1] = a.v[4 + 1] * b.v[2 + 1] + a.v[5 + 1] * b.v[6 + 1] + a.v[6 + 1] * b.v[10 + 1] + a.v[7 + 1] * b.v[14 + 1]
	matrix44.v[7 + 1] = a.v[4 + 1] * b.v[3 + 1] + a.v[5 + 1] * b.v[7 + 1] + a.v[6 + 1] * b.v[11 + 1] + a.v[7 + 1] * b.v[15 + 1]
	matrix44.v[8 + 1] = a.v[8 + 1] * b.v[0 + 1] + a.v[9 + 1] * b.v[4 + 1] + a.v[10 + 1] * b.v[8 + 1] + a.v[11 + 1] * b.v[12 + 1]
	matrix44.v[9 + 1] = a.v[8 + 1] * b.v[1 + 1] + a.v[9 + 1] * b.v[5 + 1] + a.v[10 + 1] * b.v[9 + 1] + a.v[11 + 1] * b.v[13 + 1]
	matrix44.v[10 + 1] = a.v[8 + 1] * b.v[2 + 1] + a.v[9 + 1] * b.v[6 + 1] + a.v[10 + 1] * b.v[10 + 1] + a.v[11 + 1] * b.v[14 + 1]
	matrix44.v[11 + 1] = a.v[8 + 1] * b.v[3 + 1] + a.v[9 + 1] * b.v[7 + 1] + a.v[10 + 1] * b.v[11 + 1] + a.v[11 + 1] * b.v[15 + 1]
	matrix44.v[12 + 1] = a.v[12 + 1] * b.v[0 + 1] + a.v[13 + 1] * b.v[4 + 1] + a.v[14 + 1] * b.v[8 + 1] + a.v[15 + 1] * b.v[12 + 1]
	matrix44.v[13 + 1] = a.v[12 + 1] * b.v[1 + 1] + a.v[13 + 1] * b.v[5 + 1] + a.v[14 + 1] * b.v[9 + 1] + a.v[15 + 1] * b.v[13 + 1]
	matrix44.v[14 + 1] = a.v[12 + 1] * b.v[2 + 1] + a.v[13 + 1] * b.v[6 + 1] + a.v[14 + 1] * b.v[10 + 1] + a.v[15 + 1] * b.v[14 + 1]
	matrix44.v[15 + 1] = a.v[12 + 1] * b.v[3 + 1] + a.v[13 + 1] * b.v[7 + 1] + a.v[14 + 1] * b.v[11 + 1] + a.v[15 + 1] * b.v[15 + 1]
	do return matrix44 end
end

function jk.math.Matrix44:multiplyVector(a, b)
	local x = a.v[0 + 1] * b.x + a.v[1 + 1] * b.y + a.v[2 + 1] * b.z + a.v[3 + 1] * 1.0
	local y = a.v[4 + 1] * b.x + a.v[5 + 1] * b.y + a.v[6 + 1] * b.z + a.v[7 + 1] * 1.0
	local z = a.v[8 + 1] * b.x + a.v[9 + 1] * b.y + a.v[10 + 1] * b.z + a.v[11 + 1] * 1.0
	do return _g.jk.math.Vector3:create(x, y, z) end
end

jk.math.Matrix33 = {}
jk.math.Matrix33.__index = jk.math.Matrix33
_vm:set_metatable(jk.math.Matrix33, {})

function jk.math.Matrix33._create()
	local v = _vm:set_metatable({}, jk.math.Matrix33)
	return v
end

function jk.math.Matrix33:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.math.Matrix33'
	self['_isType.jk.math.Matrix33'] = true
	self.v = _vm:allocate_array(9)
end

function jk.math.Matrix33:_construct0()
	jk.math.Matrix33._init(self)
	return self
end

function jk.math.Matrix33:forZero()
	do return _g.jk.math.Matrix33:forValues({
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0
	}) end
end

function jk.math.Matrix33:forIdentity()
	do return _g.jk.math.Matrix33:forValues({
		1.0,
		0.0,
		0.0,
		0.0,
		1.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix33:invertMatrix(m)
	local d = m.v[0 + 1] * m.v[4 + 1] * m.v[8 + 1] + m.v[3 + 1] * m.v[7 + 1] * m.v[2 + 1] + m.v[6 + 1] * m.v[1 + 1] * m.v[5 + 1] - m.v[0 + 1] * m.v[7 + 1] * m.v[5 + 1] - m.v[3 + 1] * m.v[1 + 1] * m.v[8 + 1] - m.v[6 + 1] * m.v[4 + 1] * m.v[2 + 1]
	local v = _g.jk.math.Matrix33._construct0(_g.jk.math.Matrix33._create())
	v.v[0 + 1] = (m.v[4 + 1] * m.v[8 + 1] - m.v[7 + 1] * m.v[5 + 1]) / d
	v.v[3 + 1] = (m.v[6 + 1] * m.v[5 + 1] - m.v[3 + 1] * m.v[8 + 1]) / d
	v.v[6 + 1] = (m.v[3 + 1] * m.v[7 + 1] - m.v[6 + 1] * m.v[4 + 1]) / d
	v.v[1 + 1] = (m.v[7 + 1] * m.v[2 + 1] - m.v[1 + 1] * m.v[8 + 1]) / d
	v.v[4 + 1] = (m.v[0 + 1] * m.v[8 + 1] - m.v[6 + 1] * m.v[2 + 1]) / d
	v.v[7 + 1] = (m.v[6 + 1] * m.v[1 + 1] - m.v[0 + 1] * m.v[7 + 1]) / d
	v.v[2 + 1] = (m.v[1 + 1] * m.v[5 + 1] - m.v[4 + 1] * m.v[2 + 1]) / d
	v.v[5 + 1] = (m.v[3 + 1] * m.v[2 + 1] - m.v[0 + 1] * m.v[5 + 1]) / d
	v.v[8 + 1] = (m.v[0 + 1] * m.v[4 + 1] - m.v[3 + 1] * m.v[1 + 1]) / d
	do return v end
end

function jk.math.Matrix33:forTranslate(translateX, translateY)
	do return _g.jk.math.Matrix33:forValues({
		1.0,
		0.0,
		translateX,
		0.0,
		1.0,
		translateY,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix33:forRotation(angle)
	local c = _g.jk.math.Math:cos(angle)
	local s = _g.jk.math.Math:sin(angle)
	do return _g.jk.math.Matrix33:forValues({
		c,
		s,
		0.0,
		-s,
		c,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix33:forRotationWithCenter(angle, centerX, centerY)
	local translate = _g.jk.math.Matrix33:forTranslate(centerX, centerY)
	local rotate = _g.jk.math.Matrix33:forRotation(angle)
	local translateBack = _g.jk.math.Matrix33:forTranslate(-centerX, -centerY)
	local translatedRotated = _g.jk.math.Matrix33:multiplyMatrix(translate, rotate)
	do return _g.jk.math.Matrix33:multiplyMatrix(translatedRotated, translateBack) end
end

function jk.math.Matrix33:forSkew(skewX, skewY)
	do return _g.jk.math.Matrix33:forValues({
		1.0,
		skewX,
		0.0,
		skewY,
		1.0,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix33:forScale(scaleX, scaleY)
	do return _g.jk.math.Matrix33:forValues({
		scaleX,
		0.0,
		0.0,
		0.0,
		scaleY,
		0.0,
		0.0,
		0.0,
		1.0
	}) end
end

function jk.math.Matrix33:forFlip(flipX, flipY)
	local xmat33 = _g.jk.math.Matrix33:forValues({
		1.0,
		0.0,
		0.0,
		0.0,
		-1.0,
		0.0,
		0.0,
		0.0,
		1.0
	})
	local ymat33 = _g.jk.math.Matrix33:forValues({
		-1.0,
		0.0,
		0.0,
		0.0,
		1.0,
		0.0,
		0.0,
		0.0,
		1.0
	})
	if flipX and flipY then
		do return _g.jk.math.Matrix33:multiplyMatrix(xmat33, ymat33) end
	elseif flipX then
		do return xmat33 end
	elseif flipY then
		do return ymat33 end
	end
	do return _g.jk.math.Matrix33:forIdentity() end
end

function jk.math.Matrix33:forValues(mv)
	local v = _g.jk.math.Matrix33._construct0(_g.jk.math.Matrix33._create())
	local i = 0
	do
		i = 0
		while i < 9 do
			if i >= #mv then
				v.v[i + 1] = 0.0
			else
				v.v[i + 1] = mv[i + 1]
			end
			do i = i + 1 end
		end
	end
	do return v end
end

function jk.math.Matrix33:multiplyScalar(v, mm)
	local mat33 = _g.jk.math.Matrix33:forZero()
	mat33.v[0 + 1] = mm.v[0 + 1] * v
	mat33.v[1 + 1] = mm.v[1 + 1] * v
	mat33.v[2 + 1] = mm.v[2 + 1] * v
	mat33.v[3 + 1] = mm.v[3 + 1] * v
	mat33.v[4 + 1] = mm.v[4 + 1] * v
	mat33.v[5 + 1] = mm.v[5 + 1] * v
	mat33.v[6 + 1] = mm.v[6 + 1] * v
	mat33.v[7 + 1] = mm.v[7 + 1] * v
	mat33.v[8 + 1] = mm.v[8 + 1] * v
	do return mat33 end
end

function jk.math.Matrix33:multiplyMatrix(a, b)
	local matrix33 = _g.jk.math.Matrix33._construct0(_g.jk.math.Matrix33._create())
	matrix33.v[0 + 1] = a.v[0 + 1] * b.v[0 + 1] + a.v[1 + 1] * b.v[3 + 1] + a.v[2 + 1] * b.v[6 + 1]
	matrix33.v[1 + 1] = a.v[0 + 1] * b.v[1 + 1] + a.v[1 + 1] * b.v[4 + 1] + a.v[2 + 1] * b.v[7 + 1]
	matrix33.v[2 + 1] = a.v[0 + 1] * b.v[2 + 1] + a.v[1 + 1] * b.v[5 + 1] + a.v[2 + 1] * b.v[8 + 1]
	matrix33.v[3 + 1] = a.v[3 + 1] * b.v[0 + 1] + a.v[4 + 1] * b.v[3 + 1] + a.v[5 + 1] * b.v[6 + 1]
	matrix33.v[4 + 1] = a.v[3 + 1] * b.v[1 + 1] + a.v[4 + 1] * b.v[4 + 1] + a.v[5 + 1] * b.v[7 + 1]
	matrix33.v[5 + 1] = a.v[3 + 1] * b.v[2 + 1] + a.v[4 + 1] * b.v[5 + 1] + a.v[5 + 1] * b.v[8 + 1]
	matrix33.v[6 + 1] = a.v[6 + 1] * b.v[0 + 1] + a.v[7 + 1] * b.v[3 + 1] + a.v[8 + 1] * b.v[6 + 1]
	matrix33.v[7 + 1] = a.v[6 + 1] * b.v[1 + 1] + a.v[7 + 1] * b.v[4 + 1] + a.v[8 + 1] * b.v[7 + 1]
	matrix33.v[8 + 1] = a.v[6 + 1] * b.v[2 + 1] + a.v[7 + 1] * b.v[5 + 1] + a.v[8 + 1] * b.v[8 + 1]
	do return matrix33 end
end

function jk.math.Matrix33:multiplyVector(a, b)
	local x = a.v[0 + 1] * b.x + a.v[1 + 1] * b.y + a.v[2 + 1] * 1.0
	local y = a.v[3 + 1] * b.x + a.v[4 + 1] * b.y + a.v[5 + 1] * 1.0
	do return _g.jk.math.Vector2:create(x, y) end
end

jk.math.Math = {}
jk.math.Math.__index = jk.math.Math
_vm:set_metatable(jk.math.Math, {})

jk.math.Math.M_PI = 3.14159265358979
jk.math.Math.M_PI_2 = 1.5707963267949
jk.math.Math.M_PI_4 = 0.78539816339745
jk.math.Math.M_1_PI = 0.31830988618379
jk.math.Math.M_2_PI = 0.63661977236758
jk.math.Math.M_2_SQRTPI = 1.12837916709551
jk.math.Math.M_SQRT2 = 1.4142135623731
jk.math.Math.M_SQRT1_2 = 0.70710678118655
jk.math.Math.HALF_AWAY_FROM_ZERO = 0
jk.math.Math.HALF_TOWARD_ZERO = 1
jk.math.Math.HALF_NEAREST_EVEN = 2
jk.math.Math.HALF_POSITIVE = 3
jk.math.Math.HALF_NEGATIVE = 4

function jk.math.Math._create()
	local v = _vm:set_metatable({}, jk.math.Math)
	return v
end

function jk.math.Math:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.math.Math'
	self['_isType.jk.math.Math'] = true
end

function jk.math.Math:_construct0()
	jk.math.Math._init(self)
	return self
end

function jk.math.Math:toRadians(d)
	do return _g.jk.math.Math.M_PI / 180 * d end
end

function jk.math.Math:toDegrees(r)
	do return _g.jk.math.Math.M_PI * r / 180 end
end

function jk.math.Math:abs(d)
	_io:write_to_stdout("[jk.math.Math.abs] (Math.sling:154:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:absFloat(f)
	_io:write_to_stdout("[jk.math.Math.absFloat] (Math.sling:184:3): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.math.Math:absInt32(i)
	_io:write_to_stdout("[jk.math.Math.absInt32] (Math.sling:214:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:absInt64(l)
	_io:write_to_stdout("[jk.math.Math.absInt64] (Math.sling:244:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:acos(d)
	_io:write_to_stdout("[jk.math.Math.acos] (Math.sling:274:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:asin(d)
	_io:write_to_stdout("[jk.math.Math.asin] (Math.sling:304:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:atan(d)
	_io:write_to_stdout("[jk.math.Math.atan] (Math.sling:334:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:atan2(y, x)
	_io:write_to_stdout("[jk.math.Math.atan2] (Math.sling:364:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:ceil(d)
	_io:write_to_stdout("[jk.math.Math.ceil] (Math.sling:394:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:cos(d)
	_io:write_to_stdout("[jk.math.Math.cos] (Math.sling:424:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:cosh(d)
	_io:write_to_stdout("[jk.math.Math.cosh] (Math.sling:454:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:exp(d)
	_io:write_to_stdout("[jk.math.Math.exp] (Math.sling:484:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:floor(d)
	_io:write_to_stdout("[jk.math.Math.floor] (Math.sling:514:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:remainder(x, y)
	_io:write_to_stdout("[jk.math.Math.remainder] (Math.sling:543:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:log(d)
	_io:write_to_stdout("[jk.math.Math.log] (Math.sling:573:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:log10(d)
	_io:write_to_stdout("[jk.math.Math.log10] (Math.sling:603:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:max(d1, d2)
	_io:write_to_stdout("[jk.math.Math.max] (Math.sling:639:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:maxFloat(f1, f2)
	_io:write_to_stdout("[jk.math.Math.maxFloat] (Math.sling:675:3): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.math.Math:maxInt32(i1, i2)
	_io:write_to_stdout("[jk.math.Math.maxInt32] (Math.sling:711:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:maxInt64(l1, l2)
	_io:write_to_stdout("[jk.math.Math.maxInt64] (Math.sling:747:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:min(d1, d2)
	_io:write_to_stdout("[jk.math.Math.min] (Math.sling:783:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:minFloat(f1, f2)
	_io:write_to_stdout("[jk.math.Math.minFloat] (Math.sling:819:3): Not implemented" .. "\n")
	do return 0.0 end
end

function jk.math.Math:minInt32(i1, i2)
	_io:write_to_stdout("[jk.math.Math.minInt32] (Math.sling:855:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:minInt64(l1, l2)
	_io:write_to_stdout("[jk.math.Math.minInt64] (Math.sling:891:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:pow(x, y)
	_io:write_to_stdout("[jk.math.Math.pow] (Math.sling:921:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:round(n)
	_io:write_to_stdout("[jk.math.Math.round] (Math.sling:956:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:roundWithMode(d, mode)
	local fd = _g.jk.math.Math:floor(d)
	local dp = d - fd
	if dp < 0.5 then
		do return fd end
	end
	if dp > 0.5 then
		do return _g.jk.math.Math:ceil(d) end
	end
	if mode == _g.jk.math.Math.HALF_AWAY_FROM_ZERO then
		if d < 0 then
			do return fd end
		end
		do return _g.jk.math.Math:ceil(d) end
	end
	if mode == _g.jk.math.Math.HALF_TOWARD_ZERO then
		if d < 0 then
			do return _g.jk.math.Math:ceil(d) end
		end
		do return fd end
	end
	if mode == _g.jk.math.Math.HALF_NEAREST_EVEN then
		if _util:convert_to_integer(_util:convert_to_integer(fd) % 2) == 0 then
			do return fd end
		end
		do return _g.jk.math.Math:ceil(d) end
	end
	if mode == _g.jk.math.Math.HALF_POSITIVE then
		do return _g.jk.math.Math:ceil(d) end
	end
	if mode == _g.jk.math.Math.HALF_NEGATIVE then
		do return fd end
	end
	do return d end
end

function jk.math.Math:sin(d)
	_io:write_to_stdout("[jk.math.Math.sin] (Math.sling:1056:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:sinh(d)
	_io:write_to_stdout("[jk.math.Math.sinh] (Math.sling:1086:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:sqrt(d)
	_io:write_to_stdout("[jk.math.Math.sqrt] (Math.sling:1116:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:tan(d)
	_io:write_to_stdout("[jk.math.Math.tan] (Math.sling:1146:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:tanh(d)
	_io:write_to_stdout("[jk.math.Math.tanh] (Math.sling:1176:3): Not implemented" .. "\n")
	do return 0 end
end

function jk.math.Math:computeQuinticInEasing(t, b, c, d)
	local x = t / d
	do return c * x * x * x * x * x + b end
end

function jk.math.Math:computeQuinticOutEasing(t, b, c, d)
	local x = t / d - 1
	do return c * (x * x * x * x * x + 1) + b end
end

function jk.math.Math:computeQuinticInOutEasing(t, b, c, d)
	local x = t / d / 2
	if x < 1.0 then
		do return c / 2 * x * x * x * x * x + b end
	end
	x = x - 2
	do return c / 2 * (x * x * x * x * x + 2) + b end
end
jk = jk or {}

jk.text = jk.text or {}

jk.text.StringUtil = {}
jk.text.StringUtil.__index = jk.text.StringUtil
_vm:set_metatable(jk.text.StringUtil, {})

function jk.text.StringUtil._create()
	local v = _vm:set_metatable({}, jk.text.StringUtil)
	return v
end

function jk.text.StringUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.text.StringUtil'
	self['_isType.jk.text.StringUtil'] = true
end

function jk.text.StringUtil:_construct0()
	jk.text.StringUtil._init(self)
	return self
end

function jk.text.StringUtil:padToLength(string, length, align, paddingCharacter)
	local ll = 0
	if string == nil then
		ll = 0
	else
		ll = _g.jk.lang.String:getLength(string)
	end
	if ll >= length then
		do return string end
	end
	do
		local add = length - ll
		local n = 0
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if align < 0 then
			do sb:appendString(string) end
			do
				n = 0
				while n < add do
					do sb:appendCharacter(paddingCharacter) end
					do n = n + 1 end
				end
			end
		elseif align == 0 then
			local ff = _util:convert_to_integer(add / 2)
			local ss = add - ff
			do
				n = 0
				while n < ff do
					do sb:appendCharacter(paddingCharacter) end
					do n = n + 1 end
				end
			end
			do sb:appendString(string) end
			do
				n = 0
				while n < ss do
					do sb:appendCharacter(paddingCharacter) end
					do n = n + 1 end
				end
			end
		else
			do
				n = 0
				while n < add do
					do sb:appendCharacter(paddingCharacter) end
					do n = n + 1 end
				end
			end
			do sb:appendString(string) end
		end
		do return sb:toString() end
	end
end

function jk.text.StringUtil:quotedStringToVector(str, delim, ignoreRepeatedDelimiters, escapeCharacter)
	local v = {}
	if str == nil then
		do return v end
	end
	do
		local dquote = false
		local quote = false
		local sb = nil
		local it = _g.jk.lang.String:iterate(str)
		while true do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if c == 34 and quote == false then
				dquote = not dquote
			elseif c == 39 and dquote == false then
				quote = not quote
			elseif quote == false and dquote == false and c == delim then
				if sb ~= nil then
					local r = sb:toString()
					if r == nil then
						r = ""
					end
					do _g.jk.lang.Vector:append(v, r) end
				elseif ignoreRepeatedDelimiters == false then
					do _g.jk.lang.Vector:append(v, "") end
				end
				sb = nil
			else
				if escapeCharacter > 0 and c == escapeCharacter then
					c = it:getNextChar()
					if _g.jk.lang.Character:isEOF(c) then
						do break end
					end
				end
				if sb == nil then
					sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				end
				do sb:appendCharacter(c) end
			end
			if quote == true or dquote == true and sb == nil then
				sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			end
		end
		if sb ~= nil then
			local r = sb:toString()
			if r == nil then
				r = ""
			end
			do _g.jk.lang.Vector:append(v, r) end
		end
		do return v end
	end
end

function jk.text.StringUtil:quotedStringToMap(str, delim)
	local v = {}
	local vector = _g.jk.text.StringUtil:quotedStringToVector(str, delim, true, 92)
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local c = vector[n + 1]
				if c ~= nil then
					local sp = _g.jk.lang.String:split(c, 61, 2)
					local key = sp[0 + 1]
					local val = sp[1 + 1]
					if _g.jk.lang.String:isEmpty(key) == false then
						v[key] = val
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.text.StringUtil:combine(strings, delim, unique, index)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local flags = nil
	if unique then
		flags = {}
	end
	do
		local i = index
		while i < _g.jk.lang.Vector:getSize(strings) do
			local o = strings[i + 1]
			do i = i + 1 end
			if o == nil then
				goto _continue1
			end
			if flags ~= nil then
				if _g.jk.lang.Map:get(flags, o) ~= nil then
					goto _continue1
				end
				do _g.jk.lang.Map:set(flags, o, "true") end
			end
			if delim > 0 and sb:count() > 0 then
				do sb:appendCharacter(delim) end
			end
			do sb:appendString(o) end
			::_continue1::
		end
		do return sb:toString() end
	end
end

function jk.text.StringUtil:validateCharacters(str, validator)
	if not (str ~= nil) then
		do return false end
	end
	do
		local it = _g.jk.lang.String:iterate(str)
		if not (it ~= nil) then
			do return false end
		end
		while true do
			local c = it:getNextChar()
			if c < 1 then
				do break end
			end
			if validator(c) == false then
				do return false end
			end
		end
		do return true end
	end
end

function jk.text.StringUtil:toStringVector(vector, allowConversion)
	local v = {}
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local o = vector[n + 1]
				if o ~= nil then
					if allowConversion then
						local s = _g.jk.lang.String:asString(o)
						if s ~= nil then
							do _g.jk.lang.Vector:append(v, s) end
						end
					elseif (_vm:get_variable_type(o) == 'string') then
						do _g.jk.lang.Vector:append(v, o) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.text.StringUtil:toObjectVector(vector)
	do return vector end
end

function jk.text.StringUtil:wrapToLines(text, charactersPerLine)
	if not (text ~= nil) then
		do return nil end
	end
	do
		local v = {}
		local it = _g.jk.lang.String:iterate(text)
		local lineBuilder = nil
		local wordBuilder = nil
		while it ~= nil do
			local c = it:getNextChar()
			if c == 32 or c == 9 or c == 10 or c < 1 then
				if wordBuilder ~= nil then
					local word = wordBuilder:toString()
					wordBuilder = nil
					if lineBuilder == nil then
						lineBuilder = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					end
					do
						local cc = lineBuilder:count()
						if cc > 0 then
							do cc = cc + 1 end
						end
						cc = cc + _g.jk.lang.String:getLength(word)
						if cc > charactersPerLine then
							do _g.jk.lang.Vector:append(v, lineBuilder:toString()) end
							lineBuilder = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						end
						if lineBuilder:count() > 0 then
							do lineBuilder:appendCharacter(32) end
						end
						do lineBuilder:appendString(word) end
					end
				end
				if c < 1 then
					do break end
				end
				goto _continue2
			end
			if wordBuilder == nil then
				wordBuilder = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			end
			do wordBuilder:appendCharacter(c) end
			::_continue2::
		end
		if lineBuilder ~= nil then
			do _g.jk.lang.Vector:append(v, lineBuilder:toString()) end
		end
		do return v end
	end
end

function jk.text.StringUtil:stripLeadingZeros(str)
	if _g.jk.lang.String:getChar(str, 0) == 48 then
		local iter = _g.jk.lang.String:iterate(str)
		if not (iter ~= nil) then
			do return nil end
		end
		do
			local i = 0
			while true do
				local c = iter:getNextChar()
				if _g.jk.lang.Character:isEOF(c) then
					do break end
				end
				if c ~= 48 then
					do return _g.jk.lang.String:getEndOfString(str, i) end
				end
				do i = i + 1 end
			end
			do return "" end
		end
	end
	do return str end
end

function jk.text.StringUtil:formatNumberString(vv, delimiter)
	if not (vv ~= nil) then
		do return nil end
	end
	do
		local it = _g.jk.lang.String:iterate(vv)
		if not (it ~= nil) then
			do return nil end
		end
		do
			local rr = _g.jk.lang.String:getLength(vv)
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			while true do
				local c = it:getNextChar()
				if c < 1 then
					do break end
				end
				do sb:appendCharacter(c) end
				do rr = rr - 1 end
				if rr < 1 then
					do break end
				end
				if _util:convert_to_integer(rr % 3) == 0 then
					do sb:appendCharacter(delimiter) end
				end
			end
			do return sb:toString() end
		end
	end
end

function jk.text.StringUtil:formatInteger(vv, delimiter)
	do return _g.jk.text.StringUtil:formatNumberString(_g.jk.lang.String:forInteger(vv), delimiter) end
end

function jk.text.StringUtil:formatLongInteger(vv, delimiter)
	do return _g.jk.text.StringUtil:formatNumberString(_g.jk.lang.String:forLongInteger(vv), delimiter) end
end
jk = jk or {}

jk.random = jk.random or {}

jk.random.Random = {}
jk.random.Random.__index = jk.random.Random
_vm:set_metatable(jk.random.Random, {})

jk.random.Random.instance = nil

function jk.random.Random._create()
	local v = _vm:set_metatable({}, jk.random.Random)
	return v
end

function jk.random.Random:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.random.Random'
	self['_isType.jk.random.Random'] = true
	self.random = nil
end

function jk.random.Random:getSushiRandom()
	if not (self.random ~= nil) then
		do self:setSeed(_g.jk.time.SystemClock:asUTCSeconds()) end
	end
	do return self.random end
end

function jk.random.Random:getSharedInstance()
	if not (_g.jk.random.Random.instance ~= nil) then
		_g.jk.random.Random.instance = _g.jk.random.Random._construct0(_g.jk.random.Random._create())
	end
	do return _g.jk.random.Random.instance end
end

function jk.random.Random:_construct0()
	jk.random.Random._init(self)
	return self
end

function jk.random.Random:_construct1(seed)
	jk.random.Random._init(self)
	do self:setSeed(seed) end
	return self
end

function jk.random.Random:setSeed(seed)
	self.random = _util:create_random_number_generator(seed)
end

function jk.random.Random:nextBoolean()
	if _util:convert_to_integer(self:nextInt1() % 2) == 0 then
		do return false end
	end
	do return true end
end

function jk.random.Random:nextInt1()
	local random = self:getSushiRandom()
	do return _util:create_random_number(random) end
end

function jk.random.Random:nextInt2(n)
	do return _util:convert_to_integer(self:nextInt1() % n) end
end

function jk.random.Random:nextInt3(s, e)
	do return s + _util:convert_to_integer(self:nextInt1() % (e - s)) end
end

function jk.random.Random:nextBytes(buf)
	local sz = #buf
	do
		local n = 0
		while n < sz do
			buf[n + 1] = self:nextInt3(-127, 128)
			do n = n + 1 end
		end
	end
end

function jk.random.Random:nextDouble()
	local n = self:nextInt2(2147483647)
	do return n / 2147483647.0 end
end

function jk.random.Random:nextFloat()
	local n = self:nextInt2(2147483647)
	do return n / 2147483647 end
end
jk = jk or {}

jk.env = jk.env or {}

jk.env.TemporaryDirectory = {}
jk.env.TemporaryDirectory.__index = jk.env.TemporaryDirectory
_vm:set_metatable(jk.env.TemporaryDirectory, {})

function jk.env.TemporaryDirectory._create()
	local v = _vm:set_metatable({}, jk.env.TemporaryDirectory)
	return v
end

function jk.env.TemporaryDirectory:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.env.TemporaryDirectory'
	self['_isType.jk.env.TemporaryDirectory'] = true
end

function jk.env.TemporaryDirectory:_construct0()
	jk.env.TemporaryDirectory._init(self)
	return self
end

function jk.env.TemporaryDirectory:create()
	do return _g.jk.env.TemporaryDirectory:forDirectory(nil) end
end

function jk.env.TemporaryDirectory:forDirectory(dir)
	local ff = _g.jk.env.TemporaryFile:forDirectory(dir, nil)
	if not (ff ~= nil) then
		do return nil end
	end
	do ff:remove() end
	do ff:createDirectoryRecursive() end
	if not ff:isDirectory() then
		do return nil end
	end
	do return ff end
end

jk.env.ExternalCommand = {}
jk.env.ExternalCommand.__index = jk.env.ExternalCommand
_vm:set_metatable(jk.env.ExternalCommand, {})

function jk.env.ExternalCommand._create()
	local v = _vm:set_metatable({}, jk.env.ExternalCommand)
	return v
end

function jk.env.ExternalCommand:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.env.ExternalCommand'
	self['_isType.jk.env.ExternalCommand'] = true
end

function jk.env.ExternalCommand:_construct0()
	jk.env.ExternalCommand._init(self)
	return self
end

function jk.env.ExternalCommand:findInPath(command)
	if not (command ~= nil) then
		do return nil end
	end
	do
		local path = _g.jk.env.EnvironmentVariable:get("PATH")
		if not _g.jk.lang.String:isNotEmpty(path) then
			do return nil end
		end
		do
			local separator = 58
			if _g.jk.os.OS:isWindows() then
				separator = 59
			end
			do
				local array = _g.jk.lang.String:split(path, separator, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local dir = array[n + 1]
							if dir ~= nil then
								local pp = _g.jk.fs.File:forPath(dir):rawEntry(command):asExecutable()
								if pp:isFile() then
									do return pp end
								end
							end
							do n = n + 1 end
						end
					end
				end
				do return nil end
			end
		end
	end
end

jk.env.CommonPath = {}
jk.env.CommonPath.__index = jk.env.CommonPath
_vm:set_metatable(jk.env.CommonPath, {})

function jk.env.CommonPath._create()
	local v = _vm:set_metatable({}, jk.env.CommonPath)
	return v
end

function jk.env.CommonPath:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.env.CommonPath'
	self['_isType.jk.env.CommonPath'] = true
end

function jk.env.CommonPath:_construct0()
	jk.env.CommonPath._init(self)
	return self
end

function jk.env.CommonPath:getTemporaryDirectory()
	if _g.jk.os.OS:isLinux() or _g.jk.os.OS:isMacOS() then
		do return _g.jk.fs.File:forPath("/tmp") end
	end
	_io:write_to_stdout("[jk.env.CommonPath.getTemporaryDirectory] (CommonPath.sling:45:3): Not implemented" .. "\n")
	do return _g.jk.fs.FileInvalid._construct0(_g.jk.fs.FileInvalid._create()) end
end

function jk.env.CommonPath:getHomeDirectory()
	local dirname = _g.jk.env.EnvironmentVariable:get("HOME")
	if _g.jk.lang.String:isNotEmpty(dirname) then
		do return _g.jk.fs.File:forPath(dirname) end
	end
	do return nil end
end

function jk.env.CommonPath:getAppDirectory()
	local program = _vm:get_program_path()
	if not _g.jk.lang.String:isNotEmpty(program) then
		do return nil end
	end
	do
		local pf = _g.jk.fs.File:forPath(program)
		if not (pf ~= nil) then
			do return nil end
		end
		do return pf:getParent() end
	end
end

function jk.env.CommonPath:getCodeFileForObject(oo)
	if not (oo ~= nil) then
		do return nil end
	end
	do return nil end
end

function jk.env.CommonPath:getProgramFilesDirectory()
	do return nil end
end

function jk.env.CommonPath:getProgramFilesX86Directory()
	do return nil end
end

function jk.env.CommonPath:getApplicationsDirectory()
	if _g.jk.os.OS:isMacOS() then
		local v = _g.jk.fs.File:forPath("/Applications")
		if v:isDirectory() == false then
			v = nil
		end
		do return v end
	end
	do return nil end
end

jk.env.EnvironmentVariable = {}
jk.env.EnvironmentVariable.__index = jk.env.EnvironmentVariable
_vm:set_metatable(jk.env.EnvironmentVariable, {})

function jk.env.EnvironmentVariable._create()
	local v = _vm:set_metatable({}, jk.env.EnvironmentVariable)
	return v
end

function jk.env.EnvironmentVariable:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.env.EnvironmentVariable'
	self['_isType.jk.env.EnvironmentVariable'] = true
end

function jk.env.EnvironmentVariable:_construct0()
	jk.env.EnvironmentVariable._init(self)
	return self
end

function jk.env.EnvironmentVariable:getAll()
	local v = {}
	local envs = _os:get_all_environment_variables()
	if envs ~= nil then
		if envs ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(envs)
			do
				n = 0
				while n < m do
					local env = envs[n + 1]
					if env ~= nil then
						local comps = _g.jk.lang.String:split(env, 61, 2)
						local key = _g.jk.lang.Vector:get(comps, 0)
						local val = _g.jk.lang.Vector:get(comps, 1)
						if not (key ~= nil) then
							goto _continue1
						end
						if not (val ~= nil) then
							val = ""
						end
						do _g.jk.lang.Map:set(v, key, val) end
					end
					::_continue1::
					do n = n + 1 end
				end
			end
		end
	end
	do return v end
end

function jk.env.EnvironmentVariable:get(key)
	if not (key ~= nil) then
		do return nil end
	end
	do
		local v = nil
		do v = _os:get_environment_variable(key) end
		do return v end
	end
end

function jk.env.EnvironmentVariable:set(key, val)
	if not (key ~= nil) then
		do return end
	end
	do _os:set_environment_variable(key, val) end
end

function jk.env.EnvironmentVariable:unset(key)
	_io:write_to_stdout("[jk.env.EnvironmentVariable.unset] (EnvironmentVariable.sling:146:2): Not implemented" .. "\n")
end

jk.env.TemporaryFile = {}
jk.env.TemporaryFile.__index = jk.env.TemporaryFile
_vm:set_metatable(jk.env.TemporaryFile, {})

function jk.env.TemporaryFile._create()
	local v = _vm:set_metatable({}, jk.env.TemporaryFile)
	return v
end

function jk.env.TemporaryFile:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.env.TemporaryFile'
	self['_isType.jk.env.TemporaryFile'] = true
end

function jk.env.TemporaryFile:_construct0()
	jk.env.TemporaryFile._init(self)
	return self
end

function jk.env.TemporaryFile:create(extension)
	do return _g.jk.env.TemporaryFile:forDirectory(nil, extension) end
end

function jk.env.TemporaryFile:forDirectory(dir, extension)
	local tmpdir = dir
	if tmpdir == nil then
		tmpdir = _g.jk.env.CommonPath:getTemporaryDirectory()
	end
	if tmpdir == nil then
		do return nil end
	end
	do tmpdir:createDirectoryRecursive() end
	if tmpdir:isDirectory() == false then
		do return nil end
	end
	do
		local v = nil
		local n = 0
		local rnd = _g.jk.random.Random._construct0(_g.jk.random.Random._create())
		while n < 100 do
			local id = "_tmp_" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(_g.jk.time.SystemClock:asSeconds())) .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(_util:convert_to_integer(rnd:nextInt1() % 1000000)))
			if extension == nil or _g.jk.lang.String:getLength(extension) < 1 then
				id = _g.jk.lang.String:safeString(id) .. _g.jk.lang.String:safeString(extension)
			end
			v = tmpdir:entry(id)
			if v:exists() == false then
				do v:touch() end
				do break end
			end
			do n = n + 1 end
		end
		if v ~= nil and v:isFile() == false then
			v = nil
		end
		do return v end
	end
end

function jk.env.TemporaryFile:forString(data)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local v = _g.jk.env.TemporaryFile:create(nil)
		if not (v ~= nil) then
			do return nil end
		end
		if not v:setContentsUTF8(data) then
			do v:remove() end
			do return nil end
		end
		do return v end
	end
end

function jk.env.TemporaryFile:forBuffer(data)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local v = _g.jk.env.TemporaryFile:create(nil)
		if not (v ~= nil) then
			do return nil end
		end
		if not v:setContentsBuffer(data) then
			do v:remove() end
			do return nil end
		end
		do return v end
	end
end
jk = jk or {}

jk.process = jk.process or {}

jk.process.ProcessKit = {}
jk.process.ProcessKit.__index = jk.process.ProcessKit
_vm:set_metatable(jk.process.ProcessKit, {})

function jk.process.ProcessKit._create()
	local v = _vm:set_metatable({}, jk.process.ProcessKit)
	return v
end

function jk.process.ProcessKit:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessKit'
	self['_isType.jk.process.ProcessKit'] = true
	self.ctx = nil
end

function jk.process.ProcessKit:_construct0()
	jk.process.ProcessKit._init(self)
	return self
end

function jk.process.ProcessKit:_construct1(ctx)
	jk.process.ProcessKit._init(self)
	self.ctx = ctx
	return self
end

function jk.process.ProcessKit:execute(command)
	local pl = _g.jk.process.ProcessLauncher:asProcessLauncher(command)
	if not (pl ~= nil) then
		do _g.jk.lang.Error:throw("invalidParameter", _g.jk.lang.String:asString(command)) end
	end
	do
		local cmd = pl:toString()
		do _g.jk.log.Log:debug(self.ctx, "Executing command: `" .. _g.jk.lang.String:safeString(cmd) .. "'") end
		do
			local r = pl:execute()
			if r ~= 0 then
				do _g.jk.lang.Error:throw("errorStatus", _g.jk.lang.String:forInteger(r)) end
			end
		end
	end
end

jk.process.Process = {}

jk.process.ProcessWithIO = {}

jk.process.ProcessLauncher = {}
jk.process.ProcessLauncher.__index = jk.process.ProcessLauncher
_vm:set_metatable(jk.process.ProcessLauncher, {})

function jk.process.ProcessLauncher._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncher)
	return v
end

function jk.process.ProcessLauncher:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncher'
	self['_isType.jk.process.ProcessLauncher'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.file = nil
	self.params = nil
	self.env = nil
	self.cwd = nil
	self.uid = -1
	self.gid = -1
	self.trapSigint = true
	self.replaceSelf = false
	self.pipePty = false
	self.startGroup = false
	self.noCmdWindow = false
	self.errorBuffer = nil
	self.detachFromTerminal = false
end

jk.process.ProcessLauncher.MyStringPipeHandler = {}
jk.process.ProcessLauncher.MyStringPipeHandler.__index = jk.process.ProcessLauncher.MyStringPipeHandler
_vm:set_metatable(jk.process.ProcessLauncher.MyStringPipeHandler, {})

function jk.process.ProcessLauncher.MyStringPipeHandler._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncher.MyStringPipeHandler)
	return v
end

function jk.process.ProcessLauncher.MyStringPipeHandler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncher.MyStringPipeHandler'
	self['_isType.jk.process.ProcessLauncher.MyStringPipeHandler'] = true
	self['_isType.jk.lang.BufferDataReceiver'] = true
	self.builder = nil
	self.encoding = nil
end

function jk.process.ProcessLauncher.MyStringPipeHandler:_construct0()
	jk.process.ProcessLauncher.MyStringPipeHandler._init(self)
	self.encoding = "UTF-8"
	return self
end

function jk.process.ProcessLauncher.MyStringPipeHandler:onBufferData(data, size)
	if self.builder == nil or data == nil or size < 1 then
		do return false end
	end
	do
		local str = _g.jk.lang.String:forBuffer(_g.jk.lang.Buffer:getSubBuffer(data, 0, size, false), self.encoding)
		if not (str ~= nil) then
			do return false end
		end
		do self.builder:appendString(str) end
		do return true end
	end
end

function jk.process.ProcessLauncher.MyStringPipeHandler:getBuilder()
	do return self.builder end
end

function jk.process.ProcessLauncher.MyStringPipeHandler:setBuilder(v)
	self.builder = v
	do return self end
end

function jk.process.ProcessLauncher.MyStringPipeHandler:getEncoding()
	do return self.encoding end
end

function jk.process.ProcessLauncher.MyStringPipeHandler:setEncoding(v)
	self.encoding = v
	do return self end
end

jk.process.ProcessLauncher.MyBufferPipeHandler = {}
jk.process.ProcessLauncher.MyBufferPipeHandler.__index = jk.process.ProcessLauncher.MyBufferPipeHandler
_vm:set_metatable(jk.process.ProcessLauncher.MyBufferPipeHandler, {})

function jk.process.ProcessLauncher.MyBufferPipeHandler._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncher.MyBufferPipeHandler)
	return v
end

function jk.process.ProcessLauncher.MyBufferPipeHandler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncher.MyBufferPipeHandler'
	self['_isType.jk.process.ProcessLauncher.MyBufferPipeHandler'] = true
	self['_isType.jk.lang.BufferDataReceiver'] = true
	self.data = nil
end

function jk.process.ProcessLauncher.MyBufferPipeHandler:_construct0()
	jk.process.ProcessLauncher.MyBufferPipeHandler._init(self)
	return self
end

function jk.process.ProcessLauncher.MyBufferPipeHandler:onBufferData(newData, size)
	self.data = _g.jk.lang.Buffer:append(self.data, newData, size)
	do return true end
end

function jk.process.ProcessLauncher.MyBufferPipeHandler:getData()
	do return self.data end
end

function jk.process.ProcessLauncher.MyBufferPipeHandler:setData(v)
	self.data = v
	do return self end
end

jk.process.ProcessLauncher.QuietPipeHandler = {}
jk.process.ProcessLauncher.QuietPipeHandler.__index = jk.process.ProcessLauncher.QuietPipeHandler
_vm:set_metatable(jk.process.ProcessLauncher.QuietPipeHandler, {})

function jk.process.ProcessLauncher.QuietPipeHandler._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncher.QuietPipeHandler)
	return v
end

function jk.process.ProcessLauncher.QuietPipeHandler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncher.QuietPipeHandler'
	self['_isType.jk.process.ProcessLauncher.QuietPipeHandler'] = true
	self['_isType.jk.lang.BufferDataReceiver'] = true
end

function jk.process.ProcessLauncher.QuietPipeHandler:_construct0()
	jk.process.ProcessLauncher.QuietPipeHandler._init(self)
	return self
end

function jk.process.ProcessLauncher.QuietPipeHandler:onBufferData(data, size)
	do return true end
end

function jk.process.ProcessLauncher:asProcessLauncher(o)
	if not (o ~= nil) then
		do return nil end
	end
	if (_vm:get_variable_type(o) == 'string') then
		do return _g.jk.process.ProcessLauncher:forString(o) end
	end
	do
		local vector = _g.jk.lang.Vector:asObjectVector(o)
		if vector ~= nil then
			local vsz = _g.jk.lang.Vector:getSize(vector)
			if vsz > 0 then
				local pl = _g.jk.process.ProcessLauncher:forCommand(_g.jk.lang.String:asString(_g.jk.lang.Vector:get(vector, 0)), nil)
				if not (pl ~= nil) then
					do return nil end
				end
				do
					local n = 1
					while n < vsz do
						do pl:addToParams(_g.jk.lang.String:asString(_g.jk.lang.Vector:get(vector, n))) end
						do n = n + 1 end
					end
				end
				do return pl end
			end
		end
		do return nil end
	end
end

function jk.process.ProcessLauncher:forSelf()
	local exe = _g.jk.process.CurrentProcess:getExecutableFile()
	if not (exe ~= nil) then
		do return nil end
	end
	do
		local v = _g.jk.process.ProcessLauncher._construct0(_g.jk.process.ProcessLauncher._create())
		do v:setFile(exe) end
		do return v end
	end
end

function jk.process.ProcessLauncher:forFile(file, params)
	if file == nil or file:isFile() == false then
		do return nil end
	end
	do
		local v = _g.jk.process.ProcessLauncher._construct0(_g.jk.process.ProcessLauncher._create())
		do v:setFile(file) end
		if params ~= nil then
			local n = 0
			local m = #params
			do
				n = 0
				while n < m do
					local param = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(params[n + 1])
					if param ~= nil then
						do v:addToParams(param) end
					end
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function jk.process.ProcessLauncher:forCommand(command, params)
	if _g.jk.lang.String:isEmpty(command) then
		do return nil end
	end
	do
		local file = nil
		local delim = _g.jk.fs.PathInfo:getPathSeparator()
		if _g.jk.lang.String:getIndexOfCharacter(command, delim, 0) >= 0 then
			file = _g.jk.fs.File:forPath(command)
		elseif delim ~= 47 and _g.jk.lang.String:getIndexOfCharacter(command, 47, 0) >= 0 then
			file = _g.jk.fs.File:forPath(command)
		else
			file = _g.jk.env.ExternalCommand:findInPath(command)
		end
		do return _g.jk.process.ProcessLauncher:forFile(file, params) end
	end
end

function jk.process.ProcessLauncher:forString(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return nil end
	end
	do
		local arr = _g.jk.text.StringUtil:quotedStringToVector(str, 32, true, 92)
		if arr == nil or _g.jk.lang.Vector:getSize(arr) < 1 then
			do return nil end
		end
		do
			local vsz = _g.jk.lang.Vector:getSize(arr)
			local cmd = arr[0 + 1]
			local params = nil
			local paramCount = vsz - 1
			if paramCount > 0 then
				params = _vm:allocate_array(paramCount)
				do
					local n = 1
					while n < vsz do
						params[n - 1 + 1] = arr[n + 1]
						do n = n + 1 end
					end
				end
			end
			do return _g.jk.process.ProcessLauncher:forCommand(cmd, params) end
		end
	end
end

function jk.process.ProcessLauncher:_construct0()
	jk.process.ProcessLauncher._init(self)
	self.params = {}
	self.env = {}
	return self
end

function jk.process.ProcessLauncher:appendProperParam(sb, p)
	if not _g.jk.lang.String:isNotEmpty(p) then
		do return end
	end
	do sb:appendCharacter(32) end
	do sb:appendCharacter(34) end
	do self:escapeQuotesAndBackSlashes(sb, p) end
	do sb:appendCharacter(34) end
end

function jk.process.ProcessLauncher:escapeQuotesAndBackSlashes(sb, param)
	local it = _g.jk.lang.String:iterate(param)
	while it ~= nil do
		local c = it:getNextChar()
		if _g.jk.lang.Character:isEOF(c) then
			do break end
		end
		if c == 34 or c == 92 then
			do sb:appendCharacter(92) end
		end
		do sb:appendCharacter(c) end
	end
end

function jk.process.ProcessLauncher:getFullCommandString(includeEnv)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if includeEnv then
		local keys = _g.jk.lang.Map:getKeys(self.env)
		if keys ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(keys)
			do
				n = 0
				while n < m do
					local key = keys[n + 1]
					if key ~= nil then
						do sb:appendString(key) end
						do sb:appendCharacter(61) end
						do sb:appendString(self.env[key]) end
						do sb:appendCharacter(32) end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do sb:appendCharacter(34) end
	if self.file ~= nil then
		do self:escapeQuotesAndBackSlashes(sb, self.file:getPath()) end
	end
	do sb:appendCharacter(34) end
	if self.params ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.params)
		do
			n2 = 0
			while n2 < m2 do
				local p = self.params[n2 + 1]
				if p ~= nil then
					do self:appendProperParam(sb, p) end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	do return sb:toString() end
end

function jk.process.ProcessLauncher:toString()
	do return self:getFullCommandString(true) end
end

function jk.process.ProcessLauncher:addToParams(arg)
	if arg ~= nil then
		if self.params == nil then
			self.params = {}
		end
		do _g.jk.lang.Vector:append(self.params, arg) end
	end
	do return self end
end

function jk.process.ProcessLauncher:addFileToParams(file)
	if file ~= nil then
		do self:addToParams(file:getPath()) end
	end
	do return self end
end

function jk.process.ProcessLauncher:addStringsToParams(params)
	if params ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(params)
		do
			n = 0
			while n < m do
				local s = params[n + 1]
				if s ~= nil then
					do self:addToParams(s) end
				end
				do n = n + 1 end
			end
		end
	end
	do return self end
end

function jk.process.ProcessLauncher:setEnvVariable(key, val)
	if key ~= nil then
		if self.env == nil then
			self.env = {}
		end
		self.env[key] = val
	end
end

function jk.process.ProcessLauncher:startProcess(wait, pipeHandler, withIO)
	do return _g.jk.process.ProcessLauncherSushi:startProcess(self, wait, pipeHandler, withIO, self.errorBuffer) end
end

function jk.process.ProcessLauncher:start()
	do return self:startProcess(false, nil, false) end
end

function jk.process.ProcessLauncher:startWithIO()
	do return _vm:to_table_with_key(self:startProcess(false, nil, true), '_isType.jk.process.ProcessWithIO') end
end

function jk.process.ProcessLauncher:execute()
	local cp = self:startProcess(true, nil, false)
	if cp == nil then
		do return -1 end
	end
	do return cp:getExitStatus() end
end

function jk.process.ProcessLauncher:executeSilent()
	local cp = self:startProcess(true, _g.jk.process.ProcessLauncher.QuietPipeHandler._construct0(_g.jk.process.ProcessLauncher.QuietPipeHandler._create()), false)
	if cp == nil then
		do return -1 end
	end
	do return cp:getExitStatus() end
end

function jk.process.ProcessLauncher:executeToStringBuilder(output)
	local msp = _g.jk.process.ProcessLauncher.MyStringPipeHandler._construct0(_g.jk.process.ProcessLauncher.MyStringPipeHandler._create())
	do msp:setBuilder(output) end
	do
		local cp = self:startProcess(true, msp, false)
		if cp == nil then
			do return -1 end
		end
		do return cp:getExitStatus() end
	end
end

function jk.process.ProcessLauncher:executeToString()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if self:executeToStringBuilder(sb) < 0 then
		do return nil end
	end
	do return sb:toString() end
end

function jk.process.ProcessLauncher:executeToBuffer()
	local ph = _g.jk.process.ProcessLauncher.MyBufferPipeHandler._construct0(_g.jk.process.ProcessLauncher.MyBufferPipeHandler._create())
	local cp = self:startProcess(true, ph, false)
	if cp == nil then
		do return nil end
	end
	do return ph:getData() end
end

function jk.process.ProcessLauncher:executeToPipe(pipeHandler)
	local cp = self:startProcess(true, pipeHandler, false)
	if cp == nil then
		do return -1 end
	end
	do return cp:getExitStatus() end
end

function jk.process.ProcessLauncher:getFile()
	do return self.file end
end

function jk.process.ProcessLauncher:setFile(v)
	self.file = v
	do return self end
end

function jk.process.ProcessLauncher:getParams()
	do return self.params end
end

function jk.process.ProcessLauncher:setParams(v)
	self.params = v
	do return self end
end

function jk.process.ProcessLauncher:getEnv()
	do return self.env end
end

function jk.process.ProcessLauncher:setEnv(v)
	self.env = v
	do return self end
end

function jk.process.ProcessLauncher:getCwd()
	do return self.cwd end
end

function jk.process.ProcessLauncher:setCwd(v)
	self.cwd = v
	do return self end
end

function jk.process.ProcessLauncher:getUid()
	do return self.uid end
end

function jk.process.ProcessLauncher:setUid(v)
	self.uid = v
	do return self end
end

function jk.process.ProcessLauncher:getGid()
	do return self.gid end
end

function jk.process.ProcessLauncher:setGid(v)
	self.gid = v
	do return self end
end

function jk.process.ProcessLauncher:getTrapSigint()
	do return self.trapSigint end
end

function jk.process.ProcessLauncher:setTrapSigint(v)
	self.trapSigint = v
	do return self end
end

function jk.process.ProcessLauncher:getReplaceSelf()
	do return self.replaceSelf end
end

function jk.process.ProcessLauncher:setReplaceSelf(v)
	self.replaceSelf = v
	do return self end
end

function jk.process.ProcessLauncher:getPipePty()
	do return self.pipePty end
end

function jk.process.ProcessLauncher:setPipePty(v)
	self.pipePty = v
	do return self end
end

function jk.process.ProcessLauncher:getStartGroup()
	do return self.startGroup end
end

function jk.process.ProcessLauncher:setStartGroup(v)
	self.startGroup = v
	do return self end
end

function jk.process.ProcessLauncher:getNoCmdWindow()
	do return self.noCmdWindow end
end

function jk.process.ProcessLauncher:setNoCmdWindow(v)
	self.noCmdWindow = v
	do return self end
end

function jk.process.ProcessLauncher:getErrorBuffer()
	do return self.errorBuffer end
end

function jk.process.ProcessLauncher:setErrorBuffer(v)
	self.errorBuffer = v
	do return self end
end

function jk.process.ProcessLauncher:getDetachFromTerminal()
	do return self.detachFromTerminal end
end

function jk.process.ProcessLauncher:setDetachFromTerminal(v)
	self.detachFromTerminal = v
	do return self end
end

jk.process.ProcessLauncherSushi = {}
jk.process.ProcessLauncherSushi.__index = jk.process.ProcessLauncherSushi
_vm:set_metatable(jk.process.ProcessLauncherSushi, {})

function jk.process.ProcessLauncherSushi._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncherSushi)
	return v
end

function jk.process.ProcessLauncherSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncherSushi'
	self['_isType.jk.process.ProcessLauncherSushi'] = true
end

function jk.process.ProcessLauncherSushi:_construct0()
	jk.process.ProcessLauncherSushi._init(self)
	return self
end

jk.process.ProcessLauncherSushi.FDReader = {}
jk.process.ProcessLauncherSushi.FDReader.__index = jk.process.ProcessLauncherSushi.FDReader
_vm:set_metatable(jk.process.ProcessLauncherSushi.FDReader, {})

function jk.process.ProcessLauncherSushi.FDReader._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncherSushi.FDReader)
	return v
end

function jk.process.ProcessLauncherSushi.FDReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncherSushi.FDReader'
	self['_isType.jk.process.ProcessLauncherSushi.FDReader'] = true
	self['_isType.jk.io.Reader'] = true
	self['_isType.jk.lang.Closable'] = true
	self.fd = 0
end

function jk.process.ProcessLauncherSushi.FDReader:_construct0()
	jk.process.ProcessLauncherSushi.FDReader._init(self)
	return self
end

function jk.process.ProcessLauncherSushi.FDReader:forFd(fd)
	if fd < 0 then
		do return nil end
	end
	do
		local v = _g.jk.process.ProcessLauncherSushi.FDReader._construct0(_g.jk.process.ProcessLauncherSushi.FDReader._create())
		do v:setFd(fd) end
		do return v end
	end
end

function jk.process.ProcessLauncherSushi.FDReader:close()
	local fd = self.fd
	if fd >= 0 then
		do _io:close_handle(fd) end
		fd = -1
	end
end

function jk.process.ProcessLauncherSushi.FDReader:read(buffer)
	if not (buffer ~= nil) then
		do return 0 end
	end
	do
		local fd = self.fd
		local v = 0
		do v = _io:read_from_handle(fd, buffer) end
		do return v end
	end
end

function jk.process.ProcessLauncherSushi.FDReader:getFd()
	do return self.fd end
end

function jk.process.ProcessLauncherSushi.FDReader:setFd(v)
	self.fd = v
	do return self end
end

jk.process.ProcessLauncherSushi.FDWriter = {}
jk.process.ProcessLauncherSushi.FDWriter.__index = jk.process.ProcessLauncherSushi.FDWriter
_vm:set_metatable(jk.process.ProcessLauncherSushi.FDWriter, {})

function jk.process.ProcessLauncherSushi.FDWriter._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncherSushi.FDWriter)
	return v
end

function jk.process.ProcessLauncherSushi.FDWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncherSushi.FDWriter'
	self['_isType.jk.process.ProcessLauncherSushi.FDWriter'] = true
	self['_isType.jk.io.Writer'] = true
	self['_isType.jk.lang.Closable'] = true
	self.fd = 0
end

function jk.process.ProcessLauncherSushi.FDWriter:_construct0()
	jk.process.ProcessLauncherSushi.FDWriter._init(self)
	return self
end

function jk.process.ProcessLauncherSushi.FDWriter:forFd(fd)
	if fd < 0 then
		do return nil end
	end
	do
		local v = _g.jk.process.ProcessLauncherSushi.FDWriter._construct0(_g.jk.process.ProcessLauncherSushi.FDWriter._create())
		do v:setFd(fd) end
		do return v end
	end
end

function jk.process.ProcessLauncherSushi.FDWriter:close()
	local fd = self.fd
	if fd >= 0 then
		do _io:close_handle(fd) end
		fd = -1
	end
end

function jk.process.ProcessLauncherSushi.FDWriter:write(buf, size)
	local fd = self.fd
	local v = 0
	do v = _io:write_to_handle(fd, buf, size) end
	do return v end
end

function jk.process.ProcessLauncherSushi.FDWriter:getFd()
	do return self.fd end
end

function jk.process.ProcessLauncherSushi.FDWriter:setFd(v)
	self.fd = v
	do return self end
end

jk.process.ProcessLauncherSushi.MyProcess = {}
jk.process.ProcessLauncherSushi.MyProcess.__index = jk.process.ProcessLauncherSushi.MyProcess
_vm:set_metatable(jk.process.ProcessLauncherSushi.MyProcess, {})

function jk.process.ProcessLauncherSushi.MyProcess._create()
	local v = _vm:set_metatable({}, jk.process.ProcessLauncherSushi.MyProcess)
	return v
end

function jk.process.ProcessLauncherSushi.MyProcess:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.ProcessLauncherSushi.MyProcess'
	self['_isType.jk.process.ProcessLauncherSushi.MyProcess'] = true
	self['_isType.jk.process.Process'] = true
	self['_isType.jk.process.ProcessWithIO'] = true
	self.pid = 0
	self.inWriter = nil
	self.outReader = nil
	self.errReader = nil
	self.status = 0
end

function jk.process.ProcessLauncherSushi.MyProcess:_construct0()
	jk.process.ProcessLauncherSushi.MyProcess._init(self)
	return self
end

function jk.process.ProcessLauncherSushi.MyProcess:close()
	if self.inWriter ~= nil then
		do self.inWriter:close() end
		self.inWriter = nil
	end
	if self.outReader ~= nil then
		do self.outReader:close() end
		self.outReader = nil
	end
	if self.errReader ~= nil then
		do self.errReader:close() end
		self.errReader = nil
	end
end

function jk.process.ProcessLauncherSushi.MyProcess:getStandardInput()
	do return self.inWriter end
end

function jk.process.ProcessLauncherSushi.MyProcess:getStandardOutput()
	do return self.outReader end
end

function jk.process.ProcessLauncherSushi.MyProcess:getStandardError()
	do return self.errReader end
end

function jk.process.ProcessLauncherSushi.MyProcess:getId()
	do return _g.jk.lang.String:forInteger(self.pid) end
end

function jk.process.ProcessLauncherSushi.MyProcess:updateStatus()
	if self.pid >= 0 then
		local alive = 0
		local pid = self.pid
		do alive = _os:is_process_alive(pid) end
		if alive == 0 then
			do self:waitForExit() end
		end
	end
end

function jk.process.ProcessLauncherSushi.MyProcess:isRunning()
	do self:updateStatus() end
	if self.pid >= 0 then
		do return true end
	end
	do return false end
end

function jk.process.ProcessLauncherSushi.MyProcess:getExitStatus()
	do self:updateStatus() end
	do return self.status end
end

function jk.process.ProcessLauncherSushi.MyProcess:sendInterrupt()
	local pid = self.pid
	do _os:send_process_signal(pid, 2) end
end

function jk.process.ProcessLauncherSushi.MyProcess:killRequest()
	local pid = self.pid
	do _os:send_process_signal(pid, 15) end
end

function jk.process.ProcessLauncherSushi.MyProcess:killForce()
	local pid = self.pid
	do _os:send_process_signal(pid, 9) end
end

function jk.process.ProcessLauncherSushi.MyProcess:kill(timeout)
	do self:killRequest() end
	do
		local n = 0
		while n < timeout do
			if not self:isRunning() then
				do return end
			end
			do _os:sleep_milliseconds(100); end
			n = n + 100
		end
		do self:killForce() end
	end
end

function jk.process.ProcessLauncherSushi.MyProcess:waitForExit()
	local v = self.status
	local pid = self.pid
	if pid >= 0 then
		do v = _os:wait_for_process(pid) end
		do self:close() end
		self.status = v
		self.pid = -1
	end
	do return v end
end

function jk.process.ProcessLauncherSushi.MyProcess:getPid()
	do return self.pid end
end

function jk.process.ProcessLauncherSushi.MyProcess:setPid(v)
	self.pid = v
	do return self end
end

function jk.process.ProcessLauncherSushi.MyProcess:getInWriter()
	do return self.inWriter end
end

function jk.process.ProcessLauncherSushi.MyProcess:setInWriter(v)
	self.inWriter = v
	do return self end
end

function jk.process.ProcessLauncherSushi.MyProcess:getOutReader()
	do return self.outReader end
end

function jk.process.ProcessLauncherSushi.MyProcess:setOutReader(v)
	self.outReader = v
	do return self end
end

function jk.process.ProcessLauncherSushi.MyProcess:getErrReader()
	do return self.errReader end
end

function jk.process.ProcessLauncherSushi.MyProcess:setErrReader(v)
	self.errReader = v
	do return self end
end

function jk.process.ProcessLauncherSushi:startProcess(launcher, wait, pipeHandler, withIO, errorBuffer)
	if not (launcher ~= nil) then
		do return nil end
	end
	do
		local file = launcher:getFile()
		if not (file ~= nil) then
			do return nil end
		end
		do
			local filepath = file:getPath()
			local params = launcher:getParams()
			local env = {}
			local cenv = _g.jk.env.EnvironmentVariable:getAll()
			if cenv ~= nil then
				local keys = _g.jk.lang.Map:getKeys(cenv)
				if keys ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(keys)
					do
						n = 0
						while n < m do
							local key = keys[n + 1]
							if key ~= nil then
								do _g.jk.lang.Vector:append(env, _g.jk.lang.String:safeString(key) .. "=" .. _g.jk.lang.String:safeString(cenv[key])) end
							end
							do n = n + 1 end
						end
					end
				end
			end
			do
				local emap = launcher:getEnv()
				if emap ~= nil then
					local keys = _g.jk.lang.Map:getKeys(emap)
					if keys ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(keys)
						do
							n2 = 0
							while n2 < m2 do
								local key = keys[n2 + 1]
								if key ~= nil then
									do _g.jk.lang.Vector:append(env, _g.jk.lang.String:safeString(key) .. "=" .. _g.jk.lang.String:safeString(emap[key])) end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
				do
					local cwd = launcher:getCwd()
					local cwdpath = nil
					if cwd ~= nil then
						cwdpath = cwd:getPath()
					end
					do
						local pid = 0
						local fdin = -1
						local fdout = -1
						local fderr = -1
						local sigintWasTrapped = false
						if launcher:getTrapSigint() then
							sigintWasTrapped = _g.jk.posix.PosixSignal:trapSignal(_g.jk.posix.PosixSignal.SIGINT, true)
						end
						do
							local detachFromTerminal = 0
							if launcher:getDetachFromTerminal() then
								detachFromTerminal = 1
							end
							if launcher:getReplaceSelf() then
								do _os:replace_process(filepath, params, env, cwdpath, detachFromTerminal) end
							elseif pipeHandler ~= nil then
								do pid, fdin, fdout, fderr = _os:start_piped_process(filepath, params, env, cwdpath, detachFromTerminal) end
							else
								do pid = _os:start_process(filepath, params, env, cwdpath, detachFromTerminal) end
							end
							do
								local v = nil
								if pid >= 0 then
									local vv = _g.jk.process.ProcessLauncherSushi.MyProcess._construct0(_g.jk.process.ProcessLauncherSushi.MyProcess._create())
									do vv:setPid(pid) end
									do vv:setInWriter(_g.jk.process.ProcessLauncherSushi.FDWriter:forFd(fdin)) end
									do vv:setOutReader(_g.jk.process.ProcessLauncherSushi.FDReader:forFd(fdout)) end
									do vv:setErrReader(_g.jk.process.ProcessLauncherSushi.FDReader:forFd(fderr)) end
									if wait then
										if pipeHandler ~= nil then
											local _or = vv:getOutReader()
											local buffer = _util:allocate_buffer(4096)
											while true do
												local r = _or:read(buffer)
												if r < 1 then
													do break end
												end
												do pipeHandler:onBufferData(buffer, r) end
											end
											do
												local er = vv:getErrReader()
												while true do
													local r = er:read(buffer)
													if r < 1 then
														do break end
													end
													do pipeHandler:onBufferData(buffer, r) end
												end
											end
										end
										do vv:waitForExit() end
									end
									v = vv
								end
								if launcher:getTrapSigint() and sigintWasTrapped == false then
									do _g.jk.posix.PosixSignal:trapSignal(_g.jk.posix.PosixSignal.SIGINT, sigintWasTrapped) end
								end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

jk.process.CurrentProcess = {}
jk.process.CurrentProcess.__index = jk.process.CurrentProcess
_vm:set_metatable(jk.process.CurrentProcess, {})

function jk.process.CurrentProcess._create()
	local v = _vm:set_metatable({}, jk.process.CurrentProcess)
	return v
end

function jk.process.CurrentProcess:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.process.CurrentProcess'
	self['_isType.jk.process.CurrentProcess'] = true
end

function jk.process.CurrentProcess:_construct0()
	jk.process.CurrentProcess._init(self)
	return self
end

function jk.process.CurrentProcess:terminate(value)
	_io:write_to_stdout("[jk.process.CurrentProcess.terminate] (CurrentProcess.sling:53:3): Not implemented" .. "\n")
end

function jk.process.CurrentProcess:getExecutableFile()
	do return _g.jk.fs.File:forPath(_vm.get_sushi_executable_path()) end
end

function jk.process.CurrentProcess:getProcessName()
	local v = nil
	local exe = _g.jk.process.CurrentProcess:getExecutableFile()
	if exe ~= nil then
		v = exe:getBasenameWithoutExtension()
	end
	do return v end
end
jk = jk or {}

jk.console = jk.console or {}

jk.console.ConsoleApplicationUtil = {}
jk.console.ConsoleApplicationUtil.__index = jk.console.ConsoleApplicationUtil
_vm:set_metatable(jk.console.ConsoleApplicationUtil, {})

function jk.console.ConsoleApplicationUtil._create()
	local v = _vm:set_metatable({}, jk.console.ConsoleApplicationUtil)
	return v
end

function jk.console.ConsoleApplicationUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.ConsoleApplicationUtil'
	self['_isType.jk.console.ConsoleApplicationUtil'] = true
end

function jk.console.ConsoleApplicationUtil:_construct0()
	jk.console.ConsoleApplicationUtil._init(self)
	return self
end

function jk.console.ConsoleApplicationUtil:printHeader(out, title, version, copyright, license, platform, component)
	if not (out ~= nil) then
		do return end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if _g.jk.lang.String:isEmpty(title) then
			do sb:appendString("Untitled Application") end
		else
			do sb:appendString(title) end
		end
		if _g.jk.lang.String:isNotEmpty(component) then
			if sb:count() > 0 then
				do sb:appendCharacter(32) end
			end
			do sb:appendString(component) end
		end
		if _g.jk.lang.String:isNotEmpty(version) then
			do sb:appendString(" / ") end
			do sb:appendString(version) end
		end
		if _g.jk.lang.String:isNotEmpty(platform) then
			do sb:appendString(" @ ") end
			do sb:appendString(platform) end
		end
		if sb:count() > 0 then
			do sb:appendCharacter(10) end
		end
		if _g.jk.lang.String:isNotEmpty(copyright) then
			do sb:appendString(copyright) end
			do sb:appendCharacter(10) end
		end
		if _g.jk.lang.String:isNotEmpty(license) then
			do sb:appendString(license) end
			do sb:appendCharacter(10) end
		end
		if sb:count() > 0 then
			do sb:appendCharacter(10) end
		end
		if sb:count() > 0 then
			do out:print(sb:toString()) end
		end
	end
end

function jk.console.ConsoleApplicationUtil:printVersion(out, version, title)
	if not (out ~= nil) then
		do return end
	end
	if _g.jk.lang.String:isNotEmpty(title) then
		do out:println(_g.jk.lang.String:safeString(title) .. "/" .. _g.jk.lang.String:safeString(version)) end
	else
		do out:println(version) end
	end
end

function jk.console.ConsoleApplicationUtil:parseCommandLineArguments(args)
	local v = {}
	if args ~= nil then
		local n = 0
		local m = #args
		do
			n = 0
			while n < m do
				local arg = args[n + 1]
				if arg ~= nil then
					if _g.jk.lang.String:startsWith(arg, "-", 0) then
						if _g.jk.lang.String:getIndexOfCharacter(arg, 61, 0) > 0 then
							local comps = _g.jk.lang.String:split(arg, 61, 2)
							local key = _g.jk.lang.String:getEndOfString(comps[0 + 1], 1)
							local val = comps[1 + 1]
							do _g.jk.lang.Vector:append(v, _g.jk.console.CommandLineArgument._construct5(_g.jk.console.CommandLineArgument._create(), arg, nil, nil, key, val)) end
						else
							do _g.jk.lang.Vector:append(v, _g.jk.console.CommandLineArgument._construct5(_g.jk.console.CommandLineArgument._create(), arg, nil, _g.jk.lang.String:getEndOfString(arg, 1), nil, "true")) end
						end
					else
						do _g.jk.lang.Vector:append(v, _g.jk.console.CommandLineArgument._construct5(_g.jk.console.CommandLineArgument._create(), arg, arg, nil, nil, arg)) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.console.ConsoleApplicationUtil:getLongestString(strings, add, ov)
	local v = ov
	if strings ~= nil then
		local n = 0
		local m = #strings
		do
			n = 0
			while n < m do
				local string = (function(o)
					if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(o) then
						do return o end
					end
					do return nil end
				end)(strings[n + 1])
				if string ~= nil then
					local ss = _g.jk.lang.String:getLength(_g.jk.lang.String:asString(string[0 + 1])) + add
					if ss > v then
						v = ss
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function jk.console.ConsoleApplicationUtil:printUsage(stdout, name, parameters, flags, options)
	local nn = name
	if _g.jk.lang.String:isEmpty(nn) then
		nn = _g.jk.process.CurrentProcess:getProcessName()
	end
	if _g.jk.lang.String:isEmpty(nn) then
		nn = "(command)"
	end
	do
		local ll = 0
		ll = _g.jk.console.ConsoleApplicationUtil:getLongestString(parameters, 0, ll)
		ll = _g.jk.console.ConsoleApplicationUtil:getLongestString(flags, 1, ll)
		ll = _g.jk.console.ConsoleApplicationUtil:getLongestString(options, 9, ll)
		do stdout:print("Usage: " .. _g.jk.lang.String:safeString(nn) .. " [parameters, flags and options]\n") end
		if _g.jk.lang.Array:isEmpty(parameters) == false then
			do stdout:print("\n") end
			do stdout:print("Supported Parameters:\n") end
			do stdout:print("\n") end
			if parameters ~= nil then
				local n = 0
				local m = #parameters
				do
					n = 0
					while n < m do
						local parameter = (function(o)
							if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(o) then
								do return o end
							end
							do return nil end
						end)(parameters[n + 1])
						if parameter ~= nil then
							do stdout:print("  " .. _g.jk.lang.String:safeString(_g.jk.text.StringUtil:padToLength(_g.jk.lang.String:asString(parameter[0 + 1]), ll, -1, 32)) .. " - " .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(parameter[1 + 1])) .. "\n") end
						end
						do n = n + 1 end
					end
				end
			end
		end
		if _g.jk.lang.Array:isEmpty(flags) == false then
			do stdout:print("\n") end
			do stdout:print("Supported Flags:\n") end
			do stdout:print("\n") end
			if flags ~= nil then
				local n2 = 0
				local m2 = #flags
				do
					n2 = 0
					while n2 < m2 do
						local flag = (function(o)
							if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(o) then
								do return o end
							end
							do return nil end
						end)(flags[n2 + 1])
						if flag ~= nil then
							do stdout:print("  -" .. _g.jk.lang.String:safeString(_g.jk.text.StringUtil:padToLength(_g.jk.lang.String:asString(flag[0 + 1]), ll, -1, 32)) .. " - " .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(flag[1 + 1])) .. "\n") end
						end
						do n2 = n2 + 1 end
					end
				end
			end
		end
		if _g.jk.lang.Array:isEmpty(options) == false then
			do stdout:print("\n") end
			do stdout:print("Supported Options:\n") end
			do stdout:print("\n") end
			if options ~= nil then
				local n3 = 0
				local m3 = #options
				do
					n3 = 0
					while n3 < m3 do
						local option = (function(o)
							if (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(o) then
								do return o end
							end
							do return nil end
						end)(options[n3 + 1])
						if option ~= nil then
							do stdout:print("  -" .. _g.jk.lang.String:safeString(_g.jk.text.StringUtil:padToLength(_g.jk.lang.String:safeString(_g.jk.lang.String:asString(option[0 + 1])) .. "=<value>", ll, -1, 32)) .. " - " .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(option[1 + 1])) .. "\n") end
						end
						do n3 = n3 + 1 end
					end
				end
			end
		end
		do stdout:print("\n") end
	end
end

jk.console.ConsoleApplicationContext = {}
jk.console.ConsoleApplicationContext.__index = jk.console.ConsoleApplicationContext
_vm:set_metatable(jk.console.ConsoleApplicationContext, {})

function jk.console.ConsoleApplicationContext._create()
	local v = _vm:set_metatable({}, jk.console.ConsoleApplicationContext)
	return v
end

function jk.console.ConsoleApplicationContext:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.ConsoleApplicationContext'
	self['_isType.jk.console.ConsoleApplicationContext'] = true
	self['_isType.jk.app.ApplicationContext'] = true
	self['_isType.jk.log.LoggingContext'] = true
	self.applicationName = nil
	self.enableColor = true
	self.dumbMode = false
	self.showInfo = true
	self.showWarning = true
	self.showError = true
	self.showDebug = false
	self.enableStatus = true
	self.enableOutput = true
	self.autoClearStatus = true
	self.currentPrefix = nil
	self.lastStatus = false
	self.lastStatusLength = 0
	self.errorCounter = 0
	self.warningCounter = 0
	self.infoCounter = 0
	self.debugCounter = 0
	self.stdout = nil
end

function jk.console.ConsoleApplicationContext:forApplicationName(name)
	local v = _g.jk.console.ConsoleApplicationContext._construct0(_g.jk.console.ConsoleApplicationContext._create())
	do v:setApplicationName(name) end
	do return v end
end

function jk.console.ConsoleApplicationContext:_construct0()
	jk.console.ConsoleApplicationContext._init(self)
	self.stdout = _g.jk.console.Stdout:instance()
	do
		local term = _g.jk.env.EnvironmentVariable:get("TERM")
		if term == nil or term == "cygwin" then
			self.enableColor = false
		end
		do
			local logColor = _g.jk.env.EnvironmentVariable:get("CONSOLE_LOG_COLOR")
			if logColor ~= nil then
				self.enableColor = _g.jk.lang.Boolean:asBoolean(logColor, false)
			end
			do
				local logDebug = _g.jk.env.EnvironmentVariable:get("CONSOLE_LOG_DEBUG")
				if not (logDebug ~= nil) then
					logDebug = _g.jk.env.EnvironmentVariable:get("CONSOLE_DEBUG")
				end
				if not (logDebug ~= nil) then
					logDebug = _g.jk.env.EnvironmentVariable:get("EQELA_DEBUG")
				end
				if logDebug ~= nil then
					do self:setEnableDebugMessages(_g.jk.lang.Boolean:asBoolean(logDebug, false)) end
				end
			end
		end
	end
	return self
end

function jk.console.ConsoleApplicationContext:isInDebugMode()
	do return self.showDebug end
end

function jk.console.ConsoleApplicationContext:setEnableDebugMessages(v)
	self.showDebug = v
	do return self end
end

function jk.console.ConsoleApplicationContext:useApplicationNameAsPrefix()
	self.currentPrefix = self.applicationName
	if _g.jk.lang.String:isEmpty(self.currentPrefix) then
		self.currentPrefix = _g.jk.process.CurrentProcess:getProcessName()
	end
end

function jk.console.ConsoleApplicationContext:resetCounters()
	self.errorCounter = 0
	self.warningCounter = 0
	self.infoCounter = 0
	self.debugCounter = 0
end

function jk.console.ConsoleApplicationContext:getErrorCount()
	do return self.errorCounter end
end

function jk.console.ConsoleApplicationContext:getWarningCount()
	do return self.warningCounter end
end

function jk.console.ConsoleApplicationContext:getInfoCount()
	do return self.infoCounter end
end

function jk.console.ConsoleApplicationContext:getDebugCount()
	do return self.debugCounter end
end

function jk.console.ConsoleApplicationContext:logError(message)
	if self.showError and self.enableOutput then
		do self:doPrintLine("ERROR", 91, self.currentPrefix, message) end
	end
	do self.errorCounter = self.errorCounter + 1 end
end

function jk.console.ConsoleApplicationContext:logWarning(message)
	if self.showWarning and self.enableOutput then
		do self:doPrintLine("WARNING", 95, self.currentPrefix, message) end
	end
	do self.warningCounter = self.warningCounter + 1 end
end

function jk.console.ConsoleApplicationContext:logInfo(message)
	if self.showInfo and self.enableOutput then
		do self:doPrintLine("INFO", -1, self.currentPrefix, message) end
	end
	do self.infoCounter = self.infoCounter + 1 end
end

function jk.console.ConsoleApplicationContext:logDebug(message)
	if self.showDebug and self.enableOutput then
		do self:doPrintLine("DEBUG", 96, self.currentPrefix, message) end
	end
	do self.debugCounter = self.debugCounter + 1 end
end

function jk.console.ConsoleApplicationContext:logStatus(message)
	if self.enableOutput and self.enableStatus then
		if self.currentPrefix ~= nil and message ~= nil then
			do self:doPrintStatus("[" .. _g.jk.lang.String:safeString(self.currentPrefix) .. "] " .. _g.jk.lang.String:safeString(message)) end
		else
			do self:doPrintStatus(message) end
		end
	end
end

function jk.console.ConsoleApplicationContext:getApplicationDataDirectory()
	do return self:getApplicationDataDirectoryForAppId(self.applicationName) end
end

function jk.console.ConsoleApplicationContext:getApplicationDataDirectoryForAppId(appId)
	local applicationName = appId
	if _g.jk.lang.String:isEmpty(applicationName) then
		applicationName = _g.jk.process.CurrentProcess:getProcessName()
	end
	if _g.jk.lang.String:isEmpty(applicationName) then
		do return nil end
	end
	do
		local v = nil
		if v == nil then
			v = _g.jk.fs.File:forRelativePath("." .. _g.jk.lang.String:safeString(applicationName), _g.jk.env.CommonPath:getHomeDirectory(), false)
		end
		do return v end
	end
end

function jk.console.ConsoleApplicationContext:doPrintLine(type, color, prefix, message)
	if self.autoClearStatus then
		do self:doPrintStatus(nil) end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if self.lastStatus then
			do sb:appendCharacter(10) end
		end
		if type ~= nil or prefix ~= nil then
			do sb:appendCharacter(91) end
			if self.dumbMode == false and self.enableColor and color >= 0 then
				do sb:appendCharacter(27) end
				do sb:appendCharacter(91) end
				do sb:appendInteger(color) end
				do sb:appendCharacter(109) end
			end
			if type ~= nil then
				do sb:appendString(type) end
				if prefix ~= nil then
					do sb:appendCharacter(58) end
				end
			end
			if prefix ~= nil then
				do sb:appendString(prefix) end
			end
			if self.dumbMode == false and self.enableColor and color >= 0 then
				do sb:appendCharacter(27) end
				do sb:appendString("[39m") end
			end
			do sb:appendCharacter(93) end
			do sb:appendCharacter(32) end
		end
		do sb:appendString(message) end
		do sb:appendCharacter(10) end
		if self.stdout ~= nil then
			do self.stdout:print(sb:toString()) end
		end
		self.lastStatus = false
	end
end

function jk.console.ConsoleApplicationContext:doPrintStatus(m)
	if self.showDebug and m ~= nil then
		do self:doPrintLine(nil, -1, nil, m) end
		do return end
	end
	if self.dumbMode then
		if m == nil then
			do return end
		end
		if self.stdout ~= nil then
			do self.stdout:print(_g.jk.lang.String:safeString(m) .. "\n") end
		end
		do return end
	end
	if self.lastStatusLength < 1 and m == nil then
		do return end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendCharacter(13) end
		do
			local n = 0
			while n < self.lastStatusLength do
				do sb:appendCharacter(32) end
				do n = n + 1 end
			end
		end
		do sb:appendCharacter(13) end
		do
			local rm = m
			if rm ~= nil then
				local width = 0
				if width > 0 and _g.jk.lang.String:getLength(rm) >= width then
					rm = _g.jk.lang.String:safeString(_g.jk.lang.String:getSubString(rm, 0, width - 4)) .. " .."
				end
				do sb:appendString(rm) end
			end
			if self.stdout ~= nil then
				do self.stdout:print(sb:toString()) end
			end
			if m ~= nil then
				self.lastStatusLength = _g.jk.lang.String:getLength(rm)
			else
				self.lastStatusLength = 0
			end
			if rm == nil then
				self.lastStatus = false
			else
				self.lastStatus = true
			end
		end
	end
end

function jk.console.ConsoleApplicationContext:getApplicationName()
	do return self.applicationName end
end

function jk.console.ConsoleApplicationContext:setApplicationName(v)
	self.applicationName = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getEnableColor()
	do return self.enableColor end
end

function jk.console.ConsoleApplicationContext:setEnableColor(v)
	self.enableColor = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getDumbMode()
	do return self.dumbMode end
end

function jk.console.ConsoleApplicationContext:setDumbMode(v)
	self.dumbMode = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getShowInfo()
	do return self.showInfo end
end

function jk.console.ConsoleApplicationContext:setShowInfo(v)
	self.showInfo = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getShowWarning()
	do return self.showWarning end
end

function jk.console.ConsoleApplicationContext:setShowWarning(v)
	self.showWarning = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getShowError()
	do return self.showError end
end

function jk.console.ConsoleApplicationContext:setShowError(v)
	self.showError = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getShowDebug()
	do return self.showDebug end
end

function jk.console.ConsoleApplicationContext:setShowDebug(v)
	self.showDebug = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getEnableStatus()
	do return self.enableStatus end
end

function jk.console.ConsoleApplicationContext:setEnableStatus(v)
	self.enableStatus = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getEnableOutput()
	do return self.enableOutput end
end

function jk.console.ConsoleApplicationContext:setEnableOutput(v)
	self.enableOutput = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getAutoClearStatus()
	do return self.autoClearStatus end
end

function jk.console.ConsoleApplicationContext:setAutoClearStatus(v)
	self.autoClearStatus = v
	do return self end
end

function jk.console.ConsoleApplicationContext:getCurrentPrefix()
	do return self.currentPrefix end
end

function jk.console.ConsoleApplicationContext:setCurrentPrefix(v)
	self.currentPrefix = v
	do return self end
end

jk.console.Stdout = {}
jk.console.Stdout.__index = jk.console.Stdout
_vm:set_metatable(jk.console.Stdout, {})

function jk.console.Stdout._create()
	local v = _vm:set_metatable({}, jk.console.Stdout)
	return v
end

function jk.console.Stdout:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.Stdout'
	self['_isType.jk.console.Stdout'] = true
end

function jk.console.Stdout:_construct0()
	jk.console.Stdout._init(self)
	return self
end

function jk.console.Stdout:instance()
	do return _g.jk.console.StdoutForSushi._construct0(_g.jk.console.StdoutForSushi._create()) end
end

jk.console.ConsoleApplicationMain = {}
jk.console.ConsoleApplicationMain.__index = jk.console.ConsoleApplicationMain
_vm:set_metatable(jk.console.ConsoleApplicationMain, {})

function jk.console.ConsoleApplicationMain._create()
	local v = _vm:set_metatable({}, jk.console.ConsoleApplicationMain)
	return v
end

function jk.console.ConsoleApplicationMain:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.ConsoleApplicationMain'
	self['_isType.jk.console.ConsoleApplicationMain'] = true
	self.stdout = nil
	self.stdin = nil
	self.ctx = nil
	self.args = nil
	self.verbosityLevel = 3
	self.terminal = nil
end

function jk.console.ConsoleApplicationMain:executeMain(app, args)
	if not (app ~= nil) then
		do return -1 end
	end
	do return app:executeWithArgumentArray(args) end
end

function jk.console.ConsoleApplicationMain:_construct0()
	jk.console.ConsoleApplicationMain._init(self)
	self.stdin = _g.jk.console.Stdin:instance()
	self.stdout = _g.jk.console.Stdout:instance()
	self.ctx = _g.jk.console.ConsoleApplicationContext._construct0(_g.jk.console.ConsoleApplicationContext._create())
	return self
end

function jk.console.ConsoleApplicationMain:setCtx(v)
	self.ctx = v
	do return self end
end

function jk.console.ConsoleApplicationMain:getTerminal()
	if not (self.terminal ~= nil) then
		self.terminal = _g.jk.console.Terminal:forCurrent()
	end
	do return self.terminal end
end

function jk.console.ConsoleApplicationMain:print(string)
	if self.stdout ~= nil then
		do self.stdout:print(string) end
	end
end

function jk.console.ConsoleApplicationMain:println(string)
	if self.stdout ~= nil then
		do self.stdout:println(string) end
	end
end

function jk.console.ConsoleApplicationMain:readLine()
	local tt = self:getTerminal()
	if tt ~= nil then
		do return tt:readLine() end
	end
	if self.stdin ~= nil then
		do return self.stdin:readLine() end
	end
	do return nil end
end

function jk.console.ConsoleApplicationMain:readLineWithoutEcho()
	local tt = self:getTerminal()
	if tt ~= nil then
		do return tt:readLineWithoutEcho() end
	end
	do return self:readLine() end
end

function jk.console.ConsoleApplicationMain:initialize()
	do return true end
end

function jk.console.ConsoleApplicationMain:getVerbosityLevel()
	do return self.verbosityLevel end
end

function jk.console.ConsoleApplicationMain:setVerbosityLevel(level)
	self.verbosityLevel = level
	if self.verbosityLevel <= 0 then
		do self.ctx:setEnableOutput(false) end
	elseif self.verbosityLevel == 1 then
		do self.ctx:setEnableOutput(true) end
		do self.ctx:setShowError(true) end
		do self.ctx:setShowWarning(false) end
		do self.ctx:setShowInfo(false) end
		do self.ctx:setShowDebug(false) end
	elseif self.verbosityLevel == 2 then
		do self.ctx:setEnableOutput(true) end
		do self.ctx:setShowError(true) end
		do self.ctx:setShowWarning(true) end
		do self.ctx:setShowInfo(false) end
		do self.ctx:setShowDebug(false) end
	elseif self.verbosityLevel == 3 then
		do self.ctx:setEnableOutput(true) end
		do self.ctx:setShowError(true) end
		do self.ctx:setShowWarning(true) end
		do self.ctx:setShowInfo(true) end
		do self.ctx:setShowDebug(false) end
	else
		do self.ctx:setEnableOutput(true) end
		do self.ctx:setShowError(true) end
		do self.ctx:setShowWarning(true) end
		do self.ctx:setShowInfo(true) end
		do self.ctx:setShowDebug(true) end
	end
end

function jk.console.ConsoleApplicationMain:handleVerbosityParams()
	local nargs = {}
	local vl = self.verbosityLevel
	if self.args ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.args)
		do
			n = 0
			while n < m do
				local arg = self.args[n + 1]
				if arg ~= nil then
					if arg:isFlag2("v0") then
						vl = 0
					elseif arg:isFlag2("v1") then
						vl = 1
					elseif arg:isFlag2("v2") then
						vl = 2
					elseif arg:isFlag2("v3") then
						vl = 3
					elseif arg:isFlag2("v4") or arg:isFlag2("vv") or arg:isFlag2("debug") then
						vl = 4
					else
						do _g.jk.lang.Vector:append(nargs, arg) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	self.args = nargs
	if vl ~= self.verbosityLevel then
		do self:setVerbosityLevel(vl) end
	end
end

function jk.console.ConsoleApplicationMain:executeWithArgumentArray(args)
	if args ~= nil then
		self.args = _g.jk.console.ConsoleApplicationUtil:parseCommandLineArguments(args)
	end
	if not self:initialize() then
		do return 1 end
	end
	do
		local r = self:execute()
		do _g.jk.log.Log:status(self.ctx, nil) end
		if r then
			do return 0 end
		end
		do return 1 end
	end
end

function jk.console.ConsoleApplicationMain:executeWithArgumentVector(args)
	local arga = nil
	if args ~= nil then
		arga = _vm:allocate_array(_g.jk.lang.Vector:getSize(args))
		do
			local n = 0
			if args ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(args)
				do
					n2 = 0
					while n2 < m do
						local arg = args[n2 + 1]
						if arg ~= nil then
							arga[(function() local v = n n = n + 1 return v end)() + 1] = arg
						end
						do n2 = n2 + 1 end
					end
				end
			end
		end
	end
	do return self:executeWithArgumentArray(arga) end
end

function jk.console.ConsoleApplicationMain:executeWithParsedArguments(args)
	self.args = args
	if not self:initialize() then
		do return false end
	end
	do
		local r = self:execute()
		do _g.jk.log.Log:status(self.ctx, nil) end
		do return r end
	end
end

function jk.console.ConsoleApplicationMain:execute()
end

jk.console.Stdin = {}
jk.console.Stdin.__index = jk.console.Stdin
_vm:set_metatable(jk.console.Stdin, {})

function jk.console.Stdin._create()
	local v = _vm:set_metatable({}, jk.console.Stdin)
	return v
end

function jk.console.Stdin:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.Stdin'
	self['_isType.jk.console.Stdin'] = true
end

function jk.console.Stdin:_construct0()
	jk.console.Stdin._init(self)
	return self
end

function jk.console.Stdin:instance()
	local reader = nil
	reader = _g.jk.console.StdinForSushi._construct0(_g.jk.console.StdinForSushi._create())
	if not (reader ~= nil) then
		do return nil end
	end
	do return _g.jk.io.PrintReader:forReader(reader) end
end

jk.console.Terminal = {}
jk.console.Terminal.__index = jk.console.Terminal
_vm:set_metatable(jk.console.Terminal, {})

function jk.console.Terminal._create()
	local v = _vm:set_metatable({}, jk.console.Terminal)
	return v
end

function jk.console.Terminal:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.Terminal'
	self['_isType.jk.console.Terminal'] = true
end

function jk.console.Terminal:_construct0()
	jk.console.Terminal._init(self)
	return self
end

function jk.console.Terminal:forCurrent()
	do return nil end
end

function jk.console.Terminal:clear()
end

function jk.console.Terminal:moveTo(x, y)
end

function jk.console.Terminal:print(text)
end

function jk.console.Terminal:printTo(x, y, text)
end

function jk.console.Terminal:readKey()
end

function jk.console.Terminal:readLine()
end

function jk.console.Terminal:readLineWithoutEcho()
end

jk.console.ArgumentVector = {}
jk.console.ArgumentVector.__index = jk.console.ArgumentVector
_vm:set_metatable(jk.console.ArgumentVector, {})

function jk.console.ArgumentVector._create()
	local v = _vm:set_metatable({}, jk.console.ArgumentVector)
	return v
end

function jk.console.ArgumentVector:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.ArgumentVector'
	self['_isType.jk.console.ArgumentVector'] = true
	self.args = nil
	self.position = 0
	self.optionValue = nil
end

function jk.console.ArgumentVector:_construct0()
	jk.console.ArgumentVector._init(self)
	return self
end

function jk.console.ArgumentVector:forStringVector(args)
	local v = _g.jk.console.ArgumentVector._construct0(_g.jk.console.ArgumentVector._create())
	do v:setArgs(args) end
	do return v end
end

function jk.console.ArgumentVector:forArray(args)
	local v = _g.jk.console.ArgumentVector._construct0(_g.jk.console.ArgumentVector._create())
	local vv = {}
	if args ~= nil then
		local n = 0
		local m = #args
		do
			n = 0
			while n < m do
				local arg = args[n + 1]
				if arg ~= nil then
					do _g.jk.lang.Vector:append(vv, arg) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setArgs(vv) end
	do return v end
end

function jk.console.ArgumentVector:getCurrent()
	if not (self.args ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Vector:get(self.args, self.position) end
end

function jk.console.ArgumentVector:moveToNext()
	do self.position = self.position + 1 end
end

function jk.console.ArgumentVector:hasMore()
	if not (self.args ~= nil) then
		do return false end
	end
	if self.position < _g.jk.lang.Vector:getSize(self.args) then
		do return true end
	end
	do return false end
end

function jk.console.ArgumentVector:acceptFlag(flag)
	if not (flag ~= nil) then
		do return false end
	end
	do
		local cc = self:getCurrent()
		if not (cc ~= nil) then
			do return false end
		end
		if cc == "-" .. _g.jk.lang.String:safeString(flag) then
			do self:moveToNext() end
			do return true end
		end
		if cc == "--" .. _g.jk.lang.String:safeString(flag) then
			do self:moveToNext() end
			do return true end
		end
		do return false end
	end
end

function jk.console.ArgumentVector:acceptOption(str)
	if not _g.jk.lang.String:isNotEmpty(str) then
		do return false end
	end
	do
		local cc = self:getCurrent()
		if not (cc ~= nil) then
			do return false end
		end
		do
			local f1 = "-" .. _g.jk.lang.String:safeString(str)
			local f2 = "--" .. _g.jk.lang.String:safeString(str)
			if _g.jk.lang.String:startsWith(cc, _g.jk.lang.String:safeString(f1) .. "=", 0) then
				do self:moveToNext() end
				self.optionValue = _g.jk.lang.String:getEndOfString(cc, _g.jk.lang.String:getLength(f1) + 1)
				do return true end
			end
			if _g.jk.lang.String:startsWith(cc, _g.jk.lang.String:safeString(f2) .. "=", 0) then
				do self:moveToNext() end
				self.optionValue = _g.jk.lang.String:getEndOfString(cc, _g.jk.lang.String:getLength(f2) + 1)
				do return true end
			end
			if cc == f1 or cc == f2 then
				do self:moveToNext() end
				self.optionValue = self:getCurrent()
				if not (self.optionValue ~= nil) then
					do self.position = self.position - 1 end
				else
					do self:moveToNext() end
					do return true end
				end
			end
			do return false end
		end
	end
end

function jk.console.ArgumentVector:acceptValue(value)
	if not (value ~= nil) then
		do return false end
	end
	do
		local cc = self:getCurrent()
		if not (cc ~= nil) then
			do return false end
		end
		if cc == value then
			do self:moveToNext() end
			do return true end
		end
		do return false end
	end
end

function jk.console.ArgumentVector:acceptAnyValue()
	local cc = self:getCurrent()
	if not (cc ~= nil) then
		do return nil end
	end
	do self:moveToNext() end
	do return cc end
end

function jk.console.ArgumentVector:acceptParameter()
	local cc = self:getCurrent()
	if not (cc ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:startsWith(cc, "-", 0) then
		do return nil end
	end
	do self:moveToNext() end
	do return cc end
end

function jk.console.ArgumentVector:requireParameter(name)
	local v = self:acceptParameter()
	if not (v ~= nil) then
		do _g.jk.lang.Error:throw("missingValue", name) end
	end
	do return v end
end

function jk.console.ArgumentVector:acceptAllValues()
	local v = {}
	while true do
		local cc = self:acceptAnyValue()
		if cc ~= nil then
			do _g.jk.lang.Vector:append(v, cc) end
		else
			do break end
		end
	end
	do return v end
end

function jk.console.ArgumentVector:getArgs()
	do return self.args end
end

function jk.console.ArgumentVector:setArgs(v)
	self.args = v
	do return self end
end

function jk.console.ArgumentVector:getPosition()
	do return self.position end
end

function jk.console.ArgumentVector:setPosition(v)
	self.position = v
	do return self end
end

function jk.console.ArgumentVector:getOptionValue()
	do return self.optionValue end
end

function jk.console.ArgumentVector:setOptionValue(v)
	self.optionValue = v
	do return self end
end

jk.console.UsageInfo = {}
jk.console.UsageInfo.__index = jk.console.UsageInfo
_vm:set_metatable(jk.console.UsageInfo, {})

function jk.console.UsageInfo._create()
	local v = _vm:set_metatable({}, jk.console.UsageInfo)
	return v
end

function jk.console.UsageInfo:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.UsageInfo'
	self['_isType.jk.console.UsageInfo'] = true
	self.command = nil
	self.description = nil
	self.paramDesc = nil
	self.data = nil
end

function jk.console.UsageInfo:forCommand(command)
	local v = _g.jk.console.UsageInfo._construct0(_g.jk.console.UsageInfo._create())
	do v:setCommand(command) end
	do return v end
end

jk.console.UsageInfo.Parameter = {}
jk.console.UsageInfo.Parameter.__index = jk.console.UsageInfo.Parameter
_vm:set_metatable(jk.console.UsageInfo.Parameter, {})

function jk.console.UsageInfo.Parameter._create()
	local v = _vm:set_metatable({}, jk.console.UsageInfo.Parameter)
	return v
end

function jk.console.UsageInfo.Parameter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.UsageInfo.Parameter'
	self['_isType.jk.console.UsageInfo.Parameter'] = true
	self.name = nil
	self.description = nil
end

function jk.console.UsageInfo.Parameter:_construct0()
	jk.console.UsageInfo.Parameter._init(self)
	return self
end

jk.console.UsageInfo.Flag = {}
jk.console.UsageInfo.Flag.__index = jk.console.UsageInfo.Flag
_vm:set_metatable(jk.console.UsageInfo.Flag, {})

function jk.console.UsageInfo.Flag._create()
	local v = _vm:set_metatable({}, jk.console.UsageInfo.Flag)
	return v
end

function jk.console.UsageInfo.Flag:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.UsageInfo.Flag'
	self['_isType.jk.console.UsageInfo.Flag'] = true
	self.flag = nil
	self.description = nil
end

function jk.console.UsageInfo.Flag:_construct0()
	jk.console.UsageInfo.Flag._init(self)
	return self
end

jk.console.UsageInfo.Option = {}
jk.console.UsageInfo.Option.__index = jk.console.UsageInfo.Option
_vm:set_metatable(jk.console.UsageInfo.Option, {})

function jk.console.UsageInfo.Option._create()
	local v = _vm:set_metatable({}, jk.console.UsageInfo.Option)
	return v
end

function jk.console.UsageInfo.Option:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.UsageInfo.Option'
	self['_isType.jk.console.UsageInfo.Option'] = true
	self.name = nil
	self.value = nil
	self.description = nil
end

function jk.console.UsageInfo.Option:_construct0()
	jk.console.UsageInfo.Option._init(self)
	return self
end

function jk.console.UsageInfo:_construct0()
	jk.console.UsageInfo._init(self)
	self.data = {}
	self.paramDesc = "[parameters]"
	self.command = _g.jk.process.CurrentProcess:getProcessName()
	if _g.jk.lang.String:isEmpty(self.command) then
		self.command = "(command)"
	end
	return self
end

function jk.console.UsageInfo:ensureSection()
	if _g.jk.lang.Vector:getSize(self.data) < 1 then
		do self:addSection("Available parameters") end
	end
end

function jk.console.UsageInfo:addSection(name)
	do _g.jk.lang.Vector:append(self.data, name) end
end

function jk.console.UsageInfo:addParameter(name, description)
	do self:ensureSection() end
	do
		local p = _g.jk.console.UsageInfo.Parameter._construct0(_g.jk.console.UsageInfo.Parameter._create())
		p.name = name
		p.description = description
		do _g.jk.lang.Vector:append(self.data, p) end
	end
end

function jk.console.UsageInfo:addFlag(flag, description)
	do self:ensureSection() end
	do
		local f = _g.jk.console.UsageInfo.Flag._construct0(_g.jk.console.UsageInfo.Flag._create())
		f.flag = flag
		f.description = description
		do _g.jk.lang.Vector:append(self.data, f) end
	end
end

function jk.console.UsageInfo:addOption(name, value, description)
	do self:ensureSection() end
	do
		local o = _g.jk.console.UsageInfo.Option._construct0(_g.jk.console.UsageInfo.Option._create())
		o.name = name
		o.value = value
		o.description = description
		do _g.jk.lang.Vector:append(self.data, o) end
	end
end

function jk.console.UsageInfo:toString()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString("Usage: ") end
	do sb:appendString(self.command) end
	if _g.jk.lang.String:isEmpty(self.paramDesc) == false then
		do sb:appendCharacter(32) end
		do sb:appendString(self.paramDesc) end
	end
	do sb:appendCharacter(10) end
	do sb:appendCharacter(10) end
	if _g.jk.lang.String:isEmpty(self.description) == false then
		do sb:appendString(self.description) end
		do sb:appendCharacter(10) end
		do sb:appendCharacter(10) end
	end
	do
		local longest = 0
		local db = true
		if self.data ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.data)
			do
				n = 0
				while n < m do
					local o = self.data[n + 1]
					if o ~= nil then
						if (_vm:to_table_with_key(o, '_isType.jk.console.UsageInfo.Parameter') ~= nil) then
							local nn = o.name
							if not (nn == nil) then
								local ll = _g.jk.lang.String:getLength(nn)
								if ll > longest then
									longest = ll
								end
							end
						elseif (_vm:to_table_with_key(o, '_isType.jk.console.UsageInfo.Flag') ~= nil) then
							local ff = o.flag
							if not (ff == nil) then
								local ll = _g.jk.lang.String:getLength(ff) + 1
								if ll > longest then
									longest = ll
								end
							end
						elseif (_vm:to_table_with_key(o, '_isType.jk.console.UsageInfo.Option') ~= nil) then
							local name = o.name
							local value = o.value
							local ll = 1 + _g.jk.lang.String:getLength(name) + 2 + _g.jk.lang.String:getLength(value) + 1
							if ll > longest then
								longest = ll
							end
						end
					end
					do n = n + 1 end
				end
			end
		end
		if longest < 30 then
			longest = 30
		end
		if self.data ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(self.data)
			do
				n2 = 0
				while n2 < m2 do
					local o = self.data[n2 + 1]
					if o ~= nil then
						if (_vm:get_variable_type(o) == 'string') or (_vm:to_table_with_key(o, '_isType.jk.lang.StringObject') ~= nil) then
							if db == false then
								do sb:appendCharacter(10) end
							end
							do sb:appendString(_g.jk.lang.String:asString(o)) end
							do sb:appendCharacter(58) end
							do sb:appendCharacter(10) end
							do sb:appendCharacter(10) end
							db = true
						elseif (_vm:to_table_with_key(o, '_isType.jk.console.UsageInfo.Parameter') ~= nil) then
							local p = o
							do sb:appendString("  ") end
							do sb:appendString(_g.jk.text.StringUtil:padToLength(p.name, longest, -1, 32)) end
							if _g.jk.lang.String:isEmpty(p.description) == false then
								do sb:appendString(" - ") end
								do sb:appendString(p.description) end
							end
							do sb:appendCharacter(10) end
							db = false
						elseif (_vm:to_table_with_key(o, '_isType.jk.console.UsageInfo.Flag') ~= nil) then
							local p = o
							do sb:appendString("  -") end
							do sb:appendString(_g.jk.text.StringUtil:padToLength(p.flag, longest - 1, -1, 32)) end
							if _g.jk.lang.String:isEmpty(p.description) == false then
								do sb:appendString(" - ") end
								do sb:appendString(p.description) end
							end
							do sb:appendCharacter(10) end
							db = false
						elseif (_vm:to_table_with_key(o, '_isType.jk.console.UsageInfo.Option') ~= nil) then
							local p = o
							do sb:appendString("  ") end
							do sb:appendString(_g.jk.text.StringUtil:padToLength("-" .. _g.jk.lang.String:safeString(p.name) .. "=[" .. _g.jk.lang.String:safeString(p.value) .. "]", longest, -1, 32)) end
							if _g.jk.lang.String:isEmpty(p.description) == false then
								do sb:appendString(" - ") end
								do sb:appendString(p.description) end
							end
							do sb:appendCharacter(10) end
							db = false
						end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function jk.console.UsageInfo:getCommand()
	do return self.command end
end

function jk.console.UsageInfo:setCommand(v)
	self.command = v
	do return self end
end

function jk.console.UsageInfo:getDescription()
	do return self.description end
end

function jk.console.UsageInfo:setDescription(v)
	self.description = v
	do return self end
end

function jk.console.UsageInfo:getParamDesc()
	do return self.paramDesc end
end

function jk.console.UsageInfo:setParamDesc(v)
	self.paramDesc = v
	do return self end
end

jk.console.CommandLineArgument = {}
jk.console.CommandLineArgument.__index = jk.console.CommandLineArgument
_vm:set_metatable(jk.console.CommandLineArgument, {})

function jk.console.CommandLineArgument._create()
	local v = _vm:set_metatable({}, jk.console.CommandLineArgument)
	return v
end

function jk.console.CommandLineArgument:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.CommandLineArgument'
	self['_isType.jk.console.CommandLineArgument'] = true
	self.arg = nil
	self.parameter = nil
	self.flag = nil
	self.key = nil
	self.value = nil
end

function jk.console.CommandLineArgument:_construct0()
	jk.console.CommandLineArgument._init(self)
	return self
end

function jk.console.CommandLineArgument:_construct5(arg, parameter, flag, key, value)
	jk.console.CommandLineArgument._init(self)
	self.arg = arg
	self.parameter = parameter
	self.flag = flag
	self.key = key
	self.value = value
	return self
end

function jk.console.CommandLineArgument:isParameter()
	if self.parameter ~= nil then
		do return true end
	end
	do return false end
end

function jk.console.CommandLineArgument:isFlag1()
	if self.flag ~= nil then
		do return true end
	end
	do return false end
end

function jk.console.CommandLineArgument:isOption1()
	if self.key ~= nil then
		do return true end
	end
	do return false end
end

function jk.console.CommandLineArgument:isFlag2(text)
	if text ~= nil and _g.jk.lang.String:equalsIgnoreCase(text, self.flag) then
		do return true end
	end
	do return false end
end

function jk.console.CommandLineArgument:isOption2(text)
	if text ~= nil and _g.jk.lang.String:equalsIgnoreCase(text, self.key) then
		do return true end
	end
	do return false end
end

function jk.console.CommandLineArgument:hasValue()
	if self.value ~= nil then
		do return true end
	end
	do return false end
end

function jk.console.CommandLineArgument:getKey()
	do return self.key end
end

function jk.console.CommandLineArgument:getComplete()
	do return self.arg end
end

function jk.console.CommandLineArgument:getStringValue()
	do return self.value end
end

function jk.console.CommandLineArgument:getIntegerValue()
	do return _g.jk.lang.Integer:asInteger(self.value) end
end

function jk.console.CommandLineArgument:getBooleanValue()
	do return _g.jk.lang.Boolean:asBoolean(self.value, false) end
end

function jk.console.CommandLineArgument:reportAsUnsupported(ctx)
	do _g.jk.log.Log:error(ctx, "Unsupported command line parameter: `" .. _g.jk.lang.String:safeString(self.arg) .. "'") end
end

jk.console.StdoutForSushi = {}
jk.console.StdoutForSushi.__index = jk.console.StdoutForSushi
_vm:set_metatable(jk.console.StdoutForSushi, {})

function jk.console.StdoutForSushi._create()
	local v = _vm:set_metatable({}, jk.console.StdoutForSushi)
	return v
end

function jk.console.StdoutForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.StdoutForSushi'
	self['_isType.jk.console.StdoutForSushi'] = true
	self['_isType.jk.io.Writer'] = true
	self['_isType.jk.io.PrintWriter'] = true
end

function jk.console.StdoutForSushi:_construct0()
	jk.console.StdoutForSushi._init(self)
	return self
end

function jk.console.StdoutForSushi:write(buf, size)
	local v = 0
	do v = _io:write_to_handle(1, buf, size) end
	do return v end
end

function jk.console.StdoutForSushi:print(str)
	do _io:write_to_stdout(str) end
	do return true end
end

function jk.console.StdoutForSushi:println(str)
	do _io:write_to_stdout(str .. "\n") end
	do return true end
end

jk.console.StdinForSushi = {}
jk.console.StdinForSushi.__index = jk.console.StdinForSushi
_vm:set_metatable(jk.console.StdinForSushi, {})

function jk.console.StdinForSushi._create()
	local v = _vm:set_metatable({}, jk.console.StdinForSushi)
	return v
end

function jk.console.StdinForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.console.StdinForSushi'
	self['_isType.jk.console.StdinForSushi'] = true
	self['_isType.jk.io.Reader'] = true
end

function jk.console.StdinForSushi:_construct0()
	jk.console.StdinForSushi._init(self)
	return self
end

function jk.console.StdinForSushi:read(buf)
	if buf == nil then
		do return 0 end
	end
	do
		local v = 0
		do v = _io:read_from_handle(0, buf) end
		do return v end
	end
end
jk = jk or {}

jk.base64 = jk.base64 or {}

jk.base64.Base64Decoder = {}
jk.base64.Base64Decoder.__index = jk.base64.Base64Decoder
_vm:set_metatable(jk.base64.Base64Decoder, {})

function jk.base64.Base64Decoder._create()
	local v = _vm:set_metatable({}, jk.base64.Base64Decoder)
	return v
end

function jk.base64.Base64Decoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.base64.Base64Decoder'
	self['_isType.jk.base64.Base64Decoder'] = true
end

function jk.base64.Base64Decoder:_construct0()
	jk.base64.Base64Decoder._init(self)
	return self
end

function jk.base64.Base64Decoder:fromUrlSafeFormat(str)
	local v = str
	if not (v ~= nil) then
		do return nil end
	end
	v = _g.jk.lang.String:replaceCharacter(v, 45, 43)
	v = _g.jk.lang.String:replaceCharacter(v, 95, 47)
	do
		local mod = _util:convert_to_integer(_g.jk.lang.String:getLength(v) % 4)
		if mod == 1 then
			v = _g.jk.lang.String:safeString(v) .. "==="
		elseif mod == 2 then
			v = _g.jk.lang.String:safeString(v) .. "=="
		elseif mod == 3 then
			v = _g.jk.lang.String:safeString(v) .. "="
		end
		do return v end
	end
end

function jk.base64.Base64Decoder:appendByte(buffer, byte)
	local nbyte = _g.jk.lang.Buffer:allocate(1)
	do _g.jk.lang.Buffer:setByte(nbyte, 0, byte) end
	do return _g.jk.lang.Buffer:append(buffer, nbyte, _g.jk.lang.Buffer:getSize(nbyte)) end
end

function jk.base64.Base64Decoder:fromLookupChar(ascii)
	local c = 0
	if ascii == 43 then
		c = 62
	elseif ascii == 47 then
		c = 63
	elseif ascii >= 48 and ascii <= 57 then
		c = ascii + 4
	elseif ascii >= 65 and ascii <= 90 then
		c = ascii - 65
	elseif ascii >= 97 and ascii <= 122 then
		c = ascii - 71
	end
	do return c end
end

function jk.base64.Base64Decoder:decode(text)
	if not (text ~= nil) then
		do return nil end
	end
	do
		local data = _util:allocate_buffer(0)
		local iter = _g.jk.lang.String:iterate(text)
		if iter ~= nil then
			local ch = 0
			while (function()
				ch = iter:getNextChar()
				do return ch end
			end)() > 0 do
				local c1 = 0
				local c2 = 0
				local c3 = 0
				local c4 = 0
				local byte1 = 0
				local byte2 = 0
				local byte3 = 0
				c1 = _g.jk.base64.Base64Decoder:fromLookupChar(ch)
				c2 = _g.jk.base64.Base64Decoder:fromLookupChar((function()
					ch = iter:getNextChar()
					do return ch end
				end)())
				byte1 = _vm:bitwise_left_shift(c1, 2) + _vm:bitwise_right_shift(c2, 4)
				data = _g.jk.base64.Base64Decoder:appendByte(data, byte1)
				ch = iter:getNextChar()
				if ch == 61 then
					do break end
				else
					c3 = _g.jk.base64.Base64Decoder:fromLookupChar(ch)
				end
				byte2 = _vm:bitwise_left_shift(_vm:bitwise_and(c2, 15), 4) + _vm:bitwise_right_shift(c3, 2)
				data = _g.jk.base64.Base64Decoder:appendByte(data, byte2)
				ch = iter:getNextChar()
				if ch == 61 then
					do break end
				else
					c4 = _g.jk.base64.Base64Decoder:fromLookupChar(ch)
				end
				byte3 = _vm:bitwise_left_shift(_vm:bitwise_and(c3, 3), 6) + c4
				data = _g.jk.base64.Base64Decoder:appendByte(data, byte3)
			end
		end
		do return data end
	end
end

jk.base64.Base64Encoder = {}
jk.base64.Base64Encoder.__index = jk.base64.Base64Encoder
_vm:set_metatable(jk.base64.Base64Encoder, {})

function jk.base64.Base64Encoder._create()
	local v = _vm:set_metatable({}, jk.base64.Base64Encoder)
	return v
end

function jk.base64.Base64Encoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.base64.Base64Encoder'
	self['_isType.jk.base64.Base64Encoder'] = true
end

function jk.base64.Base64Encoder:_construct0()
	jk.base64.Base64Encoder._init(self)
	return self
end

function jk.base64.Base64Encoder:toUrlSafeFormat(str)
	local v = str
	if not (v ~= nil) then
		do return nil end
	end
	v = _g.jk.lang.String:replaceString(v, "=", "")
	v = _g.jk.lang.String:replaceCharacter(v, 43, 45)
	v = _g.jk.lang.String:replaceCharacter(v, 47, 95)
	do return v end
end

function jk.base64.Base64Encoder:encodeString(str)
	if not (str ~= nil) then
		do return nil end
	end
	do return _g.jk.base64.Base64Encoder:encode(_g.jk.lang.String:toUTF8Buffer(str)) end
end

function jk.base64.Base64Encoder:encode(buffer)
	if not (buffer ~= nil) then
		do return nil end
	end
	do
		local length = _g.jk.lang.Buffer:getSize(buffer)
		local dst = _g.jk.lang.Buffer:allocate(_util:convert_to_integer((length + 2) / 3) * 4)
		local x = 0
		local dstIndex = 0
		local state = 0
		local old = 0
		do
			local srcIndex = 0
			while srcIndex < length do
				x = buffer[srcIndex + 1]
				do
					local v = (function() state = state + 1 return state end)()
					if v == 1 then
						dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(_g.jk.base64.Base64Encoder:toASCIIChar(_vm:bitwise_and(_vm:bitwise_right_shift(x, 2), 63)))
					elseif v == 2 then
						dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(_g.jk.base64.Base64Encoder:toASCIIChar(_vm:bitwise_or(_vm:bitwise_and(_vm:bitwise_left_shift(old, 4), 48), _vm:bitwise_and(_vm:bitwise_right_shift(x, 4), 15))))
					elseif v == 3 then
						dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(_g.jk.base64.Base64Encoder:toASCIIChar(_vm:bitwise_or(_vm:bitwise_and(_vm:bitwise_left_shift(old, 2), 60), _vm:bitwise_and(_vm:bitwise_right_shift(x, 6), 3))))
						dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(_g.jk.base64.Base64Encoder:toASCIIChar(_vm:bitwise_and(x, 63)))
						state = 0
					end
				end
				old = x
				do srcIndex = srcIndex + 1 end
			end
		end
		do
			local v2 = state
			if v2 == 1 then
				dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(_g.jk.base64.Base64Encoder:toASCIIChar(_vm:bitwise_and(_vm:bitwise_left_shift(old, 4), 48)))
				dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(61)
				dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(61)
			elseif v2 == 2 then
				dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(_g.jk.base64.Base64Encoder:toASCIIChar(_vm:bitwise_and(_vm:bitwise_left_shift(old, 2), 60)))
				dst[(function() local v = dstIndex dstIndex = dstIndex + 1 return v end)() + 1] = _util:convert_to_integer(61)
			end
		end
		do return _g.jk.lang.String:forBuffer(dst, "ASCII") end
	end
end

function jk.base64.Base64Encoder:toASCIIChar(lookup)
	local c = 0
	if lookup < 0 or lookup > 63 then
		do return c end
	end
	if lookup <= 25 then
		c = lookup + 65
	elseif lookup <= 51 then
		c = lookup + 71
	elseif lookup <= 61 then
		c = lookup - 4
	elseif lookup == 62 then
		c = _util:convert_to_integer(43)
	elseif lookup == 63 then
		c = _util:convert_to_integer(47)
	end
	do return c end
end
jk = jk or {}

jk.json = jk.json or {}

jk.json.JSONObject = {}

jk.json.JSONParser = {}
jk.json.JSONParser.__index = jk.json.JSONParser
_vm:set_metatable(jk.json.JSONParser, {})

function jk.json.JSONParser._create()
	local v = _vm:set_metatable({}, jk.json.JSONParser)
	return v
end

function jk.json.JSONParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.json.JSONParser'
	self['_isType.jk.json.JSONParser'] = true
	self.iterator = nil
end

function jk.json.JSONParser:_construct0()
	jk.json.JSONParser._init(self)
	return self
end

jk.json.JSONParser.NullObject = {}
jk.json.JSONParser.NullObject.__index = jk.json.JSONParser.NullObject
_vm:set_metatable(jk.json.JSONParser.NullObject, {})

function jk.json.JSONParser.NullObject._create()
	local v = _vm:set_metatable({}, jk.json.JSONParser.NullObject)
	return v
end

function jk.json.JSONParser.NullObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.json.JSONParser.NullObject'
	self['_isType.jk.json.JSONParser.NullObject'] = true
end

function jk.json.JSONParser.NullObject:_construct0()
	jk.json.JSONParser.NullObject._init(self)
	return self
end

function jk.json.JSONParser:parse(data)
	if not (data ~= nil) then
		do return nil end
	end
	if _util:is_buffer(data) then
		do return _g.jk.json.JSONParser:parseBuffer(data) end
	end
	if (_vm:get_variable_type(data) == 'string') then
		do return _g.jk.json.JSONParser:parseString(data) end
	end
	if (_vm:to_table_with_key(data, '_isType.jk.fs.File') ~= nil) then
		do return _g.jk.json.JSONParser:parseFile(data) end
	end
	do return nil end
end

function jk.json.JSONParser:parseBuffer(buffer)
	if buffer == nil then
		do return nil end
	end
	do return _g.jk.json.JSONParser:forBuffer(buffer):acceptObject() end
end

function jk.json.JSONParser:parseString(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return nil end
	end
	do return _g.jk.json.JSONParser:forString(str):acceptObject() end
end

function jk.json.JSONParser:parseFile(file)
	if file == nil then
		do return nil end
	end
	do return _g.jk.json.JSONParser:parseString(file:getContentsUTF8()) end
end

function jk.json.JSONParser:forString(str)
	local v = _g.jk.json.JSONParser._construct0(_g.jk.json.JSONParser._create())
	do v:setDataString(str) end
	do return v end
end

function jk.json.JSONParser:forBuffer(buffer)
	local v = _g.jk.json.JSONParser._construct0(_g.jk.json.JSONParser._create())
	do v:setDataBuffer(buffer) end
	do return v end
end

function jk.json.JSONParser:setDataString(str)
	self.iterator = _g.jk.lang.CharacterIteratorForString:forString(str)
	do self.iterator:moveToNextChar() end
end

function jk.json.JSONParser:setDataBuffer(buffer)
	self.iterator = _g.jk.lang.CharacterIteratorForBuffer:forBuffer(buffer)
	do self.iterator:moveToNextChar() end
end

function jk.json.JSONParser:skipSpaces()
	while true do
		if self.iterator:hasEnded() then
			do break end
		end
		do
			local c = self.iterator:getCurrentChar()
			if c == 32 or c == 9 or c == 13 or c == 10 then
				do self.iterator:moveToNextChar() end
				goto _continue1
			end
			do break end
		end
		::_continue1::
	end
end

function jk.json.JSONParser:acceptChar(c)
	do self:skipSpaces() end
	if self.iterator:getCurrentChar() == c then
		do self.iterator:moveToNextChar() end
		do return true end
	end
	do return false end
end

function jk.json.JSONParser:acceptString()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 39 and ss ~= 34 then
			do return nil end
		end
		do
			local i = 0
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			while true do
				local c = self.iterator:getNextChar()
				do i = i + 1 end
				if _g.jk.lang.Character:isEOF(c) then
					do
						local n = 0
						while n < i do
							do self.iterator:moveToPreviousChar() end
							do n = n + 1 end
						end
					end
					do return nil end
				end
				if c == ss then
					do self.iterator:moveToNextChar() end
					do break end
				end
				if c == 92 then
					c = self.iterator:getNextChar()
					if c == 117 then
						local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						local x = 0
						while x < 4 do
							if self.iterator:hasEnded() then
								do break end
							end
							do v:appendCharacter(self.iterator:getNextChar()) end
							do x = x + 1 end
						end
						c = _g.jk.lang.String:toIntegerFromHex(v:toString())
					elseif c == 116 then
						c = 9
					elseif c == 114 then
						c = 13
					elseif c == 110 then
						c = 10
					elseif c == 98 then
						c = 8
					elseif c == 102 then
						c = 12
					end
				end
				do sb:appendCharacter(c) end
			end
			do return sb:toString() end
		end
	end
end

function jk.json.JSONParser:acceptBoolean()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 116 and ss ~= 102 then
			do return nil end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			do
				local li = 5
				if ss == 116 then
					li = 4
				end
				do
					local btc = 0
					while true do
						local c = self.iterator:getNextChar()
						do btc = btc + 1 end
						if c ~= 97 and c ~= 108 and c ~= 115 and c ~= 101 and c ~= 114 and c ~= 117 then
							do self.iterator:moveToNextChar() end
							do btc = btc + 1 end
							do break end
						end
						do sb:appendCharacter(c) end
						if sb:count() == li then
							do self.iterator:moveToNextChar() end
							do btc = btc + 1 end
							do break end
						end
					end
					do
						local v = sb:toString()
						if li == 4 and "true" == v then
							do return _g.jk.lang.Boolean:asObject(true) end
						end
						if li == 5 and "false" == v then
							do return _g.jk.lang.Boolean:asObject(false) end
						end
						do
							local i = 0
							while i < btc do
								do self.iterator:moveToPreviousChar() end
								do i = i + 1 end
							end
							do return nil end
						end
					end
				end
			end
		end
	end
end

function jk.json.JSONParser:acceptNumber()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 45 and ss ~= 43 and ss ~= 46 and (ss < 48 or ss > 57) then
			do return nil end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			while true do
				local c = self.iterator:getNextChar()
				if c ~= 46 and c ~= 101 and c ~= 69 and c ~= 45 and (c < 48 or c > 57) then
					do break end
				end
				do sb:appendCharacter(c) end
			end
			do
				local s = sb:toString()
				if _g.jk.lang.String:getIndexOfCharacter(s, 46, 0) > -1 then
					do return _g.jk.lang.Double:asObject(_g.jk.lang.Double:asDouble(s)) end
				end
				do
					local value = _g.jk.lang.String:toLong(s)
					if value >= -2147483648 and value <= 2147483647 then
						do return _g.jk.lang.Integer:asObject(value) end
					end
					do return _g.jk.lang.LongInteger:asObject(value) end
				end
			end
		end
	end
end

function jk.json.JSONParser:acceptNull()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 110 then
			do return nil end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			do
				local btc = 0
				while true do
					local c = self.iterator:getNextChar()
					do btc = btc + 1 end
					if c ~= 117 and c ~= 108 then
						do self.iterator:moveToNextChar() end
						do btc = btc + 1 end
						do break end
					end
					do sb:appendCharacter(c) end
					if sb:count() == 4 then
						do self.iterator:moveToNextChar() end
						do btc = btc + 1 end
						do break end
					end
				end
				if "null" == sb:toString() then
					do return _g.jk.json.JSONParser.NullObject._construct0(_g.jk.json.JSONParser.NullObject._create()) end
				end
				do
					local i = 0
					while i < btc do
						do self.iterator:moveToPreviousChar() end
						do i = i + 1 end
					end
					do return nil end
				end
			end
		end
	end
end

function jk.json.JSONParser:acceptObject()
	if self:acceptChar(91) then
		local v = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
		while true do
			if self:acceptChar(93) then
				do break end
			end
			do
				local o = self:acceptObject()
				if o == nil then
					do return nil end
				end
				do v:appendObject(o) end
				do self:acceptChar(44) end
			end
		end
		do return v end
	end
	if self:acceptChar(123) then
		local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		while true do
			if self:acceptChar(125) then
				do break end
			end
			do
				local key = self:acceptString()
				if key == nil then
					do return nil end
				end
				if self:acceptChar(58) == false then
					do return nil end
				end
				do
					local val = self:acceptObject()
					if val == nil then
						do return nil end
					end
					if (_vm:to_table_with_key(val, '_isType.jk.json.JSONParser.NullObject') ~= nil) then
						do v:setObject(key, nil) end
					else
						do v:setObject(key, val) end
					end
					do self:acceptChar(44) end
				end
			end
		end
		do return v end
	end
	do
		local s = self:acceptString()
		if s ~= nil then
			do return s end
		end
		do
			local b = self:acceptBoolean()
			if b ~= nil then
				do return b end
			end
			do
				local n = self:acceptNull()
				if n ~= nil then
					do return n end
				end
				do
					local v = self:acceptNumber()
					if v ~= nil then
						do return v end
					end
					do return nil end
				end
			end
		end
	end
end

function jk.json.JSONParser:getNextToken()
	if self:acceptChar(91) then
		do return "[" end
	end
	if self:acceptChar(93) then
		do return "]" end
	end
	if self:acceptChar(123) then
		do return "{" end
	end
	if self:acceptChar(125) then
		do return "}" end
	end
	if self:acceptChar(44) then
		do return "," end
	end
	do
		local s = self:acceptString()
		if s ~= nil then
			do return s end
		end
		do
			local b = self:acceptBoolean()
			if b ~= nil then
				do return b end
			end
			do
				local n = self:acceptNull()
				if n ~= nil then
					do return n end
				end
				do
					local v = self:acceptNumber()
					if v ~= nil then
						do return v end
					end
					do return nil end
				end
			end
		end
	end
end

function jk.json.JSONParser:pushData(string)
	if not (string ~= nil) then
		do return end
	end
	if self.iterator == nil then
		do self:setDataString(string) end
		do return end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		while true do
			local c = self.iterator:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			do sb:appendCharacter(c) end
		end
		do sb:appendString(string) end
		do self:setDataString(sb:toString()) end
	end
end

jk.json.JSONObjectAdapterExplicit = {}
jk.json.JSONObjectAdapterExplicit.__index = jk.json.JSONObjectAdapterExplicit
_vm:set_metatable(jk.json.JSONObjectAdapterExplicit, {})

function jk.json.JSONObjectAdapterExplicit._create()
	local v = _vm:set_metatable({}, jk.json.JSONObjectAdapterExplicit)
	return v
end

function jk.json.JSONObjectAdapterExplicit:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.json.JSONObjectAdapterExplicit'
	self['_isType.jk.json.JSONObjectAdapterExplicit'] = true
	self['_isType.jk.json.JSONObject'] = true
end

function jk.json.JSONObjectAdapterExplicit:_construct0()
	jk.json.JSONObjectAdapterExplicit._init(self)
	return self
end

function jk.json.JSONObjectAdapterExplicit:asJsonValue(value)
	if not (value ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(value, '_isType.jk.json.JSONObject') ~= nil) then
		local oj = value
		do return oj:toJsonObject() end
	end
	do return value end
end

function jk.json.JSONObjectAdapterExplicit:toDynamicMap()
	do return _vm:to_table_with_key(self:toJsonObject(), '_isType.jk.lang.DynamicMap') end
end

function jk.json.JSONObjectAdapterExplicit:toObjectMap()
	local dm = self:toDynamicMap()
	if not (dm ~= nil) then
		do return nil end
	end
	do return dm:toObjectMap() end
end

function jk.json.JSONObjectAdapterExplicit:toJsonObject()
end

function jk.json.JSONObjectAdapterExplicit:fromJsonObject(o)
end

jk.json.JSONObjectAdapter = {}
jk.json.JSONObjectAdapter.__index = jk.json.JSONObjectAdapter
_vm:set_metatable(jk.json.JSONObjectAdapter, {})

function jk.json.JSONObjectAdapter._create()
	local v = _vm:set_metatable({}, jk.json.JSONObjectAdapter)
	return v
end

function jk.json.JSONObjectAdapter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.json.JSONObjectAdapter'
	self['_isType.jk.json.JSONObjectAdapter'] = true
	self['_isType.jk.json.JSONObject'] = true
end

function jk.json.JSONObjectAdapter:_construct0()
	jk.json.JSONObjectAdapter._init(self)
	return self
end

function jk.json.JSONObjectAdapter:asJsonValue(value)
	if not (value ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(value, '_isType.jk.json.JSONObject') ~= nil) then
		local oj = value
		do return oj:toJsonObject() end
	end
	do return value end
end

function jk.json.JSONObjectAdapter:toDynamicMap()
	do return _vm:to_table_with_key(self:toJsonObject(), '_isType.jk.lang.DynamicMap') end
end

function jk.json.JSONObjectAdapter:toObjectMap()
	local dm = self:toDynamicMap()
	if not (dm ~= nil) then
		do return nil end
	end
	do return dm:toObjectMap() end
end

function jk.json.JSONObjectAdapter:toJsonObject()
end

function jk.json.JSONObjectAdapter:fromJsonObject(o)
end

jk.json.JSONEncoder = {}
jk.json.JSONEncoder.__index = jk.json.JSONEncoder
_vm:set_metatable(jk.json.JSONEncoder, {})

function jk.json.JSONEncoder._create()
	local v = _vm:set_metatable({}, jk.json.JSONEncoder)
	return v
end

function jk.json.JSONEncoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.json.JSONEncoder'
	self['_isType.jk.json.JSONEncoder'] = true
	self.niceFormatting = true
	self.stringFormattedBoolean = false
	self.stringFormattedNumber = false
	self.newJSONFormat = true
	self.encodeNullAsNull = false
	self.isNewLine = true
	self.mysb = nil
end

function jk.json.JSONEncoder:_construct0()
	jk.json.JSONEncoder._init(self)
	return self
end

function jk.json.JSONEncoder:print(line, indent, startline, endline, sb)
	if startline and self.isNewLine == false then
		if self.niceFormatting then
			do sb:appendCharacter(10) end
		end
		self.isNewLine = true
	end
	if self.isNewLine and self.niceFormatting then
		do
			local n = 0
			while n < indent do
				do sb:appendCharacter(9) end
				do n = n + 1 end
			end
		end
	end
	do sb:appendString(line) end
	if endline then
		if self.niceFormatting then
			do sb:appendCharacter(10) end
		end
		self.isNewLine = true
	else
		self.isNewLine = false
	end
end

function jk.json.JSONEncoder:encodeArray(cc, indent, sb)
	do self:print("[", indent, false, true, sb) end
	do
		local first = true
		if cc ~= nil then
			local n = 0
			local m = #cc
			do
				n = 0
				while n < m do
					local o = cc[n + 1]
					if o ~= nil then
						if first == false then
							do self:print(",", indent, false, true, sb) end
						end
						do self:encodeObject(o, indent + 1, sb) end
						first = false
					end
					do n = n + 1 end
				end
			end
		end
		do self:print("]", indent, true, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeDynamicVector(cc, indent, sb)
	do self:print("[", indent, false, true, sb) end
	do
		local first = true
		local array = cc:toVector()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local o = array[n + 1]
					if o ~= nil then
						if first == false then
							do self:print(",", indent, false, true, sb) end
						end
						do self:encodeObject(o, indent + 1, sb) end
						first = false
					end
					do n = n + 1 end
				end
			end
		end
		do self:print("]", indent, true, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeVector(cc, indent, sb)
	do self:print("[", indent, false, true, sb) end
	do
		local first = true
		if cc ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(cc)
			do
				n = 0
				while n < m do
					local o = cc[n + 1]
					if o ~= nil then
						if first == false then
							do self:print(",", indent, false, true, sb) end
						end
						do self:encodeObject(o, indent + 1, sb) end
						first = false
					end
					do n = n + 1 end
				end
			end
		end
		do self:print("]", indent, true, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeMap(map, indent, sb)
	do self:print("{", indent, false, true, sb) end
	do
		local first = true
		local it = _g.jk.lang.Map:iterateKeys(map)
		while it ~= nil do
			local keyo = it:next()
			if not (keyo ~= nil) then
				do break end
			end
			do
				local key = _g.jk.lang.String:asString(keyo)
				if not (key ~= nil) then
					goto _continue2
				end
				if not first then
					do self:print(",", indent, false, true, sb) end
				end
				do self:encodeString(key, indent + 1, sb) end
				if self.niceFormatting then
					do sb:appendString(" : ") end
				else
					do sb:appendCharacter(58) end
				end
				do self:encodeObject(map[keyo], indent + 1, sb) end
				first = false
			end
			::_continue2::
		end
		do self:print("}", indent, true, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeDynamicMap(map, indent, sb)
	do self:print("{", indent, false, true, sb) end
	do
		local first = true
		local it = map:iterateKeys()
		while it ~= nil do
			local key = it:next()
			if not (key ~= nil) then
				do break end
			end
			if first == false then
				do self:print(",", indent, false, true, sb) end
			end
			do self:encodeString(key, indent + 1, sb) end
			if self.niceFormatting then
				do sb:appendString(" : ") end
			else
				do sb:appendCharacter(58) end
			end
			do self:encodeObject(map:get(key), indent + 1, sb) end
			first = false
		end
		do self:print("}", indent, true, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeKeyValueList(list, indent, sb)
	do self:print("{", indent, false, true, sb) end
	do
		local first = true
		local it = list:iterate()
		while it ~= nil do
			local pair = it:next()
			if pair == nil then
				do break end
			end
			if first == false then
				do self:print(",", indent, false, true, sb) end
			end
			do self:encodeString(pair.key, indent + 1, sb) end
			if self.niceFormatting then
				do sb:appendString(" : ") end
			else
				do sb:appendCharacter(58) end
			end
			do self:encodeString(pair.value, indent + 1, sb) end
			first = false
		end
		do self:print("}", indent, true, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeString(s, indent, sb)
	if self.mysb == nil then
		self.mysb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	else
		do self.mysb:clear() end
	end
	do self.mysb:appendCharacter(34) end
	do
		local it = _g.jk.lang.String:iterate(s)
		while true do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if self.newJSONFormat then
				if c == 9 then
					do self.mysb:appendString("\\t") end
					goto _continue3
				end
				if c == 10 then
					do self.mysb:appendString("\\n") end
					goto _continue3
				end
				if c == 13 then
					do self.mysb:appendString("\\r") end
					goto _continue3
				end
				if c == 8 then
					do self.mysb:appendString("\\b") end
					goto _continue3
				end
				if c == 12 then
					do self.mysb:appendString("\\f") end
					goto _continue3
				end
			end
			if c == 34 then
				do self.mysb:appendCharacter(92) end
			elseif c == 92 then
				do self.mysb:appendCharacter(92) end
			end
			do self.mysb:appendCharacter(c) end
			::_continue3::
		end
		do self.mysb:appendCharacter(34) end
		do self:print(self.mysb:toString(), indent, false, false, sb) end
	end
end

function jk.json.JSONEncoder:encodeBoolean(b, indent, sb)
	if self.mysb == nil then
		self.mysb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	else
		do self.mysb:clear() end
	end
	if self.stringFormattedBoolean then
		do self.mysb:appendCharacter(34) end
		do self.mysb:appendString(_g.jk.lang.String:forBoolean(b)) end
		do self.mysb:appendCharacter(34) end
	else
		do self.mysb:appendString(_g.jk.lang.String:forBoolean(b)) end
	end
	do self:print(self.mysb:toString(), indent, false, false, sb) end
end

function jk.json.JSONEncoder:encodeNumber(o, indent, sb)
	if self.mysb == nil then
		self.mysb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	else
		do self.mysb:clear() end
	end
	if self.stringFormattedNumber then
		do self.mysb:appendCharacter(34) end
		do self.mysb:appendString(_g.jk.lang.String:asString(o)) end
		do self.mysb:appendCharacter(34) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.IntegerObject') ~= nil) then
		do self.mysb:appendInteger(_g.jk.lang.Integer:asInteger(o)) end
	elseif _vm:to_table_with_key(o, '_isType.jk.lang.LongIntegerObject') ~= nil then
		do self.mysb:appendLong(_g.jk.lang.LongInteger:asLong(o)) end
	elseif _vm:to_table_with_key(o, '_isType.jk.lang.DoubleObject') ~= nil then
		do self.mysb:appendDouble(_g.jk.lang.Double:asDouble(o)) end
	else
		do self.mysb:appendString("") end
	end
	do self:print(self.mysb:toString(), indent, false, false, sb) end
end

function jk.json.JSONEncoder:encodeObject(o, indent, sb)
	if not (o ~= nil) then
		if self.encodeNullAsNull then
			do self:print("null", indent, false, false, sb) end
		else
			do self:encodeString("", indent, sb) end
		end
	elseif (_vm:to_table_with_key(o, '_isType.jk.json.JSONObject') ~= nil) then
		do self:encodeObject(o:toJsonObject(), indent, sb) end
	elseif (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(o) then
		do self:encodeArray(o, indent, sb) end
	elseif (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(o) then
		do self:encodeVector(o, indent, sb) end
	elseif (function(x) return x ~= nil and _vm:get_variable_type(x) == 'table' and not x._isClassInstance == true and #x < 1 end)(o) then
		do self:encodeMap(o, indent, sb) end
	elseif _util:is_buffer(o) then
		do self:encodeString(_g.jk.base64.Base64Encoder:encode(o), indent, sb) end
	elseif (_vm:get_variable_type(o) == 'string') then
		do self:encodeString(o, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.DynamicMap') ~= nil) then
		do self:encodeDynamicMap(o, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.DynamicVector') ~= nil) then
		do self:encodeDynamicVector(o, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.KeyValueListForStrings') ~= nil) then
		do self:encodeKeyValueList(o, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.StringObject') ~= nil) then
		do self:encodeString(o:toString(), indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.BufferObject') ~= nil) then
		do self:encodeString(_g.jk.base64.Base64Encoder:encode(o:toBuffer()), indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.ArrayObject') ~= nil) then
		local aa = o:toArray()
		do self:encodeArray(aa, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.VectorObject') ~= nil) then
		local vv = o:toVector()
		do self:encodeVector(vv, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.IntegerObject') ~= nil) or (_vm:to_table_with_key(o, '_isType.jk.lang.LongIntegerObject') ~= nil) or (_vm:to_table_with_key(o, '_isType.jk.lang.DoubleObject') ~= nil) then
		do self:encodeNumber(o, indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.CharacterObject') ~= nil) then
		do self:encodeString(_g.jk.lang.String:asString(o), indent, sb) end
	elseif (_vm:to_table_with_key(o, '_isType.jk.lang.BooleanObject') ~= nil) then
		do self:encodeBoolean(_g.jk.lang.Boolean:asBoolean(o, false), indent, sb) end
	else
		do self:encodeString("", indent, sb) end
	end
end

function jk.json.JSONEncoder:encode(o, niceFormatting, stringFormattedNumber)
	local v = _g.jk.json.JSONEncoder._construct0(_g.jk.json.JSONEncoder._create())
	do v:setStringFormattedBoolean(true) end
	do v:setStringFormattedNumber(stringFormattedNumber) end
	do v:setNiceFormatting(niceFormatting) end
	do return v:execute(o) end
end

function jk.json.JSONEncoder:execute(o)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do self:encodeObject(o, 0, sb) end
	do return sb:toString() end
end

function jk.json.JSONEncoder:encodeToBuilder(o, sb)
	if not (sb ~= nil) then
		do return end
	end
	do
		local str = _g.jk.json.JSONEncoder._construct0(_g.jk.json.JSONEncoder._create()):setEncodeNullAsNull(true):execute(o)
		if str ~= nil then
			do sb:appendString(str) end
		end
	end
end

function jk.json.JSONEncoder:toString(o)
	local v = _g.jk.json.JSONEncoder._construct0(_g.jk.json.JSONEncoder._create())
	do v:setStringFormattedBoolean(false) end
	do v:setStringFormattedNumber(false) end
	do v:setNiceFormatting(true) end
	do v:setEncodeNullAsNull(true) end
	do return v:execute(o) end
end

function jk.json.JSONEncoder:toCompactString(o)
	local v = _g.jk.json.JSONEncoder._construct0(_g.jk.json.JSONEncoder._create())
	do v:setStringFormattedBoolean(false) end
	do v:setStringFormattedNumber(false) end
	do v:setNiceFormatting(false) end
	do v:setEncodeNullAsNull(true) end
	do return v:execute(o) end
end

function jk.json.JSONEncoder:getNiceFormatting()
	do return self.niceFormatting end
end

function jk.json.JSONEncoder:setNiceFormatting(v)
	self.niceFormatting = v
	do return self end
end

function jk.json.JSONEncoder:getStringFormattedBoolean()
	do return self.stringFormattedBoolean end
end

function jk.json.JSONEncoder:setStringFormattedBoolean(v)
	self.stringFormattedBoolean = v
	do return self end
end

function jk.json.JSONEncoder:getStringFormattedNumber()
	do return self.stringFormattedNumber end
end

function jk.json.JSONEncoder:setStringFormattedNumber(v)
	self.stringFormattedNumber = v
	do return self end
end

function jk.json.JSONEncoder:getNewJSONFormat()
	do return self.newJSONFormat end
end

function jk.json.JSONEncoder:setNewJSONFormat(v)
	self.newJSONFormat = v
	do return self end
end

function jk.json.JSONEncoder:getEncodeNullAsNull()
	do return self.encodeNullAsNull end
end

function jk.json.JSONEncoder:setEncodeNullAsNull(v)
	self.encodeNullAsNull = v
	do return self end
end
sling = sling or {}

sling.common = sling.common or {}

sling.common.LiveTokenizingParser = {}
sling.common.LiveTokenizingParser.__index = sling.common.LiveTokenizingParser
_vm:set_metatable(sling.common.LiveTokenizingParser, {})

sling.common.LiveTokenizingParser.IMPROPER_COMMENT_NOOP = 0
sling.common.LiveTokenizingParser.IMPROPER_COMMENT_IGNORE = 1
sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_IGNORE = 2
sling.common.LiveTokenizingParser.IMPROPER_COMMENT_QUEUE = 3
sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_QUEUE = 4

function sling.common.LiveTokenizingParser._create()
	local v = _vm:set_metatable({}, sling.common.LiveTokenizingParser)
	return v
end

function sling.common.LiveTokenizingParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.LiveTokenizingParser'
	self['_isType.sling.common.LiveTokenizingParser'] = true
	self.improperCommentPolicy = _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_NOOP
	self.tokensAreCaseSensitive = true
	self.fileEncoding = nil
	self.ctx = nil
	self.iterator = nil
	self.currentTokenLine = 0
	self.currentTokenColumn = 0
	self.currentTokenSource = nil
	self.stagingToken = nil
	self.acceptedToken = nil
	self.commentQueue = nil
	self.parseMessages = nil
	self.previousToken = nil
	self.allowSkipSpaces = true
	self.tokenIterator = _g.jk.lang.CharacterIteratorForString._construct0(_g.jk.lang.CharacterIteratorForString._create())
end

function sling.common.LiveTokenizingParser:_construct0()
	sling.common.LiveTokenizingParser._init(self)
	return self
end

sling.common.LiveTokenizingParser.Position = {}
sling.common.LiveTokenizingParser.Position.__index = sling.common.LiveTokenizingParser.Position
_vm:set_metatable(sling.common.LiveTokenizingParser.Position, {})

function sling.common.LiveTokenizingParser.Position._create()
	local v = _vm:set_metatable({}, sling.common.LiveTokenizingParser.Position)
	return v
end

function sling.common.LiveTokenizingParser.Position:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.LiveTokenizingParser.Position'
	self['_isType.sling.common.LiveTokenizingParser.Position'] = true
	self.line = 0
	self.column = 0
	self.position = 0
	self.commentQueueSize = 0
	self.previousToken = nil
end

function sling.common.LiveTokenizingParser.Position:_construct0()
	sling.common.LiveTokenizingParser.Position._init(self)
	return self
end

function sling.common.LiveTokenizingParser:resetParserState()
	self.iterator = nil
	self.currentTokenLine = 0
	self.currentTokenColumn = 0
	self.currentTokenSource = nil
	self.stagingToken = nil
	self.acceptedToken = nil
	self.commentQueue = nil
	self.parseMessages = nil
	self.previousToken = nil
end

function sling.common.LiveTokenizingParser:consumeParseMessages()
	local v = self.parseMessages
	self.parseMessages = nil
	do return v end
end

function sling.common.LiveTokenizingParser:getDisplayText(txt)
	if _g.jk.lang.String:isEmpty(txt) then
		do return "<EMPTY>" end
	end
	if txt == "\n" then
		do return "<NL>" end
	end
	if txt == "\r" then
		do return "<CR>" end
	end
	if txt == "\t" then
		do return "<TAB>" end
	end
	if txt == " " then
		do return "<SPACE>" end
	end
	do return txt end
end

function sling.common.LiveTokenizingParser:onParseMessage(message)
	if not (message ~= nil) then
		do return end
	end
	if self.ctx ~= nil then
		do _g.sling.common.RefLog:message(self.ctx, message) end
	else
		if self.parseMessages == nil then
			self.parseMessages = {}
		end
		do _g.jk.lang.Vector:append(self.parseMessages, message) end
	end
end

function sling.common.LiveTokenizingParser:initializeForTokenSource(source)
	if not (source ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No token source", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do
		local str = source:getContent()
		if not (str ~= nil) then
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No content from source", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
		do self:resetParserState() end
		self.currentTokenSource = source
		str = self:preprocessContent(str)
		if not (str ~= nil) then
			self.currentTokenSource = nil
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Preprocessing failed", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
		self.iterator = _g.jk.lang.String:iterate(str)
		do self.iterator:moveToNextChar() end
		self.currentTokenLine = 0
		self.currentTokenColumn = 0
		do self:updateStagingToken() end
	end
end

function sling.common.LiveTokenizingParser:initializeForFile(file)
	if not (file ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null content file for parser", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do
		local content = self:readFileContentsString(file)
		if not (content ~= nil) then
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage(_g.sling.common.MessageFormatter:getFileMessage(file, "Failed to read file"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
		do
			local ts = _g.sling.common.TokenSource._construct0(_g.sling.common.TokenSource._create())
			do ts:setContent(content) end
			do
				local cn = _g.sling.common.MessageFormatter:getFilePath(file)
				if _g.jk.lang.String:isEmpty(cn) then
					cn = "<file>"
				end
				do ts:setName(cn) end
				do ts:setFile(file) end
				do self:initializeForTokenSource(ts) end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:initializeForString(content, contentName)
	if not (content ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null content string for parser", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do
		local ts = _g.sling.common.TokenSource._construct0(_g.sling.common.TokenSource._create())
		do ts:setContent(content) end
		do
			local cn = contentName
			if _g.jk.lang.String:isEmpty(cn) then
				cn = "<string>"
			end
			do ts:setName(cn) end
			do ts:setFile(nil) end
			do self:initializeForTokenSource(ts) end
		end
	end
end

function sling.common.LiveTokenizingParser:isSpaceCharacter(n)
	if n == 32 or n == 9 or n == 13 or n == 10 then
		do return true end
	end
	do return false end
end

function sling.common.LiveTokenizingParser:setCtx(ctx)
	self.ctx = ctx
	do return self end
end

function sling.common.LiveTokenizingParser:getCtx()
	do return self.ctx end
end

function sling.common.LiveTokenizingParser:getCurrentTokenSource()
	do return self.currentTokenSource end
end

function sling.common.LiveTokenizingParser:getCurrentTokenLine()
	do return self.currentTokenLine end
end

function sling.common.LiveTokenizingParser:getCurrentTokenColumn()
	do return self.currentTokenColumn end
end

function sling.common.LiveTokenizingParser:getCurrentInputName()
	if self.currentTokenSource == nil then
		do return "<none>" end
	end
	do return self.currentTokenSource:getName() end
end

function sling.common.LiveTokenizingParser:getCurrentFile()
	if self.currentTokenSource == nil then
		do return nil end
	end
	do return self.currentTokenSource:getFile() end
end

function sling.common.LiveTokenizingParser:getCurrentFileName()
	local currentFile = self:getCurrentFile()
	if currentFile == nil then
		do return nil end
	end
	do return currentFile:baseName() end
end

function sling.common.LiveTokenizingParser:getCurrentFileId()
	local currentFile = self:getCurrentFile()
	if currentFile == nil then
		if self.currentTokenSource ~= nil then
			do return self.currentTokenSource:getName() end
		end
		do return nil end
	end
	do return currentFile:baseNameWithoutExtension() end
end

function sling.common.LiveTokenizingParser:getCurrentDirectory()
	local currentFile = self:getCurrentFile()
	if not (currentFile ~= nil) then
		do return nil end
	end
	do return currentFile:getParent() end
end

function sling.common.LiveTokenizingParser:getRelativeFile(name)
	if not _g.jk.lang.String:isNotEmpty(name) then
		do return nil end
	end
	if not (_g.jk.lang.String:getIndexOfCharacter(name, 92, 0) < 0) then
		do return nil end
	end
	do
		local currentFile = self:getCurrentFile()
		if not (currentFile ~= nil) then
			do return nil end
		end
		do
			local dd = currentFile:getParent()
			if not (dd ~= nil) then
				do return nil end
			end
			do
				local array = _g.jk.lang.String:split(name, 47, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local comp = array[n + 1]
							if comp ~= nil then
								if _g.jk.lang.String:isEmpty(comp) or comp == "." or comp == ".." then
									goto _continue5
								end
								dd = dd:entry(comp)
							end
							::_continue5::
							do n = n + 1 end
						end
					end
				end
				do return dd end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:getRelativeFileIgnoreCase(name)
	local r = self:getRelativeFile(name)
	if r ~= nil and r:exists() then
		do return r end
	end
	do
		local currentFile = self:getCurrentFile()
		if not (currentFile ~= nil) then
			do return nil end
		end
		do
			local dd = currentFile:getParent()
			if not (dd ~= nil) then
				do return nil end
			end
			do
				local v = nil
				local it = dd:entries()
				while it ~= nil do
					local ff = it:next()
					if not (ff ~= nil) then
						do break end
					end
					if _g.jk.lang.String:equalsIgnoreCase(ff:baseName(), name) then
						v = ff
						do break end
					end
				end
				if it ~= nil and (_vm:to_table_with_key(it, '_isType.jk.lang.Closable') ~= nil) then
					do it:close() end
				end
				do return v end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:readFileContentsString(file)
	if not (file ~= nil) then
		do return nil end
	end
	if not (self.fileEncoding ~= nil) then
		do return file:getContentsWithBOM() end
	end
	do return file:getContentsString(self.fileEncoding) end
end

function sling.common.LiveTokenizingParser:updateStagingToken()
	if self.stagingToken == nil then
		self.stagingToken = _g.sling.common.Token._construct0(_g.sling.common.Token._create())
	end
	self.stagingToken.value = nil
	self.stagingToken.line = self.currentTokenLine
	self.stagingToken.column = self.currentTokenColumn
	self.stagingToken.source = self.currentTokenSource
	if self.iterator ~= nil then
		self.stagingToken.position = self.iterator:getCurrentPosition()
	end
end

function sling.common.LiveTokenizingParser:getStagingToken()
	do return self.stagingToken end
end

function sling.common.LiveTokenizingParser:rememberPosition()
	local v = _g.sling.common.LiveTokenizingParser.Position._construct0(_g.sling.common.LiveTokenizingParser.Position._create())
	v.line = self.currentTokenLine
	v.column = self.currentTokenColumn
	v.position = self.iterator:getCurrentPosition()
	if self.commentQueue ~= nil then
		v.commentQueueSize = self.commentQueue:getSize()
	else
		v.commentQueueSize = 0
	end
	v.previousToken = self.previousToken
	do return v end
end

function sling.common.LiveTokenizingParser:restorePosition(token)
	if not (token ~= nil) then
		do return end
	end
	self.currentTokenColumn = token.column
	self.currentTokenLine = token.line
	do self.iterator:setCurrentPosition(token.position) end
	while self.commentQueue ~= nil and self.commentQueue:getSize() > token.commentQueueSize do
		do self.commentQueue:pop() end
	end
	self.previousToken = token.previousToken
	do self:updateStagingToken() end
end

function sling.common.LiveTokenizingParser:getPreviousToken()
	do return self.previousToken end
end

function sling.common.LiveTokenizingParser:getAcceptedToken()
	do return self.acceptedToken end
end

function sling.common.LiveTokenizingParser:hasInputEnded()
	do return self.iterator:hasEnded() end
end

function sling.common.LiveTokenizingParser:peekNextCharacter()
	do return self.iterator:getCurrentChar() end
end

function sling.common.LiveTokenizingParser:getNextCharacter()
	local v = self.iterator:getCurrentChar()
	do self.iterator:moveToNextChar() end
	if v == 10 then
		do self.currentTokenLine = self.currentTokenLine + 1 end
		self.currentTokenColumn = 0
	else
		do self.currentTokenColumn = self.currentTokenColumn + 1 end
	end
	do return v end
end

function sling.common.LiveTokenizingParser:skipSpaces()
	if not (self.iterator ~= nil) then
		do return 0 end
	end
	if not self.allowSkipSpaces then
		do return 0 end
	end
	do
		local v = 0
		while true do
			if self:skipSpaceCharacter() then
				do v = v + 1 end
				goto _continue6
			end
			if self.improperCommentPolicy ~= _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_NOOP then
				local cc = self:acceptImmediateCommentToken()
				if cc ~= nil then
					do v = v + 1 end
					self.previousToken = cc
					if self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_IGNORE then
						goto _continue6
					end
					if self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_QUEUE or self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_QUEUE or self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_IGNORE then
						if self.commentQueue == nil then
							self.commentQueue = _g.jk.lang.Queue._construct0(_g.jk.lang.Queue._create())
						end
						do self.commentQueue:push(cc) end
						goto _continue6
					end
				end
			end
			do break end
			::_continue6::
		end
		do return v end
	end
end

function sling.common.LiveTokenizingParser:areTokensConnected(first, second)
	if not (first ~= nil) then
		do return false end
	end
	if not (second ~= nil) then
		do return false end
	end
	if not (first.line == second.line) then
		do return false end
	end
	if not (first.column + _g.jk.lang.String:getLength(first.value) == second.column) then
		do return false end
	end
	do return true end
end

function sling.common.LiveTokenizingParser:onTokenAccepted(token)
	if not (token ~= nil) then
		do return end
	end
	self.previousToken = self.acceptedToken
	self.acceptedToken = token
end

function sling.common.LiveTokenizingParser:acceptEOF()
	if not self:hasInputEnded() then
		do return nil end
	end
	do
		local v = self.stagingToken
		self.stagingToken = nil
		do self:updateStagingToken() end
		v.value = nil
		do self:onTokenAccepted(v) end
		do return v end
	end
end

function sling.common.LiveTokenizingParser:preprocessCharacter(c)
	if self.tokensAreCaseSensitive then
		do return c end
	end
	do return _g.jk.lang.Character:toLowercase(c) end
end

function sling.common.LiveTokenizingParser:getCharacterBoundaryClass(c)
	if c == 32 or c == 10 or c == 13 or c == 9 then
		do return 0 end
	end
	if _g.jk.lang.Character:isAlphaNumeric(c) or c == 95 then
		do return 1 end
	end
	do return 2 end
end

function sling.common.LiveTokenizingParser:isTokenBoundary(c0, c1)
	local cl0 = self:getCharacterBoundaryClass(c0)
	local cl1 = self:getCharacterBoundaryClass(c1)
	if cl1 == 1 and cl0 == 1 then
		do return false end
	end
	do return true end
end

function sling.common.LiveTokenizingParser:acceptString(str)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local it = self.tokenIterator
		do it:setString(str) end
		do
			local lc = 0
			while true do
				local c = it:getNextChar()
				if _g.jk.lang.Character:isEOF(c) then
					do break end
				end
				lc = c
				do
					local nn = self:getNextCharacter()
					if not self.tokensAreCaseSensitive then
						c = _g.jk.lang.Character:toLowercase(c)
						nn = _g.jk.lang.Character:toLowercase(nn)
					end
					if c ~= nn then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
				end
			end
			do return str end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptAnyString(strings)
	if strings ~= nil then
		local n = 0
		local m = #strings
		do
			n = 0
			while n < m do
				local string = strings[n + 1]
				if string ~= nil then
					local v = self:acceptString(string)
					if v ~= nil then
						do return v end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function sling.common.LiveTokenizingParser:acceptAnyToken(tokens)
	if tokens ~= nil then
		local n = 0
		local m = #tokens
		do
			n = 0
			while n < m do
				local token = tokens[n + 1]
				if token ~= nil then
					local v = self:acceptToken1(token)
					if v ~= nil then
						do return v end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function sling.common.LiveTokenizingParser:acceptConnectedToken(token)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local v = self:acceptToken1(token)
		if not (v ~= nil) then
			do return nil end
		end
		if not self:areTokensConnected(self:getPreviousToken(), self:getAcceptedToken()) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do return v end
	end
end

function sling.common.LiveTokenizingParser:peekToken1(token)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if self:acceptToken1(token) ~= nil then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return true end
		end
		do return false end
	end
end

function sling.common.LiveTokenizingParser:peekToken2(token)
	do return self:peekToken1(_g.jk.lang.String:forCharacter(token)) end
end

function sling.common.LiveTokenizingParser:acceptToken1(token)
	if not (token ~= nil) then
		do return nil end
	end
	do self:skipSpaces() end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local it = self.tokenIterator
			do it:setString(token) end
			do
				local lc = 0
				while true do
					local c = it:getNextChar()
					if _g.jk.lang.Character:isEOF(c) then
						do break end
					end
					if lc == 0 then
						if self.tokensAreCaseSensitive then
							if c ~= self:peekNextCharacter() then
								do return nil end
							end
						elseif _g.jk.lang.Character:toLowercase(c) ~= _g.jk.lang.Character:toLowercase(self:peekNextCharacter()) then
							do return nil end
						end
					end
					lc = c
					do
						local nn = self:getNextCharacter()
						if not self.tokensAreCaseSensitive then
							c = _g.jk.lang.Character:toLowercase(c)
							nn = _g.jk.lang.Character:toLowercase(nn)
						end
						if c ~= nn then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
					end
				end
				if self:isTokenBoundary(self:peekNextCharacter(), lc) == false then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = token
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptToken2(c)
	do self:skipSpaces() end
	if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c) then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			if self:isTokenBoundary(self:peekNextCharacter(), c) == false then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local v = self.stagingToken
				self.stagingToken = nil
				v.line = ctl
				v.column = ctc
				v.position = ctp
				v.value = _g.jk.lang.String:forCharacter(c)
				do self:updateStagingToken() end
				do self:onTokenAccepted(v) end
				do return v end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptToken3(c0, c1)
	do self:skipSpaces() end
	if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c0) then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c1) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:getNextCharacter() end
			do
				local v = self.stagingToken
				self.stagingToken = nil
				do self:updateStagingToken() end
				v.line = ctl
				v.column = ctc
				v.position = ctp
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do sb:appendCharacter(c1) end
					v.value = sb:toString()
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptToken4(c0, c1, c2)
	do self:skipSpaces() end
	if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c0) then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c1) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:getNextCharacter() end
			if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c2) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:getNextCharacter() end
			do
				local v = self.stagingToken
				self.stagingToken = nil
				do self:updateStagingToken() end
				v.line = ctl
				v.column = ctc
				v.position = ctp
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do sb:appendCharacter(c1) end
					do sb:appendCharacter(c2) end
					v.value = sb:toString()
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptToken5(c0, c1, c2, c3)
	do self:skipSpaces() end
	if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c0) then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c1) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:getNextCharacter() end
			if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c2) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:getNextCharacter() end
			if self:preprocessCharacter(self:peekNextCharacter()) ~= self:preprocessCharacter(c3) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:getNextCharacter() end
			do
				local v = self.stagingToken
				self.stagingToken = nil
				do self:updateStagingToken() end
				v.line = ctl
				v.column = ctc
				v.position = ctp
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do sb:appendCharacter(c1) end
					do sb:appendCharacter(c2) end
					do sb:appendCharacter(c3) end
					v.value = sb:toString()
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:preprocessIdentifier(t)
	do return t end
end

function sling.common.LiveTokenizingParser:acceptIdentifierToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if _g.jk.lang.Character:isEOF(c0) or self:isValidIdentifierPrefix(c0) == false then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					while true do
						local cn = self:peekNextCharacter()
						if _g.jk.lang.Character:isEOF(cn) or self:isValidIdentifierCharacter(cn) == false then
							do break end
						end
						do self:getNextCharacter() end
						do sb:appendCharacter(cn) end
					end
					do
						local ids = self:preprocessIdentifier(sb:toString())
						if self:isValidIdentifier(ids) == false then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptBacktickQuotedStringToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 96 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do
						local slash = false
						while true do
							local cn = self:getNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do sb:appendCharacter(cn) end
							if cn == 96 and slash == false then
								do break end
							end
							if cn == 92 then
								if slash == true then
									slash = false
								else
									slash = true
								end
							else
								slash = false
							end
						end
						do
							local ids = sb:toString()
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptSingleQuotedStringToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 39 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do
						local slash = false
						while true do
							local cn = self:getNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do sb:appendCharacter(cn) end
							if cn == 39 and slash == false then
								do break end
							end
							if cn == 92 then
								if slash == true then
									slash = false
								else
									slash = true
								end
							else
								slash = false
							end
						end
						do
							local ids = sb:toString()
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptDoubleQuotedStringToken(escapeChar, allowNewlines)
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 34 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do
						local escape = false
						while true do
							local cn = self:getNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							if cn == 10 and allowNewlines == false then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do sb:appendCharacter(cn) end
							if cn == 34 and escape == false then
								do break end
							end
							if escapeChar > 0 and cn == escapeChar then
								if escape == true then
									escape = false
								else
									escape = true
								end
							else
								escape = false
							end
						end
						do
							local ids = sb:toString()
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptTripleQuotedMultiLineStringToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 34 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 34 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					do
						local c2 = self:peekNextCharacter()
						if c2 ~= 34 then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do self:acceptToken2(10) end
						do
							local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
							do sb:appendCharacter(c0) end
							do sb:appendCharacter(c1) end
							do sb:appendCharacter(c2) end
							do
								local qc = 0
								while true do
									local cn = self:getNextCharacter()
									if _g.jk.lang.Character:isEOF(cn) then
										self.currentTokenColumn = ctc
										self.currentTokenLine = ctl
										do self.iterator:setCurrentPosition(ctp) end
										while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
											do self.commentQueue:pop() end
										end
										self.previousToken = cpt
										do return nil end
									end
									do sb:appendCharacter(cn) end
									if cn == 34 then
										do qc = qc + 1 end
										if qc == 3 then
											do break end
										end
									else
										qc = 0
									end
								end
								do
									local val = sb:toString()
									local v = self.stagingToken
									self.stagingToken = nil
									do self:updateStagingToken() end
									v.line = ctl
									v.column = ctc
									v.position = ctp
									v.value = val
									do self:onTokenAccepted(v) end
									do return v end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptHexNumberLiteralToken(acceptUnderscores)
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 48 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 120 and c1 ~= 88 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					do
						local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						do sb:appendCharacter(c0) end
						do sb:appendCharacter(c1) end
						while true do
							local cn = self:peekNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								do break end
							end
							if _g.jk.lang.Character:isDigit(cn) then
								do sb:appendCharacter(cn) end
							elseif cn >= 97 and cn <= 102 then
								do sb:appendCharacter(cn) end
							elseif cn >= 65 and cn <= 70 then
								do sb:appendCharacter(cn) end
							elseif cn == 95 and acceptUnderscores then
							else
								do break end
							end
							do self:getNextCharacter() end
						end
						do
							local ids = sb:toString()
							if ids == nil or _g.jk.lang.String:equals(ids, "0x") or _g.jk.lang.String:equals(ids, "0X") then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do
								local v = self.stagingToken
								self.stagingToken = nil
								do self:updateStagingToken() end
								v.line = ctl
								v.column = ctc
								v.position = ctp
								v.value = ids
								do self:onTokenAccepted(v) end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptOctalNumberLiteralToken(acceptUnderscores, requirePrefix)
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 48 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = 0
					if requirePrefix then
						c1 = self:peekNextCharacter()
						if c1 ~= 111 and c1 ~= 79 then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do self:getNextCharacter() end
					end
					do
						local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						do sb:appendCharacter(c0) end
						if requirePrefix then
							do sb:appendCharacter(c1) end
						end
						while true do
							local cn = self:peekNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								do break end
							end
							if cn >= 48 and cn <= 55 then
								do sb:appendCharacter(cn) end
							elseif cn == 95 and acceptUnderscores then
							else
								do break end
							end
							do self:getNextCharacter() end
						end
						do
							local ids = sb:toString()
							local isNotValidOctal = false
							if requirePrefix then
								isNotValidOctal = _g.jk.lang.String:equals(ids, "0o") or _g.jk.lang.String:equals(ids, "0O")
							else
								isNotValidOctal = _g.jk.lang.String:equals(ids, "0")
							end
							if ids == nil or isNotValidOctal then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do
								local v = self.stagingToken
								self.stagingToken = nil
								do self:updateStagingToken() end
								v.line = ctl
								v.column = ctc
								v.position = ctp
								v.value = ids
								do self:onTokenAccepted(v) end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptBinaryNumberLiteralToken(acceptUnderscores)
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 48 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 98 and c1 ~= 66 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					do
						local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						do sb:appendCharacter(c0) end
						do sb:appendCharacter(c1) end
						while true do
							local cn = self:peekNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								do break end
							end
							if cn == 48 or cn == 49 then
								do sb:appendCharacter(cn) end
							elseif cn == 95 and acceptUnderscores then
							else
								do break end
							end
							do self:getNextCharacter() end
						end
						do
							local ids = sb:toString()
							if ids == nil or _g.jk.lang.String:equals(ids, "0b") or _g.jk.lang.String:equals(ids, "0B") then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do
								local v = self.stagingToken
								self.stagingToken = nil
								do self:updateStagingToken() end
								v.line = ctl
								v.column = ctc
								v.position = ctp
								v.value = ids
								do self:onTokenAccepted(v) end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptIntegerLiteralToken(acceptUnderscores)
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if _g.jk.lang.Character:isDigit(c0) == false then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					while true do
						local cn = self:peekNextCharacter()
						if _g.jk.lang.Character:isEOF(cn) then
							do break end
						end
						if _g.jk.lang.Character:isDigit(cn) then
							do sb:appendCharacter(cn) end
						elseif cn == 95 and acceptUnderscores then
						else
							do break end
						end
						do self:getNextCharacter() end
					end
					do
						local ids = sb:toString()
						local v = self.stagingToken
						self.stagingToken = nil
						do self:updateStagingToken() end
						v.line = ctl
						v.column = ctc
						v.position = ctp
						v.value = ids
						do self:onTokenAccepted(v) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptDecimalNumberLiteralToken(acceptUnderscores, allowStartWithDelimiter, allowExponent, allowEndWithDelimiter)
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if _g.jk.lang.Character:isDigit(c0) then
		elseif c0 == 46 and allowStartWithDelimiter then
		else
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local hasDelimiter = false
					local hasExp = false
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					if c0 == 46 then
						hasDelimiter = true
					end
					do sb:appendCharacter(c0) end
					while true do
						local cn = self:peekNextCharacter()
						if _g.jk.lang.Character:isEOF(cn) then
							do break end
						end
						if _g.jk.lang.Character:isDigit(cn) then
							do sb:appendCharacter(cn) end
							do self:getNextCharacter() end
						elseif hasDelimiter == false and cn == 46 then
							do sb:appendCharacter(cn) end
							hasDelimiter = true
							do self:getNextCharacter() end
						elseif hasExp == false and allowExponent and (cn == 101 or cn == 69) then
							do sb:appendCharacter(cn) end
							hasDelimiter = true
							hasExp = true
							do self:getNextCharacter() end
							do
								local nn = self:peekNextCharacter()
								if nn == 43 or nn == 45 then
									do sb:appendCharacter(nn) end
									do self:getNextCharacter() end
								end
							end
						elseif acceptUnderscores and cn == 95 then
							do self:getNextCharacter() end
						else
							do break end
						end
					end
					do
						local ids = sb:toString()
						if ids == nil or _g.jk.lang.String:endsWith(ids, "e") or _g.jk.lang.String:endsWith(ids, "E") then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						if ids == "." then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						if _g.jk.lang.String:startsWith(ids, ".", 0) then
							if allowStartWithDelimiter then
								ids = "0" .. _g.jk.lang.String:safeString(ids)
							else
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
						end
						if _g.jk.lang.String:endsWith(ids, ".") then
							if allowEndWithDelimiter then
								ids = _g.jk.lang.String:safeString(ids) .. "0"
							else
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
						end
						do
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:isNumberLiteralSuffixReal(c)
	if c == 100 or c == 68 or c == 102 or c == 70 then
		do return true end
	end
	do return false end
end

function sling.common.LiveTokenizingParser:acceptImmediateHashCommentToken()
	local c0 = self:peekNextCharacter()
	if c0 ~= 35 then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			do
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendCharacter(c0) end
				while true do
					local cn = self:peekNextCharacter()
					if _g.jk.lang.Character:isEOF(cn) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					if cn == 13 then
						do self:getNextCharacter() end
						goto _continue7
					end
					if cn == 10 then
						do break end
					end
					do sb:appendCharacter(cn) end
					do self:getNextCharacter() end
					::_continue7::
				end
				do
					local ids = sb:toString()
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = ids
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptImmediateSlashSlashCommentToken()
	local c0 = self:peekNextCharacter()
	if c0 ~= 47 then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			do
				local c1 = self:peekNextCharacter()
				if c1 ~= 47 then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do sb:appendCharacter(c1) end
					while true do
						local cn = self:peekNextCharacter()
						if _g.jk.lang.Character:isEOF(cn) then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						if cn == 13 then
							do self:getNextCharacter() end
							goto _continue8
						end
						if cn == 10 then
							do break end
						end
						do sb:appendCharacter(cn) end
						do self:getNextCharacter() end
						::_continue8::
					end
					do
						local ids = sb:toString()
						local v = self.stagingToken
						self.stagingToken = nil
						do self:updateStagingToken() end
						v.line = ctl
						v.column = ctc
						v.position = ctp
						v.value = ids
						do self:onTokenAccepted(v) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:acceptImmediateSlashAsteriskCommentToken()
	local c0 = self:peekNextCharacter()
	if c0 ~= 47 then
		do return nil end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			do
				local c1 = self:peekNextCharacter()
				if c1 ~= 42 then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					do sb:appendCharacter(c1) end
					do
						local pc = 0
						while true do
							local cn = self:getNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							if cn == 13 then
								goto _continue9
							end
							do sb:appendCharacter(cn) end
							if pc == 42 and cn == 47 then
								do break end
							end
							pc = cn
							::_continue9::
						end
						do
							local ids = sb:toString()
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:parseIdentifierToken()
	local id = self:acceptIdentifierToken()
	if not (id ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("identifier"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return id end
end

function sling.common.LiveTokenizingParser:acceptIdentifier()
	local v = self:acceptIdentifierToken()
	if not (v ~= nil) then
		do return nil end
	end
	do return v.value end
end

function sling.common.LiveTokenizingParser:parseIdentifier()
	local v = self:parseIdentifierToken()
	if not (v ~= nil) then
		do return nil end
	end
	do return v.value end
end

function sling.common.LiveTokenizingParser:parseToken1(token)
	local v = self:acceptToken1(token)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText(token), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.common.LiveTokenizingParser:parseToken2(token)
	local v = self:acceptToken2(token)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText(_g.jk.lang.String:forCharacter(token)), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.common.LiveTokenizingParser:acceptCommentString()
	local t = self:acceptCommentToken()
	if not (t ~= nil) then
		do return nil end
	end
	do return t:getValue() end
end

function sling.common.LiveTokenizingParser:acceptCommentToken()
	if self.commentQueue ~= nil and (self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_QUEUE or self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_QUEUE or self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_IGNORE) then
		while true do
			local cc = self.commentQueue:pop()
			if cc ~= nil then
				local isImproper = true
				if cc == self.previousToken then
					isImproper = false
				end
				if self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_IGNORE then
					if isImproper then
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Improper comment", cc)) end
					end
				else
					if self.improperCommentPolicy == _g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_QUEUE and isImproper then
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Improper comment", cc)) end
					end
					do return cc end
				end
			else
				do break end
			end
		end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local n = 0
			while true do
				if self:skipSpaceCharacter() then
					do n = n + 1 end
					goto _continue10
				end
				do break end
				::_continue10::
			end
			do
				local v = self:acceptImmediateCommentToken()
				if v ~= nil then
					do return v end
				end
				if n > 0 then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do return nil end
			end
		end
	end
end

function sling.common.LiveTokenizingParser:skipSpaceCharacter()
	if self:isSpaceCharacter(self:peekNextCharacter()) then
		do self:getNextCharacter() end
		do return true end
	end
	do return false end
end

function sling.common.LiveTokenizingParser:isValidIdentifier(t)
	if not (t ~= nil) then
		do return false end
	end
	do
		local c = _g.jk.lang.String:getChar(t, 0)
		if not self:isValidIdentifierPrefix(c) then
			do return false end
		end
		do
			local it = self.tokenIterator
			do it:setString(t) end
			do it:getNextChar() end
			while true do
				local c = it:getNextChar()
				if _g.jk.lang.Character:isEOF(c) then
					do break end
				end
				if self:isValidIdentifierCharacter(c) == false then
					do return false end
				end
			end
			do return true end
		end
	end
end

function sling.common.LiveTokenizingParser:isValidIdentifierPrefix(c)
	do return false end
end

function sling.common.LiveTokenizingParser:isValidIdentifierCharacter(c)
	do return false end
end

function sling.common.LiveTokenizingParser:preprocessContent(content)
	do return content end
end

function sling.common.LiveTokenizingParser:acceptImmediateCommentToken()
	do return nil end
end

function sling.common.LiveTokenizingParser:getImproperCommentPolicy()
	do return self.improperCommentPolicy end
end

function sling.common.LiveTokenizingParser:setImproperCommentPolicy(v)
	self.improperCommentPolicy = v
	do return self end
end

function sling.common.LiveTokenizingParser:getTokensAreCaseSensitive()
	do return self.tokensAreCaseSensitive end
end

function sling.common.LiveTokenizingParser:setTokensAreCaseSensitive(v)
	self.tokensAreCaseSensitive = v
	do return self end
end

function sling.common.LiveTokenizingParser:getFileEncoding()
	do return self.fileEncoding end
end

function sling.common.LiveTokenizingParser:setFileEncoding(v)
	self.fileEncoding = v
	do return self end
end

function sling.common.LiveTokenizingParser:getParseMessages()
	do return self.parseMessages end
end

function sling.common.LiveTokenizingParser:setParseMessages(v)
	self.parseMessages = v
	do return self end
end

function sling.common.LiveTokenizingParser:getAllowSkipSpaces()
	do return self.allowSkipSpaces end
end

function sling.common.LiveTokenizingParser:setAllowSkipSpaces(v)
	self.allowSkipSpaces = v
	do return self end
end

sling.common.OutputWriterManager = {}

sling.common.NodeInsertionPoint = {}

sling.common.Message = {}
sling.common.Message.__index = sling.common.Message
_vm:set_metatable(sling.common.Message, {})

function sling.common.Message._create()
	local v = _vm:set_metatable({}, sling.common.Message)
	return v
end

function sling.common.Message:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.Message'
	self['_isType.sling.common.Message'] = true
	self['_isType.jk.json.JSONObject'] = true
	self['_isType.jk.lang.StringObject'] = true
	self['_isType.jk.lang.StringObjectWithDebug'] = true
	self.message = nil
	self.reference = nil
	self.relatedMessages = nil
end

function sling.common.Message:_construct0()
	sling.common.Message._init(self)
	return self
end

function sling.common.Message:formatToken(token)
	if not (token ~= nil) then
		do return nil end
	end
	if token == "\n" then
		do return "<NL>" end
	end
	if token == "\r" then
		do return "<CR>" end
	end
	do return token end
end

function sling.common.Message:toJsonObject()
	local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	do v:setString("type", self:getType()) end
	do v:setString("message", self.message) end
	if self.reference ~= nil then
		local rv = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		do rv:setString("sourceName", self.reference:getSourceName()) end
		do rv:setString("sourceToken", self:formatToken(self.reference:getSourceToken())) end
		do rv:setInteger("sourceLineNumber", self.reference:getSourceLineNumber()) end
		do rv:setInteger("sourceColumnNumber", self.reference:getSourceColumnNumber()) end
		do rv:setString("sourceContentLine", self.reference:getSourceContentLine()) end
		do rv:setString("nodeTrace", self.reference:getNodeTrace()) end
		do v:setObject("reference", rv) end
	end
	do
		local rms = nil
		if self.relatedMessages ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.relatedMessages)
			do
				n = 0
				while n < m do
					local related = self.relatedMessages[n + 1]
					if related ~= nil then
						local r = related:toJsonObject()
						if not (r ~= nil) then
							goto _continue1
						end
						if rms == nil then
							rms = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
						end
						do rms:appendObject(r) end
					end
					::_continue1::
					do n = n + 1 end
				end
			end
		end
		if rms ~= nil then
			do v:setObject("relatedMessages", rms) end
		end
		do return v end
	end
end

function sling.common.Message:fromJsonObject(o)
	do return false end
end

function sling.common.Message:getType()
end

function sling.common.Message:addRelatedMessage(message)
	if not (message ~= nil) then
		do return end
	end
	if self.relatedMessages == nil then
		self.relatedMessages = {}
	end
	do _g.jk.lang.Vector:append(self.relatedMessages, message) end
end

function sling.common.Message:copyFrom(msg)
	if not (msg ~= nil) then
		do return end
	end
	do self:setReference(msg:getReference()) end
	do self:setMessage(msg:getMessage()) end
end

function sling.common.Message:getMessageString()
	do return self.message end
end

function sling.common.Message:toStringWithDebug(isDebug)
	local mm = self:getMessageString()
	if mm == nil then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if self.reference == nil then
			do sb:appendString(mm) end
		else
			local line = self.reference:getSourceLineNumber()
			local col = self.reference:getSourceColumnNumber()
			local name = self.reference:getSourceName()
			if _g.jk.lang.String:isEmpty(name) then
				name = "<unknown>"
			end
			do
				local token = self.reference:getSourceToken()
				if token ~= nil then
					if token == "\n" then
						token = "<NL>"
					elseif token == "\r" then
						token = "<CR>"
					elseif token == "\t" then
						token = "<TAB>"
					elseif token == "\f" then
						token = "<FF>"
					elseif _g.jk.lang.String:getIndexOfCharacter(token, 10, 0) >= 0 then
						token = "<multi-line-token>"
					end
				end
				do sb:appendString(name) end
				if line >= 0 then
					do sb:appendCharacter(58) end
					do sb:appendInteger(line + 1) end
					if col >= 0 then
						do sb:appendCharacter(58) end
						do sb:appendInteger(col + 1) end
					end
				end
				if _g.jk.lang.String:isEmpty(token) == false then
					do sb:appendString(" (`") end
					do sb:appendString(token) end
					do sb:appendString("')") end
				end
				do sb:appendString(": ") end
				do sb:appendString(mm) end
				do
					local cl = self.reference:getSourceContentLine()
					if not (cl == nil) then
						do sb:appendCharacter(10) end
						do
							local it = _g.jk.lang.String:iterate(cl)
							local c = 0
							while (function()
								c = it:getNextChar()
								do return c end
							end)() > 0 do
								if c == 9 then
									do sb:appendCharacter(32) end
								else
									do sb:appendCharacter(c) end
								end
							end
							if col >= 0 then
								do sb:appendCharacter(10) end
								do
									local n = 0
									do
										n = 0
										while n < col do
											do sb:appendCharacter(32) end
											do n = n + 1 end
										end
									end
									do sb:appendCharacter(94) end
								end
							end
						end
					else
						do sb:appendString("\n\t(no reference content)\n") end
					end
					if isDebug then
						local trace = self.reference:getNodeTrace()
						if _g.jk.lang.String:isNotEmpty(trace) then
							if _g.jk.lang.String:startsWith(trace, "\n", 0) == false then
								do sb:appendCharacter(10) end
							end
							do sb:appendString(trace) end
							if _g.jk.lang.String:endsWith(trace, "\n") == false then
								do sb:appendCharacter(10) end
							end
						end
					end
				end
			end
		end
		do
			local rms = false
			if self.relatedMessages ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(self.relatedMessages)
				do
					n2 = 0
					while n2 < m do
						local relatedMessage = self.relatedMessages[n2 + 1]
						if relatedMessage ~= nil then
							local rmts = relatedMessage:toStringWithDebug(isDebug)
							if _g.jk.lang.String:isEmpty(rmts) then
								goto _continue2
							end
							do
								local array = _g.jk.lang.String:split(rmts, 10, 0)
								if array ~= nil then
									local n3 = 0
									local m2 = _g.jk.lang.Vector:getSize(array)
									do
										n3 = 0
										while n3 < m2 do
											local line = array[n3 + 1]
											if line ~= nil then
												do sb:appendString("\n  => ") end
												do sb:appendString(line) end
											end
											do n3 = n3 + 1 end
										end
									end
								end
								rms = true
							end
						end
						::_continue2::
						do n2 = n2 + 1 end
					end
				end
			end
			if rms then
				do sb:appendCharacter(10) end
			end
			do return sb:toString() end
		end
	end
end

function sling.common.Message:toString()
	do return self:toStringWithDebug(false) end
end

function sling.common.Message:getMessage()
	do return self.message end
end

function sling.common.Message:setMessage(v)
	self.message = v
	do return self end
end

function sling.common.Message:getReference()
	do return self.reference end
end

function sling.common.Message:setReference(v)
	self.reference = v
	do return self end
end

function sling.common.Message:getRelatedMessages()
	do return self.relatedMessages end
end

function sling.common.Message:setRelatedMessages(v)
	self.relatedMessages = v
	do return self end
end

sling.common.NodeVisitor = {}
sling.common.NodeVisitor.__index = sling.common.NodeVisitor
_vm:set_metatable(sling.common.NodeVisitor, {})

function sling.common.NodeVisitor._create()
	local v = _vm:set_metatable({}, sling.common.NodeVisitor)
	return v
end

function sling.common.NodeVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NodeVisitor'
	self['_isType.sling.common.NodeVisitor'] = true
	self.skipChildren = false
	self.level = 0
end

function sling.common.NodeVisitor:_construct0()
	sling.common.NodeVisitor._init(self)
	return self
end

function sling.common.NodeVisitor:onStartVisit(node)
	do self.level = self.level + 1 end
	do return true end
end

function sling.common.NodeVisitor:onEndVisit(node)
	do self.level = self.level - 1 end
	self.skipChildren = false
	do return true end
end

function sling.common.NodeVisitor:visit(node)
	do return true end
end

function sling.common.NodeVisitor:getSkipChildren()
	do return self.skipChildren end
end

function sling.common.NodeVisitor:setSkipChildren(v)
	self.skipChildren = v
	do return self end
end

function sling.common.NodeVisitor:getLevel()
	do return self.level end
end

function sling.common.NodeVisitor:setLevel(v)
	self.level = v
	do return self end
end

sling.common.RefLogContext = {}

sling.common.OutputWriter = {}

sling.common.ResolveResult = {}
sling.common.ResolveResult.__index = sling.common.ResolveResult
_vm:set_metatable(sling.common.ResolveResult, {})

function sling.common.ResolveResult._create()
	local v = _vm:set_metatable({}, sling.common.ResolveResult)
	return v
end

function sling.common.ResolveResult:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ResolveResult'
	self['_isType.sling.common.ResolveResult'] = true
	self.node = nil
	self.typemap = nil
	self.typeParameters = nil
end

function sling.common.ResolveResult:_construct0()
	sling.common.ResolveResult._init(self)
	return self
end

function sling.common.ResolveResult:forNode(node)
	local v = _g.sling.common.ResolveResult._construct0(_g.sling.common.ResolveResult._create())
	do v:setNode(node) end
	do return v end
end

function sling.common.ResolveResult:getNode()
	do return self.node end
end

function sling.common.ResolveResult:setNode(v)
	self.node = v
	do return self end
end

function sling.common.ResolveResult:getTypemap()
	do return self.typemap end
end

function sling.common.ResolveResult:setTypemap(v)
	self.typemap = v
	do return self end
end

function sling.common.ResolveResult:getTypeParameters()
	do return self.typeParameters end
end

function sling.common.ResolveResult:setTypeParameters(v)
	self.typeParameters = v
	do return self end
end

sling.common.SourceReference = {}

sling.common.FileGenerator = {}
sling.common.FileGenerator.__index = sling.common.FileGenerator
_vm:set_metatable(sling.common.FileGenerator, {})

function sling.common.FileGenerator._create()
	local v = _vm:set_metatable({}, sling.common.FileGenerator)
	return v
end

function sling.common.FileGenerator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.FileGenerator'
	self['_isType.sling.common.FileGenerator'] = true
	self.outputCounter = 0
	self.outputWriterManager = nil
	self.ctx = nil
	self.writer = nil
	self.currentFileName = nil
end

function sling.common.FileGenerator:_construct0()
	sling.common.FileGenerator._init(self)
	return self
end

function sling.common.FileGenerator:_construct2(ctx, output)
	sling.common.FileGenerator._init(self)
	self.ctx = ctx
	self.outputWriterManager = output
	return self
end

function sling.common.FileGenerator:setCtx(ctx)
	self.ctx = ctx
end

function sling.common.FileGenerator:setOutput(output)
	self.outputWriterManager = output
end

function sling.common.FileGenerator:getCurrentWriter()
	do return self.writer end
end

function sling.common.FileGenerator:getCurrentFileName()
	do return self.currentFileName end
end

function sling.common.FileGenerator:getCurrentFileId()
	local v = self:getCurrentFileName()
	if not (v ~= nil) then
		do return nil end
	end
	do
		local fslash = _g.jk.lang.String:getIndexOfCharacter(v, 47, 0)
		if fslash > 0 then
			v = _g.jk.lang.String:getEndOfString(v, fslash + 1)
		end
		do
			local bslash = _g.jk.lang.String:getIndexOfCharacter(v, 92, 0)
			if bslash > 0 then
				v = _g.jk.lang.String:getEndOfString(v, bslash + 1)
			end
			do
				local dot = _g.jk.lang.String:getLastIndexOfCharacter(v, 46, -1)
				if dot > 0 then
					v = _g.jk.lang.String:getSubString(v, 0, dot)
				end
				do return v end
			end
		end
	end
end

function sling.common.FileGenerator:output(output)
	do self:outputDirect(output) end
end

function sling.common.FileGenerator:outputDirect(str)
	if not (self.writer ~= nil) then
		do return end
	end
	do self.writer:writeString(str) end
	do self.outputCounter = self.outputCounter + 1 end
end

function sling.common.FileGenerator:onFileStarted()
end

function sling.common.FileGenerator:onFileEnding()
end

function sling.common.FileGenerator:startFile(name)
	if self.writer ~= nil then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("startFile called, but a file is already being written.", nil, _g.jk.lang.StackTrace:generate()))
	end
	do _g.sling.common.RefLog:status(self.ctx, "[Writing] " .. _g.jk.lang.String:safeString(name) .. " ..") end
	self.writer = self.outputWriterManager:getOutputFile(name)
	if not (self.writer ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to start writing file: `" .. _g.jk.lang.String:safeString(name) .. "'", nil, _g.jk.lang.StackTrace:generate()))
	end
	self.currentFileName = name
	do self:onFileStarted() end
end

function sling.common.FileGenerator:endFile()
	if not (self.writer ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("endFile called, but no file is being written.", nil, _g.jk.lang.StackTrace:generate()))
	end
	do _g.sling.common.RefLog:status(self.ctx, nil) end
	do self:onFileEnding() end
	do self.writer:finalize() end
	self.writer = nil
	self.currentFileName = nil
end

function sling.common.FileGenerator:writeToFile1(name)
	do _g.sling.common.RefLog:debug(self.ctx, "Writing to file: `" .. _g.jk.lang.String:safeString(name) .. "'", nil) end
	do
		local v = self.outputWriterManager:getOutputFile(name)
		if not (v ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write to file: `" .. _g.jk.lang.String:safeString(name) .. "'", nil, _g.jk.lang.StackTrace:generate()))
		end
		do return v end
	end
end

function sling.common.FileGenerator:writeToRelativeFile(name)
	if not (self.currentFileName ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("writeToRelativeFile without currentFileName", nil, _g.jk.lang.StackTrace:generate()))
	end
	if not (name ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("writeToRelativeFile without name", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local rfn = name
		local slash = _g.jk.lang.String:getLastIndexOfCharacter(self.currentFileName, 47, -1)
		if slash >= 0 then
			rfn = _g.jk.lang.String:safeString(_g.jk.lang.String:getSubString(self.currentFileName, 0, slash + 1)) .. _g.jk.lang.String:safeString(name)
		end
		do return self:writeToFile1(rfn) end
	end
end

function sling.common.FileGenerator:writeBufferToRelativeFile(buffer, name)
	local writer = self:writeToRelativeFile(name)
	local v = writer:writeBuffer(buffer)
	do writer:finalize() end
	if not v then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write buffer to file: `" .. _g.jk.lang.String:safeString(name) .. "'", nil, _g.jk.lang.StackTrace:generate()))
	end
end

function sling.common.FileGenerator:writeFileToRelativeFile(file, name)
	if not (file ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("writeFileToRelativeFile with null file", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local btw = file:getContentsBuffer()
		if not (btw ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, _g.jk.lang.StackTrace:generate()))
		end
		do
			local writer = self:writeToRelativeFile(name)
			local v = writer:writeBuffer(btw)
			do writer:finalize() end
			if not v then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write buffer to file: `" .. _g.jk.lang.String:safeString(name) .. "'", nil, _g.jk.lang.StackTrace:generate()))
			end
		end
	end
end

function sling.common.FileGenerator:writeRelativeFileToRelativeFile(relativeTo, name)
	if not (relativeTo ~= nil) or not (name ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("writeRelativeFileToRelativeFile: null parameter", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local ff = relativeTo:getParent()
		local array = _g.jk.lang.String:split(name, 47, 0)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local comp = array[n + 1]
					if comp ~= nil then
						if _g.jk.lang.String:isNotEmpty(comp) then
							ff = ff:entry(comp)
						end
					end
					do n = n + 1 end
				end
			end
		end
		do self:writeFileToRelativeFile(ff, name) end
	end
end

function sling.common.FileGenerator:writeToFile2(name, content)
	if _g.jk.lang.String:isEmpty(name) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("empty file name", nil, _g.jk.lang.StackTrace:generate()))
	end
	if _g.jk.lang.String:isEmpty(content) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("empty content", nil, _g.jk.lang.StackTrace:generate()))
	end
	do self:startFile(name) end
	do self:output(content) end
	do self:endFile() end
end

function sling.common.FileGenerator:writeToFile3(name, content)
	if _g.jk.lang.String:isEmpty(name) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("empty file name", nil, _g.jk.lang.StackTrace:generate()))
	end
	if _g.jk.lang.Buffer:getSize(content) < 1 then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("empty content", nil, _g.jk.lang.StackTrace:generate()))
	end
	do self:startFile(name) end
	do self.writer:writeBuffer(content) end
	do self:endFile() end
end

function sling.common.FileGenerator:getOutputCounter()
	do return self.outputCounter end
end

function sling.common.FileGenerator:setOutputCounter(v)
	self.outputCounter = v
	do return self end
end

sling.common.NodeObject = {}
sling.common.NodeObject.__index = sling.common.NodeObject
_vm:set_metatable(sling.common.NodeObject, {})

function sling.common.NodeObject._create()
	local v = _vm:set_metatable({}, sling.common.NodeObject)
	return v
end

function sling.common.NodeObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NodeObject'
	self['_isType.sling.common.NodeObject'] = true
	self['_isType.sling.common.SourceReference'] = true
	self.parent = nil
	self.source = nil
	self.modifiers = nil
end

function sling.common.NodeObject:_construct0()
	sling.common.NodeObject._init(self)
	return self
end

function sling.common.NodeObject:dupNode(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local v = node:dup()
		if not (v ~= nil) then
			do return nil end
		end
		do return v end
	end
end

function sling.common.NodeObject:onModifiersChanged()
end

function sling.common.NodeObject:removeModifiers()
	if not (self.modifiers ~= nil) then
		do return end
	end
	do
		local array = self.modifiers:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						do node:destroy() end
					end
					do n = n + 1 end
				end
			end
		end
		self.modifiers = nil
		do self:onModifiersChanged() end
	end
end

function sling.common.NodeObject:removeModifier(mod)
	if not (self.modifiers ~= nil) then
		do return end
	end
	if self.modifiers:removeCommon(mod) then
		do self:onModifiersChanged() end
	end
end

function sling.common.NodeObject:removeCustomModifier(mod)
	if not (self.modifiers ~= nil) then
		do return end
	end
	if self.modifiers:removeCustom(mod) then
		do self:onModifiersChanged() end
	end
end

function sling.common.NodeObject:removeModifierNode(mod)
	if not (mod ~= nil) then
		do return end
	end
	if not (self.modifiers ~= nil) then
		do return end
	end
	if self.modifiers:removeNode(mod) then
		do mod:destroy() end
		do self:onModifiersChanged() end
	end
end

function sling.common.NodeObject:addModifier(mod)
	if not (mod ~= nil) then
		do return end
	end
	if not (self.modifiers ~= nil) then
		self.modifiers = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	end
	do self.modifiers:addCommon(mod) end
	do self:onModifiersChanged() end
end

function sling.common.NodeObject:addCustomModifier(mod)
	if not (mod ~= nil) then
		do return end
	end
	if not (self.modifiers ~= nil) then
		self.modifiers = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	end
	do self.modifiers:addCustom(mod) end
	do self:onModifiersChanged() end
end

function sling.common.NodeObject:addModifierNode(mod)
	if not (mod ~= nil) then
		do return end
	end
	if not (self.modifiers ~= nil) then
		self.modifiers = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	end
	do self.modifiers:addNode(mod) end
	do mod:setParent(self) end
	do self:onModifiersChanged() end
end

function sling.common.NodeObject:setModifiers(mods)
	do self:removeModifiers() end
	self.modifiers = mods
	if self.modifiers ~= nil then
		local array = self.modifiers:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						do node:setParent(self) end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.common.NodeObject:getModifierSet()
	if not (self.modifiers ~= nil) then
		do return nil end
	end
	do return self.modifiers:getCommons() end
end

function sling.common.NodeObject:getCustomModifierSet()
	if not (self.modifiers ~= nil) then
		do return nil end
	end
	do return self.modifiers:getCustoms() end
end

function sling.common.NodeObject:getAllCommonModifiers()
	if not (self.modifiers ~= nil) then
		do return nil end
	end
	do return self.modifiers:getCommonsVector() end
end

function sling.common.NodeObject:getAllCustomModifiers()
	if not (self.modifiers ~= nil) then
		do return nil end
	end
	do return self.modifiers:getCustomsVector() end
end

function sling.common.NodeObject:getModifierNodeVector()
	if not (self.modifiers ~= nil) then
		do return nil end
	end
	do return self.modifiers:getNodes() end
end

function sling.common.NodeObject:getModifiers()
	do return self.modifiers end
end

function sling.common.NodeObject:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do self:onModifiersChanged() end
	do return v end
end

function sling.common.NodeObject:hasModifier(name)
	if not (self.modifiers ~= nil) then
		do return false end
	end
	do return self.modifiers:hasCommon(name) end
end

function sling.common.NodeObject:hasCustomModifier(name)
	if not (self.modifiers ~= nil) then
		do return false end
	end
	do return self.modifiers:hasCustom(name) end
end

function sling.common.NodeObject:copyModifiersFrom(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local mods = node:getModifiers()
		if not (mods ~= nil) then
			do return end
		end
		do
			local moddup = mods:dup()
			if not (moddup ~= nil) then
				do return end
			end
			do self:setModifiers(moddup) end
		end
	end
end

function sling.common.NodeObject:visitVector(vector, visitor)
	if vector ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(vector)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(vector[n + 1], '_isType.sling.common.NodeObject')
				if node ~= nil then
					if not node:accept(visitor) then
						do return false end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return true end
end

function sling.common.NodeObject:visitMap(nodes, visitor)
	if nodes == nil then
		do return true end
	end
	do
		local it = _vm:to_table_with_key(_g.jk.lang.Map:iterateValues(nodes), '_isType.jk.lang.Iterator')
		while it ~= nil do
			local o = it:next()
			if not (o ~= nil) then
				do break end
			end
			do
				local node = _vm:to_table_with_key(o, '_isType.sling.common.NodeObject')
				if not (node ~= nil) then
					goto _continue4
				end
				if not node:accept(visitor) then
					do return false end
				end
			end
			::_continue4::
		end
		do return true end
	end
end

function sling.common.NodeObject:accept(visitor)
	if visitor:getSkipChildren() then
		do return true end
	end
	if not visitor:onStartVisit(self) then
		do return false end
	end
	do
		local v = self:acceptVisitor(visitor)
		if visitor:onEndVisit(self) == false then
			v = false
		end
		do return v end
	end
end

function sling.common.NodeObject:acceptVisitor(visitor)
	if not visitor:visit(self) then
		do return false end
	end
	if self.modifiers ~= nil then
		if not self:visitVector(self.modifiers:getNodes(), visitor) then
			do return false end
		end
	end
	do return true end
end

function sling.common.NodeObject:getSource()
	local source = self.source
	if source == nil then
		local pp = self:getParent()
		while true do
			if pp == nil then
				do break end
			end
			source = pp:getSource()
			if source ~= nil then
				do break end
			end
			pp = pp:getParent()
		end
	end
	do return source end
end

function sling.common.NodeObject:setSource(src)
	self.source = src
	do return self end
end

function sling.common.NodeObject:getSourceName()
	local ss = self:getSource()
	if not (ss ~= nil) then
		do return nil end
	end
	do return ss:getSourceName() end
end

function sling.common.NodeObject:getSourceToken()
	local ss = self:getSource()
	if not (ss ~= nil) then
		do return nil end
	end
	do return ss:getSourceToken() end
end

function sling.common.NodeObject:getSourceLineNumber()
	local ss = self:getSource()
	if ss == nil then
		do return -1 end
	end
	do return ss:getSourceLineNumber() end
end

function sling.common.NodeObject:getSourceColumnNumber()
	local ss = self:getSource()
	if ss == nil then
		do return -1 end
	end
	do return ss:getSourceColumnNumber() end
end

function sling.common.NodeObject:getSourceContentLine()
	local ss = self:getSource()
	if not (ss ~= nil) then
		do return nil end
	end
	do return ss:getSourceContentLine() end
end

function sling.common.NodeObject:getNodeTrace()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local p = self
	while p ~= nil do
		do sb:appendString("\n<- ") end
		do sb:appendString(p:getNodeTypeName()) end
		if (_vm:to_table_with_key(p, '_isType.sling.common.NamedNode') ~= nil) then
			local pname = p:getNodeName()
			if _g.jk.lang.String:isEmpty(pname) == false then
				do sb:appendString(" \"") end
				do sb:appendString(pname) end
				do sb:appendString("\"") end
			end
		end
		p = p:getParent()
	end
	do return sb:toString() end
end

function sling.common.NodeObject:onIndexPropertiesChanged()
	local pp = _vm:to_table_with_key(self:getParent(), '_isType.sling.common.ContainerNode')
	if pp ~= nil then
		do pp:updateIndex(self) end
	end
end

function sling.common.NodeObject:getNodeTypeName()
	do return "NodeObject" end
end

function sling.common.NodeObject:getParent()
	do return self.parent end
end

function sling.common.NodeObject:clearParent()
	do self:setParent(nil) end
end

function sling.common.NodeObject:setParent(parent)
	if parent == nil and self.parent ~= nil then
		do self:destroy() end
	end
	self.parent = parent
	if parent ~= nil then
		do self:initialize() end
	end
end

function sling.common.NodeObject:initialize()
end

function sling.common.NodeObject:onChildDestroy(node)
end

function sling.common.NodeObject:destroy()
	if self.parent ~= nil then
		do self.parent:onChildDestroy(self) end
	end
	self.parent = nil
	do self:removeModifiers() end
end

function sling.common.NodeObject:dup()
	local v = self:createNew()
	if not (v ~= nil) then
		do return nil end
	end
	if self:copyTo(v) == false then
		v = nil
	end
	do return v end
end

function sling.common.NodeObject:remove()
	do return self:replaceWith(nil, false) end
end

function sling.common.NodeObject:exportNode()
	do return self:replaceWith(nil, true) end
end

function sling.common.NodeObject:replaceNodeInVector(nodes, oldnode, newnode, doExport)
	if not (nodes ~= nil) then
		do return false end
	end
	if not (oldnode ~= nil) then
		do return false end
	end
	if newnode == nil then
		if _g.jk.lang.Vector:removeValue(nodes, oldnode) < 0 then
			do return false end
		end
		if doExport == false then
			do oldnode:destroy() end
		end
		do return true end
	end
	do
		local m = _g.jk.lang.Vector:getSize(nodes)
		do
			local n = 0
			while n < m do
				local value = _g.jk.lang.Vector:getAt(nodes, n)
				if value == oldnode then
					if doExport == false then
						do oldnode:destroy() end
					end
					do _g.jk.lang.Vector:set(nodes, n, newnode) end
					do newnode:setParent(self) end
					do return true end
				end
				do n = n + 1 end
			end
		end
		do return false end
	end
end

function sling.common.NodeObject:replaceChild(oldnode, newnode, doExport)
	if self.modifiers ~= nil then
		if self:replaceNodeInVector(self.modifiers:getNodes(), oldnode, newnode, doExport) then
			do self:onModifiersChanged() end
			do return true end
		end
	end
	do return false end
end

function sling.common.NodeObject:replaceWith(newnode, doExport)
	local pp = self:getParent()
	if not (pp ~= nil) then
		do return false end
	end
	if not pp:replaceChild(self, newnode, doExport) then
		do return false end
	end
	if newnode ~= nil and newnode:getSource() == nil then
		do newnode:setSource(self.source) end
	end
	do return true end
end

function sling.common.NodeObject:createNew()
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not implemented: createNew", self:getSource(), _g.jk.lang.StackTrace:generate()))
	do return nil end
end

function sling.common.NodeObject:copyCustomTo(node)
	do return true end
end

function sling.common.NodeObject:copyTo(node)
	if node ~= nil then
		do node:setSource(self.source) end
		if not self:copyModifiersTo(node) then
			do return false end
		end
		if not self:copyCustomTo(node) then
			do return false end
		end
	end
	do return true end
end

function sling.common.NodeObject:copyModifiersTo(node)
	if node ~= nil and self.modifiers ~= nil then
		local nmods = self.modifiers:dup()
		if nmods ~= nil then
			do node:setModifiers(nmods) end
		end
	end
	do return true end
end

function sling.common.NodeObject:getInsertionPoint()
	local pp = _vm:to_table_with_key(self:getParent(), '_isType.sling.common.ContainerNode')
	if not (pp ~= nil) then
		do return nil end
	end
	do return pp:getInsertionPointForNode(self) end
end

sling.common.ErrorMessage = _g.sling.common.Message._create()
sling.common.ErrorMessage.__index = sling.common.ErrorMessage
_vm:set_metatable(sling.common.ErrorMessage, {
	__index = _g.sling.common.Message
})

function sling.common.ErrorMessage._create()
	local v = _vm:set_metatable({}, sling.common.ErrorMessage)
	return v
end

function sling.common.ErrorMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ErrorMessage'
	self['_isType.sling.common.ErrorMessage'] = true
	self.stackTrace = nil
end

function sling.common.ErrorMessage:_construct0()
	sling.common.ErrorMessage._init(self)
	do _g.sling.common.Message._construct0(self) end
	return self
end

function sling.common.ErrorMessage:forText(t, ref, isDebug, trace)
	local v = _g.sling.common.ErrorMessage._construct0(_g.sling.common.ErrorMessage._create())
	do v:setMessage(t) end
	do v:setReference(ref) end
	if isDebug then
		if trace ~= nil then
			do v:setStackTrace(trace) end
		else
			do v:updateStackTrace() end
		end
	end
	do return v end
end

function sling.common.ErrorMessage:forError(err, ref, isDebug, trace)
	local v = _g.sling.common.ErrorMessage._construct0(_g.sling.common.ErrorMessage._create())
	do v:setMessage(_g.jk.lang.Error:asString(err)) end
	do v:setReference(ref) end
	if isDebug then
		if trace ~= nil then
			do v:setStackTrace(trace) end
		else
			do v:updateStackTrace() end
		end
	end
	do return v end
end

function sling.common.ErrorMessage:forObject(o, isDebug, trace)
	if not (o ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(o, '_isType.sling.common.ErrorMessage') ~= nil) then
		do return _vm:to_table_with_key(o, '_isType.sling.common.ErrorMessage') end
	end
	if (_vm:get_variable_type(o) == 'string') or (_vm:to_table_with_key(o, '_isType.jk.lang.StringObject') ~= nil) then
		do return _g.sling.common.ErrorMessage:forText(_g.jk.lang.String:asString(o), nil, isDebug, trace) end
	end
	if (_vm:to_table_with_key(o, '_isType.jk.lang.Error') ~= nil) then
		do return _g.sling.common.ErrorMessage:forError(o, nil, isDebug, trace) end
	end
	do return nil end
end

function sling.common.ErrorMessage:asWarning()
	local v = _g.sling.common.WarningMessage:forText(self:getMessage(), self:getReference())
	local array = self:getRelatedMessages()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local relatedMessage = array[n + 1]
				if relatedMessage ~= nil then
					do v:addRelatedMessage(relatedMessage) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.common.ErrorMessage:updateStackTrace()
	do self:setStackTrace(_g.jk.lang.StackTrace:generate()) end
end

function sling.common.ErrorMessage:getType()
	do return "error" end
end

function sling.common.ErrorMessage:toStringWithDebug(isDebug)
	local v = _g.sling.common.Message.toStringWithDebug(self, isDebug)
	if isDebug == false or _g.jk.lang.String:isEmpty(self.stackTrace) then
		do return v end
	end
	do return _g.jk.lang.String:safeString(v) .. "\n" .. _g.jk.lang.String:safeString(self.stackTrace) end
end

function sling.common.ErrorMessage:getStackTrace()
	do return self.stackTrace end
end

function sling.common.ErrorMessage:setStackTrace(v)
	self.stackTrace = v
	do return self end
end

sling.common.StaticTextErrorMessage = _g.sling.common.ErrorMessage._create()
sling.common.StaticTextErrorMessage.__index = sling.common.StaticTextErrorMessage
_vm:set_metatable(sling.common.StaticTextErrorMessage, {
	__index = _g.sling.common.ErrorMessage
})

function sling.common.StaticTextErrorMessage._create()
	local v = _vm:set_metatable({}, sling.common.StaticTextErrorMessage)
	return v
end

function sling.common.StaticTextErrorMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.StaticTextErrorMessage'
	self['_isType.sling.common.StaticTextErrorMessage'] = true
	self.text = nil
end

function sling.common.StaticTextErrorMessage:_construct0()
	sling.common.StaticTextErrorMessage._init(self)
	do _g.sling.common.ErrorMessage._construct0(self) end
	return self
end

function sling.common.StaticTextErrorMessage:getPrefix()
	do return nil end
end

function sling.common.StaticTextErrorMessage:getMessageString()
	local pf = self:getPrefix()
	if not (pf ~= nil) then
		pf = "Error"
	end
	if _g.jk.lang.String:isEmpty(self.text) then
		do return pf end
	end
	do return _g.jk.lang.String:safeString(pf) .. ": " .. _g.jk.lang.String:safeString(self.text) end
end

function sling.common.StaticTextErrorMessage:getText()
	do return self.text end
end

function sling.common.StaticTextErrorMessage:setText(v)
	self.text = v
	do return self end
end

sling.common.TokenSource = {}
sling.common.TokenSource.__index = sling.common.TokenSource
_vm:set_metatable(sling.common.TokenSource, {})

function sling.common.TokenSource._create()
	local v = _vm:set_metatable({}, sling.common.TokenSource)
	return v
end

function sling.common.TokenSource:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.TokenSource'
	self['_isType.sling.common.TokenSource'] = true
	self.file = nil
	self.content = nil
	self.name = nil
	self.lines = nil
end

function sling.common.TokenSource:_construct0()
	sling.common.TokenSource._init(self)
	return self
end

function sling.common.TokenSource:forFile(file, name)
	local v = _g.sling.common.TokenSource._construct0(_g.sling.common.TokenSource._create())
	do v:setFile(file) end
	do v:setName(name) end
	do return v end
end

function sling.common.TokenSource:forString(str)
	local v = _g.sling.common.TokenSource._construct0(_g.sling.common.TokenSource._create())
	do v:setContent(str) end
	do return v end
end

function sling.common.TokenSource:setName(v)
	self.name = v
	do return self end
end

function sling.common.TokenSource:getName()
	do return self.name end
end

function sling.common.TokenSource:getContent()
	if self.content == nil and self.file ~= nil then
		self.content = self.file:getContentsUTF8()
	end
	do return self.content end
end

function sling.common.TokenSource:setContent(v)
	self.content = v
	do return self end
end

function sling.common.TokenSource:recycleContent()
	if self.file ~= nil then
		self.content = nil
	end
end

function sling.common.TokenSource:getLines()
	if self.lines == nil then
		local cc = self:getContent()
		if cc ~= nil then
			self.lines = {}
			do
				local array = _g.jk.lang.String:split(self.content, 10, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local line = array[n + 1]
							if line ~= nil then
								while _g.jk.lang.String:endsWith(line, "\r") do
									line = _g.jk.lang.String:getSubString(line, 0, _g.jk.lang.String:getLength(line) - 1)
								end
								do _g.jk.lang.Vector:append(self.lines, line) end
							end
							do n = n + 1 end
						end
					end
				end
				do self:recycleContent() end
			end
		end
	end
	do return self.lines end
end

function sling.common.TokenSource:getLine(n)
	local lines = self:getLines()
	if not (lines ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Vector:getAt(lines, n) end
end

function sling.common.TokenSource:getFile()
	do return self.file end
end

function sling.common.TokenSource:setFile(v)
	self.file = v
	do return self end
end

sling.common.InfoMessage = _g.sling.common.Message._create()
sling.common.InfoMessage.__index = sling.common.InfoMessage
_vm:set_metatable(sling.common.InfoMessage, {
	__index = _g.sling.common.Message
})

function sling.common.InfoMessage._create()
	local v = _vm:set_metatable({}, sling.common.InfoMessage)
	return v
end

function sling.common.InfoMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.InfoMessage'
	self['_isType.sling.common.InfoMessage'] = true
end

function sling.common.InfoMessage:_construct0()
	sling.common.InfoMessage._init(self)
	do _g.sling.common.Message._construct0(self) end
	return self
end

function sling.common.InfoMessage:forText(t, ref)
	local v = _g.sling.common.InfoMessage._construct0(_g.sling.common.InfoMessage._create())
	do v:setMessage(t) end
	do v:setReference(ref) end
	do return v end
end

function sling.common.InfoMessage:getType()
	do return "info" end
end

sling.common.ContainerNode = _g.sling.common.NodeObject._create()
sling.common.ContainerNode.__index = sling.common.ContainerNode
_vm:set_metatable(sling.common.ContainerNode, {
	__index = _g.sling.common.NodeObject
})

function sling.common.ContainerNode._create()
	local v = _vm:set_metatable({}, sling.common.ContainerNode)
	return v
end

function sling.common.ContainerNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ContainerNode'
	self['_isType.sling.common.ContainerNode'] = true
	self.nodes = nil
	self.nodeIndex = nil
	self.caseSensitiveIndex = true
end

function sling.common.ContainerNode:_construct0()
	sling.common.ContainerNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.common.ContainerNode:getNodeIndexNames()
	local v = _g.jk.lang.Map:getKeys(self.nodeIndex)
	do return v end
end

function sling.common.ContainerNode:getNodeIndexForName(name)
	if not (self.nodeIndex ~= nil) then
		do return nil end
	end
	if self.caseSensitiveIndex == false then
		do return _g.jk.lang.Map:get(self.nodeIndex, _g.jk.lang.String:toLowerCase(name)) end
	end
	do return _g.jk.lang.Map:get(self.nodeIndex, name) end
end

function sling.common.ContainerNode:copyTo(node)
	if not _g.sling.common.NodeObject.copyTo(self, node) then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(node, '_isType.sling.common.ContainerNode')
		if n == nil then
			do return true end
		end
		do n:clearNodes() end
		do n:setCaseSensitiveIndex(self:getCaseSensitiveIndex()) end
		if self.nodes ~= nil then
			local n2 = 0
			local m = _g.jk.lang.Vector:getSize(self.nodes)
			do
				n2 = 0
				while n2 < m do
					local cn = _vm:to_table_with_key(self.nodes[n2 + 1], '_isType.sling.common.NodeObject')
					if cn ~= nil then
						local ndup = cn:dup()
						if not (ndup ~= nil) then
							do return false end
						end
						do n:addNode(ndup) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do return true end
	end
end

function sling.common.ContainerNode:getChildCount()
	if self.nodes == nil then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.nodes) end
end

sling.common.ContainerNode.MyInsertionPoint = {}
sling.common.ContainerNode.MyInsertionPoint.__index = sling.common.ContainerNode.MyInsertionPoint
_vm:set_metatable(sling.common.ContainerNode.MyInsertionPoint, {})

function sling.common.ContainerNode.MyInsertionPoint._create()
	local v = _vm:set_metatable({}, sling.common.ContainerNode.MyInsertionPoint)
	return v
end

function sling.common.ContainerNode.MyInsertionPoint:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ContainerNode.MyInsertionPoint'
	self['_isType.sling.common.ContainerNode.MyInsertionPoint'] = true
	self['_isType.sling.common.NodeInsertionPoint'] = true
	self.container = nil
	self.nodes = nil
	self.index = 0
end

function sling.common.ContainerNode.MyInsertionPoint:_construct0()
	sling.common.ContainerNode.MyInsertionPoint._init(self)
	return self
end

function sling.common.ContainerNode.MyInsertionPoint:insertBefore(n)
	if not (n ~= nil) then
		do return false end
	end
	do _g.jk.lang.Vector:insert(self.nodes, n, self.index) end
	do n:setParent(self.container) end
	do self.container:addToIndex(n) end
	do self.index = self.index + 1 end
	do return true end
end

function sling.common.ContainerNode.MyInsertionPoint:insertAfter(n)
	if not (n ~= nil) then
		do return false end
	end
	do _g.jk.lang.Vector:insert(self.nodes, n, self.index + 1) end
	do n:setParent(self.container) end
	do self.container:addToIndex(n) end
	do return true end
end

function sling.common.ContainerNode.MyInsertionPoint:getBefore()
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.nodes, self.index - 1), '_isType.sling.common.NodeObject') end
end

function sling.common.ContainerNode.MyInsertionPoint:getNode()
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.nodes, self.index), '_isType.sling.common.NodeObject') end
end

function sling.common.ContainerNode.MyInsertionPoint:getAfter()
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.nodes, self.index + 1), '_isType.sling.common.NodeObject') end
end

function sling.common.ContainerNode.MyInsertionPoint:getContainer()
	do return self.container end
end

function sling.common.ContainerNode.MyInsertionPoint:setContainer(v)
	self.container = v
	do return self end
end

function sling.common.ContainerNode.MyInsertionPoint:getNodes()
	do return self.nodes end
end

function sling.common.ContainerNode.MyInsertionPoint:setNodes(v)
	self.nodes = v
	do return self end
end

function sling.common.ContainerNode.MyInsertionPoint:getIndex()
	do return self.index end
end

function sling.common.ContainerNode.MyInsertionPoint:setIndex(v)
	self.index = v
	do return self end
end

function sling.common.ContainerNode:getInsertionPointForNode(node)
	if not (node ~= nil) then
		do return nil end
	end
	if not (self.nodes ~= nil) then
		do return nil end
	end
	do
		local m = _g.jk.lang.Vector:getSize(self.nodes)
		do
			local n = 0
			while n < m do
				local value = _g.jk.lang.Vector:get(self.nodes, n)
				if node == value then
					local v = _g.sling.common.ContainerNode.MyInsertionPoint._construct0(_g.sling.common.ContainerNode.MyInsertionPoint._create())
					do v:setContainer(self) end
					do v:setNodes(self.nodes) end
					do v:setIndex(n) end
					do return v end
				end
				do n = n + 1 end
			end
		end
		do return nil end
	end
end

function sling.common.ContainerNode:insertAboveNode(newnode, existingnode)
	if not (newnode ~= nil) then
		do return false end
	end
	if existingnode == nil then
		do self:addNode(newnode) end
		do return true end
	end
	if not (self.nodes ~= nil) then
		do return false end
	end
	do
		local m = _g.jk.lang.Vector:getSize(self.nodes)
		do
			local n = 0
			while n < m do
				local value = _g.jk.lang.Vector:get(self.nodes, n)
				if existingnode == value then
					do _g.jk.lang.Vector:insert(self.nodes, newnode, n) end
					do newnode:setParent(self) end
					do self:addToIndex(newnode) end
					do return true end
				end
				do n = n + 1 end
			end
		end
		do return false end
	end
end

function sling.common.ContainerNode:insertBelowNode(newnode, existingnode)
	if not (newnode ~= nil) then
		do return false end
	end
	if existingnode == nil then
		do self:addNode(newnode) end
		do return true end
	end
	if not (self.nodes ~= nil) then
		do return false end
	end
	do
		local m = _g.jk.lang.Vector:getSize(self.nodes)
		do
			local n = 0
			while n < m do
				local value = _g.jk.lang.Vector:get(self.nodes, n)
				if existingnode == value then
					do _g.jk.lang.Vector:insert(self.nodes, newnode, n + 1) end
					do newnode:setParent(self) end
					do self:addToIndex(newnode) end
					do return true end
				end
				do n = n + 1 end
			end
		end
		do return false end
	end
end

function sling.common.ContainerNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.nodes, oldnode, newnode, doExport) then
		if doExport then
			do self:removeFromIndex(oldnode) end
		end
		if newnode ~= nil then
			do self:addToIndex(newnode) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.ContainerNode:replaceExport(oldnode, newnode)
	if oldnode == nil then
		if newnode ~= nil then
			do self:addNode(newnode) end
		end
		do return nil end
	end
	if newnode == nil then
		do return self:exportNode1(oldnode) end
	end
	if not (self.nodes ~= nil) then
		do return nil end
	end
	do
		local m = _g.jk.lang.Vector:getSize(self.nodes)
		do
			local n = 0
			while n < m do
				local value = _g.jk.lang.Vector:get(self.nodes, n)
				if oldnode == value then
					do self:removeFromIndex(oldnode) end
					do _g.jk.lang.Vector:set(self.nodes, n, newnode) end
					do newnode:setParent(self) end
					do self:addToIndex(newnode) end
					do return oldnode end
				end
				do n = n + 1 end
			end
		end
		do return nil end
	end
end

function sling.common.ContainerNode:getNodeTypeName()
	do return "ContainerNode" end
end

function sling.common.ContainerNode:acceptVisitor(visitor)
	if not _g.sling.common.NodeObject.acceptVisitor(self, visitor) then
		do return false end
	end
	if not self:visitVector(self.nodes, visitor) then
		do return false end
	end
	do return true end
end

function sling.common.ContainerNode:exportNode1(decl)
	if not (decl ~= nil) then
		do return nil end
	end
	if not (self.nodes ~= nil) then
		do return nil end
	end
	do _g.jk.lang.Vector:removeValue(self.nodes, decl) end
	do self:removeFromIndex(decl) end
	do return decl end
end

function sling.common.ContainerNode:getNodes()
	do return self.nodes end
end

function sling.common.ContainerNode:getFirstNode()
	if not (self.nodes ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:getFirst(self.nodes), '_isType.sling.common.NodeObject') end
end

function sling.common.ContainerNode:getLastNode()
	if not (self.nodes ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:getLast(self.nodes), '_isType.sling.common.NodeObject') end
end

function sling.common.ContainerNode:exportNodes()
	local v = self.nodes
	self.nodes = nil
	self.nodeIndex = nil
	do return v end
end

function sling.common.ContainerNode:importNodes(decls)
	do self:clearNodes() end
	if decls ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(decls)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(decls[n + 1], '_isType.sling.common.NodeObject')
				if node ~= nil then
					do node:setParent(self) end
				end
				do n = n + 1 end
			end
		end
	end
	self.nodes = decls
end

function sling.common.ContainerNode:hasChildNode(name)
	if not (self.nodeIndex ~= nil) or not (name ~= nil) then
		do return false end
	end
	do
		local a = self:getNodeIndexForName(name)
		if _g.jk.lang.Vector:isEmpty(a) then
			do return false end
		end
		do return true end
	end
end

function sling.common.ContainerNode:setNodes(decls)
	do self:clearNodes() end
	if decls ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(decls)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(decls[n + 1], '_isType.sling.common.NodeObject')
				if decl ~= nil then
					do self:addNode(decl) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.common.ContainerNode:addToIndex(decl)
	if not (decl ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(decl, '_isType.sling.common.NamedNode') ~= nil) then
		local name = decl:getNodeName()
		if not (name ~= nil) then
			do return end
		end
		if not (self.nodeIndex ~= nil) then
			self.nodeIndex = {}
		end
		do
			local ll = self:getNodeIndexForName(name)
			if not (ll ~= nil) then
				if self.caseSensitiveIndex == false then
					name = _g.jk.lang.String:toLowerCase(name)
				end
				ll = {}
				self.nodeIndex[name] = ll
			end
			do _g.jk.lang.Vector:append(ll, decl) end
		end
	end
end

function sling.common.ContainerNode:removeFromIndex(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.nodeIndex ~= nil) then
		do return end
	end
	if not (_vm:to_table_with_key(decl, '_isType.sling.common.NamedNode') ~= nil) then
		do return end
	end
	do
		local name = decl:getNodeName()
		if not (name ~= nil) then
			do return end
		end
		do
			local list = self:getNodeIndexForName(name)
			if list ~= nil then
				do _g.jk.lang.Vector:removeValue(list, decl) end
				if _g.jk.lang.Vector:getSize(list) < 1 then
					if self.caseSensitiveIndex == false then
						name = _g.jk.lang.String:toLowerCase(name)
					end
					do _g.jk.lang.Map:remove(self.nodeIndex, name) end
				end
			end
		end
	end
end

function sling.common.ContainerNode:updateIndex(decl)
	do self:removeFromIndex(decl) end
	do self:addToIndex(decl) end
end

function sling.common.ContainerNode:insertNode(decl, index)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.nodes ~= nil) then
		self.nodes = {}
	end
	do
		local idx = index
		local ns = _g.jk.lang.Vector:getSize(self.nodes)
		if idx > ns then
			idx = ns
		end
		if idx < 0 then
			idx = 0
		end
		do _g.jk.lang.Vector:insert(self.nodes, decl, index) end
		do self:addToIndex(decl) end
		do decl:setParent(self) end
	end
end

function sling.common.ContainerNode:addNode(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.nodes ~= nil) then
		self.nodes = {}
	end
	do _g.jk.lang.Vector:append(self.nodes, decl) end
	do self:addToIndex(decl) end
	do decl:setParent(self) end
end

function sling.common.ContainerNode:prependNode(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.nodes ~= nil) then
		self.nodes = {}
	end
	do _g.jk.lang.Vector:prepend(self.nodes, decl) end
	do self:addToIndex(decl) end
	do decl:setParent(self) end
end

function sling.common.ContainerNode:removeNode(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.nodes ~= nil) then
		do return end
	end
	do _g.jk.lang.Vector:removeValue(self.nodes, decl) end
	do decl:destroy() end
end

function sling.common.ContainerNode:clearNodes()
	self.nodeIndex = nil
	if self.nodes ~= nil then
		local n2 = 0
		local m = _g.jk.lang.Vector:getSize(self.nodes)
		do
			n2 = 0
			while n2 < m do
				local n = _vm:to_table_with_key(self.nodes[n2 + 1], '_isType.sling.common.NodeObject')
				if n ~= nil then
					do n:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.nodes = nil
end

function sling.common.ContainerNode:onChildDestroy(node)
	do _g.sling.common.NodeObject.onChildDestroy(self, node) end
	do self:removeFromIndex(node) end
end

function sling.common.ContainerNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	do self:clearNodes() end
end

function sling.common.ContainerNode:merge(other)
	if not (other ~= nil) then
		do return true end
	end
	do
		local array = other:exportNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						if (_vm:to_table_with_key(node, '_isType.sling.common.NamedNode') ~= nil) and (_vm:to_table_with_key(node, '_isType.sling.common.ContainerNode') ~= nil) then
							local nt = node:getNodeTypeName()
							local idx = self:getNodeIndexForName(node:getNodeName())
							if nt ~= nil and idx ~= nil and _g.jk.lang.Vector:getSize(idx) > 0 then
								local ok = false
								if idx ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(idx)
									do
										n2 = 0
										while n2 < m2 do
											local xnode = _vm:to_table_with_key(idx[n2 + 1], '_isType.sling.common.ContainerNode')
											if xnode ~= nil then
												if nt == xnode:getNodeTypeName() then
													if not xnode:merge(node) then
														do return false end
													end
													ok = true
													do break end
												end
											end
											do n2 = n2 + 1 end
										end
									end
								end
								if ok then
									goto _continue3
								end
							end
						end
						do self:addNode(node) end
					end
					::_continue3::
					do n = n + 1 end
				end
			end
		end
		do return true end
	end
end

function sling.common.ContainerNode:getCaseSensitiveIndex()
	do return self.caseSensitiveIndex end
end

function sling.common.ContainerNode:setCaseSensitiveIndex(v)
	self.caseSensitiveIndex = v
	do return self end
end

sling.common.DebugMessage = _g.sling.common.Message._create()
sling.common.DebugMessage.__index = sling.common.DebugMessage
_vm:set_metatable(sling.common.DebugMessage, {
	__index = _g.sling.common.Message
})

function sling.common.DebugMessage._create()
	local v = _vm:set_metatable({}, sling.common.DebugMessage)
	return v
end

function sling.common.DebugMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.DebugMessage'
	self['_isType.sling.common.DebugMessage'] = true
end

function sling.common.DebugMessage:_construct0()
	sling.common.DebugMessage._init(self)
	do _g.sling.common.Message._construct0(self) end
	return self
end

function sling.common.DebugMessage:forText(t, ref)
	local v = _g.sling.common.DebugMessage._construct0(_g.sling.common.DebugMessage._create())
	do v:setMessage(t) end
	do v:setReference(ref) end
	do return v end
end

function sling.common.DebugMessage:forMessage(msg)
	local v = _g.sling.common.DebugMessage._construct0(_g.sling.common.DebugMessage._create())
	if msg ~= nil then
		do v:setMessage(msg:getMessage()) end
		do v:setReference(msg:getReference()) end
	end
	do return v end
end

function sling.common.DebugMessage:getType()
	do return "debug" end
end

sling.common.NamedNode = {}

sling.common.FileParser = {}

sling.common.StringOutputWriterManager = {}
sling.common.StringOutputWriterManager.__index = sling.common.StringOutputWriterManager
_vm:set_metatable(sling.common.StringOutputWriterManager, {})

function sling.common.StringOutputWriterManager._create()
	local v = _vm:set_metatable({}, sling.common.StringOutputWriterManager)
	return v
end

function sling.common.StringOutputWriterManager:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.StringOutputWriterManager'
	self['_isType.sling.common.StringOutputWriterManager'] = true
	self['_isType.sling.common.OutputWriterManager'] = true
	self.buf = nil
end

sling.common.StringOutputWriterManager.MyOutput = {}
sling.common.StringOutputWriterManager.MyOutput.__index = sling.common.StringOutputWriterManager.MyOutput
_vm:set_metatable(sling.common.StringOutputWriterManager.MyOutput, {})

function sling.common.StringOutputWriterManager.MyOutput._create()
	local v = _vm:set_metatable({}, sling.common.StringOutputWriterManager.MyOutput)
	return v
end

function sling.common.StringOutputWriterManager.MyOutput:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.StringOutputWriterManager.MyOutput'
	self['_isType.sling.common.StringOutputWriterManager.MyOutput'] = true
	self['_isType.sling.common.OutputWriter'] = true
	self.buf = nil
end

function sling.common.StringOutputWriterManager.MyOutput:_construct0()
	sling.common.StringOutputWriterManager.MyOutput._init(self)
	return self
end

function sling.common.StringOutputWriterManager.MyOutput:writeString(str)
	do self.buf:appendString(str) end
	do return true end
end

function sling.common.StringOutputWriterManager.MyOutput:writeBuffer(bb)
	do self.buf:appendString(_g.jk.lang.String:forUTF8Buffer(bb)) end
	do return true end
end

function sling.common.StringOutputWriterManager.MyOutput:finalize()
	do return true end
end

function sling.common.StringOutputWriterManager.MyOutput:getBuf()
	do return self.buf end
end

function sling.common.StringOutputWriterManager.MyOutput:setBuf(v)
	self.buf = v
	do return self end
end

function sling.common.StringOutputWriterManager:_construct0()
	sling.common.StringOutputWriterManager._init(self)
	self.buf = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	return self
end

function sling.common.StringOutputWriterManager:getOutputFile(name)
	if self.buf:count() > 0 then
		do self.buf:appendCharacter(10) end
	end
	do return _g.sling.common.StringOutputWriterManager.MyOutput._construct0(_g.sling.common.StringOutputWriterManager.MyOutput._create()):setBuf(self.buf) end
end

function sling.common.StringOutputWriterManager:getResult()
	do return self.buf:toString() end
end

function sling.common.StringOutputWriterManager:finalize()
end

function sling.common.StringOutputWriterManager:toString()
	do return self.buf:toString() end
end

sling.common.NamedContainerNode = _g.sling.common.ContainerNode._create()
sling.common.NamedContainerNode.__index = sling.common.NamedContainerNode
_vm:set_metatable(sling.common.NamedContainerNode, {
	__index = _g.sling.common.ContainerNode
})

function sling.common.NamedContainerNode._create()
	local v = _vm:set_metatable({}, sling.common.NamedContainerNode)
	return v
end

function sling.common.NamedContainerNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NamedContainerNode'
	self['_isType.sling.common.NamedContainerNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
end

function sling.common.NamedContainerNode:_construct0()
	sling.common.NamedContainerNode._init(self)
	do _g.sling.common.ContainerNode._construct0(self) end
	return self
end

function sling.common.NamedContainerNode:getNodeName()
	do return self.name end
end

function sling.common.NamedContainerNode:renameNode(name)
	do self:setName(name) end
end

function sling.common.NamedContainerNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.common.NamedContainerNode:getNodeTypeName()
	do return "NamedContainerNode" end
end

function sling.common.NamedContainerNode:createNew()
	do return _g.sling.common.NamedContainerNode._construct0(_g.sling.common.NamedContainerNode._create()) end
end

function sling.common.NamedContainerNode:copyTo(o)
	if _g.sling.common.ContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.NamedContainerNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		do return true end
	end
end

function sling.common.NamedContainerNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.NamedContainerNode:acceptVisitor(visitor)
	if _g.sling.common.ContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.common.NamedContainerNode:destroy()
	do _g.sling.common.ContainerNode.destroy(self) end
end

function sling.common.NamedContainerNode:getName()
	do return self.name end
end

sling.common.StatusMessage = _g.sling.common.Message._create()
sling.common.StatusMessage.__index = sling.common.StatusMessage
_vm:set_metatable(sling.common.StatusMessage, {
	__index = _g.sling.common.Message
})

function sling.common.StatusMessage._create()
	local v = _vm:set_metatable({}, sling.common.StatusMessage)
	return v
end

function sling.common.StatusMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.StatusMessage'
	self['_isType.sling.common.StatusMessage'] = true
end

function sling.common.StatusMessage:_construct0()
	sling.common.StatusMessage._init(self)
	do _g.sling.common.Message._construct0(self) end
	return self
end

function sling.common.StatusMessage:forText(text)
	local v = _g.sling.common.StatusMessage._construct0(_g.sling.common.StatusMessage._create())
	do v:setMessage(text) end
	do return v end
end

function sling.common.StatusMessage:getType()
	do return "status" end
end

sling.common.ModifierContainer = {}
sling.common.ModifierContainer.__index = sling.common.ModifierContainer
_vm:set_metatable(sling.common.ModifierContainer, {})

function sling.common.ModifierContainer._create()
	local v = _vm:set_metatable({}, sling.common.ModifierContainer)
	return v
end

function sling.common.ModifierContainer:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ModifierContainer'
	self['_isType.sling.common.ModifierContainer'] = true
	self.commons = nil
	self.customs = nil
	self.nodes = nil
end

function sling.common.ModifierContainer:_construct0()
	sling.common.ModifierContainer._init(self)
	return self
end

function sling.common.ModifierContainer:dup()
	local v = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	if self.commons ~= nil then
		local ss = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
		local array = self.commons:getAll()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local cc = array[n + 1]
					if cc ~= nil then
						do ss:add(cc) end
					end
					do n = n + 1 end
				end
			end
		end
		do v:setCommons(ss) end
	end
	if self.customs ~= nil then
		local ss = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
		local array2 = self.customs:getAll()
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local cc = array2[n2 + 1]
					if cc ~= nil then
						do ss:add(cc) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do v:setCustoms(ss) end
	end
	if self.nodes ~= nil then
		local ss = {}
		if self.nodes ~= nil then
			local n3 = 0
			local m3 = _g.jk.lang.Vector:getSize(self.nodes)
			do
				n3 = 0
				while n3 < m3 do
					local o = self.nodes[n3 + 1]
					if o ~= nil then
						if (_vm:to_table_with_key(o, '_isType.sling.common.NodeObject') ~= nil) then
							local oo = o:dup()
							if oo ~= nil then
								do _g.jk.lang.Vector:append(ss, oo) end
							end
						else
							do _g.jk.lang.Vector:append(ss, o) end
						end
					end
					do n3 = n3 + 1 end
				end
			end
		end
		do v:setNodes(ss) end
	end
	do return v end
end

function sling.common.ModifierContainer:addCommon(mod)
	if not (mod ~= nil) then
		do return end
	end
	if self.commons == nil then
		self.commons = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
	end
	do self.commons:add(mod) end
end

function sling.common.ModifierContainer:addCustom(mod)
	if not (mod ~= nil) then
		do return end
	end
	if self.customs == nil then
		self.customs = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
	end
	do self.customs:add(mod) end
end

function sling.common.ModifierContainer:addNode(mod)
	if not (mod ~= nil) then
		do return end
	end
	if self.nodes == nil then
		self.nodes = {}
	end
	do _g.jk.lang.Vector:append(self.nodes, mod) end
end

function sling.common.ModifierContainer:removeNode(mod)
	if not (mod ~= nil) then
		do return false end
	end
	if not (self.nodes ~= nil) then
		do return false end
	end
	do _g.jk.lang.Vector:removeValue(self.nodes, mod) end
	do return true end
end

function sling.common.ModifierContainer:removeCommon(mod)
	if not (mod ~= nil) then
		do return false end
	end
	if not (self.commons ~= nil) then
		do return false end
	end
	do self.commons:remove(mod) end
	do return true end
end

function sling.common.ModifierContainer:removeCustom(mod)
	if not (mod ~= nil) then
		do return false end
	end
	if not (self.customs ~= nil) then
		do return false end
	end
	do self.customs:remove(mod) end
	do return true end
end

function sling.common.ModifierContainer:hasCommon(name)
	if not (name ~= nil) then
		do return false end
	end
	if not (self.commons ~= nil) then
		do return false end
	end
	do return self.commons:contains(name) end
end

function sling.common.ModifierContainer:hasCustom(name)
	if not (name ~= nil) then
		do return false end
	end
	if not (self.customs ~= nil) then
		do return false end
	end
	do return self.customs:contains(name) end
end

function sling.common.ModifierContainer:getCommonsVector()
	if not (self.commons ~= nil) then
		do return nil end
	end
	do return self.commons:getAll() end
end

function sling.common.ModifierContainer:getCustomsVector()
	if not (self.customs ~= nil) then
		do return nil end
	end
	do return self.customs:getAll() end
end

function sling.common.ModifierContainer:getCommons()
	do return self.commons end
end

function sling.common.ModifierContainer:setCommons(v)
	self.commons = v
	do return self end
end

function sling.common.ModifierContainer:getCustoms()
	do return self.customs end
end

function sling.common.ModifierContainer:setCustoms(v)
	self.customs = v
	do return self end
end

function sling.common.ModifierContainer:getNodes()
	do return self.nodes end
end

function sling.common.ModifierContainer:setNodes(v)
	self.nodes = v
	do return self end
end

sling.common.Token = {}
sling.common.Token.__index = sling.common.Token
_vm:set_metatable(sling.common.Token, {})

function sling.common.Token._create()
	local v = _vm:set_metatable({}, sling.common.Token)
	return v
end

function sling.common.Token:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.Token'
	self['_isType.sling.common.Token'] = true
	self['_isType.sling.common.SourceReference'] = true
	self.value = nil
	self.line = 0
	self.column = 0
	self.position = 0
	self.source = nil
end

function sling.common.Token:_construct0()
	sling.common.Token._init(self)
	return self
end

function sling.common.Token:instance(value, line, column, position)
	local v = _g.sling.common.Token._construct0(_g.sling.common.Token._create())
	v.value = value
	v.line = line
	v.column = column
	v.position = position
	do return v end
end

function sling.common.Token:dupWithValue(str)
	local v = _g.sling.common.Token._construct0(_g.sling.common.Token._create())
	v.value = str
	v.line = self.line
	v.column = self.column
	v.position = self.position
	v.source = self.source
	do return v end
end

function sling.common.Token:getTokenLineCount()
	if self.value == nil then
		do return 0 end
	end
	do
		local v = 1
		local it = _g.jk.lang.String:iterate(self.value)
		while true do
			local c = it:getNextChar()
			if c < 1 then
				do break end
			end
			if c == 10 then
				do v = v + 1 end
			end
		end
		do return v end
	end
end

function sling.common.Token:setValue(val)
	self.value = val
	do return self end
end

function sling.common.Token:getValue()
	do return self.value end
end

function sling.common.Token:getSourceName()
	if not (self.source ~= nil) then
		do return nil end
	end
	do return self.source:getName() end
end

function sling.common.Token:getSourceToken()
	do return self.value end
end

function sling.common.Token:getSourceLineNumber()
	do return self.line end
end

function sling.common.Token:getSourceColumnNumber()
	do return self.column end
end

function sling.common.Token:getSourceContentLine()
	if not (self.source ~= nil) then
		do return nil end
	end
	do return self.source:getLine(self.line) end
end

function sling.common.Token:getNodeTrace()
	do return nil end
end

sling.common.DataTypeNode = _g.sling.common.NodeObject._create()
sling.common.DataTypeNode.__index = sling.common.DataTypeNode
_vm:set_metatable(sling.common.DataTypeNode, {
	__index = _g.sling.common.NodeObject
})

function sling.common.DataTypeNode._create()
	local v = _vm:set_metatable({}, sling.common.DataTypeNode)
	return v
end

function sling.common.DataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.DataTypeNode'
	self['_isType.sling.common.DataTypeNode'] = true
	self.isNullable = false
end

function sling.common.DataTypeNode:duplicate(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local v = _vm:to_table_with_key(node:dup(), '_isType.sling.common.DataTypeNode')
		if not (v ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate as data type", node:getSource(), _g.jk.lang.StackTrace:generate()))
		end
		do return v end
	end
end

function sling.common.DataTypeNode:_construct0()
	sling.common.DataTypeNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	do self:setIsNullable(true) end
	return self
end

function sling.common.DataTypeNode:getNodeTypeName()
	do return "DataTypeNode" end
end

function sling.common.DataTypeNode:createNew()
	do return _g.sling.common.DataTypeNode._construct0(_g.sling.common.DataTypeNode._create()) end
end

function sling.common.DataTypeNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.DataTypeNode')
		if n == nil then
			do return true end
		end
		n.isNullable = self.isNullable
		do return true end
	end
end

function sling.common.DataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.DataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.common.DataTypeNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.common.DataTypeNode:setIsNullable(v)
	self.isNullable = v
end

function sling.common.DataTypeNode:getIsNullable()
	do return self.isNullable end
end

sling.common.ExpressionNode = _g.sling.common.NodeObject._create()
sling.common.ExpressionNode.__index = sling.common.ExpressionNode
_vm:set_metatable(sling.common.ExpressionNode, {
	__index = _g.sling.common.NodeObject
})

function sling.common.ExpressionNode._create()
	local v = _vm:set_metatable({}, sling.common.ExpressionNode)
	return v
end

function sling.common.ExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ExpressionNode'
	self['_isType.sling.common.ExpressionNode'] = true
	self.defaultDataType = nil
	self.resolvedDataType = nil
end

function sling.common.ExpressionNode:_construct0()
	sling.common.ExpressionNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.common.ExpressionNode:getNodeTypeName()
	do return "ExpressionNode" end
end

function sling.common.ExpressionNode:createNew()
	do return _g.sling.common.ExpressionNode._construct0(_g.sling.common.ExpressionNode._create()) end
end

function sling.common.ExpressionNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.ExpressionNode')
		if n == nil then
			do return true end
		end
		if n.defaultDataType ~= nil then
			do n.defaultDataType:destroy() end
			n.defaultDataType = nil
		end
		if self.defaultDataType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.defaultDataType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.defaultDataType = pcp
			do n.defaultDataType:setParent(n) end
		end
		if n.resolvedDataType ~= nil then
			do n.resolvedDataType:destroy() end
			n.resolvedDataType = nil
		end
		if self.resolvedDataType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.resolvedDataType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.resolvedDataType = pcp
			do n.resolvedDataType:setParent(n) end
		end
		do return true end
	end
end

function sling.common.ExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.defaultDataType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.defaultDataType:destroy() end
		end
		self.defaultDataType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.defaultDataType ~= nil then
			do self.defaultDataType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.resolvedDataType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.resolvedDataType:destroy() end
		end
		self.resolvedDataType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.resolvedDataType ~= nil then
			do self.resolvedDataType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.ExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.defaultDataType ~= nil then
		if self.defaultDataType:accept(visitor) == false then
			do return false end
		end
	end
	if self.resolvedDataType ~= nil then
		if self.resolvedDataType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.common.ExpressionNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.defaultDataType ~= nil then
		do self.defaultDataType:destroy() end
		self.defaultDataType = nil
	end
	if self.resolvedDataType ~= nil then
		do self.resolvedDataType:destroy() end
		self.resolvedDataType = nil
	end
end

function sling.common.ExpressionNode:setDefaultDataType(v, doExport)
	if self.defaultDataType ~= nil and doExport == false then
		do self.defaultDataType:destroy() end
	end
	self.defaultDataType = v
	if self.defaultDataType ~= nil then
		do self.defaultDataType:setParent(self) end
	end
end

function sling.common.ExpressionNode:getDefaultDataType()
	do return self.defaultDataType end
end

function sling.common.ExpressionNode:exportDefaultDataType()
	local v = self.defaultDataType
	self.defaultDataType = nil
	do return v end
end

function sling.common.ExpressionNode:setResolvedDataType(v, doExport)
	if self.resolvedDataType ~= nil and doExport == false then
		do self.resolvedDataType:destroy() end
	end
	self.resolvedDataType = v
	if self.resolvedDataType ~= nil then
		do self.resolvedDataType:setParent(self) end
	end
end

function sling.common.ExpressionNode:getResolvedDataType()
	do return self.resolvedDataType end
end

function sling.common.ExpressionNode:exportResolvedDataType()
	local v = self.resolvedDataType
	self.resolvedDataType = nil
	do return v end
end

sling.common.CodeFileNode = _g.sling.common.NamedContainerNode._create()
sling.common.CodeFileNode.__index = sling.common.CodeFileNode
_vm:set_metatable(sling.common.CodeFileNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.common.CodeFileNode._create()
	local v = _vm:set_metatable({}, sling.common.CodeFileNode)
	return v
end

function sling.common.CodeFileNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeFileNode'
	self['_isType.sling.common.CodeFileNode'] = true
	self.file = nil
	self.description = nil
end

function sling.common.CodeFileNode:_construct0()
	sling.common.CodeFileNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.common.CodeFileNode:getNodeTypeName()
	do return "CodeFileNode" end
end

function sling.common.CodeFileNode:createNew()
	do return _g.sling.common.CodeFileNode._construct0(_g.sling.common.CodeFileNode._create()) end
end

function sling.common.CodeFileNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.CodeFileNode')
		if n == nil then
			do return true end
		end
		n.file = self.file
		n.description = self.description
		do return true end
	end
end

function sling.common.CodeFileNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.CodeFileNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.common.CodeFileNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
end

function sling.common.CodeFileNode:setFile(v)
	self.file = v
end

function sling.common.CodeFileNode:getFile()
	do return self.file end
end

function sling.common.CodeFileNode:setDescription(v)
	self.description = v
end

function sling.common.CodeFileNode:getDescription()
	do return self.description end
end

sling.common.CodeDirectoryNode = _g.sling.common.NamedContainerNode._create()
sling.common.CodeDirectoryNode.__index = sling.common.CodeDirectoryNode
_vm:set_metatable(sling.common.CodeDirectoryNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.common.CodeDirectoryNode._create()
	local v = _vm:set_metatable({}, sling.common.CodeDirectoryNode)
	return v
end

function sling.common.CodeDirectoryNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeDirectoryNode'
	self['_isType.sling.common.CodeDirectoryNode'] = true
	self.description = nil
end

function sling.common.CodeDirectoryNode:_construct0()
	sling.common.CodeDirectoryNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.common.CodeDirectoryNode:getNodeTypeName()
	do return "CodeDirectoryNode" end
end

function sling.common.CodeDirectoryNode:createNew()
	do return _g.sling.common.CodeDirectoryNode._construct0(_g.sling.common.CodeDirectoryNode._create()) end
end

function sling.common.CodeDirectoryNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.CodeDirectoryNode')
		if n == nil then
			do return true end
		end
		n.description = self.description
		do return true end
	end
end

function sling.common.CodeDirectoryNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.CodeDirectoryNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.common.CodeDirectoryNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
end

function sling.common.CodeDirectoryNode:setDescription(v)
	self.description = v
end

function sling.common.CodeDirectoryNode:getDescription()
	do return self.description end
end

sling.common.DirectoryOutputWriterManager = {}
sling.common.DirectoryOutputWriterManager.__index = sling.common.DirectoryOutputWriterManager
_vm:set_metatable(sling.common.DirectoryOutputWriterManager, {})

function sling.common.DirectoryOutputWriterManager._create()
	local v = _vm:set_metatable({}, sling.common.DirectoryOutputWriterManager)
	return v
end

function sling.common.DirectoryOutputWriterManager:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.DirectoryOutputWriterManager'
	self['_isType.sling.common.DirectoryOutputWriterManager'] = true
	self['_isType.sling.common.OutputWriterManager'] = true
	self.directory = nil
	self.ctx = nil
	self.overwrite = false
end

function sling.common.DirectoryOutputWriterManager:_construct0()
	sling.common.DirectoryOutputWriterManager._init(self)
	return self
end

function sling.common.DirectoryOutputWriterManager:forDirectory(ctx, dir, overwrite)
	local v = _g.sling.common.DirectoryOutputWriterManager._construct0(_g.sling.common.DirectoryOutputWriterManager._create())
	do v:setDirectory(dir) end
	do v:setCtx(ctx) end
	do v:setOverwrite(overwrite) end
	do return v end
end

function sling.common.DirectoryOutputWriterManager:sanitizeComponent(comp)
	if _g.jk.os.OS:isWindows() == false then
		do return comp end
	end
	do
		local str = comp
		local dot = _g.jk.lang.String:getIndexOfCharacter(str, 46, 0)
		if dot >= 0 then
			str = _g.jk.lang.String:getSubString(str, 0, dot)
		end
		do
			local array = {
				"con",
				"prn",
				"aux",
				"nul",
				"com1",
				"com2",
				"com3",
				"com4",
				"com5",
				"com6",
				"com7",
				"com8",
				"com9",
				"lpt1",
				"lpt2",
				"lpt3",
				"lpt4",
				"lpt5",
				"lpt6",
				"lpt7",
				"lpt8",
				"lpt9"
			}
			if array ~= nil then
				local n = 0
				local m = #array
				do
					n = 0
					while n < m do
						local reserved = (function(o)
							if (_vm:get_variable_type(o) == 'string') then
								do return o end
							end
							do return nil end
						end)(array[n + 1])
						if reserved ~= nil then
							if _g.jk.lang.String:equalsIgnoreCase(str, reserved) then
								do return "_" .. _g.jk.lang.String:safeString(comp) end
							end
						end
						do n = n + 1 end
					end
				end
			end
			do return comp end
		end
	end
end

function sling.common.DirectoryOutputWriterManager:getOutputFile(name)
	if not (self.directory ~= nil) then
		do _g.sling.common.RefLog:error(self.ctx, "No directory specified for DirectoryOutputWriterManager", nil, nil) end
		do return nil end
	end
	if not (name ~= nil) then
		do _g.sling.common.RefLog:error(self.ctx, "No filename specified for DirectoryOutputWriterManager", nil, nil) end
		do return nil end
	end
	do
		local ff = self.directory
		local nn = _g.jk.lang.String:replaceCharacter(name, 92, 47)
		local array = _g.jk.lang.String:split(nn, 47, 0)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local comp = array[n + 1]
					if comp ~= nil then
						ff = ff:entry(self:sanitizeComponent(comp))
					end
					do n = n + 1 end
				end
			end
		end
		do
			local pp = ff:getParent()
			do pp:createDirectoryRecursive() end
			do _g.sling.common.RefLog:debug(self.ctx, "Writing file: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(ff)) .. "'", nil) end
			if self.overwrite == false then
				if not (ff:exists() == false) then
					do _g.sling.common.RefLog:error(self.ctx, "File already exists, cannot write: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(ff)) .. "'", nil, nil) end
					do return nil end
				end
			end
			do
				local wr = ff:write()
				if not (wr ~= nil) then
					local errorMessage = _g.sling.common.ErrorMessage:forText("Failed to write file: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(ff)) .. "'", nil, self.ctx:isInDebugMode(), nil)
					local ed = ff:getLastErrorDescription()
					if _g.jk.lang.String:isNotEmpty(ed) then
						do errorMessage:addRelatedMessage(_g.sling.common.ErrorMessage:forText(ed, nil, self.ctx:isInDebugMode(), nil)) end
					end
					do _g.sling.common.RefLog:message(self.ctx, errorMessage) end
					do return nil end
				end
				do return _g.sling.common.PrintWriterOutputWriter._construct0(_g.sling.common.PrintWriterOutputWriter._create()):setWriter(_g.jk.io.PrintWriterWrapper:forWriter(wr)) end
			end
		end
	end
end

function sling.common.DirectoryOutputWriterManager:finalize()
end

function sling.common.DirectoryOutputWriterManager:getDirectory()
	do return self.directory end
end

function sling.common.DirectoryOutputWriterManager:setDirectory(v)
	self.directory = v
	do return self end
end

function sling.common.DirectoryOutputWriterManager:getCtx()
	do return self.ctx end
end

function sling.common.DirectoryOutputWriterManager:setCtx(v)
	self.ctx = v
	do return self end
end

function sling.common.DirectoryOutputWriterManager:getOverwrite()
	do return self.overwrite end
end

function sling.common.DirectoryOutputWriterManager:setOverwrite(v)
	self.overwrite = v
	do return self end
end

sling.common.WarningMessage = _g.sling.common.Message._create()
sling.common.WarningMessage.__index = sling.common.WarningMessage
_vm:set_metatable(sling.common.WarningMessage, {
	__index = _g.sling.common.Message
})

function sling.common.WarningMessage._create()
	local v = _vm:set_metatable({}, sling.common.WarningMessage)
	return v
end

function sling.common.WarningMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.WarningMessage'
	self['_isType.sling.common.WarningMessage'] = true
end

function sling.common.WarningMessage:_construct0()
	sling.common.WarningMessage._init(self)
	do _g.sling.common.Message._construct0(self) end
	return self
end

function sling.common.WarningMessage:forText(t, ref)
	local v = _g.sling.common.WarningMessage._construct0(_g.sling.common.WarningMessage._create())
	do v:setMessage(t) end
	do v:setReference(ref) end
	do return v end
end

function sling.common.WarningMessage:getType()
	do return "warning" end
end

sling.common.MessageFormatter = {}
sling.common.MessageFormatter.__index = sling.common.MessageFormatter
_vm:set_metatable(sling.common.MessageFormatter, {})

function sling.common.MessageFormatter._create()
	local v = _vm:set_metatable({}, sling.common.MessageFormatter)
	return v
end

function sling.common.MessageFormatter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.MessageFormatter'
	self['_isType.sling.common.MessageFormatter'] = true
end

function sling.common.MessageFormatter:_construct0()
	sling.common.MessageFormatter._init(self)
	return self
end

function sling.common.MessageFormatter:getFilePath(file)
	if not (file ~= nil) then
		do return nil end
	end
	do return file:getPath() end
end

function sling.common.MessageFormatter:getFileMessage(file, message)
	if not (message ~= nil) then
		do return _g.sling.common.MessageFormatter:getFilePath(file) end
	end
	do return _g.jk.lang.String:safeString(message) .. ": `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(file)) .. "'" end
end

sling.common.StaticSourceReference = {}
sling.common.StaticSourceReference.__index = sling.common.StaticSourceReference
_vm:set_metatable(sling.common.StaticSourceReference, {})

function sling.common.StaticSourceReference._create()
	local v = _vm:set_metatable({}, sling.common.StaticSourceReference)
	return v
end

function sling.common.StaticSourceReference:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.StaticSourceReference'
	self['_isType.sling.common.StaticSourceReference'] = true
	self['_isType.sling.common.SourceReference'] = true
	self.name = nil
	self.token = nil
	self.lineNumber = 0
	self.columnNumber = 0
	self.contentLine = nil
	self.sourceReference = nil
end

function sling.common.StaticSourceReference:_construct0()
	sling.common.StaticSourceReference._init(self)
	return self
end

function sling.common.StaticSourceReference:instance(name, token, line, column, content, ref)
	local v = _g.sling.common.StaticSourceReference._construct0(_g.sling.common.StaticSourceReference._create())
	do v:setName(name) end
	do v:setToken(token) end
	do v:setLineNumber(line) end
	do v:setColumnNumber(column) end
	do v:setContentLine(content) end
	do v:setSourceReference(ref) end
	do return v end
end

function sling.common.StaticSourceReference:forFile(file)
	local cn = _g.sling.common.MessageFormatter:getFilePath(file)
	if _g.jk.lang.String:isEmpty(cn) then
		cn = "<file>"
	end
	do
		local v = _g.sling.common.StaticSourceReference._construct0(_g.sling.common.StaticSourceReference._create())
		do v:setName(cn) end
		do v:setToken(nil) end
		do v:setLineNumber(-1) end
		do v:setColumnNumber(-1) end
		do v:setContentLine(nil) end
		do v:setSourceReference(nil) end
		do return v end
	end
end

function sling.common.StaticSourceReference:getSourceName()
	do return self.name end
end

function sling.common.StaticSourceReference:getSourceToken()
	do return self.token end
end

function sling.common.StaticSourceReference:getSourceLineNumber()
	do return self.lineNumber end
end

function sling.common.StaticSourceReference:getSourceColumnNumber()
	do return self.columnNumber end
end

function sling.common.StaticSourceReference:getSourceContentLine()
	do return self.contentLine end
end

function sling.common.StaticSourceReference:getNodeTrace()
	if self.sourceReference ~= nil then
		do return self.sourceReference:getNodeTrace() end
	end
	do return nil end
end

function sling.common.StaticSourceReference:getName()
	do return self.name end
end

function sling.common.StaticSourceReference:setName(v)
	self.name = v
	do return self end
end

function sling.common.StaticSourceReference:getToken()
	do return self.token end
end

function sling.common.StaticSourceReference:setToken(v)
	self.token = v
	do return self end
end

function sling.common.StaticSourceReference:getLineNumber()
	do return self.lineNumber end
end

function sling.common.StaticSourceReference:setLineNumber(v)
	self.lineNumber = v
	do return self end
end

function sling.common.StaticSourceReference:getColumnNumber()
	do return self.columnNumber end
end

function sling.common.StaticSourceReference:setColumnNumber(v)
	self.columnNumber = v
	do return self end
end

function sling.common.StaticSourceReference:getContentLine()
	do return self.contentLine end
end

function sling.common.StaticSourceReference:setContentLine(v)
	self.contentLine = v
	do return self end
end

function sling.common.StaticSourceReference:getSourceReference()
	do return self.sourceReference end
end

function sling.common.StaticSourceReference:setSourceReference(v)
	self.sourceReference = v
	do return self end
end

sling.common.CodeParser = _g.sling.common.LiveTokenizingParser._create()
sling.common.CodeParser.__index = sling.common.CodeParser
_vm:set_metatable(sling.common.CodeParser, {
	__index = _g.sling.common.LiveTokenizingParser
})

function sling.common.CodeParser._create()
	local v = _vm:set_metatable({}, sling.common.CodeParser)
	return v
end

function sling.common.CodeParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeParser'
	self['_isType.sling.common.CodeParser'] = true
	self['_isType.sling.common.FileParser'] = true
end

function sling.common.CodeParser:_construct0()
	sling.common.CodeParser._init(self)
	do _g.sling.common.LiveTokenizingParser._construct0(self) end
	return self
end

function sling.common.CodeParser:finalizeResult1(result, file)
	if not (result ~= nil) then
		do return nil end
	end
	if file ~= nil then
		if _g.jk.lang.String:isEmpty(result:getNodeName()) then
			do result:renameNode(file:baseNameWithoutExtension()) end
		end
		if not (result:getFile() ~= nil) then
			do result:setFile(file) end
		end
	end
	do return result end
end

function sling.common.CodeParser:finalizeResult2(result, name)
	if not (result ~= nil) then
		do return nil end
	end
	if name ~= nil then
		if _g.jk.lang.String:isEmpty(result:getNodeName()) then
			do result:renameNode(name) end
		end
	end
	do return result end
end

function sling.common.CodeParser:parseFile(file)
	do self:initializeForFile(file) end
	do return self:finalizeResult1(self:parse(), file) end
end

function sling.common.CodeParser:parseString(string, name)
	do self:initializeForString(string, name) end
	do return self:finalizeResult2(self:parse(), name) end
end

function sling.common.CodeParser:parse()
end

sling.common.ReferenceError = _g.jk.lang.Exception._create()
sling.common.ReferenceError.__index = sling.common.ReferenceError
_vm:set_metatable(sling.common.ReferenceError, {
	__index = _g.jk.lang.Exception
})

function sling.common.ReferenceError._create()
	local v = _vm:set_metatable({}, sling.common.ReferenceError)
	return v
end

function sling.common.ReferenceError:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ReferenceError'
	self['_isType.sling.common.ReferenceError'] = true
	self['_isType.jk.lang.StringObject'] = true
	self['_isType.jk.lang.StringObjectWithDebug'] = true
	self.error = nil
end

function sling.common.ReferenceError:_construct0()
	sling.common.ReferenceError._init(self)
	do _g.jk.lang.Exception._construct0(self) end
	return self
end

function sling.common.ReferenceError:forMessage(message, source, trace)
	local v = _g.sling.common.ReferenceError._construct0(_g.sling.common.ReferenceError._create())
	do v:setError(_g.sling.common.ErrorMessage:forText(message, source, true, trace)) end
	do return v end
end

function sling.common.ReferenceError:forErrorMessage(error)
	local v = _g.sling.common.ReferenceError._construct0(_g.sling.common.ReferenceError._create())
	do v:setError(error) end
	do return v end
end

function sling.common.ReferenceError:getMessage()
	if not (self.error ~= nil) then
		do return nil end
	end
	do return self.error:getMessage() end
end

function sling.common.ReferenceError:getReference()
	if not (self.error ~= nil) then
		do return nil end
	end
	do return self.error:getReference() end
end

function sling.common.ReferenceError:addRelatedMessage(message, source)
	do self:addRelatedMessageObject(_g.sling.common.ErrorMessage:forText(message, source, false, nil)) end
	do return self end
end

function sling.common.ReferenceError:addRelatedMessageObject(message)
	if not (self.error ~= nil and message ~= nil) then
		do return end
	end
	do self.error:addRelatedMessage(message) end
end

function sling.common.ReferenceError:toStringWithDebug(debug)
	if not (self.error ~= nil) then
		do return nil end
	end
	do return self.error:toStringWithDebug(debug) end
end

function sling.common.ReferenceError:toString()
	do return self:toStringWithDebug(false) end
end

function sling.common.ReferenceError:getError()
	do return self.error end
end

function sling.common.ReferenceError:setError(v)
	self.error = v
	do return self end
end

sling.common.NodeFinder = {}
sling.common.NodeFinder.__index = sling.common.NodeFinder
_vm:set_metatable(sling.common.NodeFinder, {})

function sling.common.NodeFinder._create()
	local v = _vm:set_metatable({}, sling.common.NodeFinder)
	return v
end

function sling.common.NodeFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NodeFinder'
	self['_isType.sling.common.NodeFinder'] = true
end

function sling.common.NodeFinder:_construct0()
	sling.common.NodeFinder._init(self)
	return self
end

sling.common.NodeFinder.NodeTypeFinder = _g.sling.common.NodeVisitor._create()
sling.common.NodeFinder.NodeTypeFinder.__index = sling.common.NodeFinder.NodeTypeFinder
_vm:set_metatable(sling.common.NodeFinder.NodeTypeFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.common.NodeFinder.NodeTypeFinder._create()
	local v = _vm:set_metatable({}, sling.common.NodeFinder.NodeTypeFinder)
	return v
end

function sling.common.NodeFinder.NodeTypeFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NodeFinder.NodeTypeFinder'
	self['_isType.sling.common.NodeFinder.NodeTypeFinder'] = true
	self.searchForTypes = {}
	self.results = {}
	self.ignoreMacros = true
	self.ignoreHeaders = true
end

function sling.common.NodeFinder.NodeTypeFinder:_construct0()
	sling.common.NodeFinder.NodeTypeFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.common.NodeFinder.NodeTypeFinder:addToSearchForTypes(type)
	do _g.jk.lang.Vector:append(self.searchForTypes, type) end
end

function sling.common.NodeFinder.NodeTypeFinder:visit(node)
	if node ~= nil then
		if self.ignoreMacros and node:hasCustomModifier("macro") then
			do self:setSkipChildren(true) end
			do return true end
		end
		if self.ignoreHeaders and node:hasModifier("header") then
			do self:setSkipChildren(true) end
			do return true end
		end
		do
			local nti = _vm:get_datatype_info(node)
			if self.searchForTypes ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(self.searchForTypes)
				do
					n = 0
					while n < m do
						local searchForType = self.searchForTypes[n + 1]
						if searchForType ~= nil then
							if nti == searchForType then
								do _g.jk.lang.Vector:append(self.results, node) end
								do break end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
	do return true end
end

function sling.common.NodeFinder.NodeTypeFinder:getSearchForTypes()
	do return self.searchForTypes end
end

function sling.common.NodeFinder.NodeTypeFinder:setSearchForTypes(v)
	self.searchForTypes = v
	do return self end
end

function sling.common.NodeFinder.NodeTypeFinder:getResults()
	do return self.results end
end

function sling.common.NodeFinder.NodeTypeFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.common.NodeFinder.NodeTypeFinder:getIgnoreMacros()
	do return self.ignoreMacros end
end

function sling.common.NodeFinder.NodeTypeFinder:setIgnoreMacros(v)
	self.ignoreMacros = v
	do return self end
end

function sling.common.NodeFinder.NodeTypeFinder:getIgnoreHeaders()
	do return self.ignoreHeaders end
end

function sling.common.NodeFinder.NodeTypeFinder:setIgnoreHeaders(v)
	self.ignoreHeaders = v
	do return self end
end

function sling.common.NodeFinder:findNodesOfType(node, type, reverse, ignoreMacros, ignoreHeaders)
	local ff = _g.sling.common.NodeFinder.NodeTypeFinder._construct0(_g.sling.common.NodeFinder.NodeTypeFinder._create())
	do ff:setIgnoreMacros(ignoreMacros) end
	do ff:setIgnoreHeaders(ignoreHeaders) end
	if node ~= nil and type ~= nil then
		do ff:addToSearchForTypes(type) end
		do node:accept(ff) end
	end
	do
		local v = ff:getResults()
		if reverse then
			do _g.jk.lang.Vector:reverse(v) end
		end
		do return v end
	end
end

function sling.common.NodeFinder:findNodesOfTypes(node, types, reverse, ignoreMacros, ignoreHeaders)
	local ff = _g.sling.common.NodeFinder.NodeTypeFinder._construct0(_g.sling.common.NodeFinder.NodeTypeFinder._create())
	do ff:setIgnoreMacros(ignoreMacros) end
	do ff:setIgnoreHeaders(ignoreHeaders) end
	if node ~= nil and types ~= nil then
		if types ~= nil then
			local n = 0
			local m = #types
			do
				n = 0
				while n < m do
					local type = types[n + 1]
					if type ~= nil then
						do ff:addToSearchForTypes(type) end
					end
					do n = n + 1 end
				end
			end
		end
		do node:accept(ff) end
	end
	do
		local v = ff:getResults()
		if reverse then
			do _g.jk.lang.Vector:reverse(v) end
		end
		do return v end
	end
end

sling.common.NodeFinder.NodeBaseTypeFinder = _g.sling.common.NodeVisitor._create()
sling.common.NodeFinder.NodeBaseTypeFinder.__index = sling.common.NodeFinder.NodeBaseTypeFinder
_vm:set_metatable(sling.common.NodeFinder.NodeBaseTypeFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.common.NodeFinder.NodeBaseTypeFinder._create()
	local v = _vm:set_metatable({}, sling.common.NodeFinder.NodeBaseTypeFinder)
	return v
end

function sling.common.NodeFinder.NodeBaseTypeFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NodeFinder.NodeBaseTypeFinder'
	self['_isType.sling.common.NodeFinder.NodeBaseTypeFinder'] = true
	self.searchForTypes = {}
	self.results = {}
	self.ignoreMacros = true
	self.ignoreHeaders = true
end

function sling.common.NodeFinder.NodeBaseTypeFinder:_construct0()
	sling.common.NodeFinder.NodeBaseTypeFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.common.NodeFinder.NodeBaseTypeFinder:addToSearchForTypes(type)
	do _g.jk.lang.Vector:append(self.searchForTypes, type) end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:visit(node)
	if node ~= nil then
		if self.ignoreMacros and node:hasCustomModifier("macro") then
			do self:setSkipChildren(true) end
			do return true end
		end
		if self.ignoreHeaders and node:hasModifier("header") then
			do self:setSkipChildren(true) end
			do return true end
		end
		if self.searchForTypes ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.searchForTypes)
			do
				n = 0
				while n < m do
					local searchForType = self.searchForTypes[n + 1]
					if searchForType ~= nil then
						if _g.jk.lang.Reflection:isInstanceOf(node, searchForType) then
							do _g.jk.lang.Vector:append(self.results, node) end
							do break end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do return true end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:getSearchForTypes()
	do return self.searchForTypes end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:setSearchForTypes(v)
	self.searchForTypes = v
	do return self end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:getResults()
	do return self.results end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:getIgnoreMacros()
	do return self.ignoreMacros end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:setIgnoreMacros(v)
	self.ignoreMacros = v
	do return self end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:getIgnoreHeaders()
	do return self.ignoreHeaders end
end

function sling.common.NodeFinder.NodeBaseTypeFinder:setIgnoreHeaders(v)
	self.ignoreHeaders = v
	do return self end
end

function sling.common.NodeFinder:findCompatibleNodes(node, type, reverse, ignoreMacros, ignoreHeaders)
	local ff = _g.sling.common.NodeFinder.NodeBaseTypeFinder._construct0(_g.sling.common.NodeFinder.NodeBaseTypeFinder._create())
	do ff:setIgnoreMacros(ignoreMacros) end
	do ff:setIgnoreHeaders(ignoreHeaders) end
	if node ~= nil and type ~= nil then
		do ff:addToSearchForTypes(type) end
		do node:accept(ff) end
	end
	do
		local v = ff:getResults()
		if reverse then
			do _g.jk.lang.Vector:reverse(v) end
		end
		do return v end
	end
end

function sling.common.NodeFinder:findCompatibleNodesForTypes(node, types, reverse, ignoreMacros, ignoreHeaders)
	local ff = _g.sling.common.NodeFinder.NodeBaseTypeFinder._construct0(_g.sling.common.NodeFinder.NodeBaseTypeFinder._create())
	do ff:setIgnoreMacros(ignoreMacros) end
	do ff:setIgnoreHeaders(ignoreHeaders) end
	if node ~= nil and types ~= nil then
		if types ~= nil then
			local n = 0
			local m = #types
			do
				n = 0
				while n < m do
					local type = types[n + 1]
					if type ~= nil then
						do ff:addToSearchForTypes(type) end
					end
					do n = n + 1 end
				end
			end
		end
		do node:accept(ff) end
	end
	do
		local v = ff:getResults()
		if reverse then
			do _g.jk.lang.Vector:reverse(v) end
		end
		do return v end
	end
end

sling.common.NodeFinder.CustomNodeVisitor = _g.sling.common.NodeVisitor._create()
sling.common.NodeFinder.CustomNodeVisitor.__index = sling.common.NodeFinder.CustomNodeVisitor
_vm:set_metatable(sling.common.NodeFinder.CustomNodeVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.common.NodeFinder.CustomNodeVisitor._create()
	local v = _vm:set_metatable({}, sling.common.NodeFinder.CustomNodeVisitor)
	return v
end

function sling.common.NodeFinder.CustomNodeVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.NodeFinder.CustomNodeVisitor'
	self['_isType.sling.common.NodeFinder.CustomNodeVisitor'] = true
	self._function = nil
end

function sling.common.NodeFinder.CustomNodeVisitor:_construct0()
	sling.common.NodeFinder.CustomNodeVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.common.NodeFinder.CustomNodeVisitor:visit(node)
	if self._function ~= nil then
		do self._function(node) end
	end
	do return true end
end

function sling.common.NodeFinder.CustomNodeVisitor:getFunction()
	do return self._function end
end

function sling.common.NodeFinder.CustomNodeVisitor:setFunction(v)
	self._function = v
	do return self end
end

function sling.common.NodeFinder:visitAllNodes(node, visitor)
	if not (node ~= nil) then
		do return end
	end
	do
		local cnv = _g.sling.common.NodeFinder.CustomNodeVisitor._construct0(_g.sling.common.NodeFinder.CustomNodeVisitor._create())
		do cnv:setFunction(visitor) end
		do node:accept(cnv) end
	end
end

sling.common.ExpectedErrorMessage = _g.sling.common.StaticTextErrorMessage._create()
sling.common.ExpectedErrorMessage.__index = sling.common.ExpectedErrorMessage
_vm:set_metatable(sling.common.ExpectedErrorMessage, {
	__index = _g.sling.common.StaticTextErrorMessage
})

function sling.common.ExpectedErrorMessage._create()
	local v = _vm:set_metatable({}, sling.common.ExpectedErrorMessage)
	return v
end

function sling.common.ExpectedErrorMessage:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.ExpectedErrorMessage'
	self['_isType.sling.common.ExpectedErrorMessage'] = true
end

function sling.common.ExpectedErrorMessage:_construct0()
	sling.common.ExpectedErrorMessage._init(self)
	do _g.sling.common.StaticTextErrorMessage._construct0(self) end
	return self
end

function sling.common.ExpectedErrorMessage:forText1(t, ref, isDebug)
	local v = _g.sling.common.ExpectedErrorMessage._construct0(_g.sling.common.ExpectedErrorMessage._create())
	do v:setText(t) end
	do v:setReference(ref) end
	if isDebug then
		do v:updateStackTrace() end
	end
	do return v end
end

function sling.common.ExpectedErrorMessage:getPrefix()
	do return "Expected" end
end

sling.common.RefLog = {}
sling.common.RefLog.__index = sling.common.RefLog
_vm:set_metatable(sling.common.RefLog, {})

function sling.common.RefLog._create()
	local v = _vm:set_metatable({}, sling.common.RefLog)
	return v
end

function sling.common.RefLog:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.RefLog'
	self['_isType.sling.common.RefLog'] = true
end

function sling.common.RefLog:_construct0()
	sling.common.RefLog._init(self)
	return self
end

function sling.common.RefLog:error(ctx, text, ref, trace)
	local isInDebugMode = true
	if ctx ~= nil then
		isInDebugMode = ctx:isInDebugMode()
	end
	do _g.sling.common.RefLog:message(ctx, _g.sling.common.ErrorMessage:forText(text, ref, isInDebugMode, trace)) end
end

function sling.common.RefLog:warning(ctx, text, ref)
	do _g.sling.common.RefLog:message(ctx, _g.sling.common.WarningMessage:forText(text, ref)) end
end

function sling.common.RefLog:info(ctx, text, ref)
	do _g.sling.common.RefLog:message(ctx, _g.sling.common.InfoMessage:forText(text, ref)) end
end

function sling.common.RefLog:debug(ctx, text, ref)
	do _g.sling.common.RefLog:message(ctx, _g.sling.common.DebugMessage:forText(text, ref)) end
end

function sling.common.RefLog:status(ctx, text)
	do _g.sling.common.RefLog:message(ctx, _g.sling.common.StatusMessage:forText(text)) end
end

function sling.common.RefLog:message(ctx, msg)
	if not (ctx ~= nil and msg ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(ctx, '_isType.sling.common.RefLogContext') ~= nil) then
		do ctx:onMessage(msg) end
		do return end
	end
	do
		local txt = msg:toStringWithDebug(ctx:isInDebugMode())
		if not (txt ~= nil) then
			do return end
		end
		if (_vm:to_table_with_key(msg, '_isType.sling.common.DebugMessage') ~= nil) then
			do _g.jk.log.Log:debug(ctx, txt) end
		elseif (_vm:to_table_with_key(msg, '_isType.sling.common.WarningMessage') ~= nil) then
			do _g.jk.log.Log:warning(ctx, txt) end
		elseif (_vm:to_table_with_key(msg, '_isType.sling.common.ErrorMessage') ~= nil) then
			do _g.jk.log.Log:error(ctx, txt) end
		elseif (_vm:to_table_with_key(msg, '_isType.sling.common.StatusMessage') ~= nil) then
			do _g.jk.log.Log:status(ctx, txt) end
		else
			do _g.jk.log.Log:info(ctx, txt) end
		end
	end
end

sling.common.PrintWriterOutputWriter = {}
sling.common.PrintWriterOutputWriter.__index = sling.common.PrintWriterOutputWriter
_vm:set_metatable(sling.common.PrintWriterOutputWriter, {})

function sling.common.PrintWriterOutputWriter._create()
	local v = _vm:set_metatable({}, sling.common.PrintWriterOutputWriter)
	return v
end

function sling.common.PrintWriterOutputWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.PrintWriterOutputWriter'
	self['_isType.sling.common.PrintWriterOutputWriter'] = true
	self['_isType.sling.common.OutputWriter'] = true
	self.writer = nil
	self.doClose = true
end

function sling.common.PrintWriterOutputWriter:_construct0()
	sling.common.PrintWriterOutputWriter._init(self)
	return self
end

function sling.common.PrintWriterOutputWriter:writeString(str)
	if not (self.writer ~= nil) then
		do return false end
	end
	do return self.writer:print(str) end
end

function sling.common.PrintWriterOutputWriter:writeBuffer(buf)
	if not (buf ~= nil) then
		do return true end
	end
	if not (self.writer ~= nil) then
		do return false end
	end
	do
		local sz = _g.jk.lang.Buffer:getSize(buf)
		if self.writer:write(buf, -1) == sz then
			do return true end
		end
		do return false end
	end
end

function sling.common.PrintWriterOutputWriter:finalize()
	if self.doClose then
		if (_vm:to_table_with_key(self.writer, '_isType.jk.lang.Closable') ~= nil) then
			do self.writer:close() end
		end
	end
	self.writer = nil
	do return true end
end

function sling.common.PrintWriterOutputWriter:getWriter()
	do return self.writer end
end

function sling.common.PrintWriterOutputWriter:setWriter(v)
	self.writer = v
	do return self end
end

function sling.common.PrintWriterOutputWriter:getDoClose()
	do return self.doClose end
end

function sling.common.PrintWriterOutputWriter:setDoClose(v)
	self.doClose = v
	do return self end
end

sling.common.RefLogCollectorContext = {}
sling.common.RefLogCollectorContext.__index = sling.common.RefLogCollectorContext
_vm:set_metatable(sling.common.RefLogCollectorContext, {})

function sling.common.RefLogCollectorContext._create()
	local v = _vm:set_metatable({}, sling.common.RefLogCollectorContext)
	return v
end

function sling.common.RefLogCollectorContext:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.RefLogCollectorContext'
	self['_isType.sling.common.RefLogCollectorContext'] = true
	self['_isType.jk.log.LoggingContext'] = true
	self['_isType.sling.common.RefLogContext'] = true
	self.messages = nil
	self.errors = 0
	self.warnings = 0
	self.infos = 0
	self.debugs = 0
end

function sling.common.RefLogCollectorContext:_construct0()
	sling.common.RefLogCollectorContext._init(self)
	return self
end

function sling.common.RefLogCollectorContext:onMessage(message)
	if not (message ~= nil) then
		do return end
	end
	if self.messages == nil then
		self.messages = {}
	end
	do _g.jk.lang.Vector:append(self.messages, message) end
	if (_vm:to_table_with_key(message, '_isType.sling.common.ErrorMessage') ~= nil) then
		do self.errors = self.errors + 1 end
	elseif (_vm:to_table_with_key(message, '_isType.sling.common.WarningMessage') ~= nil) then
		do self.warnings = self.warnings + 1 end
	elseif (_vm:to_table_with_key(message, '_isType.sling.common.InfoMessage') ~= nil) then
		do self.infos = self.infos + 1 end
	elseif (_vm:to_table_with_key(message, '_isType.sling.common.DebugMessage') ~= nil) then
		do self.debugs = self.debugs + 1 end
	end
end

function sling.common.RefLogCollectorContext:logError(message)
	do self:onMessage(_g.sling.common.ErrorMessage:forText(message, nil, true, nil)) end
end

function sling.common.RefLogCollectorContext:logWarning(message)
	do self:onMessage(_g.sling.common.WarningMessage:forText(message, nil)) end
end

function sling.common.RefLogCollectorContext:logInfo(message)
	do self:onMessage(_g.sling.common.InfoMessage:forText(message, nil)) end
end

function sling.common.RefLogCollectorContext:logDebug(message)
	do self:onMessage(_g.sling.common.DebugMessage:forText(message, nil)) end
end

function sling.common.RefLogCollectorContext:logStatus(message)
	do self:onMessage(_g.sling.common.StatusMessage:forText(message)) end
end

function sling.common.RefLogCollectorContext:isInDebugMode()
	do return true end
end

function sling.common.RefLogCollectorContext:getErrorCount()
	do return self.errors end
end

function sling.common.RefLogCollectorContext:getWarningCount()
	do return self.warnings end
end

function sling.common.RefLogCollectorContext:getInfoCount()
	do return self.infos end
end

function sling.common.RefLogCollectorContext:getDebugCount()
	do return self.debugs end
end

function sling.common.RefLogCollectorContext:resetCounters()
	self.errors = 0
	self.warnings = 0
	self.infos = 0
	self.debugs = 0
end

function sling.common.RefLogCollectorContext:getMessages()
	do return self.messages end
end

function sling.common.RefLogCollectorContext:setMessages(v)
	self.messages = v
	do return self end
end

sling.common.TypeMap = {}
sling.common.TypeMap.__index = sling.common.TypeMap
_vm:set_metatable(sling.common.TypeMap, {})

function sling.common.TypeMap._create()
	local v = _vm:set_metatable({}, sling.common.TypeMap)
	return v
end

function sling.common.TypeMap:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.TypeMap'
	self['_isType.sling.common.TypeMap'] = true
	self.map = nil
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function sling.common.TypeMap:_construct0()
	sling.common.TypeMap._init(self)
	return self
end

function sling.common.TypeMap:merge(from, ato)
	local to = ato
	if not (to ~= nil) then
		to = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
	end
	if from ~= nil then
		do from:copyTo(to) end
	end
	do return to end
end

function sling.common.TypeMap:forDynamicMap(v)
	local r = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
	if v ~= nil then
		local array = v:getKeys()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local key = array[n + 1]
					if key ~= nil then
						do r:set(key, _vm:to_table_with_key(v:get(key), '_isType.sling.common.DataTypeNode')) end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do return r end
end

function sling.common.TypeMap:_destruct()
	do self:clear() end
end

function sling.common.TypeMap:asDynamicMap()
	do return self.map end
end

function sling.common.TypeMap:get(name)
	if not (name ~= nil) then
		do return nil end
	end
	if not (self.map ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(self.map:get(name), '_isType.sling.common.DataTypeNode') end
end

function sling.common.TypeMap:dup()
	local v = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
	do self:copyTo(v) end
	do return v end
end

function sling.common.TypeMap:clear()
	if self.map ~= nil then
		local array = self.map:getValues()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local value = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.DataTypeNode')
					if value ~= nil then
						do value:destroy() end
					end
					do n = n + 1 end
				end
			end
		end
		self.map = nil
	end
end

function sling.common.TypeMap:copyTo(r)
	if not (r ~= nil) then
		do return end
	end
	if self.map ~= nil then
		local array = self.map:getKeys()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local key = array[n + 1]
					if key ~= nil then
						do r:set(key, _vm:to_table_with_key(self.map:get(key), '_isType.sling.common.DataTypeNode')) end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.common.TypeMap:copyFrom(r)
	if r ~= nil then
		do r:copyTo(self) end
	end
end

function sling.common.TypeMap:set(name, dt)
	if not (name ~= nil) then
		do return end
	end
	if not (self.map ~= nil) then
		self.map = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	end
	do
		local sdt = dt
		if sdt ~= nil then
			sdt = _vm:to_table_with_key(sdt:dup(), '_isType.sling.common.DataTypeNode')
		end
		do self.map:setObject(name, sdt) end
	end
end

function sling.common.TypeMap:contains(name)
	if not (name ~= nil) then
		do return false end
	end
	if not (self.map ~= nil) then
		do return false end
	end
	if self.map:get(name) ~= nil then
		do return true end
	end
	do return false end
end

sling.common.CodeUnitSettingsNode = _g.sling.common.NodeObject._create()
sling.common.CodeUnitSettingsNode.__index = sling.common.CodeUnitSettingsNode
_vm:set_metatable(sling.common.CodeUnitSettingsNode, {
	__index = _g.sling.common.NodeObject
})

function sling.common.CodeUnitSettingsNode._create()
	local v = _vm:set_metatable({}, sling.common.CodeUnitSettingsNode)
	return v
end

function sling.common.CodeUnitSettingsNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeUnitSettingsNode'
	self['_isType.sling.common.CodeUnitSettingsNode'] = true
end

function sling.common.CodeUnitSettingsNode:_construct0()
	sling.common.CodeUnitSettingsNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.common.CodeUnitSettingsNode:getNodeTypeName()
	do return "CodeUnitSettingsNode" end
end

function sling.common.CodeUnitSettingsNode:createNew()
	do return _g.sling.common.CodeUnitSettingsNode._construct0(_g.sling.common.CodeUnitSettingsNode._create()) end
end

function sling.common.CodeUnitSettingsNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.CodeUnitSettingsNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.common.CodeUnitSettingsNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.CodeUnitSettingsNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.common.CodeUnitSettingsNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

sling.common.CodeUnitNode = _g.sling.common.NamedContainerNode._create()
sling.common.CodeUnitNode.__index = sling.common.CodeUnitNode
_vm:set_metatable(sling.common.CodeUnitNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.common.CodeUnitNode._create()
	local v = _vm:set_metatable({}, sling.common.CodeUnitNode)
	return v
end

function sling.common.CodeUnitNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeUnitNode'
	self['_isType.sling.common.CodeUnitNode'] = true
	self.description = nil
	self.settings = nil
end

function sling.common.CodeUnitNode:_construct0()
	sling.common.CodeUnitNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.common.CodeUnitNode:getNodeTypeName()
	do return "CodeUnitNode" end
end

function sling.common.CodeUnitNode:createNew()
	do return _g.sling.common.CodeUnitNode._construct0(_g.sling.common.CodeUnitNode._create()) end
end

function sling.common.CodeUnitNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.common.CodeUnitNode')
		if n == nil then
			do return true end
		end
		if n.settings ~= nil then
			do n.settings:destroy() end
			n.settings = nil
		end
		if self.settings ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.settings), '_isType.sling.common.CodeUnitSettingsNode')
			if pcp == nil then
				do return false end
			end
			n.settings = pcp
			do n.settings:setParent(n) end
		end
		n.description = self.description
		do return true end
	end
end

function sling.common.CodeUnitNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.settings then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.CodeUnitSettingsNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.settings:destroy() end
		end
		self.settings = _vm:to_table_with_key(newnode, '_isType.sling.common.CodeUnitSettingsNode')
		if self.settings ~= nil then
			do self.settings:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.common.CodeUnitNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.settings ~= nil then
		if self.settings:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.common.CodeUnitNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
	if self.settings ~= nil then
		do self.settings:destroy() end
		self.settings = nil
	end
end

function sling.common.CodeUnitNode:setSettings(v, doExport)
	if self.settings ~= nil and doExport == false then
		do self.settings:destroy() end
	end
	self.settings = v
	if self.settings ~= nil then
		do self.settings:setParent(self) end
	end
end

function sling.common.CodeUnitNode:getSettings()
	do return self.settings end
end

function sling.common.CodeUnitNode:exportSettings()
	local v = self.settings
	self.settings = nil
	do return v end
end

function sling.common.CodeUnitNode:setDescription(v)
	self.description = v
end

function sling.common.CodeUnitNode:getDescription()
	do return self.description end
end

sling.common.CodeGenerator = _g.sling.common.FileGenerator._create()
sling.common.CodeGenerator.__index = sling.common.CodeGenerator
_vm:set_metatable(sling.common.CodeGenerator, {
	__index = _g.sling.common.FileGenerator
})

function sling.common.CodeGenerator._create()
	local v = _vm:set_metatable({}, sling.common.CodeGenerator)
	return v
end

function sling.common.CodeGenerator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeGenerator'
	self['_isType.sling.common.CodeGenerator'] = true
	self.currentModule = nil
end

function sling.common.CodeGenerator:_construct0()
	sling.common.CodeGenerator._init(self)
	do _g.sling.common.FileGenerator._construct0(self) end
	return self
end

function sling.common.CodeGenerator:_construct2(ctx, output)
	sling.common.CodeGenerator._init(self)
	do _g.sling.common.FileGenerator._construct2(self, ctx, output) end
	return self
end

function sling.common.CodeGenerator:getCurrentModuleName()
	if not (self.currentModule ~= nil) then
		do return nil end
	end
	do return self.currentModule:getName() end
end

function sling.common.CodeGenerator:onModuleStarted()
end

function sling.common.CodeGenerator:onModuleEnded()
end

function sling.common.CodeGenerator:writeModule(module)
	if not (module ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null module", nil, _g.jk.lang.StackTrace:generate()))
	end
	if not (self.outputWriterManager ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No output writer manager specified", nil, _g.jk.lang.StackTrace:generate()))
	end
	self.currentModule = module
	do self:onModuleStarted() end
	do
		local error = nil
		do
			local _status, _err = _vm:execute_protected_call(function()
				do self:dumpModule(module) end
			end)
			if _err then
				if (_vm:to_table_with_key(_err, '_isType.jk.lang.Exception') ~= nil) then
					local e = _err
					error = e
				else
					_vm:throw_error(_err)
				end
			end
		end
		do self:onModuleEnded() end
		if error ~= nil then
			_vm:throw_error(error)
		end
	end
end

function sling.common.CodeGenerator:writeFile(file)
	if not (file ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null file", nil, _g.jk.lang.StackTrace:generate()))
	end
	if not (self.outputWriterManager ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No output writer manager specified", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local error = nil
		do
			local _status, _err = _vm:execute_protected_call(function()
				do self:dumpFile(file) end
			end)
			if _err then
				if (_vm:to_table_with_key(_err, '_isType.jk.lang.Exception') ~= nil) then
					local e = _err
					error = e
				else
					_vm:throw_error(_err)
				end
			end
		end
		if error ~= nil then
			_vm:throw_error(error)
		end
	end
end

function sling.common.CodeGenerator:dumpModule(module)
end

function sling.common.CodeGenerator:dumpFile(file)
end

function sling.common.CodeGenerator:getCurrentModule()
	do return self.currentModule end
end

function sling.common.CodeGenerator:setCurrentModule(v)
	self.currentModule = v
	do return self end
end

sling.common.CodeStringUtil = {}
sling.common.CodeStringUtil.__index = sling.common.CodeStringUtil
_vm:set_metatable(sling.common.CodeStringUtil, {})

function sling.common.CodeStringUtil._create()
	local v = _vm:set_metatable({}, sling.common.CodeStringUtil)
	return v
end

function sling.common.CodeStringUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.common.CodeStringUtil'
	self['_isType.sling.common.CodeStringUtil'] = true
end

function sling.common.CodeStringUtil:_construct0()
	sling.common.CodeStringUtil._init(self)
	return self
end

function sling.common.CodeStringUtil:combineCamelCase(components)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if components ~= nil then
		local n = 0
		local m = #components
		do
			n = 0
			while n < m do
				local component = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(components[n + 1])
				if component ~= nil then
					if sb:count() < 1 then
						do sb:appendString(component) end
					else
						local c0 = _g.jk.lang.String:getChar(component, 0)
						if c0 >= 97 and c0 <= 122 then
							do sb:appendCharacter(c0 - 97 + 65) end
							do sb:appendString(_g.jk.lang.String:getEndOfString(component, 1)) end
						else
							do sb:appendString(component) end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return sb:toString() end
end

function sling.common.CodeStringUtil:escapeStringLiteralCStyle(str)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local it = _g.jk.lang.String:iterate(str)
		local c = 0
		while (function()
			c = it:getNextChar()
			do return c end
		end)() > 0 do
			if c == 34 then
				do sb:appendString("\\\"") end
			elseif c == 7 then
				do sb:appendString("\\a") end
			elseif c == 8 then
				do sb:appendString("\\b") end
			elseif c == 12 then
				do sb:appendString("\\f") end
			elseif c == 10 then
				do sb:appendString("\\n") end
			elseif c == 13 then
				do sb:appendString("\\r") end
			elseif c == 9 then
				do sb:appendString("\\t") end
			elseif c == 11 then
				do sb:appendString("\\v") end
			elseif c == 92 then
				do sb:appendString("\\\\") end
			else
				do sb:appendCharacter(c) end
			end
		end
		do return sb:toString() end
	end
end

function sling.common.CodeStringUtil:unescapeStringLiteralCStyle(str, removeFirstAndLast)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local n = 0
		local max = _g.jk.lang.String:getLength(str)
		if removeFirstAndLast then
			max = max - 2
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			local it = _g.jk.lang.String:iterate(str)
			if removeFirstAndLast then
				do it:getNextChar() end
			end
			while n < max do
				local c = it:getNextChar()
				do n = n + 1 end
				if c ~= 92 then
					do sb:appendCharacter(c) end
					goto _continue11
				end
				if n >= max then
					do break end
				end
				c = it:getNextChar()
				do n = n + 1 end
				if c == 97 then
					do sb:appendCharacter(7) end
				elseif c == 98 then
					do sb:appendCharacter(8) end
				elseif c == 102 then
					do sb:appendCharacter(12) end
				elseif c == 110 then
					do sb:appendCharacter(10) end
				elseif c == 114 then
					do sb:appendCharacter(13) end
				elseif c == 116 then
					do sb:appendCharacter(9) end
				elseif c == 118 then
					do sb:appendCharacter(11) end
				elseif c == 48 then
					do sb:appendCharacter(0) end
				else
					do sb:appendCharacter(c) end
				end
				::_continue11::
			end
			do return sb:toString() end
		end
	end
end

function sling.common.CodeStringUtil:unescapeStringLiteralSingleQuoteStyle(str)
	local n = 0
	local max = _g.jk.lang.String:getLength(str) - 2
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local it = _g.jk.lang.String:iterate(str)
	do it:getNextChar() end
	while n < max do
		local c = it:getNextChar()
		do n = n + 1 end
		if c ~= 92 then
			do sb:appendCharacter(c) end
			goto _continue12
		end
		if n >= max then
			do break end
		end
		c = it:getNextChar()
		do n = n + 1 end
		if c == 39 then
			do sb:appendCharacter(39) end
		elseif c == 92 then
			do sb:appendCharacter(92) end
		else
			do sb:appendCharacter(92) end
			do sb:appendCharacter(c) end
		end
		::_continue12::
	end
	do return sb:toString() end
end

function sling.common.CodeStringUtil:unescapeCharacterLiteralCStyle(literal, removeFirstAndLast)
	local str = literal
	if removeFirstAndLast then
		if not _g.jk.lang.String:startsWith(literal, "'", 0) then
			do return nil end
		end
		if not _g.jk.lang.String:endsWith(literal, "'") then
			do return nil end
		end
		str = _g.jk.lang.String:getSubString(literal, 1, _g.jk.lang.String:getLength(literal) - 2)
	end
	do
		local c = 0
		local ll = _g.jk.lang.String:getLength(str)
		if ll == 1 then
			c = _g.jk.lang.String:getChar(str, 0)
		elseif str == "\\a" then
			c = 7
		elseif str == "\\b" then
			c = 8
		elseif str == "\\f" then
			c = 12
		elseif str == "\\n" then
			c = 10
		elseif str == "\\r" then
			c = 13
		elseif str == "\\t" then
			c = 9
		elseif str == "\\v" then
			c = 11
		elseif str == "\\\\" then
			c = 92
		elseif str == "\\'" then
			c = 39
		elseif str == "\\\"" then
			c = 34
		elseif str == "\\?" then
			c = 63
		elseif str == "\\0" then
			c = 0
		elseif ll == 4 and _g.jk.lang.String:getChar(str, 0) == 92 and _g.jk.lang.String:getChar(str, 1) == 120 then
			local s2 = _g.jk.lang.String:getSubString(str, 2, 2)
			c = _g.jk.lang.String:toIntegerFromHex(s2)
		elseif ll == 6 and _g.jk.lang.String:getChar(str, 0) == 92 and _g.jk.lang.String:getChar(str, 1) == 117 then
			local s2 = _g.jk.lang.String:getSubString(str, 2, 4)
			c = _g.jk.lang.String:toIntegerFromHex(s2)
		elseif ll == 4 and _g.jk.lang.String:getChar(str, 0) == 92 then
			do return nil end
		else
			do return nil end
		end
		do return _g.jk.lang.Character:asObject(c) end
	end
end

function sling.common.CodeStringUtil:forDoubleHex(vv, minlength)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local d = _g.jk.math.Math:abs(vv)
	local subnormal = d < -1022
	local signifBits = _g.jk.lang.Double:doubleToLongBits(vv)
	signifBits = _vm:bitwise_or(_vm:bitwise_and(signifBits, 4503599627370495), 1152921504606846976)
	do sb:appendString((function(a, b, c)
		if a then
			do return b() end
		end
		do return c() end
	end)(subnormal, function()
		do return "0." end
	end, function()
		do return "1." end
	end)) end
	do
		local signif = _g.jk.lang.String:forLongIntegerHex(signifBits, 0)
		local str = _g.jk.lang.String:getSubString(signif, 3, _g.jk.lang.String:getLength(signif) - 3)
		if _g.jk.lang.String:equals(str, "0000000000000") then
			do sb:appendString("0") end
		else
			do sb:appendString(_g.jk.lang.String:getSubString(str, 0, 1)) end
			do
				local sstr = _g.jk.lang.String:getSubString(str, 1, 12)
				sstr = _g.jk.lang.String:replaceString(sstr, "0", "")
				do sb:appendString(sstr) end
			end
		end
		do sb:appendString("p") end
		if d == 0 then
			do sb:appendString("0") end
		else
			local exponent = _util:convert_to_integer(_g.jk.math.Math:log(d) / _g.jk.math.Math:log(2))
			do sb:appendInteger((function(a, b, c)
				if a then
					do return b() end
				end
				do return c() end
			end)(subnormal, function()
				do return -1022 end
			end, function()
				do return exponent end
			end)) end
		end
		do return sb:toString() end
	end
end

function sling.common.CodeStringUtil:toDoubleFromHex(str)
	local isNegative = (function(a, b, c)
		if a then
			do return b() end
		end
		do return c() end
	end)(_g.jk.lang.String:getChar(str, 0) == 45, function()
		do return true end
	end, function()
		do return false end
	end)
	local isFractionalForm = (function(a, b, c)
		if a then
			do return b() end
		end
		do return c() end
	end)(_g.jk.lang.String:contains(str, "."), function()
		do return true end
	end, function()
		do return false end
	end)
	local iPart = nil
	local fPart = nil
	local ePart = nil
	if isFractionalForm then
		local cmp = _g.jk.lang.String:split(str, 46, 0)
		iPart = (function(o)
			if (_vm:get_variable_type(o) == 'string') then
				do return o end
			end
			do return nil end
		end)(cmp[0 + 1])
		do
			local frac = (function(o)
				if (_vm:get_variable_type(o) == 'string') then
					do return o end
				end
				do return nil end
			end)(cmp[1 + 1])
			frac = _g.jk.lang.String:toLowerCase(frac)
			if _g.jk.lang.String:contains(frac, "p") then
				local efrac = _g.jk.lang.String:split(frac, 112, 0)
				fPart = efrac[0 + 1]
				ePart = efrac[1 + 1]
			else
				fPart = frac
			end
		end
	elseif _g.jk.lang.String:contains(str, "p") then
		local efrac = _g.jk.lang.String:split(str, 112, 0)
		iPart = efrac[0 + 1]
		ePart = efrac[1 + 1]
	else
		iPart = str
	end
	do
		local significandString = nil
		local signifLength = 0
		local exponentAdjust = 0
		local leftDigits = 0
		local rightDigits = 0
		if not isFractionalForm then
			significandString = _g.jk.text.StringUtil:stripLeadingZeros(iPart)
			leftDigits = _g.jk.lang.String:getLength(significandString)
		else
			local iPortion = _g.jk.text.StringUtil:stripLeadingZeros(iPart)
			leftDigits = _g.jk.lang.String:getLength(iPortion)
			do
				local fPortion = fPart
				rightDigits = _g.jk.lang.String:getLength(fPortion)
				significandString = _g.jk.lang.String:safeString(iPortion) .. _g.jk.lang.String:safeString(fPortion)
			end
		end
		significandString = _g.jk.text.StringUtil:stripLeadingZeros(significandString)
		signifLength = _g.jk.lang.String:getLength(significandString)
		if leftDigits >= 1 then
			exponentAdjust = 4 * (leftDigits - 1)
		else
			exponentAdjust = -4 * (rightDigits - signifLength + 1)
		end
		if signifLength == 0 then
			do return (function(a, b, c)
				if a then
					do return b() end
				end
				do return c() end
			end)(isNegative, function()
				do return -0.0 end
			end, function()
				do return 0.0 end
			end) end
		end
		do
			local positiveExponent = not _g.jk.lang.String:contains(ePart, "-")
			local rawExponent = (function(a, b, c)
				if a then
					do return b() end
				end
				do return c() end
			end)(positiveExponent, function()
				do return 1 end
			end, function()
				do return -1 end
			end) * _g.jk.lang.String:toInteger(ePart)
			local exponent = rawExponent + exponentAdjust
			local round = false
			local sticky = false
			local nextShift = 0
			local significand = 0
			local leadingDigit = _g.jk.lang.Character:getHexDigit(_g.jk.lang.String:getChar(significandString, 0))
			if leadingDigit == 1 then
				significand = _vm:bitwise_or(significand, _vm:bitwise_left_shift(leadingDigit, 52))
				nextShift = 52 - 4
			elseif leadingDigit <= 3 then
				significand = _vm:bitwise_or(significand, _vm:bitwise_left_shift(leadingDigit, 51))
				nextShift = 52 - 5
				exponent = exponent + 1
			elseif leadingDigit <= 7 then
				significand = _vm:bitwise_or(significand, _vm:bitwise_left_shift(leadingDigit, 50))
				nextShift = 52 - 6
				exponent = exponent + 2
			elseif leadingDigit <= 15 then
				significand = _vm:bitwise_or(significand, _vm:bitwise_left_shift(leadingDigit, 49))
				nextShift = 52 - 7
				exponent = exponent + 3
			else
				do return 0.0 end
			end
			do
				local i = 0
				do
					i = 1
					while i < signifLength and nextShift >= 0 do
						local currentDigit = _g.jk.lang.Character:getHexDigit(_g.jk.lang.String:getChar(significandString, i))
						significand = _vm:bitwise_or(significand, _vm:bitwise_left_shift(currentDigit, nextShift))
						nextShift = nextShift - 4
						do i = i + 1 end
					end
				end
				if i < signifLength then
					local currentDigit = _g.jk.lang.Character:getHexDigit(_g.jk.lang.String:getChar(significandString, i))
					do
						local v = nextShift
						if v == -1 then
							significand = _vm:bitwise_or(significand, _vm:bitwise_right_shift(_vm:bitwise_and(currentDigit, 14), 1))
							round = _vm:bitwise_and(currentDigit, 1) ~= 0
						elseif v == -2 then
							significand = _vm:bitwise_or(significand, _vm:bitwise_right_shift(_vm:bitwise_and(currentDigit, 12), 2))
							round = _vm:bitwise_and(currentDigit, 2) ~= 0
							sticky = _vm:bitwise_and(currentDigit, 1) ~= 0
						elseif v == -3 then
							significand = _vm:bitwise_or(significand, _vm:bitwise_right_shift(_vm:bitwise_and(currentDigit, 8), 3))
							round = _vm:bitwise_and(currentDigit, 4) ~= 0
							sticky = _vm:bitwise_and(currentDigit, 3) ~= 0
						elseif v == -4 then
							round = _vm:bitwise_and(currentDigit, 8) ~= 0
							sticky = _vm:bitwise_and(currentDigit, 7) ~= 0
						else
							_io:write_to_stdout("[sling.common.CodeStringUtil.toDoubleFromHex] (CodeStringUtil.sling:384:5): Unexpected shift distance remainder." .. "\n")
							do return 0.0 end
						end
					end
					do i = i + 1 end
					while i < signifLength and not sticky do
						currentDigit = _g.jk.lang.Character:getHexDigit(_g.jk.lang.String:getChar(significandString, i))
						sticky = sticky or currentDigit ~= 0
						do i = i + 1 end
					end
				end
				do
					local doubleSignificandWidth = 53
					local doubleMinSubExp = -1022 - (doubleSignificandWidth - 1)
					if exponent > 1023 then
						do return 0.0 end
					else
						if exponent <= 1023 and exponent >= -1022 then
							significand = _vm:bitwise_or(_vm:bitwise_and(_vm:bitwise_left_shift(exponent + 1023, doubleSignificandWidth - 1), 9218868437227405312), _vm:bitwise_and(4503599627370495, significand))
						elseif exponent < doubleMinSubExp - 1 then
							do return 0.0 end
						else
							sticky = sticky or round
							round = false
							do
								local bitsDiscarded = 53 - (exponent - doubleMinSubExp + 1)
								if not (bitsDiscarded >= 1 and bitsDiscarded <= 53) then
									do return 0.0 end
								end
								round = _vm:bitwise_and(significand, _vm:bitwise_left_shift(1, bitsDiscarded - 1)) ~= 0
								if bitsDiscarded > 1 then
									local mask = _vm:bitwise_not(_vm:bitwise_left_shift(0, bitsDiscarded - 1))
									sticky = sticky or _vm:bitwise_and(significand, mask) ~= 0
								end
								significand = _vm:bitwise_right_shift(significand, bitsDiscarded)
								significand = _vm:bitwise_or(_vm:bitwise_and(_vm:bitwise_left_shift(-1022 - 1 + 1023, doubleSignificandWidth - 1), 9218868437227405312), _vm:bitwise_and(4503599627370495, significand))
							end
						end
						do
							local leastZero = _vm:bitwise_and(significand, 1) == 0
							if leastZero and round and sticky or (not leastZero and round) then
								do significand = significand + 1 end
							end
							significand = (function(a, b, c)
								if a then
									do return b() end
								end
								do return c() end
							end)(isNegative, function()
								do return _vm:bitwise_or(significand, 2147483648) end
							end, function()
								do return significand end
							end)
						end
					end
					do return _g.jk.lang.Double:longBitsToDouble(significand) end
				end
			end
		end
	end
end
sling = sling or {}

sling.model = sling.model or {}

sling.model.EntityDeclarationNode = _g.sling.common.NamedContainerNode._create()
sling.model.EntityDeclarationNode.__index = sling.model.EntityDeclarationNode
_vm:set_metatable(sling.model.EntityDeclarationNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.model.EntityDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EntityDeclarationNode)
	return v
end

function sling.model.EntityDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EntityDeclarationNode'
	self['_isType.sling.model.EntityDeclarationNode'] = true
	self.baseTypes = nil
	self.importEntities = nil
	self.importNamespaces = nil
	self.importStaticNamespaces = nil
	self.sourceLanguage = nil
	self.dependencies = nil
	self.description = nil
	self.metadata = nil
	self.baseTypeMetaParameters = nil
end

function sling.model.EntityDeclarationNode:_construct0()
	sling.model.EntityDeclarationNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.model.EntityDeclarationNode:clearImports()
	do self:clearImportNamespaces() end
	do self:clearImportStaticNamespaces() end
	do self:clearImportEntities() end
end

function sling.model.EntityDeclarationNode:addBaseTypeExtends(type)
	do self:addBaseType(type, _g.sling.model.BaseTypeNode.INHERIT_EXTEND) end
end

function sling.model.EntityDeclarationNode:addBaseTypeExtendsAsExpression(expType)
	do self:addBaseTypeForExpression(expType, _g.sling.model.BaseTypeNode.INHERIT_EXTEND) end
end

function sling.model.EntityDeclarationNode:addBaseTypeImplements(type)
	do self:addBaseType(type, _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT) end
end

function sling.model.EntityDeclarationNode:addBaseTypeAutomatic(type)
	do self:addBaseType(type, _g.sling.model.BaseTypeNode.INHERIT_AUTO) end
end

function sling.model.EntityDeclarationNode:addBaseType(type, inheritType)
	do self:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(type, inheritType)) end
end

function sling.model.EntityDeclarationNode:addBaseTypeForExpression(expression, inheritType)
	do self:addToBaseTypes(_g.sling.model.BaseTypeNode:forExpression(expression, inheritType)) end
end

function sling.model.EntityDeclarationNode:getNodeTypeName()
	do return "EntityDeclarationNode" end
end

function sling.model.EntityDeclarationNode:createNew()
	do return _g.sling.model.EntityDeclarationNode._construct0(_g.sling.model.EntityDeclarationNode._create()) end
end

function sling.model.EntityDeclarationNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EntityDeclarationNode')
		if n == nil then
			do return true end
		end
		n.sourceLanguage = self.sourceLanguage
		n.description = self.description
		n.metadata = self.metadata
		do
			local array = n.baseTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.baseTypes = nil
			if self.baseTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.baseTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.baseTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.baseTypes == nil then
								n.baseTypes = {}
							end
							do _g.jk.lang.Vector:append(n.baseTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.importEntities
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.importEntities = nil
				if self.importEntities ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.importEntities)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.importEntities[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.importEntities == nil then
									n.importEntities = {}
								end
								do _g.jk.lang.Vector:append(n.importEntities, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do
					local array3 = n.importNamespaces
					if array3 ~= nil then
						local n6 = 0
						local m5 = _g.jk.lang.Vector:getSize(array3)
						do
							n6 = 0
							while n6 < m5 do
								local xx = _vm:to_table_with_key(array3[n6 + 1], '_isType.sling.common.NodeObject')
								if xx ~= nil then
									do xx:destroy() end
								end
								do n6 = n6 + 1 end
							end
						end
					end
					n.importNamespaces = nil
					if self.importNamespaces ~= nil then
						local n7 = 0
						local m6 = _g.jk.lang.Vector:getSize(self.importNamespaces)
						do
							n7 = 0
							while n7 < m6 do
								local nod = _vm:to_table_with_key(self.importNamespaces[n7 + 1], '_isType.sling.common.NodeObject')
								if nod ~= nil then
									local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
									if ndup == nil then
										do return false end
									end
									if n.importNamespaces == nil then
										n.importNamespaces = {}
									end
									do _g.jk.lang.Vector:append(n.importNamespaces, ndup) end
									do ndup:setParent(n) end
								end
								do n7 = n7 + 1 end
							end
						end
					end
					do
						local array4 = n.importStaticNamespaces
						if array4 ~= nil then
							local n8 = 0
							local m7 = _g.jk.lang.Vector:getSize(array4)
							do
								n8 = 0
								while n8 < m7 do
									local xx = _vm:to_table_with_key(array4[n8 + 1], '_isType.sling.common.NodeObject')
									if xx ~= nil then
										do xx:destroy() end
									end
									do n8 = n8 + 1 end
								end
							end
						end
						n.importStaticNamespaces = nil
						if self.importStaticNamespaces ~= nil then
							local n9 = 0
							local m8 = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
							do
								n9 = 0
								while n9 < m8 do
									local nod = _vm:to_table_with_key(self.importStaticNamespaces[n9 + 1], '_isType.sling.common.NodeObject')
									if nod ~= nil then
										local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
										if ndup == nil then
											do return false end
										end
										if n.importStaticNamespaces == nil then
											n.importStaticNamespaces = {}
										end
										do _g.jk.lang.Vector:append(n.importStaticNamespaces, ndup) end
										do ndup:setParent(n) end
									end
									do n9 = n9 + 1 end
								end
							end
						end
						n.dependencies = {}
						if self.dependencies ~= nil then
							local n10 = 0
							local m9 = _g.jk.lang.Vector:getSize(self.dependencies)
							do
								n10 = 0
								while n10 < m9 do
									local value = self.dependencies[n10 + 1]
									if value ~= nil then
										do _g.jk.lang.Vector:append(n.dependencies, value) end
									end
									do n10 = n10 + 1 end
								end
							end
						end
						do
							local array5 = n.baseTypeMetaParameters
							if array5 ~= nil then
								local n11 = 0
								local m10 = _g.jk.lang.Vector:getSize(array5)
								do
									n11 = 0
									while n11 < m10 do
										local xx = _vm:to_table_with_key(array5[n11 + 1], '_isType.sling.common.NodeObject')
										if xx ~= nil then
											do xx:destroy() end
										end
										do n11 = n11 + 1 end
									end
								end
							end
							n.baseTypeMetaParameters = nil
							if self.baseTypeMetaParameters ~= nil then
								local n12 = 0
								local m11 = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
								do
									n12 = 0
									while n12 < m11 do
										local nod = _vm:to_table_with_key(self.baseTypeMetaParameters[n12 + 1], '_isType.sling.common.NodeObject')
										if nod ~= nil then
											local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
											if ndup == nil then
												do return false end
											end
											if n.baseTypeMetaParameters == nil then
												n.baseTypeMetaParameters = {}
											end
											do _g.jk.lang.Vector:append(n.baseTypeMetaParameters, ndup) end
											do ndup:setParent(n) end
										end
										do n12 = n12 + 1 end
									end
								end
							end
							do return true end
						end
					end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.baseTypes, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.importEntities, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.importNamespaces, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.importStaticNamespaces, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.baseTypeMetaParameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EntityDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.baseTypes, visitor) == false then
		do return false end
	end
	if self:visitVector(self.importEntities, visitor) == false then
		do return false end
	end
	if self:visitVector(self.importNamespaces, visitor) == false then
		do return false end
	end
	if self:visitVector(self.importStaticNamespaces, visitor) == false then
		do return false end
	end
	if self:visitVector(self.baseTypeMetaParameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EntityDeclarationNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
	if self.importEntities ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.importEntities)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.importEntities[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.importEntities = nil
	if self.importNamespaces ~= nil then
		local n3 = 0
		local m3 = _g.jk.lang.Vector:getSize(self.importNamespaces)
		do
			n3 = 0
			while n3 < m3 do
				local nx = _vm:to_table_with_key(self.importNamespaces[n3 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n3 = n3 + 1 end
			end
		end
	end
	self.importNamespaces = nil
	if self.importStaticNamespaces ~= nil then
		local n4 = 0
		local m4 = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
		do
			n4 = 0
			while n4 < m4 do
				local nx = _vm:to_table_with_key(self.importStaticNamespaces[n4 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n4 = n4 + 1 end
			end
		end
	end
	self.importStaticNamespaces = nil
	if self.baseTypeMetaParameters ~= nil then
		local n5 = 0
		local m5 = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
		do
			n5 = 0
			while n5 < m5 do
				local nx = _vm:to_table_with_key(self.baseTypeMetaParameters[n5 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n5 = n5 + 1 end
			end
		end
	end
	self.baseTypeMetaParameters = nil
end

function sling.model.EntityDeclarationNode:setSourceLanguage(v)
	self.sourceLanguage = v
end

function sling.model.EntityDeclarationNode:getSourceLanguage()
	do return self.sourceLanguage end
end

function sling.model.EntityDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.EntityDeclarationNode:getDescription()
	do return self.description end
end

function sling.model.EntityDeclarationNode:setMetadata(v)
	self.metadata = v
end

function sling.model.EntityDeclarationNode:getMetadata()
	do return self.metadata end
end

function sling.model.EntityDeclarationNode:setBaseTypes(v, doExport)
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.baseTypes = nil
	else
		self.baseTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.baseTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getBaseTypes()
	do return self.baseTypes end
end

function sling.model.EntityDeclarationNode:exportBaseTypes()
	local v = self.baseTypes
	self.baseTypes = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToBaseTypes(v)
	if v == nil then
		do return end
	end
	if self.baseTypes == nil then
		self.baseTypes = {}
	end
	do _g.jk.lang.Vector:append(self.baseTypes, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearBaseTypes()
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
end

function sling.model.EntityDeclarationNode:setImportEntities(v, doExport)
	if self.importEntities ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importEntities)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importEntities[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.importEntities = nil
	else
		self.importEntities = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.importEntities, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getImportEntities()
	do return self.importEntities end
end

function sling.model.EntityDeclarationNode:exportImportEntities()
	local v = self.importEntities
	self.importEntities = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToImportEntities(v)
	if v == nil then
		do return end
	end
	if self.importEntities == nil then
		self.importEntities = {}
	end
	do _g.jk.lang.Vector:append(self.importEntities, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearImportEntities()
	if self.importEntities ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importEntities)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importEntities[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.importEntities = nil
end

function sling.model.EntityDeclarationNode:setImportNamespaces(v, doExport)
	if self.importNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.importNamespaces = nil
	else
		self.importNamespaces = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.importNamespaces, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getImportNamespaces()
	do return self.importNamespaces end
end

function sling.model.EntityDeclarationNode:exportImportNamespaces()
	local v = self.importNamespaces
	self.importNamespaces = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToImportNamespaces(v)
	if v == nil then
		do return end
	end
	if self.importNamespaces == nil then
		self.importNamespaces = {}
	end
	do _g.jk.lang.Vector:append(self.importNamespaces, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearImportNamespaces()
	if self.importNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.importNamespaces = nil
end

function sling.model.EntityDeclarationNode:setImportStaticNamespaces(v, doExport)
	if self.importStaticNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importStaticNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.importStaticNamespaces = nil
	else
		self.importStaticNamespaces = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.importStaticNamespaces, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getImportStaticNamespaces()
	do return self.importStaticNamespaces end
end

function sling.model.EntityDeclarationNode:exportImportStaticNamespaces()
	local v = self.importStaticNamespaces
	self.importStaticNamespaces = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToImportStaticNamespaces(v)
	if v == nil then
		do return end
	end
	if self.importStaticNamespaces == nil then
		self.importStaticNamespaces = {}
	end
	do _g.jk.lang.Vector:append(self.importStaticNamespaces, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearImportStaticNamespaces()
	if self.importStaticNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importStaticNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.importStaticNamespaces = nil
end

function sling.model.EntityDeclarationNode:setDependencies(v)
	self.dependencies = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.dependencies, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getDependencies()
	do return self.dependencies end
end

function sling.model.EntityDeclarationNode:addToDependencies(v)
	if v == nil then
		do return end
	end
	if self.dependencies == nil then
		self.dependencies = {}
	end
	do _g.jk.lang.Vector:append(self.dependencies, v) end
end

function sling.model.EntityDeclarationNode:clearDependencies()
	self.dependencies = nil
end

function sling.model.EntityDeclarationNode:setBaseTypeMetaParameters(v, doExport)
	if self.baseTypeMetaParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypeMetaParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.baseTypeMetaParameters = nil
	else
		self.baseTypeMetaParameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.baseTypeMetaParameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getBaseTypeMetaParameters()
	do return self.baseTypeMetaParameters end
end

function sling.model.EntityDeclarationNode:exportBaseTypeMetaParameters()
	local v = self.baseTypeMetaParameters
	self.baseTypeMetaParameters = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToBaseTypeMetaParameters(v)
	if v == nil then
		do return end
	end
	if self.baseTypeMetaParameters == nil then
		self.baseTypeMetaParameters = {}
	end
	do _g.jk.lang.Vector:append(self.baseTypeMetaParameters, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearBaseTypeMetaParameters()
	if self.baseTypeMetaParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypeMetaParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypeMetaParameters = nil
end

sling.model.BinaryExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.BinaryExpressionNode.__index = sling.model.BinaryExpressionNode
_vm:set_metatable(sling.model.BinaryExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.BinaryExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BinaryExpressionNode)
	return v
end

function sling.model.BinaryExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BinaryExpressionNode'
	self['_isType.sling.model.BinaryExpressionNode'] = true
	self.left = nil
	self.right = nil
end

function sling.model.BinaryExpressionNode:_construct0()
	sling.model.BinaryExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.BinaryExpressionNode:getNodeTypeName()
	do return "BinaryExpressionNode" end
end

function sling.model.BinaryExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BinaryExpressionNode')
		if n == nil then
			do return true end
		end
		if n.left ~= nil then
			do n.left:destroy() end
			n.left = nil
		end
		if self.left ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.left), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.left = pcp
			do n.left:setParent(n) end
		end
		if n.right ~= nil then
			do n.right:destroy() end
			n.right = nil
		end
		if self.right ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.right), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.right = pcp
			do n.right:setParent(n) end
		end
		do return true end
	end
end

function sling.model.BinaryExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.left then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.left:destroy() end
		end
		self.left = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.left ~= nil then
			do self.left:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.right then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.right:destroy() end
		end
		self.right = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.right ~= nil then
			do self.right:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BinaryExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.left ~= nil then
		if self.left:accept(visitor) == false then
			do return false end
		end
	end
	if self.right ~= nil then
		if self.right:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.BinaryExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.left ~= nil then
		do self.left:destroy() end
		self.left = nil
	end
	if self.right ~= nil then
		do self.right:destroy() end
		self.right = nil
	end
end

function sling.model.BinaryExpressionNode:setLeft(v, doExport)
	if self.left ~= nil and doExport == false then
		do self.left:destroy() end
	end
	self.left = v
	if self.left ~= nil then
		do self.left:setParent(self) end
	end
end

function sling.model.BinaryExpressionNode:getLeft()
	do return self.left end
end

function sling.model.BinaryExpressionNode:exportLeft()
	local v = self.left
	self.left = nil
	do return v end
end

function sling.model.BinaryExpressionNode:setRight(v, doExport)
	if self.right ~= nil and doExport == false then
		do self.right:destroy() end
	end
	self.right = v
	if self.right ~= nil then
		do self.right:setParent(self) end
	end
end

function sling.model.BinaryExpressionNode:getRight()
	do return self.right end
end

function sling.model.BinaryExpressionNode:exportRight()
	local v = self.right
	self.right = nil
	do return v end
end

sling.model.UnaryExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.UnaryExpressionNode.__index = sling.model.UnaryExpressionNode
_vm:set_metatable(sling.model.UnaryExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.UnaryExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.UnaryExpressionNode)
	return v
end

function sling.model.UnaryExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.UnaryExpressionNode'
	self['_isType.sling.model.UnaryExpressionNode'] = true
	self.expression = nil
end

function sling.model.UnaryExpressionNode:_construct0()
	sling.model.UnaryExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.UnaryExpressionNode:getNodeTypeName()
	do return "UnaryExpressionNode" end
end

function sling.model.UnaryExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.UnaryExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.UnaryExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.UnaryExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.UnaryExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.UnaryExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.UnaryExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.UnaryExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.AssignmentExpressionBaseNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.AssignmentExpressionBaseNode.__index = sling.model.AssignmentExpressionBaseNode
_vm:set_metatable(sling.model.AssignmentExpressionBaseNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.AssignmentExpressionBaseNode._create()
	local v = _vm:set_metatable({}, sling.model.AssignmentExpressionBaseNode)
	return v
end

function sling.model.AssignmentExpressionBaseNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AssignmentExpressionBaseNode'
	self['_isType.sling.model.AssignmentExpressionBaseNode'] = true
end

function sling.model.AssignmentExpressionBaseNode:_construct0()
	sling.model.AssignmentExpressionBaseNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.AssignmentExpressionBaseNode:getNodeTypeName()
	do return "AssignmentExpressionBaseNode" end
end

function sling.model.AssignmentExpressionBaseNode:createNew()
	do return _g.sling.model.AssignmentExpressionBaseNode._construct0(_g.sling.model.AssignmentExpressionBaseNode._create()) end
end

function sling.model.AssignmentExpressionBaseNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AssignmentExpressionBaseNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AssignmentExpressionBaseNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AssignmentExpressionBaseNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AssignmentExpressionBaseNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.DataTypeExtenderNode = _g.sling.common.DataTypeNode._create()
sling.model.DataTypeExtenderNode.__index = sling.model.DataTypeExtenderNode
_vm:set_metatable(sling.model.DataTypeExtenderNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DataTypeExtenderNode._create()
	local v = _vm:set_metatable({}, sling.model.DataTypeExtenderNode)
	return v
end

function sling.model.DataTypeExtenderNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DataTypeExtenderNode'
	self['_isType.sling.model.DataTypeExtenderNode'] = true
	self.primaryType = nil
end

function sling.model.DataTypeExtenderNode:_construct0()
	sling.model.DataTypeExtenderNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DataTypeExtenderNode:getNodeTypeName()
	do return "DataTypeExtenderNode" end
end

function sling.model.DataTypeExtenderNode:createNew()
	do return _g.sling.model.DataTypeExtenderNode._construct0(_g.sling.model.DataTypeExtenderNode._create()) end
end

function sling.model.DataTypeExtenderNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DataTypeExtenderNode')
		if n == nil then
			do return true end
		end
		if n.primaryType ~= nil then
			do n.primaryType:destroy() end
			n.primaryType = nil
		end
		if self.primaryType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.primaryType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.primaryType = pcp
			do n.primaryType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DataTypeExtenderNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.primaryType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.primaryType:destroy() end
		end
		self.primaryType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.primaryType ~= nil then
			do self.primaryType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DataTypeExtenderNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.primaryType ~= nil then
		if self.primaryType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DataTypeExtenderNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.primaryType ~= nil then
		do self.primaryType:destroy() end
		self.primaryType = nil
	end
end

function sling.model.DataTypeExtenderNode:setPrimaryType(v, doExport)
	if self.primaryType ~= nil and doExport == false then
		do self.primaryType:destroy() end
	end
	self.primaryType = v
	if self.primaryType ~= nil then
		do self.primaryType:setParent(self) end
	end
end

function sling.model.DataTypeExtenderNode:getPrimaryType()
	do return self.primaryType end
end

function sling.model.DataTypeExtenderNode:exportPrimaryType()
	local v = self.primaryType
	self.primaryType = nil
	do return v end
end

sling.model.VariableDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.VariableDeclarationNode.__index = sling.model.VariableDeclarationNode
_vm:set_metatable(sling.model.VariableDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.VariableDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableDeclarationNode)
	return v
end

function sling.model.VariableDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableDeclarationNode'
	self['_isType.sling.model.VariableDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.fundamentalType = nil
	self.type = nil
	self.name = nil
	self.paramName = nil
	self.initializer = nil
	self.description = nil
end

function sling.model.VariableDeclarationNode:_construct0()
	sling.model.VariableDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.VariableDeclarationNode:forAutomatic(name, initializer)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setType(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), false) end
	do v:setName(name) end
	do v:setInitializer(initializer, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:instance(type, name, initializer)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setType(type, false) end
	do v:setName(name) end
	do v:setInitializer(initializer, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:forInitializer(initializer)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setInitializer(initializer, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:forDynamic(name)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setName(name) end
	do v:setType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	do return v end
end

function sling.model.VariableDeclarationNode:forName(name)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.VariableDeclarationNode:forType(type)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:getNodeName()
	do return self.name end
end

function sling.model.VariableDeclarationNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.VariableDeclarationNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.VariableDeclarationNode:getNodeTypeName()
	do return "VariableDeclarationNode" end
end

function sling.model.VariableDeclarationNode:createNew()
	do return _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create()) end
end

function sling.model.VariableDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.fundamentalType ~= nil then
			do n.fundamentalType:destroy() end
			n.fundamentalType = nil
		end
		if self.fundamentalType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.fundamentalType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.fundamentalType = pcp
			do n.fundamentalType:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		n.name = self.name
		n.paramName = self.paramName
		n.description = self.description
		do return true end
	end
end

function sling.model.VariableDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.fundamentalType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.fundamentalType:destroy() end
		end
		self.fundamentalType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.fundamentalType ~= nil then
			do self.fundamentalType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.fundamentalType ~= nil then
		if self.fundamentalType:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.VariableDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.fundamentalType ~= nil then
		do self.fundamentalType:destroy() end
		self.fundamentalType = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
end

function sling.model.VariableDeclarationNode:setFundamentalType(v, doExport)
	if self.fundamentalType ~= nil and doExport == false then
		do self.fundamentalType:destroy() end
	end
	self.fundamentalType = v
	if self.fundamentalType ~= nil then
		do self.fundamentalType:setParent(self) end
	end
end

function sling.model.VariableDeclarationNode:getFundamentalType()
	do return self.fundamentalType end
end

function sling.model.VariableDeclarationNode:exportFundamentalType()
	local v = self.fundamentalType
	self.fundamentalType = nil
	do return v end
end

function sling.model.VariableDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.VariableDeclarationNode:getType()
	do return self.type end
end

function sling.model.VariableDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.VariableDeclarationNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.VariableDeclarationNode:getInitializer()
	do return self.initializer end
end

function sling.model.VariableDeclarationNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.VariableDeclarationNode:getName()
	do return self.name end
end

function sling.model.VariableDeclarationNode:setParamName(v)
	self.paramName = v
end

function sling.model.VariableDeclarationNode:getParamName()
	do return self.paramName end
end

function sling.model.VariableDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.VariableDeclarationNode:getDescription()
	do return self.description end
end

sling.model.SymbolNode = _g.sling.common.NodeObject._create()
sling.model.SymbolNode.__index = sling.model.SymbolNode
_vm:set_metatable(sling.model.SymbolNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.SymbolNode._create()
	local v = _vm:set_metatable({}, sling.model.SymbolNode)
	return v
end

function sling.model.SymbolNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SymbolNode'
	self['_isType.sling.model.SymbolNode'] = true
	self.components = nil
	self.magical = false
	self.typeParameters = nil
	self.binding = nil
	self.bindingTypemap = nil
end

function sling.model.SymbolNode:_construct0()
	sling.model.SymbolNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.SymbolNode:forBinding(node, typemap)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	do v:setBinding(node, typemap) end
	do return v end
end

function sling.model.SymbolNode:forName(name)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	do v:addToComponents(_g.sling.model.SymbolNameComponentNode:forName(name)) end
	do return v end
end

function sling.model.SymbolNode:forArrayOfNames(names)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	if names ~= nil then
		local n = 0
		local m = #names
		do
			n = 0
			while n < m do
				local name = names[n + 1]
				if name ~= nil then
					do v:addObjectToComponents(name) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.SymbolNode:forVectorOfNames(names)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	if names ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(names)
		do
			n = 0
			while n < m do
				local name = names[n + 1]
				if name ~= nil then
					do v:addObjectToComponents(name) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.SymbolNode:getBinding()
	do return self.binding end
end

function sling.model.SymbolNode:getBindingTypemap()
	do return self.bindingTypemap end
end

function sling.model.SymbolNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	do self:setBinding(nil, nil) end
end

function sling.model.SymbolNode:setBinding(binding, typemap)
	self.binding = binding
	if self.bindingTypemap ~= nil then
		do self.bindingTypemap:clear() end
	end
	self.bindingTypemap = (function(a, b, c)
		if a then
			do return b() end
		end
		do return c() end
	end)(typemap, function()
		do return typemap:dup() end
	end, function()
		do return nil end
	end)
end

function sling.model.SymbolNode:copyCustomTo(node)
	do _g.sling.common.NodeObject.copyCustomTo(self, node) end
	do
		local noth = _vm:to_table_with_key(node, '_isType.sling.model.SymbolNode')
		if noth ~= nil then
			do noth:setBinding(self.binding, self.bindingTypemap) end
		end
		do return true end
	end
end

function sling.model.SymbolNode:addObjectToComponents(obj)
	do self:addToComponents(_g.sling.model.SymbolNameComponentNode:forObject(obj)) end
end

function sling.model.SymbolNode:addNameToComponents(name)
	do self:addToComponents(_g.sling.model.SymbolNameComponentNode:forName(name)) end
end

function sling.model.SymbolNode:getNodeTypeName()
	do return "SymbolNode" end
end

function sling.model.SymbolNode:createNew()
	do return _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create()) end
end

function sling.model.SymbolNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SymbolNode')
		if n == nil then
			do return true end
		end
		n.magical = self.magical
		do
			local array = n.components
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.components = nil
			if self.components ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.components)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.components[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.components == nil then
								n.components = {}
							end
							do _g.jk.lang.Vector:append(n.components, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.typeParameters
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.typeParameters = nil
				if self.typeParameters ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.typeParameters)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.typeParameters[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.typeParameters == nil then
									n.typeParameters = {}
								end
								do _g.jk.lang.Vector:append(n.typeParameters, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.SymbolNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.components, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.typeParameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SymbolNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.components, visitor) == false then
		do return false end
	end
	if self:visitVector(self.typeParameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SymbolNode:setMagical(v)
	self.magical = v
end

function sling.model.SymbolNode:getMagical()
	do return self.magical end
end

function sling.model.SymbolNode:setComponents(v, doExport)
	if self.components ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.components)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.components[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.components = nil
	else
		self.components = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.components, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SymbolNode:getComponents()
	do return self.components end
end

function sling.model.SymbolNode:exportComponents()
	local v = self.components
	self.components = nil
	do return v end
end

function sling.model.SymbolNode:addToComponents(v)
	if v == nil then
		do return end
	end
	if self.components == nil then
		self.components = {}
	end
	do _g.jk.lang.Vector:append(self.components, v) end
	do v:setParent(self) end
end

function sling.model.SymbolNode:clearComponents()
	if self.components ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.components)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.components[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.components = nil
end

function sling.model.SymbolNode:setTypeParameters(v, doExport)
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.typeParameters = nil
	else
		self.typeParameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.typeParameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SymbolNode:getTypeParameters()
	do return self.typeParameters end
end

function sling.model.SymbolNode:exportTypeParameters()
	local v = self.typeParameters
	self.typeParameters = nil
	do return v end
end

function sling.model.SymbolNode:addToTypeParameters(v)
	if v == nil then
		do return end
	end
	if self.typeParameters == nil then
		self.typeParameters = {}
	end
	do _g.jk.lang.Vector:append(self.typeParameters, v) end
	do v:setParent(self) end
end

function sling.model.SymbolNode:clearTypeParameters()
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.typeParameters = nil
end

sling.model.DynamicDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.DynamicDataTypeNode.__index = sling.model.DynamicDataTypeNode
_vm:set_metatable(sling.model.DynamicDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DynamicDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicDataTypeNode)
	return v
end

function sling.model.DynamicDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicDataTypeNode'
	self['_isType.sling.model.DynamicDataTypeNode'] = true
end

function sling.model.DynamicDataTypeNode:_construct0()
	sling.model.DynamicDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DynamicDataTypeNode:getNodeTypeName()
	do return "DynamicDataTypeNode" end
end

function sling.model.DynamicDataTypeNode:createNew()
	do return _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()) end
end

function sling.model.DynamicDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.CaseBlockNode = _g.sling.common.NodeObject._create()
sling.model.CaseBlockNode.__index = sling.model.CaseBlockNode
_vm:set_metatable(sling.model.CaseBlockNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CaseBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseBlockNode)
	return v
end

function sling.model.CaseBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseBlockNode'
	self['_isType.sling.model.CaseBlockNode'] = true
	self.block = nil
	self.isRaw = false
end

function sling.model.CaseBlockNode:_construct0()
	sling.model.CaseBlockNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CaseBlockNode:getNodeTypeName()
	do return "CaseBlockNode" end
end

function sling.model.CaseBlockNode:createNew()
	do return _g.sling.model.CaseBlockNode._construct0(_g.sling.model.CaseBlockNode._create()) end
end

function sling.model.CaseBlockNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseBlockNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		n.isRaw = self.isRaw
		do return true end
	end
end

function sling.model.CaseBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseBlockNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseBlockNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.CaseBlockNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.CaseBlockNode:getBlock()
	do return self.block end
end

function sling.model.CaseBlockNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.CaseBlockNode:setIsRaw(v)
	self.isRaw = v
end

function sling.model.CaseBlockNode:getIsRaw()
	do return self.isRaw end
end

sling.model.TypeCastExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.TypeCastExpressionNode.__index = sling.model.TypeCastExpressionNode
_vm:set_metatable(sling.model.TypeCastExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.TypeCastExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeCastExpressionNode)
	return v
end

function sling.model.TypeCastExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeCastExpressionNode'
	self['_isType.sling.model.TypeCastExpressionNode'] = true
	self.expression = nil
	self.type = nil
end

function sling.model.TypeCastExpressionNode:_construct0()
	sling.model.TypeCastExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TypeCastExpressionNode:getNodeTypeName()
	do return "TypeCastExpressionNode" end
end

function sling.model.TypeCastExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeCastExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TypeCastExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeCastExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TypeCastExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.TypeCastExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.TypeCastExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.TypeCastExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.TypeCastExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.TypeCastExpressionNode:getType()
	do return self.type end
end

function sling.model.TypeCastExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.GenericCapableEntityDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.GenericCapableEntityDeclarationNode.__index = sling.model.GenericCapableEntityDeclarationNode
_vm:set_metatable(sling.model.GenericCapableEntityDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.GenericCapableEntityDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.GenericCapableEntityDeclarationNode)
	return v
end

function sling.model.GenericCapableEntityDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GenericCapableEntityDeclarationNode'
	self['_isType.sling.model.GenericCapableEntityDeclarationNode'] = true
	self.genericTypes = nil
end

function sling.model.GenericCapableEntityDeclarationNode:_construct0()
	sling.model.GenericCapableEntityDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.GenericCapableEntityDeclarationNode:getNodeTypeName()
	do return "GenericCapableEntityDeclarationNode" end
end

function sling.model.GenericCapableEntityDeclarationNode:createNew()
	do return _g.sling.model.GenericCapableEntityDeclarationNode._construct0(_g.sling.model.GenericCapableEntityDeclarationNode._create()) end
end

function sling.model.GenericCapableEntityDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GenericCapableEntityDeclarationNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.genericTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.genericTypes = nil
			if self.genericTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.genericTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.genericTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.genericTypes == nil then
								n.genericTypes = {}
							end
							do _g.jk.lang.Vector:append(n.genericTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.GenericCapableEntityDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.genericTypes, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GenericCapableEntityDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.genericTypes, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GenericCapableEntityDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
end

function sling.model.GenericCapableEntityDeclarationNode:setGenericTypes(v, doExport)
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.genericTypes = nil
	else
		self.genericTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.genericTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.GenericCapableEntityDeclarationNode:getGenericTypes()
	do return self.genericTypes end
end

function sling.model.GenericCapableEntityDeclarationNode:exportGenericTypes()
	local v = self.genericTypes
	self.genericTypes = nil
	do return v end
end

function sling.model.GenericCapableEntityDeclarationNode:addToGenericTypes(v)
	if v == nil then
		do return end
	end
	if self.genericTypes == nil then
		self.genericTypes = {}
	end
	do _g.jk.lang.Vector:append(self.genericTypes, v) end
	do v:setParent(self) end
end

function sling.model.GenericCapableEntityDeclarationNode:clearGenericTypes()
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
end

sling.model.StringDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.StringDataTypeNode.__index = sling.model.StringDataTypeNode
_vm:set_metatable(sling.model.StringDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.StringDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.StringDataTypeNode)
	return v
end

function sling.model.StringDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringDataTypeNode'
	self['_isType.sling.model.StringDataTypeNode'] = true
	self.fixedLength = nil
end

function sling.model.StringDataTypeNode:_construct0()
	sling.model.StringDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.StringDataTypeNode:getNodeTypeName()
	do return "StringDataTypeNode" end
end

function sling.model.StringDataTypeNode:createNew()
	do return _g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()) end
end

function sling.model.StringDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.fixedLength ~= nil then
			do n.fixedLength:destroy() end
			n.fixedLength = nil
		end
		if self.fixedLength ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.fixedLength), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.fixedLength = pcp
			do n.fixedLength:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StringDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.fixedLength then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.fixedLength:destroy() end
		end
		self.fixedLength = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.fixedLength ~= nil then
			do self.fixedLength:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.fixedLength ~= nil then
		if self.fixedLength:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StringDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.fixedLength ~= nil then
		do self.fixedLength:destroy() end
		self.fixedLength = nil
	end
end

function sling.model.StringDataTypeNode:setFixedLength(v, doExport)
	if self.fixedLength ~= nil and doExport == false then
		do self.fixedLength:destroy() end
	end
	self.fixedLength = v
	if self.fixedLength ~= nil then
		do self.fixedLength:setParent(self) end
	end
end

function sling.model.StringDataTypeNode:getFixedLength()
	do return self.fixedLength end
end

function sling.model.StringDataTypeNode:exportFixedLength()
	local v = self.fixedLength
	self.fixedLength = nil
	do return v end
end

sling.model.LiteralExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.LiteralExpressionNode.__index = sling.model.LiteralExpressionNode
_vm:set_metatable(sling.model.LiteralExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.LiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LiteralExpressionNode)
	return v
end

function sling.model.LiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LiteralExpressionNode'
	self['_isType.sling.model.LiteralExpressionNode'] = true
end

function sling.model.LiteralExpressionNode:_construct0()
	sling.model.LiteralExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.LiteralExpressionNode:getNodeTypeName()
	do return "LiteralExpressionNode" end
end

function sling.model.LiteralExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LiteralExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

sling.model.CatchBlockNode = _g.sling.common.NodeObject._create()
sling.model.CatchBlockNode.__index = sling.model.CatchBlockNode
_vm:set_metatable(sling.model.CatchBlockNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CatchBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CatchBlockNode)
	return v
end

function sling.model.CatchBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CatchBlockNode'
	self['_isType.sling.model.CatchBlockNode'] = true
	self.exceptions = nil
	self.block = nil
end

function sling.model.CatchBlockNode:_construct0()
	sling.model.CatchBlockNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CatchBlockNode:instance(xc, nn)
	local v = _g.sling.model.CatchBlockNode._construct0(_g.sling.model.CatchBlockNode._create())
	if xc ~= nil then
		do v:addToExceptions(xc) end
	end
	do v:setBlock(nn, false) end
	do return v end
end

function sling.model.CatchBlockNode:getNodeTypeName()
	do return "CatchBlockNode" end
end

function sling.model.CatchBlockNode:createNew()
	do return _g.sling.model.CatchBlockNode._construct0(_g.sling.model.CatchBlockNode._create()) end
end

function sling.model.CatchBlockNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CatchBlockNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do
			local array = n.exceptions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.exceptions = nil
			if self.exceptions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.exceptions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.exceptions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.exceptions == nil then
								n.exceptions = {}
							end
							do _g.jk.lang.Vector:append(n.exceptions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.CatchBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.exceptions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CatchBlockNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.exceptions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CatchBlockNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
	if self.exceptions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.exceptions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.exceptions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.exceptions = nil
end

function sling.model.CatchBlockNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.CatchBlockNode:getBlock()
	do return self.block end
end

function sling.model.CatchBlockNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.CatchBlockNode:setExceptions(v, doExport)
	if self.exceptions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.exceptions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.exceptions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.exceptions = nil
	else
		self.exceptions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.exceptions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CatchBlockNode:getExceptions()
	do return self.exceptions end
end

function sling.model.CatchBlockNode:exportExceptions()
	local v = self.exceptions
	self.exceptions = nil
	do return v end
end

function sling.model.CatchBlockNode:addToExceptions(v)
	if v == nil then
		do return end
	end
	if self.exceptions == nil then
		self.exceptions = {}
	end
	do _g.jk.lang.Vector:append(self.exceptions, v) end
	do v:setParent(self) end
end

function sling.model.CatchBlockNode:clearExceptions()
	if self.exceptions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.exceptions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.exceptions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.exceptions = nil
end

sling.model.VariableDeclarationExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.VariableDeclarationExpressionNode.__index = sling.model.VariableDeclarationExpressionNode
_vm:set_metatable(sling.model.VariableDeclarationExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.VariableDeclarationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableDeclarationExpressionNode)
	return v
end

function sling.model.VariableDeclarationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableDeclarationExpressionNode'
	self['_isType.sling.model.VariableDeclarationExpressionNode'] = true
	self.declaration = nil
end

function sling.model.VariableDeclarationExpressionNode:_construct0()
	sling.model.VariableDeclarationExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.VariableDeclarationExpressionNode:getNodeTypeName()
	do return "VariableDeclarationExpressionNode" end
end

function sling.model.VariableDeclarationExpressionNode:createNew()
	do return _g.sling.model.VariableDeclarationExpressionNode._construct0(_g.sling.model.VariableDeclarationExpressionNode._create()) end
end

function sling.model.VariableDeclarationExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableDeclarationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.VariableDeclarationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableDeclarationExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.VariableDeclarationExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
end

function sling.model.VariableDeclarationExpressionNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.VariableDeclarationExpressionNode:getDeclaration()
	do return self.declaration end
end

function sling.model.VariableDeclarationExpressionNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

sling.model.NamedParameterExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.NamedParameterExpressionNode.__index = sling.model.NamedParameterExpressionNode
_vm:set_metatable(sling.model.NamedParameterExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.NamedParameterExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NamedParameterExpressionNode)
	return v
end

function sling.model.NamedParameterExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NamedParameterExpressionNode'
	self['_isType.sling.model.NamedParameterExpressionNode'] = true
	self.name = nil
	self.value = nil
end

function sling.model.NamedParameterExpressionNode:_construct0()
	sling.model.NamedParameterExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.NamedParameterExpressionNode:getNodeTypeName()
	do return "NamedParameterExpressionNode" end
end

function sling.model.NamedParameterExpressionNode:createNew()
	do return _g.sling.model.NamedParameterExpressionNode._construct0(_g.sling.model.NamedParameterExpressionNode._create()) end
end

function sling.model.NamedParameterExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NamedParameterExpressionNode')
		if n == nil then
			do return true end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.NamedParameterExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NamedParameterExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.NamedParameterExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.NamedParameterExpressionNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.NamedParameterExpressionNode:getValue()
	do return self.value end
end

function sling.model.NamedParameterExpressionNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.NamedParameterExpressionNode:setName(v)
	self.name = v
end

function sling.model.NamedParameterExpressionNode:getName()
	do return self.name end
end

sling.model.EnumDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.EnumDeclarationNode.__index = sling.model.EnumDeclarationNode
_vm:set_metatable(sling.model.EnumDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.EnumDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EnumDeclarationNode)
	return v
end

function sling.model.EnumDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EnumDeclarationNode'
	self['_isType.sling.model.EnumDeclarationNode'] = true
end

function sling.model.EnumDeclarationNode:_construct0()
	sling.model.EnumDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.EnumDeclarationNode:forName(name)
	local v = _g.sling.model.EnumDeclarationNode._construct0(_g.sling.model.EnumDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.EnumDeclarationNode:getNodeTypeName()
	do return "EnumDeclarationNode" end
end

function sling.model.EnumDeclarationNode:createNew()
	do return _g.sling.model.EnumDeclarationNode._construct0(_g.sling.model.EnumDeclarationNode._create()) end
end

function sling.model.EnumDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EnumDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EnumDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EnumDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EnumDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
end

sling.model.ArrayLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.ArrayLiteralExpressionNode.__index = sling.model.ArrayLiteralExpressionNode
_vm:set_metatable(sling.model.ArrayLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.ArrayLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ArrayLiteralExpressionNode)
	return v
end

function sling.model.ArrayLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ArrayLiteralExpressionNode'
	self['_isType.sling.model.ArrayLiteralExpressionNode'] = true
	self.expressions = nil
	self.type = nil
end

function sling.model.ArrayLiteralExpressionNode:_construct0()
	sling.model.ArrayLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	return self
end

function sling.model.ArrayLiteralExpressionNode:forExpressions(xprs)
	local v = _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create())
	do v:setExpressions(xprs, false) end
	do return v end
end

function sling.model.ArrayLiteralExpressionNode:getNodeTypeName()
	do return "ArrayLiteralExpressionNode" end
end

function sling.model.ArrayLiteralExpressionNode:createNew()
	do return _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create()) end
end

function sling.model.ArrayLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ArrayLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ArrayLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ArrayLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ArrayLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.ArrayLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ArrayLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.ArrayLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ArrayLiteralExpressionNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ArrayLiteralExpressionNode:getExpressions()
	do return self.expressions end
end

function sling.model.ArrayLiteralExpressionNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.ArrayLiteralExpressionNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.ArrayLiteralExpressionNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.FunctionDeclarationBaseNode = _g.sling.common.NodeObject._create()
sling.model.FunctionDeclarationBaseNode.__index = sling.model.FunctionDeclarationBaseNode
_vm:set_metatable(sling.model.FunctionDeclarationBaseNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.FunctionDeclarationBaseNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDeclarationBaseNode)
	return v
end

function sling.model.FunctionDeclarationBaseNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDeclarationBaseNode'
	self['_isType.sling.model.FunctionDeclarationBaseNode'] = true
	self.genericTypes = nil
	self.parameters = nil
	self.throwables = nil
	self.handles = nil
	self.body = nil
	self.description = nil
end

function sling.model.FunctionDeclarationBaseNode:_construct0()
	sling.model.FunctionDeclarationBaseNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.FunctionDeclarationBaseNode:getCreateBody()
	if self.body == nil then
		do self:setBody(_g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()), false) end
	end
	do return self.body end
end

function sling.model.FunctionDeclarationBaseNode:prependParameter(param)
	if not (param ~= nil) then
		do return end
	end
	if self.parameters == nil then
		do self:addToParameters(param) end
		do return end
	end
	do _g.jk.lang.Vector:prepend(self.parameters, param) end
	do param:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:getParameterCount()
	if not (self.parameters ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.parameters) end
end

function sling.model.FunctionDeclarationBaseNode:removeFirstParameter()
	if not (self.parameters ~= nil) then
		do return nil end
	end
	do
		local psz = _g.jk.lang.Vector:getSize(self.parameters)
		if not (psz > 0) then
			do return nil end
		end
		do
			local fp = _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, 0), '_isType.sling.common.NodeObject')
			if not (fp ~= nil) then
				do return nil end
			end
			do fp:destroy() end
			if psz == 1 then
				self.parameters = nil
			else
				do _g.jk.lang.Vector:removeFirst(self.parameters) end
			end
			do return fp end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getParameter(n)
	if not (self.parameters ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, n), '_isType.sling.common.NodeObject') end
end

function sling.model.FunctionDeclarationBaseNode:getNodeTypeName()
	do return "FunctionDeclarationBaseNode" end
end

function sling.model.FunctionDeclarationBaseNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDeclarationBaseNode')
		if n == nil then
			do return true end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		n.description = self.description
		do
			local array = n.genericTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.genericTypes = nil
			if self.genericTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.genericTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.genericTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.genericTypes == nil then
								n.genericTypes = {}
							end
							do _g.jk.lang.Vector:append(n.genericTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.parameters
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.parameters = nil
				if self.parameters ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.parameters)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.parameters[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.parameters == nil then
									n.parameters = {}
								end
								do _g.jk.lang.Vector:append(n.parameters, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do
					local array3 = n.throwables
					if array3 ~= nil then
						local n6 = 0
						local m5 = _g.jk.lang.Vector:getSize(array3)
						do
							n6 = 0
							while n6 < m5 do
								local xx = _vm:to_table_with_key(array3[n6 + 1], '_isType.sling.common.NodeObject')
								if xx ~= nil then
									do xx:destroy() end
								end
								do n6 = n6 + 1 end
							end
						end
					end
					n.throwables = nil
					if self.throwables ~= nil then
						local n7 = 0
						local m6 = _g.jk.lang.Vector:getSize(self.throwables)
						do
							n7 = 0
							while n7 < m6 do
								local nod = _vm:to_table_with_key(self.throwables[n7 + 1], '_isType.sling.common.NodeObject')
								if nod ~= nil then
									local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
									if ndup == nil then
										do return false end
									end
									if n.throwables == nil then
										n.throwables = {}
									end
									do _g.jk.lang.Vector:append(n.throwables, ndup) end
									do ndup:setParent(n) end
								end
								do n7 = n7 + 1 end
							end
						end
					end
					do
						local array4 = n.handles
						if array4 ~= nil then
							local n8 = 0
							local m7 = _g.jk.lang.Vector:getSize(array4)
							do
								n8 = 0
								while n8 < m7 do
									local xx = _vm:to_table_with_key(array4[n8 + 1], '_isType.sling.common.NodeObject')
									if xx ~= nil then
										do xx:destroy() end
									end
									do n8 = n8 + 1 end
								end
							end
						end
						n.handles = nil
						if self.handles ~= nil then
							local n9 = 0
							local m8 = _g.jk.lang.Vector:getSize(self.handles)
							do
								n9 = 0
								while n9 < m8 do
									local nod = _vm:to_table_with_key(self.handles[n9 + 1], '_isType.sling.common.NodeObject')
									if nod ~= nil then
										local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
										if ndup == nil then
											do return false end
										end
										if n.handles == nil then
											n.handles = {}
										end
										do _g.jk.lang.Vector:append(n.handles, ndup) end
										do ndup:setParent(n) end
									end
									do n9 = n9 + 1 end
								end
							end
						end
						do return true end
					end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.genericTypes, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.throwables, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.handles, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDeclarationBaseNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.genericTypes, visitor) == false then
		do return false end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	if self:visitVector(self.throwables, visitor) == false then
		do return false end
	end
	if self:visitVector(self.handles, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FunctionDeclarationBaseNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
	if self.parameters ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.parameters[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.parameters = nil
	if self.throwables ~= nil then
		local n3 = 0
		local m3 = _g.jk.lang.Vector:getSize(self.throwables)
		do
			n3 = 0
			while n3 < m3 do
				local nx = _vm:to_table_with_key(self.throwables[n3 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n3 = n3 + 1 end
			end
		end
	end
	self.throwables = nil
	if self.handles ~= nil then
		local n4 = 0
		local m4 = _g.jk.lang.Vector:getSize(self.handles)
		do
			n4 = 0
			while n4 < m4 do
				local nx = _vm:to_table_with_key(self.handles[n4 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n4 = n4 + 1 end
			end
		end
	end
	self.handles = nil
end

function sling.model.FunctionDeclarationBaseNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.FunctionDeclarationBaseNode:getBody()
	do return self.body end
end

function sling.model.FunctionDeclarationBaseNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:setDescription(v)
	self.description = v
end

function sling.model.FunctionDeclarationBaseNode:getDescription()
	do return self.description end
end

function sling.model.FunctionDeclarationBaseNode:setGenericTypes(v, doExport)
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.genericTypes = nil
	else
		self.genericTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.genericTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getGenericTypes()
	do return self.genericTypes end
end

function sling.model.FunctionDeclarationBaseNode:exportGenericTypes()
	local v = self.genericTypes
	self.genericTypes = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToGenericTypes(v)
	if v == nil then
		do return end
	end
	if self.genericTypes == nil then
		self.genericTypes = {}
	end
	do _g.jk.lang.Vector:append(self.genericTypes, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearGenericTypes()
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
end

function sling.model.FunctionDeclarationBaseNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getParameters()
	do return self.parameters end
end

function sling.model.FunctionDeclarationBaseNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.FunctionDeclarationBaseNode:setThrowables(v, doExport)
	if self.throwables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.throwables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.throwables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.throwables = nil
	else
		self.throwables = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.throwables, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getThrowables()
	do return self.throwables end
end

function sling.model.FunctionDeclarationBaseNode:exportThrowables()
	local v = self.throwables
	self.throwables = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToThrowables(v)
	if v == nil then
		do return end
	end
	if self.throwables == nil then
		self.throwables = {}
	end
	do _g.jk.lang.Vector:append(self.throwables, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearThrowables()
	if self.throwables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.throwables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.throwables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.throwables = nil
end

function sling.model.FunctionDeclarationBaseNode:setHandles(v, doExport)
	if self.handles ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.handles)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.handles[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.handles = nil
	else
		self.handles = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.handles, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getHandles()
	do return self.handles end
end

function sling.model.FunctionDeclarationBaseNode:exportHandles()
	local v = self.handles
	self.handles = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToHandles(v)
	if v == nil then
		do return end
	end
	if self.handles == nil then
		self.handles = {}
	end
	do _g.jk.lang.Vector:append(self.handles, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearHandles()
	if self.handles ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.handles)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.handles[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.handles = nil
end

sling.model.ImportStatementNode = _g.sling.common.NodeObject._create()
sling.model.ImportStatementNode.__index = sling.model.ImportStatementNode
_vm:set_metatable(sling.model.ImportStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ImportStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportStatementNode)
	return v
end

function sling.model.ImportStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportStatementNode'
	self['_isType.sling.model.ImportStatementNode'] = true
	self.localName = nil
end

function sling.model.ImportStatementNode:_construct0()
	sling.model.ImportStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ImportStatementNode:getNodeTypeName()
	do return "ImportStatementNode" end
end

function sling.model.ImportStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportStatementNode')
		if n == nil then
			do return true end
		end
		n.localName = self.localName
		do return true end
	end
end

function sling.model.ImportStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ImportStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ImportStatementNode:setLocalName(v)
	self.localName = v
end

function sling.model.ImportStatementNode:getLocalName()
	do return self.localName end
end

sling.model.GetReferenceExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.GetReferenceExpressionNode.__index = sling.model.GetReferenceExpressionNode
_vm:set_metatable(sling.model.GetReferenceExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.GetReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetReferenceExpressionNode)
	return v
end

function sling.model.GetReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetReferenceExpressionNode'
	self['_isType.sling.model.GetReferenceExpressionNode'] = true
end

function sling.model.GetReferenceExpressionNode:_construct0()
	sling.model.GetReferenceExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.GetReferenceExpressionNode:forExpression(expression)
	local v = _g.sling.model.GetReferenceExpressionNode._construct0(_g.sling.model.GetReferenceExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.GetReferenceExpressionNode:getNodeTypeName()
	do return "GetReferenceExpressionNode" end
end

function sling.model.GetReferenceExpressionNode:createNew()
	do return _g.sling.model.GetReferenceExpressionNode._construct0(_g.sling.model.GetReferenceExpressionNode._create()) end
end

function sling.model.GetReferenceExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GetReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GetReferenceExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.PrintStatementNode = _g.sling.common.NodeObject._create()
sling.model.PrintStatementNode.__index = sling.model.PrintStatementNode
_vm:set_metatable(sling.model.PrintStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PrintStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.PrintStatementNode)
	return v
end

function sling.model.PrintStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PrintStatementNode'
	self['_isType.sling.model.PrintStatementNode'] = true
	self.expression = nil
end

function sling.model.PrintStatementNode:_construct0()
	sling.model.PrintStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PrintStatementNode:forExpression(expression)
	local v = _g.sling.model.PrintStatementNode._construct0(_g.sling.model.PrintStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PrintStatementNode:getNodeTypeName()
	do return "PrintStatementNode" end
end

function sling.model.PrintStatementNode:createNew()
	do return _g.sling.model.PrintStatementNode._construct0(_g.sling.model.PrintStatementNode._create()) end
end

function sling.model.PrintStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PrintStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PrintStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PrintStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PrintStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.PrintStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.PrintStatementNode:getExpression()
	do return self.expression end
end

function sling.model.PrintStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.ComparisonExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ComparisonExpressionNode.__index = sling.model.ComparisonExpressionNode
_vm:set_metatable(sling.model.ComparisonExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ComparisonExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ComparisonExpressionNode)
	return v
end

function sling.model.ComparisonExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ComparisonExpressionNode'
	self['_isType.sling.model.ComparisonExpressionNode'] = true
end

function sling.model.ComparisonExpressionNode:_construct0()
	sling.model.ComparisonExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
	return self
end

function sling.model.ComparisonExpressionNode:getNodeTypeName()
	do return "ComparisonExpressionNode" end
end

function sling.model.ComparisonExpressionNode:createNew()
	do return _g.sling.model.ComparisonExpressionNode._construct0(_g.sling.model.ComparisonExpressionNode._create()) end
end

function sling.model.ComparisonExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ComparisonExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ComparisonExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ComparisonExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ComparisonExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.AllocateBufferExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.AllocateBufferExpressionNode.__index = sling.model.AllocateBufferExpressionNode
_vm:set_metatable(sling.model.AllocateBufferExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.AllocateBufferExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AllocateBufferExpressionNode)
	return v
end

function sling.model.AllocateBufferExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AllocateBufferExpressionNode'
	self['_isType.sling.model.AllocateBufferExpressionNode'] = true
end

function sling.model.AllocateBufferExpressionNode:forExpression(expression)
	local v = _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.AllocateBufferExpressionNode:_construct0()
	sling.model.AllocateBufferExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()), false) end
	return self
end

function sling.model.AllocateBufferExpressionNode:getNodeTypeName()
	do return "AllocateBufferExpressionNode" end
end

function sling.model.AllocateBufferExpressionNode:createNew()
	do return _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create()) end
end

function sling.model.AllocateBufferExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AllocateBufferExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AllocateBufferExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AllocateBufferExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AllocateBufferExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ExceptionDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ExceptionDataTypeNode.__index = sling.model.ExceptionDataTypeNode
_vm:set_metatable(sling.model.ExceptionDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ExceptionDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ExceptionDataTypeNode)
	return v
end

function sling.model.ExceptionDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExceptionDataTypeNode'
	self['_isType.sling.model.ExceptionDataTypeNode'] = true
end

function sling.model.ExceptionDataTypeNode:_construct0()
	sling.model.ExceptionDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ExceptionDataTypeNode:getNodeTypeName()
	do return "ExceptionDataTypeNode" end
end

function sling.model.ExceptionDataTypeNode:createNew()
	do return _g.sling.model.ExceptionDataTypeNode._construct0(_g.sling.model.ExceptionDataTypeNode._create()) end
end

function sling.model.ExceptionDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExceptionDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ExceptionDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExceptionDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExceptionDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.GetTypeinfoExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.GetTypeinfoExpressionNode.__index = sling.model.GetTypeinfoExpressionNode
_vm:set_metatable(sling.model.GetTypeinfoExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.GetTypeinfoExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetTypeinfoExpressionNode)
	return v
end

function sling.model.GetTypeinfoExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetTypeinfoExpressionNode'
	self['_isType.sling.model.GetTypeinfoExpressionNode'] = true
end

function sling.model.GetTypeinfoExpressionNode:_construct0()
	sling.model.GetTypeinfoExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.GetTypeinfoExpressionNode:getNodeTypeName()
	do return "GetTypeinfoExpressionNode" end
end

function sling.model.GetTypeinfoExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetTypeinfoExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GetTypeinfoExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetTypeinfoExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GetTypeinfoExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

sling.model.DestructorDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.DestructorDeclarationNode.__index = sling.model.DestructorDeclarationNode
_vm:set_metatable(sling.model.DestructorDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.DestructorDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.DestructorDeclarationNode)
	return v
end

function sling.model.DestructorDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DestructorDeclarationNode'
	self['_isType.sling.model.DestructorDeclarationNode'] = true
end

function sling.model.DestructorDeclarationNode:_construct0()
	sling.model.DestructorDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.DestructorDeclarationNode:getNodeTypeName()
	do return "DestructorDeclarationNode" end
end

function sling.model.DestructorDeclarationNode:createNew()
	do return _g.sling.model.DestructorDeclarationNode._construct0(_g.sling.model.DestructorDeclarationNode._create()) end
end

function sling.model.DestructorDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DestructorDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DestructorDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DestructorDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DestructorDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.NullDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.NullDataTypeNode.__index = sling.model.NullDataTypeNode
_vm:set_metatable(sling.model.NullDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.NullDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.NullDataTypeNode)
	return v
end

function sling.model.NullDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NullDataTypeNode'
	self['_isType.sling.model.NullDataTypeNode'] = true
end

function sling.model.NullDataTypeNode:_construct0()
	sling.model.NullDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.NullDataTypeNode:getNodeTypeName()
	do return "NullDataTypeNode" end
end

function sling.model.NullDataTypeNode:createNew()
	do return _g.sling.model.NullDataTypeNode._construct0(_g.sling.model.NullDataTypeNode._create()) end
end

function sling.model.NullDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NullDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NullDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NullDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NullDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.EqualityComparisonExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.EqualityComparisonExpressionNode.__index = sling.model.EqualityComparisonExpressionNode
_vm:set_metatable(sling.model.EqualityComparisonExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

sling.model.EqualityComparisonExpressionNode.SEMANTICS_CLASSIC = 0
sling.model.EqualityComparisonExpressionNode.SEMANTICS_COERCED = 1
sling.model.EqualityComparisonExpressionNode.SEMANTICS_IDENTITY = 2
sling.model.EqualityComparisonExpressionNode.SEMANTICS_VALUE = 3
sling.model.EqualityComparisonExpressionNode.SEMANTICS_OBJECT = 4

function sling.model.EqualityComparisonExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.EqualityComparisonExpressionNode)
	return v
end

function sling.model.EqualityComparisonExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EqualityComparisonExpressionNode'
	self['_isType.sling.model.EqualityComparisonExpressionNode'] = true
	self.semantics = 0
end

function sling.model.EqualityComparisonExpressionNode:_construct0()
	sling.model.EqualityComparisonExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.EqualityComparisonExpressionNode:getNodeTypeName()
	do return "EqualityComparisonExpressionNode" end
end

function sling.model.EqualityComparisonExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EqualityComparisonExpressionNode')
		if n == nil then
			do return true end
		end
		n.semantics = self.semantics
		do return true end
	end
end

function sling.model.EqualityComparisonExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EqualityComparisonExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EqualityComparisonExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

function sling.model.EqualityComparisonExpressionNode:setSemantics(v)
	self.semantics = v
end

function sling.model.EqualityComparisonExpressionNode:getSemantics()
	do return self.semantics end
end

sling.model.MapDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.MapDataTypeNode.__index = sling.model.MapDataTypeNode
_vm:set_metatable(sling.model.MapDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.MapDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.MapDataTypeNode)
	return v
end

function sling.model.MapDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MapDataTypeNode'
	self['_isType.sling.model.MapDataTypeNode'] = true
	self.keyType = nil
	self.valueType = nil
end

function sling.model.MapDataTypeNode:_construct0()
	sling.model.MapDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.MapDataTypeNode:forTypes(key, value)
	local v = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do v:setKeyType(key, false) end
	do v:setValueType(value, false) end
	do return v end
end

function sling.model.MapDataTypeNode:getNodeTypeName()
	do return "MapDataTypeNode" end
end

function sling.model.MapDataTypeNode:createNew()
	do return _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create()) end
end

function sling.model.MapDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MapDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.keyType ~= nil then
			do n.keyType:destroy() end
			n.keyType = nil
		end
		if self.keyType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.keyType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.keyType = pcp
			do n.keyType:setParent(n) end
		end
		if n.valueType ~= nil then
			do n.valueType:destroy() end
			n.valueType = nil
		end
		if self.valueType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.valueType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.valueType = pcp
			do n.valueType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.MapDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.keyType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.keyType:destroy() end
		end
		self.keyType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.keyType ~= nil then
			do self.keyType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.valueType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.valueType:destroy() end
		end
		self.valueType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.valueType ~= nil then
			do self.valueType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MapDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.keyType ~= nil then
		if self.keyType:accept(visitor) == false then
			do return false end
		end
	end
	if self.valueType ~= nil then
		if self.valueType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.MapDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.keyType ~= nil then
		do self.keyType:destroy() end
		self.keyType = nil
	end
	if self.valueType ~= nil then
		do self.valueType:destroy() end
		self.valueType = nil
	end
end

function sling.model.MapDataTypeNode:setKeyType(v, doExport)
	if self.keyType ~= nil and doExport == false then
		do self.keyType:destroy() end
	end
	self.keyType = v
	if self.keyType ~= nil then
		do self.keyType:setParent(self) end
	end
end

function sling.model.MapDataTypeNode:getKeyType()
	do return self.keyType end
end

function sling.model.MapDataTypeNode:exportKeyType()
	local v = self.keyType
	self.keyType = nil
	do return v end
end

function sling.model.MapDataTypeNode:setValueType(v, doExport)
	if self.valueType ~= nil and doExport == false then
		do self.valueType:destroy() end
	end
	self.valueType = v
	if self.valueType ~= nil then
		do self.valueType:setParent(self) end
	end
end

function sling.model.MapDataTypeNode:getValueType()
	do return self.valueType end
end

function sling.model.MapDataTypeNode:exportValueType()
	local v = self.valueType
	self.valueType = nil
	do return v end
end

sling.model.CaseTypePatternBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseTypePatternBlockNode.__index = sling.model.CaseTypePatternBlockNode
_vm:set_metatable(sling.model.CaseTypePatternBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseTypePatternBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseTypePatternBlockNode)
	return v
end

function sling.model.CaseTypePatternBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseTypePatternBlockNode'
	self['_isType.sling.model.CaseTypePatternBlockNode'] = true
	self.type = nil
	self.name = nil
end

function sling.model.CaseTypePatternBlockNode:_construct0()
	sling.model.CaseTypePatternBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseTypePatternBlockNode:instance(type, name, bb)
	local v = _g.sling.model.CaseTypePatternBlockNode._construct0(_g.sling.model.CaseTypePatternBlockNode._create())
	do v:setType(type, false) end
	do v:setName(name) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseTypePatternBlockNode:getNodeTypeName()
	do return "CaseTypePatternBlockNode" end
end

function sling.model.CaseTypePatternBlockNode:createNew()
	do return _g.sling.model.CaseTypePatternBlockNode._construct0(_g.sling.model.CaseTypePatternBlockNode._create()) end
end

function sling.model.CaseTypePatternBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseTypePatternBlockNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.CaseTypePatternBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseTypePatternBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseTypePatternBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.CaseTypePatternBlockNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.CaseTypePatternBlockNode:getType()
	do return self.type end
end

function sling.model.CaseTypePatternBlockNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.CaseTypePatternBlockNode:setName(v)
	self.name = v
end

function sling.model.CaseTypePatternBlockNode:getName()
	do return self.name end
end

sling.model.GreaterOrEqualExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.GreaterOrEqualExpressionNode.__index = sling.model.GreaterOrEqualExpressionNode
_vm:set_metatable(sling.model.GreaterOrEqualExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.GreaterOrEqualExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GreaterOrEqualExpressionNode)
	return v
end

function sling.model.GreaterOrEqualExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GreaterOrEqualExpressionNode'
	self['_isType.sling.model.GreaterOrEqualExpressionNode'] = true
end

function sling.model.GreaterOrEqualExpressionNode:_construct0()
	sling.model.GreaterOrEqualExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.GreaterOrEqualExpressionNode:instance(left, right)
	local v = _g.sling.model.GreaterOrEqualExpressionNode._construct0(_g.sling.model.GreaterOrEqualExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.GreaterOrEqualExpressionNode:getNodeTypeName()
	do return "GreaterOrEqualExpressionNode" end
end

function sling.model.GreaterOrEqualExpressionNode:createNew()
	do return _g.sling.model.GreaterOrEqualExpressionNode._construct0(_g.sling.model.GreaterOrEqualExpressionNode._create()) end
end

function sling.model.GreaterOrEqualExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GreaterOrEqualExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GreaterOrEqualExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GreaterOrEqualExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GreaterOrEqualExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.KeyValueNode = _g.sling.common.NodeObject._create()
sling.model.KeyValueNode.__index = sling.model.KeyValueNode
_vm:set_metatable(sling.model.KeyValueNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.KeyValueNode._create()
	local v = _vm:set_metatable({}, sling.model.KeyValueNode)
	return v
end

function sling.model.KeyValueNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.KeyValueNode'
	self['_isType.sling.model.KeyValueNode'] = true
	self.key = nil
	self.value = nil
	self.comment = nil
end

function sling.model.KeyValueNode:_construct0()
	sling.model.KeyValueNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.KeyValueNode:forValues(key, value)
	local v = _g.sling.model.KeyValueNode._construct0(_g.sling.model.KeyValueNode._create())
	do v:setKey(key, false) end
	do v:setValue(value, false) end
	do return v end
end

function sling.model.KeyValueNode:getNodeTypeName()
	do return "KeyValueNode" end
end

function sling.model.KeyValueNode:createNew()
	do return _g.sling.model.KeyValueNode._construct0(_g.sling.model.KeyValueNode._create()) end
end

function sling.model.KeyValueNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.KeyValueNode')
		if n == nil then
			do return true end
		end
		if n.key ~= nil then
			do n.key:destroy() end
			n.key = nil
		end
		if self.key ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.key), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.key = pcp
			do n.key:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.comment = self.comment
		do return true end
	end
end

function sling.model.KeyValueNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.key then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.key:destroy() end
		end
		self.key = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.key ~= nil then
			do self.key:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.KeyValueNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.key ~= nil then
		if self.key:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.KeyValueNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.key ~= nil then
		do self.key:destroy() end
		self.key = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.KeyValueNode:setKey(v, doExport)
	if self.key ~= nil and doExport == false then
		do self.key:destroy() end
	end
	self.key = v
	if self.key ~= nil then
		do self.key:setParent(self) end
	end
end

function sling.model.KeyValueNode:getKey()
	do return self.key end
end

function sling.model.KeyValueNode:exportKey()
	local v = self.key
	self.key = nil
	do return v end
end

function sling.model.KeyValueNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.KeyValueNode:getValue()
	do return self.value end
end

function sling.model.KeyValueNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.KeyValueNode:setComment(v)
	self.comment = v
end

function sling.model.KeyValueNode:getComment()
	do return self.comment end
end

sling.model.GetSizeExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.GetSizeExpressionNode.__index = sling.model.GetSizeExpressionNode
_vm:set_metatable(sling.model.GetSizeExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.GetSizeExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetSizeExpressionNode)
	return v
end

function sling.model.GetSizeExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetSizeExpressionNode'
	self['_isType.sling.model.GetSizeExpressionNode'] = true
end

function sling.model.GetSizeExpressionNode:_construct0()
	sling.model.GetSizeExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.GetSizeExpressionNode:forExpression(expression)
	local v = _g.sling.model.GetSizeExpressionNode._construct0(_g.sling.model.GetSizeExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.GetSizeExpressionNode:getNodeTypeName()
	do return "GetSizeExpressionNode" end
end

function sling.model.GetSizeExpressionNode:createNew()
	do return _g.sling.model.GetSizeExpressionNode._construct0(_g.sling.model.GetSizeExpressionNode._create()) end
end

function sling.model.GetSizeExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetSizeExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GetSizeExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetSizeExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GetSizeExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.StringLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.StringLiteralExpressionNode.__index = sling.model.StringLiteralExpressionNode
_vm:set_metatable(sling.model.StringLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.StringLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringLiteralExpressionNode)
	return v
end

function sling.model.StringLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringLiteralExpressionNode'
	self['_isType.sling.model.StringLiteralExpressionNode'] = true
	self.value = nil
	self.type = nil
	self.isLongString = false
	self.isRawString = false
	self.identifier = nil
end

function sling.model.StringLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.StringLiteralExpressionNode._construct0(_g.sling.model.StringLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.StringLiteralExpressionNode:_construct0()
	sling.model.StringLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
	return self
end

function sling.model.StringLiteralExpressionNode:getNodeTypeName()
	do return "StringLiteralExpressionNode" end
end

function sling.model.StringLiteralExpressionNode:createNew()
	do return _g.sling.model.StringLiteralExpressionNode._construct0(_g.sling.model.StringLiteralExpressionNode._create()) end
end

function sling.model.StringLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.value = self.value
		n.isLongString = self.isLongString
		n.isRawString = self.isRawString
		n.identifier = self.identifier
		do return true end
	end
end

function sling.model.StringLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StringLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.StringLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.StringLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.StringLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.StringLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.StringLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.StringLiteralExpressionNode:setIsLongString(v)
	self.isLongString = v
end

function sling.model.StringLiteralExpressionNode:getIsLongString()
	do return self.isLongString end
end

function sling.model.StringLiteralExpressionNode:setIsRawString(v)
	self.isRawString = v
end

function sling.model.StringLiteralExpressionNode:getIsRawString()
	do return self.isRawString end
end

function sling.model.StringLiteralExpressionNode:setIdentifier(v)
	self.identifier = v
end

function sling.model.StringLiteralExpressionNode:getIdentifier()
	do return self.identifier end
end

sling.model.CustomModifierDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.CustomModifierDeclarationNode.__index = sling.model.CustomModifierDeclarationNode
_vm:set_metatable(sling.model.CustomModifierDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CustomModifierDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.CustomModifierDeclarationNode)
	return v
end

function sling.model.CustomModifierDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CustomModifierDeclarationNode'
	self['_isType.sling.model.CustomModifierDeclarationNode'] = true
	self.type = nil
end

function sling.model.CustomModifierDeclarationNode:_construct0()
	sling.model.CustomModifierDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CustomModifierDeclarationNode:getNodeTypeName()
	do return "CustomModifierDeclarationNode" end
end

function sling.model.CustomModifierDeclarationNode:createNew()
	do return _g.sling.model.CustomModifierDeclarationNode._construct0(_g.sling.model.CustomModifierDeclarationNode._create()) end
end

function sling.model.CustomModifierDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CustomModifierDeclarationNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.CustomModifierDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CustomModifierDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CustomModifierDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.CustomModifierDeclarationNode:setType(v)
	self.type = v
end

function sling.model.CustomModifierDeclarationNode:getType()
	do return self.type end
end

sling.model.InitializerFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.InitializerFunctionDeclarationNode.__index = sling.model.InitializerFunctionDeclarationNode
_vm:set_metatable(sling.model.InitializerFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.InitializerFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.InitializerFunctionDeclarationNode)
	return v
end

function sling.model.InitializerFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.InitializerFunctionDeclarationNode'
	self['_isType.sling.model.InitializerFunctionDeclarationNode'] = true
end

function sling.model.InitializerFunctionDeclarationNode:_construct0()
	sling.model.InitializerFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.InitializerFunctionDeclarationNode:getNodeTypeName()
	do return "InitializerFunctionDeclarationNode" end
end

function sling.model.InitializerFunctionDeclarationNode:createNew()
	do return _g.sling.model.InitializerFunctionDeclarationNode._construct0(_g.sling.model.InitializerFunctionDeclarationNode._create()) end
end

function sling.model.InitializerFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.InitializerFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.InitializerFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.InitializerFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.InitializerFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.LoopStatementNode = {}

sling.model.ArithmeticExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ArithmeticExpressionNode.__index = sling.model.ArithmeticExpressionNode
_vm:set_metatable(sling.model.ArithmeticExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ArithmeticExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ArithmeticExpressionNode)
	return v
end

function sling.model.ArithmeticExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ArithmeticExpressionNode'
	self['_isType.sling.model.ArithmeticExpressionNode'] = true
end

function sling.model.ArithmeticExpressionNode:_construct0()
	sling.model.ArithmeticExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ArithmeticExpressionNode:getNodeTypeName()
	do return "ArithmeticExpressionNode" end
end

function sling.model.ArithmeticExpressionNode:createNew()
	do return _g.sling.model.ArithmeticExpressionNode._construct0(_g.sling.model.ArithmeticExpressionNode._create()) end
end

function sling.model.ArithmeticExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ArithmeticExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ArithmeticExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ArithmeticExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ArithmeticExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.SubtractionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.SubtractionExpressionNode.__index = sling.model.SubtractionExpressionNode
_vm:set_metatable(sling.model.SubtractionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.SubtractionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SubtractionExpressionNode)
	return v
end

function sling.model.SubtractionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SubtractionExpressionNode'
	self['_isType.sling.model.SubtractionExpressionNode'] = true
end

function sling.model.SubtractionExpressionNode:_construct0()
	sling.model.SubtractionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.SubtractionExpressionNode:instance(left, right)
	local v = _g.sling.model.SubtractionExpressionNode._construct0(_g.sling.model.SubtractionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.SubtractionExpressionNode:getNodeTypeName()
	do return "SubtractionExpressionNode" end
end

function sling.model.SubtractionExpressionNode:createNew()
	do return _g.sling.model.SubtractionExpressionNode._construct0(_g.sling.model.SubtractionExpressionNode._create()) end
end

function sling.model.SubtractionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SubtractionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SubtractionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SubtractionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SubtractionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.ShiftRightAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ShiftRightAssignmentExpressionNode.__index = sling.model.ShiftRightAssignmentExpressionNode
_vm:set_metatable(sling.model.ShiftRightAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ShiftRightAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftRightAssignmentExpressionNode)
	return v
end

function sling.model.ShiftRightAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftRightAssignmentExpressionNode'
	self['_isType.sling.model.ShiftRightAssignmentExpressionNode'] = true
	self.zeroLeftmostBit = false
end

function sling.model.ShiftRightAssignmentExpressionNode:_construct0()
	sling.model.ShiftRightAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ShiftRightAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftRightAssignmentExpressionNode._construct0(_g.sling.model.ShiftRightAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftRightAssignmentExpressionNode:getNodeTypeName()
	do return "ShiftRightAssignmentExpressionNode" end
end

function sling.model.ShiftRightAssignmentExpressionNode:createNew()
	do return _g.sling.model.ShiftRightAssignmentExpressionNode._construct0(_g.sling.model.ShiftRightAssignmentExpressionNode._create()) end
end

function sling.model.ShiftRightAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftRightAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		n.zeroLeftmostBit = self.zeroLeftmostBit
		do return true end
	end
end

function sling.model.ShiftRightAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftRightAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftRightAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

function sling.model.ShiftRightAssignmentExpressionNode:setZeroLeftmostBit(v)
	self.zeroLeftmostBit = v
end

function sling.model.ShiftRightAssignmentExpressionNode:getZeroLeftmostBit()
	do return self.zeroLeftmostBit end
end

sling.model.DivisionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.DivisionExpressionNode.__index = sling.model.DivisionExpressionNode
_vm:set_metatable(sling.model.DivisionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.DivisionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DivisionExpressionNode)
	return v
end

function sling.model.DivisionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DivisionExpressionNode'
	self['_isType.sling.model.DivisionExpressionNode'] = true
end

function sling.model.DivisionExpressionNode:_construct0()
	sling.model.DivisionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.DivisionExpressionNode:instance(left, right)
	local v = _g.sling.model.DivisionExpressionNode._construct0(_g.sling.model.DivisionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DivisionExpressionNode:getNodeTypeName()
	do return "DivisionExpressionNode" end
end

function sling.model.DivisionExpressionNode:createNew()
	do return _g.sling.model.DivisionExpressionNode._construct0(_g.sling.model.DivisionExpressionNode._create()) end
end

function sling.model.DivisionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DivisionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DivisionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DivisionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DivisionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.CaseGreaterOrEqualBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseGreaterOrEqualBlockNode.__index = sling.model.CaseGreaterOrEqualBlockNode
_vm:set_metatable(sling.model.CaseGreaterOrEqualBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseGreaterOrEqualBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseGreaterOrEqualBlockNode)
	return v
end

function sling.model.CaseGreaterOrEqualBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseGreaterOrEqualBlockNode'
	self['_isType.sling.model.CaseGreaterOrEqualBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseGreaterOrEqualBlockNode:_construct0()
	sling.model.CaseGreaterOrEqualBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseGreaterOrEqualBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseGreaterOrEqualBlockNode._construct0(_g.sling.model.CaseGreaterOrEqualBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseGreaterOrEqualBlockNode:getNodeTypeName()
	do return "CaseGreaterOrEqualBlockNode" end
end

function sling.model.CaseGreaterOrEqualBlockNode:createNew()
	do return _g.sling.model.CaseGreaterOrEqualBlockNode._construct0(_g.sling.model.CaseGreaterOrEqualBlockNode._create()) end
end

function sling.model.CaseGreaterOrEqualBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseGreaterOrEqualBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseGreaterOrEqualBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseGreaterOrEqualBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseGreaterOrEqualBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseGreaterOrEqualBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseGreaterOrEqualBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseGreaterOrEqualBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.ThrowStatementNode = _g.sling.common.NodeObject._create()
sling.model.ThrowStatementNode.__index = sling.model.ThrowStatementNode
_vm:set_metatable(sling.model.ThrowStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ThrowStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ThrowStatementNode)
	return v
end

function sling.model.ThrowStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ThrowStatementNode'
	self['_isType.sling.model.ThrowStatementNode'] = true
	self.expression = nil
end

function sling.model.ThrowStatementNode:_construct0()
	sling.model.ThrowStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ThrowStatementNode:forExpression(expression)
	local v = _g.sling.model.ThrowStatementNode._construct0(_g.sling.model.ThrowStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.ThrowStatementNode:getNodeTypeName()
	do return "ThrowStatementNode" end
end

function sling.model.ThrowStatementNode:createNew()
	do return _g.sling.model.ThrowStatementNode._construct0(_g.sling.model.ThrowStatementNode._create()) end
end

function sling.model.ThrowStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ThrowStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ThrowStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ThrowStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ThrowStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ThrowStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ThrowStatementNode:getExpression()
	do return self.expression end
end

function sling.model.ThrowStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.VectorDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.VectorDataTypeNode.__index = sling.model.VectorDataTypeNode
_vm:set_metatable(sling.model.VectorDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.VectorDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.VectorDataTypeNode)
	return v
end

function sling.model.VectorDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VectorDataTypeNode'
	self['_isType.sling.model.VectorDataTypeNode'] = true
end

function sling.model.VectorDataTypeNode:_construct0()
	sling.model.VectorDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.VectorDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.VectorDataTypeNode._construct0(_g.sling.model.VectorDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.VectorDataTypeNode:getNodeTypeName()
	do return "VectorDataTypeNode" end
end

function sling.model.VectorDataTypeNode:createNew()
	do return _g.sling.model.VectorDataTypeNode._construct0(_g.sling.model.VectorDataTypeNode._create()) end
end

function sling.model.VectorDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VectorDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.VectorDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VectorDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.VectorDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.MultipleDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.MultipleDataTypeNode.__index = sling.model.MultipleDataTypeNode
_vm:set_metatable(sling.model.MultipleDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.MultipleDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.MultipleDataTypeNode)
	return v
end

function sling.model.MultipleDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultipleDataTypeNode'
	self['_isType.sling.model.MultipleDataTypeNode'] = true
	self.types = nil
end

function sling.model.MultipleDataTypeNode:_construct0()
	sling.model.MultipleDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.MultipleDataTypeNode:getNodeTypeName()
	do return "MultipleDataTypeNode" end
end

function sling.model.MultipleDataTypeNode:createNew()
	do return _g.sling.model.MultipleDataTypeNode._construct0(_g.sling.model.MultipleDataTypeNode._create()) end
end

function sling.model.MultipleDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultipleDataTypeNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.types
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.types = nil
			if self.types ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.types)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.types[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.types == nil then
								n.types = {}
							end
							do _g.jk.lang.Vector:append(n.types, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MultipleDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.types, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultipleDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.types, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultipleDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

function sling.model.MultipleDataTypeNode:setTypes(v, doExport)
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.types = nil
	else
		self.types = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.types, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MultipleDataTypeNode:getTypes()
	do return self.types end
end

function sling.model.MultipleDataTypeNode:exportTypes()
	local v = self.types
	self.types = nil
	do return v end
end

function sling.model.MultipleDataTypeNode:addToTypes(v)
	if v == nil then
		do return end
	end
	if self.types == nil then
		self.types = {}
	end
	do _g.jk.lang.Vector:append(self.types, v) end
	do v:setParent(self) end
end

function sling.model.MultipleDataTypeNode:clearTypes()
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

sling.model.StringConcatenationAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.StringConcatenationAssignmentExpressionNode.__index = sling.model.StringConcatenationAssignmentExpressionNode
_vm:set_metatable(sling.model.StringConcatenationAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.StringConcatenationAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringConcatenationAssignmentExpressionNode)
	return v
end

function sling.model.StringConcatenationAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringConcatenationAssignmentExpressionNode'
	self['_isType.sling.model.StringConcatenationAssignmentExpressionNode'] = true
end

function sling.model.StringConcatenationAssignmentExpressionNode:_construct0()
	sling.model.StringConcatenationAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.StringConcatenationAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.StringConcatenationAssignmentExpressionNode._construct0(_g.sling.model.StringConcatenationAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StringConcatenationAssignmentExpressionNode:getNodeTypeName()
	do return "StringConcatenationAssignmentExpressionNode" end
end

function sling.model.StringConcatenationAssignmentExpressionNode:createNew()
	do return _g.sling.model.StringConcatenationAssignmentExpressionNode._construct0(_g.sling.model.StringConcatenationAssignmentExpressionNode._create()) end
end

function sling.model.StringConcatenationAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringConcatenationAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StringConcatenationAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringConcatenationAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringConcatenationAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.PreprocessorValueExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.PreprocessorValueExpressionNode.__index = sling.model.PreprocessorValueExpressionNode
_vm:set_metatable(sling.model.PreprocessorValueExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.PreprocessorValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreprocessorValueExpressionNode)
	return v
end

function sling.model.PreprocessorValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreprocessorValueExpressionNode'
	self['_isType.sling.model.PreprocessorValueExpressionNode'] = true
	self.variable = nil
end

function sling.model.PreprocessorValueExpressionNode:_construct0()
	sling.model.PreprocessorValueExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.PreprocessorValueExpressionNode:forVariable(value)
	local v = _g.sling.model.PreprocessorValueExpressionNode._construct0(_g.sling.model.PreprocessorValueExpressionNode._create())
	do v:setVariable(value) end
	do return v end
end

function sling.model.PreprocessorValueExpressionNode:getNodeTypeName()
	do return "PreprocessorValueExpressionNode" end
end

function sling.model.PreprocessorValueExpressionNode:createNew()
	do return _g.sling.model.PreprocessorValueExpressionNode._construct0(_g.sling.model.PreprocessorValueExpressionNode._create()) end
end

function sling.model.PreprocessorValueExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreprocessorValueExpressionNode')
		if n == nil then
			do return true end
		end
		n.variable = self.variable
		do return true end
	end
end

function sling.model.PreprocessorValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreprocessorValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreprocessorValueExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

function sling.model.PreprocessorValueExpressionNode:setVariable(v)
	self.variable = v
end

function sling.model.PreprocessorValueExpressionNode:getVariable()
	do return self.variable end
end

sling.model.ModuloAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ModuloAssignmentExpressionNode.__index = sling.model.ModuloAssignmentExpressionNode
_vm:set_metatable(sling.model.ModuloAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ModuloAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ModuloAssignmentExpressionNode)
	return v
end

function sling.model.ModuloAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ModuloAssignmentExpressionNode'
	self['_isType.sling.model.ModuloAssignmentExpressionNode'] = true
end

function sling.model.ModuloAssignmentExpressionNode:_construct0()
	sling.model.ModuloAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ModuloAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ModuloAssignmentExpressionNode._construct0(_g.sling.model.ModuloAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ModuloAssignmentExpressionNode:getNodeTypeName()
	do return "ModuloAssignmentExpressionNode" end
end

function sling.model.ModuloAssignmentExpressionNode:createNew()
	do return _g.sling.model.ModuloAssignmentExpressionNode._construct0(_g.sling.model.ModuloAssignmentExpressionNode._create()) end
end

function sling.model.ModuloAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ModuloAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ModuloAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ModuloAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ModuloAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.CaseRangeBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseRangeBlockNode.__index = sling.model.CaseRangeBlockNode
_vm:set_metatable(sling.model.CaseRangeBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseRangeBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseRangeBlockNode)
	return v
end

function sling.model.CaseRangeBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseRangeBlockNode'
	self['_isType.sling.model.CaseRangeBlockNode'] = true
	self.lowerBound = nil
	self.upperBound = nil
	self.exclusionType = 0
end

function sling.model.CaseRangeBlockNode:_construct0()
	sling.model.CaseRangeBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseRangeBlockNode:instance(from, to, bb, type)
	local v = _g.sling.model.CaseRangeBlockNode._construct0(_g.sling.model.CaseRangeBlockNode._create())
	do v:setLowerBound(from, false) end
	do v:setUpperBound(to, false) end
	do v:setBlock(bb, false) end
	do v:setExclusionType(type) end
	do return v end
end

function sling.model.CaseRangeBlockNode:getNodeTypeName()
	do return "CaseRangeBlockNode" end
end

function sling.model.CaseRangeBlockNode:createNew()
	do return _g.sling.model.CaseRangeBlockNode._construct0(_g.sling.model.CaseRangeBlockNode._create()) end
end

function sling.model.CaseRangeBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseRangeBlockNode')
		if n == nil then
			do return true end
		end
		if n.lowerBound ~= nil then
			do n.lowerBound:destroy() end
			n.lowerBound = nil
		end
		if self.lowerBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.lowerBound), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.lowerBound = pcp
			do n.lowerBound:setParent(n) end
		end
		if n.upperBound ~= nil then
			do n.upperBound:destroy() end
			n.upperBound = nil
		end
		if self.upperBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.upperBound), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.upperBound = pcp
			do n.upperBound:setParent(n) end
		end
		n.exclusionType = self.exclusionType
		do return true end
	end
end

function sling.model.CaseRangeBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.lowerBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.lowerBound:destroy() end
		end
		self.lowerBound = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.lowerBound ~= nil then
			do self.lowerBound:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.upperBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.upperBound:destroy() end
		end
		self.upperBound = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.upperBound ~= nil then
			do self.upperBound:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseRangeBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.lowerBound ~= nil then
		if self.lowerBound:accept(visitor) == false then
			do return false end
		end
	end
	if self.upperBound ~= nil then
		if self.upperBound:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseRangeBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.lowerBound ~= nil then
		do self.lowerBound:destroy() end
		self.lowerBound = nil
	end
	if self.upperBound ~= nil then
		do self.upperBound:destroy() end
		self.upperBound = nil
	end
end

function sling.model.CaseRangeBlockNode:setLowerBound(v, doExport)
	if self.lowerBound ~= nil and doExport == false then
		do self.lowerBound:destroy() end
	end
	self.lowerBound = v
	if self.lowerBound ~= nil then
		do self.lowerBound:setParent(self) end
	end
end

function sling.model.CaseRangeBlockNode:getLowerBound()
	do return self.lowerBound end
end

function sling.model.CaseRangeBlockNode:exportLowerBound()
	local v = self.lowerBound
	self.lowerBound = nil
	do return v end
end

function sling.model.CaseRangeBlockNode:setUpperBound(v, doExport)
	if self.upperBound ~= nil and doExport == false then
		do self.upperBound:destroy() end
	end
	self.upperBound = v
	if self.upperBound ~= nil then
		do self.upperBound:setParent(self) end
	end
end

function sling.model.CaseRangeBlockNode:getUpperBound()
	do return self.upperBound end
end

function sling.model.CaseRangeBlockNode:exportUpperBound()
	local v = self.upperBound
	self.upperBound = nil
	do return v end
end

function sling.model.CaseRangeBlockNode:setExclusionType(v)
	self.exclusionType = v
end

function sling.model.CaseRangeBlockNode:getExclusionType()
	do return self.exclusionType end
end

sling.model.SubtractionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.SubtractionAssignmentExpressionNode.__index = sling.model.SubtractionAssignmentExpressionNode
_vm:set_metatable(sling.model.SubtractionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.SubtractionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SubtractionAssignmentExpressionNode)
	return v
end

function sling.model.SubtractionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SubtractionAssignmentExpressionNode'
	self['_isType.sling.model.SubtractionAssignmentExpressionNode'] = true
end

function sling.model.SubtractionAssignmentExpressionNode:_construct0()
	sling.model.SubtractionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.SubtractionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.SubtractionAssignmentExpressionNode._construct0(_g.sling.model.SubtractionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.SubtractionAssignmentExpressionNode:getNodeTypeName()
	do return "SubtractionAssignmentExpressionNode" end
end

function sling.model.SubtractionAssignmentExpressionNode:createNew()
	do return _g.sling.model.SubtractionAssignmentExpressionNode._construct0(_g.sling.model.SubtractionAssignmentExpressionNode._create()) end
end

function sling.model.SubtractionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SubtractionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SubtractionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SubtractionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SubtractionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.FlatBlockNode = _g.sling.common.ContainerNode._create()
sling.model.FlatBlockNode.__index = sling.model.FlatBlockNode
_vm:set_metatable(sling.model.FlatBlockNode, {
	__index = _g.sling.common.ContainerNode
})

function sling.model.FlatBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.FlatBlockNode)
	return v
end

function sling.model.FlatBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FlatBlockNode'
	self['_isType.sling.model.FlatBlockNode'] = true
end

function sling.model.FlatBlockNode:_construct0()
	sling.model.FlatBlockNode._init(self)
	do _g.sling.common.ContainerNode._construct0(self) end
	return self
end

function sling.model.FlatBlockNode:forStatement(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
		do v:addNode(node) end
		do return v end
	end
end

function sling.model.FlatBlockNode:getNodeTypeName()
	do return "FlatBlockNode" end
end

function sling.model.FlatBlockNode:createNew()
	do return _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()) end
end

function sling.model.FlatBlockNode:copyTo(o)
	if _g.sling.common.ContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FlatBlockNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FlatBlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FlatBlockNode:acceptVisitor(visitor)
	if _g.sling.common.ContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FlatBlockNode:destroy()
	do _g.sling.common.ContainerNode.destroy(self) end
end

sling.model.BaseClassAccessExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.BaseClassAccessExpressionNode.__index = sling.model.BaseClassAccessExpressionNode
_vm:set_metatable(sling.model.BaseClassAccessExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.BaseClassAccessExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BaseClassAccessExpressionNode)
	return v
end

function sling.model.BaseClassAccessExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BaseClassAccessExpressionNode'
	self['_isType.sling.model.BaseClassAccessExpressionNode'] = true
end

function sling.model.BaseClassAccessExpressionNode:_construct0()
	sling.model.BaseClassAccessExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.BaseClassAccessExpressionNode:getNodeTypeName()
	do return "BaseClassAccessExpressionNode" end
end

function sling.model.BaseClassAccessExpressionNode:createNew()
	do return _g.sling.model.BaseClassAccessExpressionNode._construct0(_g.sling.model.BaseClassAccessExpressionNode._create()) end
end

function sling.model.BaseClassAccessExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BaseClassAccessExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BaseClassAccessExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BaseClassAccessExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BaseClassAccessExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

sling.model.MultiDimensionalArrayDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.MultiDimensionalArrayDataTypeNode.__index = sling.model.MultiDimensionalArrayDataTypeNode
_vm:set_metatable(sling.model.MultiDimensionalArrayDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.MultiDimensionalArrayDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.MultiDimensionalArrayDataTypeNode)
	return v
end

function sling.model.MultiDimensionalArrayDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultiDimensionalArrayDataTypeNode'
	self['_isType.sling.model.MultiDimensionalArrayDataTypeNode'] = true
	self.dimensions = 0
end

function sling.model.MultiDimensionalArrayDataTypeNode:_construct0()
	sling.model.MultiDimensionalArrayDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.MultiDimensionalArrayDataTypeNode:forDimensions(type, dimensions)
	local v = _g.sling.model.MultiDimensionalArrayDataTypeNode._construct0(_g.sling.model.MultiDimensionalArrayDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do v:setDimensions(dimensions) end
	do return v end
end

function sling.model.MultiDimensionalArrayDataTypeNode:getNodeTypeName()
	do return "MultiDimensionalArrayDataTypeNode" end
end

function sling.model.MultiDimensionalArrayDataTypeNode:createNew()
	do return _g.sling.model.MultiDimensionalArrayDataTypeNode._construct0(_g.sling.model.MultiDimensionalArrayDataTypeNode._create()) end
end

function sling.model.MultiDimensionalArrayDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultiDimensionalArrayDataTypeNode')
		if n == nil then
			do return true end
		end
		n.dimensions = self.dimensions
		do return true end
	end
end

function sling.model.MultiDimensionalArrayDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultiDimensionalArrayDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultiDimensionalArrayDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

function sling.model.MultiDimensionalArrayDataTypeNode:setDimensions(v)
	self.dimensions = v
end

function sling.model.MultiDimensionalArrayDataTypeNode:getDimensions()
	do return self.dimensions end
end

sling.model.OptionalDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.OptionalDataTypeNode.__index = sling.model.OptionalDataTypeNode
_vm:set_metatable(sling.model.OptionalDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

sling.model.OptionalDataTypeNode.EXPLICIT_UNWRAPPING = 0
sling.model.OptionalDataTypeNode.IMPLICIT_UNWRAPPING = 1

function sling.model.OptionalDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.OptionalDataTypeNode)
	return v
end

function sling.model.OptionalDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.OptionalDataTypeNode'
	self['_isType.sling.model.OptionalDataTypeNode'] = true
	self.unwrappingMethod = 0
end

function sling.model.OptionalDataTypeNode:_construct0()
	sling.model.OptionalDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.OptionalDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.OptionalDataTypeNode._construct0(_g.sling.model.OptionalDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.OptionalDataTypeNode:getNodeTypeName()
	do return "OptionalDataTypeNode" end
end

function sling.model.OptionalDataTypeNode:createNew()
	do return _g.sling.model.OptionalDataTypeNode._construct0(_g.sling.model.OptionalDataTypeNode._create()) end
end

function sling.model.OptionalDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.OptionalDataTypeNode')
		if n == nil then
			do return true end
		end
		n.unwrappingMethod = self.unwrappingMethod
		do return true end
	end
end

function sling.model.OptionalDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.OptionalDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.OptionalDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

function sling.model.OptionalDataTypeNode:setUnwrappingMethod(v)
	self.unwrappingMethod = v
end

function sling.model.OptionalDataTypeNode:getUnwrappingMethod()
	do return self.unwrappingMethod end
end

sling.model.IfStatementNode = _g.sling.common.NodeObject._create()
sling.model.IfStatementNode.__index = sling.model.IfStatementNode
_vm:set_metatable(sling.model.IfStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.IfStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.IfStatementNode)
	return v
end

function sling.model.IfStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IfStatementNode'
	self['_isType.sling.model.IfStatementNode'] = true
	self.condition = nil
	self.ifBlock = nil
	self.elseBlock = nil
	self.elseBlockComment = nil
end

function sling.model.IfStatementNode:_construct0()
	sling.model.IfStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.IfStatementNode:instance(condition, ifBlock, elseBlock)
	local v = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setIfBlock(ifBlock, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.IfStatementNode:forStatement(condition, statement)
	if not (condition ~= nil and statement ~= nil) then
		do return nil end
	end
	do
		local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
		do block:addNode(statement) end
		do return _g.sling.model.IfStatementNode:instance(condition, block, nil) end
	end
end

function sling.model.IfStatementNode:getNodeTypeName()
	do return "IfStatementNode" end
end

function sling.model.IfStatementNode:createNew()
	do return _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create()) end
end

function sling.model.IfStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IfStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.ifBlock ~= nil then
			do n.ifBlock:destroy() end
			n.ifBlock = nil
		end
		if self.ifBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.ifBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.ifBlock = pcp
			do n.ifBlock:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		if n.elseBlockComment ~= nil then
			do n.elseBlockComment:destroy() end
			n.elseBlockComment = nil
		end
		if self.elseBlockComment ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlockComment), '_isType.sling.model.CommentNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlockComment = pcp
			do n.elseBlockComment:setParent(n) end
		end
		do return true end
	end
end

function sling.model.IfStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.ifBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.ifBlock:destroy() end
		end
		self.ifBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.ifBlock ~= nil then
			do self.ifBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlockComment then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlockComment:destroy() end
		end
		self.elseBlockComment = _vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode')
		if self.elseBlockComment ~= nil then
			do self.elseBlockComment:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IfStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.ifBlock ~= nil then
		if self.ifBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlockComment ~= nil then
		if self.elseBlockComment:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.IfStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.ifBlock ~= nil then
		do self.ifBlock:destroy() end
		self.ifBlock = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:destroy() end
		self.elseBlockComment = nil
	end
end

function sling.model.IfStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.IfStatementNode:getCondition()
	do return self.condition end
end

function sling.model.IfStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.IfStatementNode:setIfBlock(v, doExport)
	if self.ifBlock ~= nil and doExport == false then
		do self.ifBlock:destroy() end
	end
	self.ifBlock = v
	if self.ifBlock ~= nil then
		do self.ifBlock:setParent(self) end
	end
end

function sling.model.IfStatementNode:getIfBlock()
	do return self.ifBlock end
end

function sling.model.IfStatementNode:exportIfBlock()
	local v = self.ifBlock
	self.ifBlock = nil
	do return v end
end

function sling.model.IfStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.IfStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.IfStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.IfStatementNode:setElseBlockComment(v, doExport)
	if self.elseBlockComment ~= nil and doExport == false then
		do self.elseBlockComment:destroy() end
	end
	self.elseBlockComment = v
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:setParent(self) end
	end
end

function sling.model.IfStatementNode:getElseBlockComment()
	do return self.elseBlockComment end
end

function sling.model.IfStatementNode:exportElseBlockComment()
	local v = self.elseBlockComment
	self.elseBlockComment = nil
	do return v end
end

sling.model.PreIncrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PreIncrementExpressionNode.__index = sling.model.PreIncrementExpressionNode
_vm:set_metatable(sling.model.PreIncrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PreIncrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreIncrementExpressionNode)
	return v
end

function sling.model.PreIncrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreIncrementExpressionNode'
	self['_isType.sling.model.PreIncrementExpressionNode'] = true
end

function sling.model.PreIncrementExpressionNode:_construct0()
	sling.model.PreIncrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PreIncrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PreIncrementExpressionNode._construct0(_g.sling.model.PreIncrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PreIncrementExpressionNode:getNodeTypeName()
	do return "PreIncrementExpressionNode" end
end

function sling.model.PreIncrementExpressionNode:createNew()
	do return _g.sling.model.PreIncrementExpressionNode._construct0(_g.sling.model.PreIncrementExpressionNode._create()) end
end

function sling.model.PreIncrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreIncrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PreIncrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreIncrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreIncrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ReferenceDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ReferenceDataTypeNode.__index = sling.model.ReferenceDataTypeNode
_vm:set_metatable(sling.model.ReferenceDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ReferenceDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ReferenceDataTypeNode)
	return v
end

function sling.model.ReferenceDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ReferenceDataTypeNode'
	self['_isType.sling.model.ReferenceDataTypeNode'] = true
	self.magical = false
	self.symbol = nil
end

function sling.model.ReferenceDataTypeNode:_construct0()
	sling.model.ReferenceDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ReferenceDataTypeNode:forNode(node, typemap)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forBinding(node, typemap), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forName(vv)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forName(vv), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forVectorOfNames(nn)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forVectorOfNames(nn), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forArrayOfNames(nn)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	local nna = {}
	if nn ~= nil then
		local n = 0
		local m = #nn
		do
			n = 0
			while n < m do
				local s = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(nn[n + 1])
				if s ~= nil then
					do _g.jk.lang.Vector:append(nna, s) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setSymbol(_g.sling.model.SymbolNode:forVectorOfNames(nna), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forSymbol(sym)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(sym, false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:setName(name)
	do self:setSymbol(_g.sling.model.SymbolNode:forName(name), false) end
end

function sling.model.ReferenceDataTypeNode:setNames(nss)
	do self:setSymbol(_g.sling.model.SymbolNode:forVectorOfNames(nss), false) end
end

function sling.model.ReferenceDataTypeNode:getNodeTypeName()
	do return "ReferenceDataTypeNode" end
end

function sling.model.ReferenceDataTypeNode:createNew()
	do return _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create()) end
end

function sling.model.ReferenceDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ReferenceDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		n.magical = self.magical
		do return true end
	end
end

function sling.model.ReferenceDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ReferenceDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ReferenceDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.ReferenceDataTypeNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.ReferenceDataTypeNode:getSymbol()
	do return self.symbol end
end

function sling.model.ReferenceDataTypeNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

function sling.model.ReferenceDataTypeNode:setMagical(v)
	self.magical = v
end

function sling.model.ReferenceDataTypeNode:getMagical()
	do return self.magical end
end

sling.model.IntegerLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.IntegerLiteralExpressionNode.__index = sling.model.IntegerLiteralExpressionNode
_vm:set_metatable(sling.model.IntegerLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

sling.model.IntegerLiteralExpressionNode.FORMAT_DECIMAL = 0
sling.model.IntegerLiteralExpressionNode.FORMAT_HEXADECIMAL = 1
sling.model.IntegerLiteralExpressionNode.FORMAT_BINARY = 2
sling.model.IntegerLiteralExpressionNode.FORMAT_OCTAL = 3

function sling.model.IntegerLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.IntegerLiteralExpressionNode)
	return v
end

function sling.model.IntegerLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IntegerLiteralExpressionNode'
	self['_isType.sling.model.IntegerLiteralExpressionNode'] = true
	self.value = 0
	self.type = 0
	self.format = 0
end

function sling.model.IntegerLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.IntegerLiteralExpressionNode._construct0(_g.sling.model.IntegerLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.IntegerLiteralExpressionNode:_construct0()
	sling.model.IntegerLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	self.type = _g.sling.model.IntegerDataTypeNode.TYPE_INT
	do self:setDefaultDataType(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), false) end
	return self
end

function sling.model.IntegerLiteralExpressionNode:getNodeTypeName()
	do return "IntegerLiteralExpressionNode" end
end

function sling.model.IntegerLiteralExpressionNode:createNew()
	do return _g.sling.model.IntegerLiteralExpressionNode._construct0(_g.sling.model.IntegerLiteralExpressionNode._create()) end
end

function sling.model.IntegerLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IntegerLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		n.type = self.type
		n.format = self.format
		do return true end
	end
end

function sling.model.IntegerLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IntegerLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.IntegerLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.IntegerLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.IntegerLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.IntegerLiteralExpressionNode:setType(v)
	self.type = v
end

function sling.model.IntegerLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.IntegerLiteralExpressionNode:setFormat(v)
	self.format = v
end

function sling.model.IntegerLiteralExpressionNode:getFormat()
	do return self.format end
end

sling.model.CaseEqualsBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseEqualsBlockNode.__index = sling.model.CaseEqualsBlockNode
_vm:set_metatable(sling.model.CaseEqualsBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseEqualsBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseEqualsBlockNode)
	return v
end

function sling.model.CaseEqualsBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseEqualsBlockNode'
	self['_isType.sling.model.CaseEqualsBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseEqualsBlockNode:_construct0()
	sling.model.CaseEqualsBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseEqualsBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseEqualsBlockNode._construct0(_g.sling.model.CaseEqualsBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseEqualsBlockNode:getNodeTypeName()
	do return "CaseEqualsBlockNode" end
end

function sling.model.CaseEqualsBlockNode:createNew()
	do return _g.sling.model.CaseEqualsBlockNode._construct0(_g.sling.model.CaseEqualsBlockNode._create()) end
end

function sling.model.CaseEqualsBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseEqualsBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseEqualsBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseEqualsBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseEqualsBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseEqualsBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseEqualsBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseEqualsBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.DependencyDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.DependencyDeclarationNode.__index = sling.model.DependencyDeclarationNode
_vm:set_metatable(sling.model.DependencyDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.DependencyDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.DependencyDeclarationNode)
	return v
end

function sling.model.DependencyDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DependencyDeclarationNode'
	self['_isType.sling.model.DependencyDeclarationNode'] = true
	self.value = nil
end

function sling.model.DependencyDeclarationNode:_construct0()
	sling.model.DependencyDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.DependencyDeclarationNode:getNodeTypeName()
	do return "DependencyDeclarationNode" end
end

function sling.model.DependencyDeclarationNode:createNew()
	do return _g.sling.model.DependencyDeclarationNode._construct0(_g.sling.model.DependencyDeclarationNode._create()) end
end

function sling.model.DependencyDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DependencyDeclarationNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.DependencyDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DependencyDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DependencyDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.DependencyDeclarationNode:setValue(v)
	self.value = v
end

function sling.model.DependencyDeclarationNode:getValue()
	do return self.value end
end

sling.model.DynamicCastExpressionNode = _g.sling.model.TypeCastExpressionNode._create()
sling.model.DynamicCastExpressionNode.__index = sling.model.DynamicCastExpressionNode
_vm:set_metatable(sling.model.DynamicCastExpressionNode, {
	__index = _g.sling.model.TypeCastExpressionNode
})

function sling.model.DynamicCastExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicCastExpressionNode)
	return v
end

function sling.model.DynamicCastExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicCastExpressionNode'
	self['_isType.sling.model.DynamicCastExpressionNode'] = true
end

function sling.model.DynamicCastExpressionNode:_construct0()
	sling.model.DynamicCastExpressionNode._init(self)
	do _g.sling.model.TypeCastExpressionNode._construct0(self) end
	return self
end

function sling.model.DynamicCastExpressionNode:instance(type, expression)
	local v = _g.sling.model.DynamicCastExpressionNode._construct0(_g.sling.model.DynamicCastExpressionNode._create())
	do v:setType(type, false) end
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.DynamicCastExpressionNode:getNodeTypeName()
	do return "DynamicCastExpressionNode" end
end

function sling.model.DynamicCastExpressionNode:createNew()
	do return _g.sling.model.DynamicCastExpressionNode._construct0(_g.sling.model.DynamicCastExpressionNode._create()) end
end

function sling.model.DynamicCastExpressionNode:copyTo(o)
	if _g.sling.model.TypeCastExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicCastExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicCastExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.TypeCastExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicCastExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.TypeCastExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicCastExpressionNode:destroy()
	do _g.sling.model.TypeCastExpressionNode.destroy(self) end
end

sling.model.BitwiseAndExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.BitwiseAndExpressionNode.__index = sling.model.BitwiseAndExpressionNode
_vm:set_metatable(sling.model.BitwiseAndExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.BitwiseAndExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseAndExpressionNode)
	return v
end

function sling.model.BitwiseAndExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseAndExpressionNode'
	self['_isType.sling.model.BitwiseAndExpressionNode'] = true
end

function sling.model.BitwiseAndExpressionNode:_construct0()
	sling.model.BitwiseAndExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseAndExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseAndExpressionNode._construct0(_g.sling.model.BitwiseAndExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseAndExpressionNode:getNodeTypeName()
	do return "BitwiseAndExpressionNode" end
end

function sling.model.BitwiseAndExpressionNode:createNew()
	do return _g.sling.model.BitwiseAndExpressionNode._construct0(_g.sling.model.BitwiseAndExpressionNode._create()) end
end

function sling.model.BitwiseAndExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseAndExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseAndExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseAndExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseAndExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.AdditionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.AdditionAssignmentExpressionNode.__index = sling.model.AdditionAssignmentExpressionNode
_vm:set_metatable(sling.model.AdditionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.AdditionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AdditionAssignmentExpressionNode)
	return v
end

function sling.model.AdditionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AdditionAssignmentExpressionNode'
	self['_isType.sling.model.AdditionAssignmentExpressionNode'] = true
end

function sling.model.AdditionAssignmentExpressionNode:_construct0()
	sling.model.AdditionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.AdditionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.AdditionAssignmentExpressionNode._construct0(_g.sling.model.AdditionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.AdditionAssignmentExpressionNode:getNodeTypeName()
	do return "AdditionAssignmentExpressionNode" end
end

function sling.model.AdditionAssignmentExpressionNode:createNew()
	do return _g.sling.model.AdditionAssignmentExpressionNode._construct0(_g.sling.model.AdditionAssignmentExpressionNode._create()) end
end

function sling.model.AdditionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AdditionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AdditionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AdditionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AdditionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.CommonModifierDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.CommonModifierDeclarationNode.__index = sling.model.CommonModifierDeclarationNode
_vm:set_metatable(sling.model.CommonModifierDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CommonModifierDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.CommonModifierDeclarationNode)
	return v
end

function sling.model.CommonModifierDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CommonModifierDeclarationNode'
	self['_isType.sling.model.CommonModifierDeclarationNode'] = true
	self.type = nil
end

function sling.model.CommonModifierDeclarationNode:_construct0()
	sling.model.CommonModifierDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CommonModifierDeclarationNode:getNodeTypeName()
	do return "CommonModifierDeclarationNode" end
end

function sling.model.CommonModifierDeclarationNode:createNew()
	do return _g.sling.model.CommonModifierDeclarationNode._construct0(_g.sling.model.CommonModifierDeclarationNode._create()) end
end

function sling.model.CommonModifierDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CommonModifierDeclarationNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.CommonModifierDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CommonModifierDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CommonModifierDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.CommonModifierDeclarationNode:setType(v)
	self.type = v
end

function sling.model.CommonModifierDeclarationNode:getType()
	do return self.type end
end

sling.model.EmbedBlockNode = _g.sling.common.ExpressionNode._create()
sling.model.EmbedBlockNode.__index = sling.model.EmbedBlockNode
_vm:set_metatable(sling.model.EmbedBlockNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.EmbedBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.EmbedBlockNode)
	return v
end

function sling.model.EmbedBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EmbedBlockNode'
	self['_isType.sling.model.EmbedBlockNode'] = true
	self.type = nil
	self.code = nil
end

function sling.model.EmbedBlockNode:_construct0()
	sling.model.EmbedBlockNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.EmbedBlockNode:instance(type, code)
	local v = _g.sling.model.EmbedBlockNode._construct0(_g.sling.model.EmbedBlockNode._create())
	do v:setType(type) end
	do v:setCode(code) end
	do return v end
end

function sling.model.EmbedBlockNode:getNodeTypeName()
	do return "EmbedBlockNode" end
end

function sling.model.EmbedBlockNode:createNew()
	do return _g.sling.model.EmbedBlockNode._construct0(_g.sling.model.EmbedBlockNode._create()) end
end

function sling.model.EmbedBlockNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EmbedBlockNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		n.code = self.code
		do return true end
	end
end

function sling.model.EmbedBlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EmbedBlockNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EmbedBlockNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

function sling.model.EmbedBlockNode:setType(v)
	self.type = v
end

function sling.model.EmbedBlockNode:getType()
	do return self.type end
end

function sling.model.EmbedBlockNode:setCode(v)
	self.code = v
end

function sling.model.EmbedBlockNode:getCode()
	do return self.code end
end

sling.model.ThisDataTypeNode = _g.sling.model.ReferenceDataTypeNode._create()
sling.model.ThisDataTypeNode.__index = sling.model.ThisDataTypeNode
_vm:set_metatable(sling.model.ThisDataTypeNode, {
	__index = _g.sling.model.ReferenceDataTypeNode
})

function sling.model.ThisDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ThisDataTypeNode)
	return v
end

function sling.model.ThisDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ThisDataTypeNode'
	self['_isType.sling.model.ThisDataTypeNode'] = true
end

function sling.model.ThisDataTypeNode:_construct0()
	sling.model.ThisDataTypeNode._init(self)
	do _g.sling.model.ReferenceDataTypeNode._construct0(self) end
	return self
end

function sling.model.ThisDataTypeNode:getNodeTypeName()
	do return "ThisDataTypeNode" end
end

function sling.model.ThisDataTypeNode:createNew()
	do return _g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()) end
end

function sling.model.ThisDataTypeNode:copyTo(o)
	if _g.sling.model.ReferenceDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ThisDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ThisDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ReferenceDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ThisDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.ReferenceDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ThisDataTypeNode:destroy()
	do _g.sling.model.ReferenceDataTypeNode.destroy(self) end
end

sling.model.LessThanExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.LessThanExpressionNode.__index = sling.model.LessThanExpressionNode
_vm:set_metatable(sling.model.LessThanExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.LessThanExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LessThanExpressionNode)
	return v
end

function sling.model.LessThanExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LessThanExpressionNode'
	self['_isType.sling.model.LessThanExpressionNode'] = true
end

function sling.model.LessThanExpressionNode:_construct0()
	sling.model.LessThanExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.LessThanExpressionNode:instance(left, right)
	local v = _g.sling.model.LessThanExpressionNode._construct0(_g.sling.model.LessThanExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LessThanExpressionNode:getNodeTypeName()
	do return "LessThanExpressionNode" end
end

function sling.model.LessThanExpressionNode:createNew()
	do return _g.sling.model.LessThanExpressionNode._construct0(_g.sling.model.LessThanExpressionNode._create()) end
end

function sling.model.LessThanExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LessThanExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LessThanExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LessThanExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LessThanExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.PostDecrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PostDecrementExpressionNode.__index = sling.model.PostDecrementExpressionNode
_vm:set_metatable(sling.model.PostDecrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PostDecrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PostDecrementExpressionNode)
	return v
end

function sling.model.PostDecrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PostDecrementExpressionNode'
	self['_isType.sling.model.PostDecrementExpressionNode'] = true
end

function sling.model.PostDecrementExpressionNode:_construct0()
	sling.model.PostDecrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PostDecrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PostDecrementExpressionNode._construct0(_g.sling.model.PostDecrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PostDecrementExpressionNode:getNodeTypeName()
	do return "PostDecrementExpressionNode" end
end

function sling.model.PostDecrementExpressionNode:createNew()
	do return _g.sling.model.PostDecrementExpressionNode._construct0(_g.sling.model.PostDecrementExpressionNode._create()) end
end

function sling.model.PostDecrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PostDecrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PostDecrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PostDecrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PostDecrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ResourceFileNode = _g.sling.common.NodeObject._create()
sling.model.ResourceFileNode.__index = sling.model.ResourceFileNode
_vm:set_metatable(sling.model.ResourceFileNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ResourceFileNode._create()
	local v = _vm:set_metatable({}, sling.model.ResourceFileNode)
	return v
end

function sling.model.ResourceFileNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ResourceFileNode'
	self['_isType.sling.model.ResourceFileNode'] = true
	self.file = nil
	self.buffer = nil
	self.fileName = nil
	self.condition = nil
end

function sling.model.ResourceFileNode:_construct0()
	sling.model.ResourceFileNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ResourceFileNode:forFile(file)
	local v = _g.sling.model.ResourceFileNode._construct0(_g.sling.model.ResourceFileNode._create())
	do v:setFile(file) end
	do v:setSource(_g.sling.common.StaticSourceReference:forFile(file)) end
	do return v end
end

function sling.model.ResourceFileNode:getName()
	if self.fileName ~= nil then
		do return self.fileName end
	end
	if not (self.file ~= nil) then
		do return nil end
	end
	do return self.file:baseName() end
end

function sling.model.ResourceFileNode:getNameWithoutExtension()
	if self.fileName ~= nil then
		local dot = _g.jk.lang.String:getLastIndexOfCharacter(self.fileName, 46, -1)
		if dot < 1 then
			do return self.fileName end
		end
		do return _g.jk.lang.String:getSubString(self.fileName, 0, dot) end
	end
	if not (self.file ~= nil) then
		do return nil end
	end
	do return self.file:baseNameWithoutExtension() end
end

function sling.model.ResourceFileNode:getPath()
	if not (self.file ~= nil) then
		do return nil end
	end
	do return self.file:getPath() end
end

function sling.model.ResourceFileNode:getNodeTypeName()
	do return "ResourceFileNode" end
end

function sling.model.ResourceFileNode:createNew()
	do return _g.sling.model.ResourceFileNode._construct0(_g.sling.model.ResourceFileNode._create()) end
end

function sling.model.ResourceFileNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ResourceFileNode')
		if n == nil then
			do return true end
		end
		n.file = self.file
		n.buffer = self.buffer
		n.fileName = self.fileName
		n.condition = self.condition
		do return true end
	end
end

function sling.model.ResourceFileNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ResourceFileNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ResourceFileNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ResourceFileNode:setFile(v)
	self.file = v
end

function sling.model.ResourceFileNode:getFile()
	do return self.file end
end

function sling.model.ResourceFileNode:setBuffer(v)
	self.buffer = v
end

function sling.model.ResourceFileNode:getBuffer()
	do return self.buffer end
end

function sling.model.ResourceFileNode:setFileName(v)
	self.fileName = v
end

function sling.model.ResourceFileNode:getFileName()
	do return self.fileName end
end

function sling.model.ResourceFileNode:setCondition(v)
	self.condition = v
end

function sling.model.ResourceFileNode:getCondition()
	do return self.condition end
end

sling.model.AdditionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.AdditionExpressionNode.__index = sling.model.AdditionExpressionNode
_vm:set_metatable(sling.model.AdditionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.AdditionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AdditionExpressionNode)
	return v
end

function sling.model.AdditionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AdditionExpressionNode'
	self['_isType.sling.model.AdditionExpressionNode'] = true
end

function sling.model.AdditionExpressionNode:_construct0()
	sling.model.AdditionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.AdditionExpressionNode:instance(left, right)
	local v = _g.sling.model.AdditionExpressionNode._construct0(_g.sling.model.AdditionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.AdditionExpressionNode:getNodeTypeName()
	do return "AdditionExpressionNode" end
end

function sling.model.AdditionExpressionNode:createNew()
	do return _g.sling.model.AdditionExpressionNode._construct0(_g.sling.model.AdditionExpressionNode._create()) end
end

function sling.model.AdditionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AdditionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AdditionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AdditionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AdditionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.BitwiseNotExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.BitwiseNotExpressionNode.__index = sling.model.BitwiseNotExpressionNode
_vm:set_metatable(sling.model.BitwiseNotExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.BitwiseNotExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseNotExpressionNode)
	return v
end

function sling.model.BitwiseNotExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseNotExpressionNode'
	self['_isType.sling.model.BitwiseNotExpressionNode'] = true
end

function sling.model.BitwiseNotExpressionNode:_construct0()
	sling.model.BitwiseNotExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseNotExpressionNode:forExpression(expression)
	local v = _g.sling.model.BitwiseNotExpressionNode._construct0(_g.sling.model.BitwiseNotExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.BitwiseNotExpressionNode:getNodeTypeName()
	do return "BitwiseNotExpressionNode" end
end

function sling.model.BitwiseNotExpressionNode:createNew()
	do return _g.sling.model.BitwiseNotExpressionNode._construct0(_g.sling.model.BitwiseNotExpressionNode._create()) end
end

function sling.model.BitwiseNotExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseNotExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseNotExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseNotExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseNotExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.MapLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.MapLiteralExpressionNode.__index = sling.model.MapLiteralExpressionNode
_vm:set_metatable(sling.model.MapLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.MapLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MapLiteralExpressionNode)
	return v
end

function sling.model.MapLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MapLiteralExpressionNode'
	self['_isType.sling.model.MapLiteralExpressionNode'] = true
	self.values = nil
end

function sling.model.MapLiteralExpressionNode:_construct0()
	sling.model.MapLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	return self
end

function sling.model.MapLiteralExpressionNode:forObjects()
	local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
	local ddt = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do ddt:setKeyType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
	do ddt:setValueType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
	do v:setDefaultDataType(ddt, false) end
	do return v end
end

function sling.model.MapLiteralExpressionNode:forDynamics()
	local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
	local ddt = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do ddt:setKeyType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	do ddt:setValueType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	do v:setDefaultDataType(ddt, false) end
	do return v end
end

function sling.model.MapLiteralExpressionNode:getNodeTypeName()
	do return "MapLiteralExpressionNode" end
end

function sling.model.MapLiteralExpressionNode:createNew()
	do return _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create()) end
end

function sling.model.MapLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MapLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.values
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.values = nil
			if self.values ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.values)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.values[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.values == nil then
								n.values = {}
							end
							do _g.jk.lang.Vector:append(n.values, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MapLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.values, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MapLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.values, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MapLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

function sling.model.MapLiteralExpressionNode:setValues(v, doExport)
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.values = nil
	else
		self.values = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.values, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MapLiteralExpressionNode:getValues()
	do return self.values end
end

function sling.model.MapLiteralExpressionNode:exportValues()
	local v = self.values
	self.values = nil
	do return v end
end

function sling.model.MapLiteralExpressionNode:addToValues(v)
	if v == nil then
		do return end
	end
	if self.values == nil then
		self.values = {}
	end
	do _g.jk.lang.Vector:append(self.values, v) end
	do v:setParent(self) end
end

function sling.model.MapLiteralExpressionNode:clearValues()
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

sling.model.TypeCheckExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.TypeCheckExpressionNode.__index = sling.model.TypeCheckExpressionNode
_vm:set_metatable(sling.model.TypeCheckExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.TypeCheckExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeCheckExpressionNode)
	return v
end

function sling.model.TypeCheckExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeCheckExpressionNode'
	self['_isType.sling.model.TypeCheckExpressionNode'] = true
	self.type = nil
	self.expression = nil
	self.negate = false
end

function sling.model.TypeCheckExpressionNode:_construct0()
	sling.model.TypeCheckExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TypeCheckExpressionNode:instance(type, expression, negate)
	local v = _g.sling.model.TypeCheckExpressionNode._construct0(_g.sling.model.TypeCheckExpressionNode._create())
	do v:setType(type, false) end
	do v:setExpression(expression, false) end
	do v:setNegate(negate) end
	do return v end
end

function sling.model.TypeCheckExpressionNode:getNodeTypeName()
	do return "TypeCheckExpressionNode" end
end

function sling.model.TypeCheckExpressionNode:createNew()
	do return _g.sling.model.TypeCheckExpressionNode._construct0(_g.sling.model.TypeCheckExpressionNode._create()) end
end

function sling.model.TypeCheckExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeCheckExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.negate = self.negate
		do return true end
	end
end

function sling.model.TypeCheckExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeCheckExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TypeCheckExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.TypeCheckExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.TypeCheckExpressionNode:getType()
	do return self.type end
end

function sling.model.TypeCheckExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.TypeCheckExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.TypeCheckExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.TypeCheckExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.TypeCheckExpressionNode:setNegate(v)
	self.negate = v
end

function sling.model.TypeCheckExpressionNode:getNegate()
	do return self.negate end
end

sling.model.BufferLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.BufferLiteralExpressionNode.__index = sling.model.BufferLiteralExpressionNode
_vm:set_metatable(sling.model.BufferLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.BufferLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BufferLiteralExpressionNode)
	return v
end

function sling.model.BufferLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BufferLiteralExpressionNode'
	self['_isType.sling.model.BufferLiteralExpressionNode'] = true
	self.value = nil
	self.type = nil
end

function sling.model.BufferLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.BufferLiteralExpressionNode._construct0(_g.sling.model.BufferLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.BufferLiteralExpressionNode:_construct0()
	sling.model.BufferLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()), false) end
	return self
end

function sling.model.BufferLiteralExpressionNode:getNodeTypeName()
	do return "BufferLiteralExpressionNode" end
end

function sling.model.BufferLiteralExpressionNode:createNew()
	do return _g.sling.model.BufferLiteralExpressionNode._construct0(_g.sling.model.BufferLiteralExpressionNode._create()) end
end

function sling.model.BufferLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BufferLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.BufferLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BufferLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.BufferLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.BufferLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.BufferLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.BufferLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.BufferLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.BufferLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.LessOrEqualExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.LessOrEqualExpressionNode.__index = sling.model.LessOrEqualExpressionNode
_vm:set_metatable(sling.model.LessOrEqualExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.LessOrEqualExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LessOrEqualExpressionNode)
	return v
end

function sling.model.LessOrEqualExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LessOrEqualExpressionNode'
	self['_isType.sling.model.LessOrEqualExpressionNode'] = true
end

function sling.model.LessOrEqualExpressionNode:_construct0()
	sling.model.LessOrEqualExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.LessOrEqualExpressionNode:instance(left, right)
	local v = _g.sling.model.LessOrEqualExpressionNode._construct0(_g.sling.model.LessOrEqualExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LessOrEqualExpressionNode:getNodeTypeName()
	do return "LessOrEqualExpressionNode" end
end

function sling.model.LessOrEqualExpressionNode:createNew()
	do return _g.sling.model.LessOrEqualExpressionNode._construct0(_g.sling.model.LessOrEqualExpressionNode._create()) end
end

function sling.model.LessOrEqualExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LessOrEqualExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LessOrEqualExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LessOrEqualExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LessOrEqualExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.NegativeNumberExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.NegativeNumberExpressionNode.__index = sling.model.NegativeNumberExpressionNode
_vm:set_metatable(sling.model.NegativeNumberExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.NegativeNumberExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NegativeNumberExpressionNode)
	return v
end

function sling.model.NegativeNumberExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NegativeNumberExpressionNode'
	self['_isType.sling.model.NegativeNumberExpressionNode'] = true
end

function sling.model.NegativeNumberExpressionNode:_construct0()
	sling.model.NegativeNumberExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.NegativeNumberExpressionNode:forExpression(expression)
	local v = _g.sling.model.NegativeNumberExpressionNode._construct0(_g.sling.model.NegativeNumberExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.NegativeNumberExpressionNode:getNodeTypeName()
	do return "NegativeNumberExpressionNode" end
end

function sling.model.NegativeNumberExpressionNode:createNew()
	do return _g.sling.model.NegativeNumberExpressionNode._construct0(_g.sling.model.NegativeNumberExpressionNode._create()) end
end

function sling.model.NegativeNumberExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NegativeNumberExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NegativeNumberExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NegativeNumberExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NegativeNumberExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.LabeledStatementNode = _g.sling.common.NodeObject._create()
sling.model.LabeledStatementNode.__index = sling.model.LabeledStatementNode
_vm:set_metatable(sling.model.LabeledStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.LabeledStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.LabeledStatementNode)
	return v
end

function sling.model.LabeledStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LabeledStatementNode'
	self['_isType.sling.model.LabeledStatementNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.statement = nil
	self.name = nil
end

function sling.model.LabeledStatementNode:_construct0()
	sling.model.LabeledStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.LabeledStatementNode:forLabel(label)
	local v = _g.sling.model.LabeledStatementNode._construct0(_g.sling.model.LabeledStatementNode._create())
	do v:setName(label) end
	do return v end
end

function sling.model.LabeledStatementNode:getNodeName()
	do return self.name end
end

function sling.model.LabeledStatementNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.LabeledStatementNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.LabeledStatementNode:getNodeTypeName()
	do return "LabeledStatementNode" end
end

function sling.model.LabeledStatementNode:createNew()
	do return _g.sling.model.LabeledStatementNode._construct0(_g.sling.model.LabeledStatementNode._create()) end
end

function sling.model.LabeledStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LabeledStatementNode')
		if n == nil then
			do return true end
		end
		if n.statement ~= nil then
			do n.statement:destroy() end
			n.statement = nil
		end
		if self.statement ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.statement), '_isType.sling.common.NodeObject')
			if pcp == nil then
				do return false end
			end
			n.statement = pcp
			do n.statement:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.LabeledStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.statement then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.statement:destroy() end
		end
		self.statement = _vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject')
		if self.statement ~= nil then
			do self.statement:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LabeledStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.statement ~= nil then
		if self.statement:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.LabeledStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.statement ~= nil then
		do self.statement:destroy() end
		self.statement = nil
	end
end

function sling.model.LabeledStatementNode:setStatement(v, doExport)
	if self.statement ~= nil and doExport == false then
		do self.statement:destroy() end
	end
	self.statement = v
	if self.statement ~= nil then
		do self.statement:setParent(self) end
	end
end

function sling.model.LabeledStatementNode:getStatement()
	do return self.statement end
end

function sling.model.LabeledStatementNode:exportStatement()
	local v = self.statement
	self.statement = nil
	do return v end
end

function sling.model.LabeledStatementNode:getName()
	do return self.name end
end

sling.model.UIExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.UIExpressionNode.__index = sling.model.UIExpressionNode
_vm:set_metatable(sling.model.UIExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.UIExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.UIExpressionNode)
	return v
end

function sling.model.UIExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.UIExpressionNode'
	self['_isType.sling.model.UIExpressionNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
	self.expression = nil
	self.layoutParams = nil
	self.children = nil
end

function sling.model.UIExpressionNode:_construct0()
	sling.model.UIExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.UIExpressionNode:getNodeName()
	do return self.name end
end

function sling.model.UIExpressionNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.UIExpressionNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.UIExpressionNode:getNodeTypeName()
	do return "UIExpressionNode" end
end

function sling.model.UIExpressionNode:createNew()
	do return _g.sling.model.UIExpressionNode._construct0(_g.sling.model.UIExpressionNode._create()) end
end

function sling.model.UIExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.UIExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.name = self.name
		do
			local array = n.layoutParams
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.layoutParams = nil
			if self.layoutParams ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.layoutParams)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.layoutParams[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.layoutParams == nil then
								n.layoutParams = {}
							end
							do _g.jk.lang.Vector:append(n.layoutParams, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.children
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.children = nil
				if self.children ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.children)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.children[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.children == nil then
									n.children = {}
								end
								do _g.jk.lang.Vector:append(n.children, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.UIExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.layoutParams, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.children, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.UIExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.layoutParams, visitor) == false then
		do return false end
	end
	if self:visitVector(self.children, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.UIExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.layoutParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.layoutParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.layoutParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.layoutParams = nil
	if self.children ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.children)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.children[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.children = nil
end

function sling.model.UIExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.UIExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.UIExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.UIExpressionNode:getName()
	do return self.name end
end

function sling.model.UIExpressionNode:setLayoutParams(v, doExport)
	if self.layoutParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.layoutParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.layoutParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.layoutParams = nil
	else
		self.layoutParams = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.layoutParams, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.UIExpressionNode:getLayoutParams()
	do return self.layoutParams end
end

function sling.model.UIExpressionNode:exportLayoutParams()
	local v = self.layoutParams
	self.layoutParams = nil
	do return v end
end

function sling.model.UIExpressionNode:addToLayoutParams(v)
	if v == nil then
		do return end
	end
	if self.layoutParams == nil then
		self.layoutParams = {}
	end
	do _g.jk.lang.Vector:append(self.layoutParams, v) end
	do v:setParent(self) end
end

function sling.model.UIExpressionNode:clearLayoutParams()
	if self.layoutParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.layoutParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.layoutParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.layoutParams = nil
end

function sling.model.UIExpressionNode:setChildren(v, doExport)
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.children = nil
	else
		self.children = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.children, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.UIExpressionNode:getChildren()
	do return self.children end
end

function sling.model.UIExpressionNode:exportChildren()
	local v = self.children
	self.children = nil
	do return v end
end

function sling.model.UIExpressionNode:addToChildren(v)
	if v == nil then
		do return end
	end
	if self.children == nil then
		self.children = {}
	end
	do _g.jk.lang.Vector:append(self.children, v) end
	do v:setParent(self) end
end

function sling.model.UIExpressionNode:clearChildren()
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.children = nil
end

sling.model.WhileStatementNode = _g.sling.common.NodeObject._create()
sling.model.WhileStatementNode.__index = sling.model.WhileStatementNode
_vm:set_metatable(sling.model.WhileStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.WhileStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.WhileStatementNode)
	return v
end

function sling.model.WhileStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.WhileStatementNode'
	self['_isType.sling.model.WhileStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.condition = nil
	self.block = nil
	self.elseBlock = nil
end

function sling.model.WhileStatementNode:_construct0()
	sling.model.WhileStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.WhileStatementNode:instance(condition, block, elseBlock)
	local v = _g.sling.model.WhileStatementNode._construct0(_g.sling.model.WhileStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setBlock(block, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.WhileStatementNode:forSingleStatement(condition, statement)
	local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	do v:addNode(statement) end
	do return _g.sling.model.WhileStatementNode:instance(condition, v, nil) end
end

function sling.model.WhileStatementNode:getNodeTypeName()
	do return "WhileStatementNode" end
end

function sling.model.WhileStatementNode:createNew()
	do return _g.sling.model.WhileStatementNode._construct0(_g.sling.model.WhileStatementNode._create()) end
end

function sling.model.WhileStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.WhileStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		do return true end
	end
end

function sling.model.WhileStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.WhileStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.WhileStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
end

function sling.model.WhileStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.WhileStatementNode:getCondition()
	do return self.condition end
end

function sling.model.WhileStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.WhileStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.WhileStatementNode:getBlock()
	do return self.block end
end

function sling.model.WhileStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.WhileStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.WhileStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.WhileStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

sling.model.GreaterThanExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.GreaterThanExpressionNode.__index = sling.model.GreaterThanExpressionNode
_vm:set_metatable(sling.model.GreaterThanExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.GreaterThanExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GreaterThanExpressionNode)
	return v
end

function sling.model.GreaterThanExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GreaterThanExpressionNode'
	self['_isType.sling.model.GreaterThanExpressionNode'] = true
end

function sling.model.GreaterThanExpressionNode:_construct0()
	sling.model.GreaterThanExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.GreaterThanExpressionNode:instance(left, right)
	local v = _g.sling.model.GreaterThanExpressionNode._construct0(_g.sling.model.GreaterThanExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.GreaterThanExpressionNode:getNodeTypeName()
	do return "GreaterThanExpressionNode" end
end

function sling.model.GreaterThanExpressionNode:createNew()
	do return _g.sling.model.GreaterThanExpressionNode._construct0(_g.sling.model.GreaterThanExpressionNode._create()) end
end

function sling.model.GreaterThanExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GreaterThanExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GreaterThanExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GreaterThanExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GreaterThanExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.RangeDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.RangeDataTypeNode.__index = sling.model.RangeDataTypeNode
_vm:set_metatable(sling.model.RangeDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.RangeDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.RangeDataTypeNode)
	return v
end

function sling.model.RangeDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.RangeDataTypeNode'
	self['_isType.sling.model.RangeDataTypeNode'] = true
end

function sling.model.RangeDataTypeNode:_construct0()
	sling.model.RangeDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.RangeDataTypeNode:getNodeTypeName()
	do return "RangeDataTypeNode" end
end

function sling.model.RangeDataTypeNode:createNew()
	do return _g.sling.model.RangeDataTypeNode._construct0(_g.sling.model.RangeDataTypeNode._create()) end
end

function sling.model.RangeDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.RangeDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.RangeDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.RangeDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.RangeDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.VariableArgumentsDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.VariableArgumentsDeclarationNode.__index = sling.model.VariableArgumentsDeclarationNode
_vm:set_metatable(sling.model.VariableArgumentsDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.VariableArgumentsDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableArgumentsDeclarationNode)
	return v
end

function sling.model.VariableArgumentsDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableArgumentsDeclarationNode'
	self['_isType.sling.model.VariableArgumentsDeclarationNode'] = true
	self.variableDeclaration = nil
end

function sling.model.VariableArgumentsDeclarationNode:_construct0()
	sling.model.VariableArgumentsDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.VariableArgumentsDeclarationNode:forDeclaration(decl)
	local v = _g.sling.model.VariableArgumentsDeclarationNode._construct0(_g.sling.model.VariableArgumentsDeclarationNode._create())
	do v:setVariableDeclaration(decl, false) end
	do return v end
end

function sling.model.VariableArgumentsDeclarationNode:getType()
	if not (self.variableDeclaration ~= nil) then
		do return nil end
	end
	do return self.variableDeclaration:getType() end
end

function sling.model.VariableArgumentsDeclarationNode:getNodeTypeName()
	do return "VariableArgumentsDeclarationNode" end
end

function sling.model.VariableArgumentsDeclarationNode:createNew()
	do return _g.sling.model.VariableArgumentsDeclarationNode._construct0(_g.sling.model.VariableArgumentsDeclarationNode._create()) end
end

function sling.model.VariableArgumentsDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableArgumentsDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.variableDeclaration ~= nil then
			do n.variableDeclaration:destroy() end
			n.variableDeclaration = nil
		end
		if self.variableDeclaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.variableDeclaration), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.variableDeclaration = pcp
			do n.variableDeclaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.VariableArgumentsDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.variableDeclaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.variableDeclaration:destroy() end
		end
		self.variableDeclaration = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.variableDeclaration ~= nil then
			do self.variableDeclaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableArgumentsDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.variableDeclaration ~= nil then
		if self.variableDeclaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.VariableArgumentsDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.variableDeclaration ~= nil then
		do self.variableDeclaration:destroy() end
		self.variableDeclaration = nil
	end
end

function sling.model.VariableArgumentsDeclarationNode:setVariableDeclaration(v, doExport)
	if self.variableDeclaration ~= nil and doExport == false then
		do self.variableDeclaration:destroy() end
	end
	self.variableDeclaration = v
	if self.variableDeclaration ~= nil then
		do self.variableDeclaration:setParent(self) end
	end
end

function sling.model.VariableArgumentsDeclarationNode:getVariableDeclaration()
	do return self.variableDeclaration end
end

function sling.model.VariableArgumentsDeclarationNode:exportVariableDeclaration()
	local v = self.variableDeclaration
	self.variableDeclaration = nil
	do return v end
end

sling.model.ClassDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.ClassDeclarationNode.__index = sling.model.ClassDeclarationNode
_vm:set_metatable(sling.model.ClassDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.ClassDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ClassDeclarationNode)
	return v
end

function sling.model.ClassDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ClassDeclarationNode'
	self['_isType.sling.model.ClassDeclarationNode'] = true
end

function sling.model.ClassDeclarationNode:_construct0()
	sling.model.ClassDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.ClassDeclarationNode:forName(name)
	local v = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.ClassDeclarationNode:getNodeTypeName()
	do return "ClassDeclarationNode" end
end

function sling.model.ClassDeclarationNode:createNew()
	do return _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create()) end
end

function sling.model.ClassDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ClassDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ClassDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ClassDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ClassDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
end

sling.model.GetValueExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.GetValueExpressionNode.__index = sling.model.GetValueExpressionNode
_vm:set_metatable(sling.model.GetValueExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.GetValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetValueExpressionNode)
	return v
end

function sling.model.GetValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetValueExpressionNode'
	self['_isType.sling.model.GetValueExpressionNode'] = true
	self.expression = nil
end

function sling.model.GetValueExpressionNode:_construct0()
	sling.model.GetValueExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.GetValueExpressionNode:getNodeTypeName()
	do return "GetValueExpressionNode" end
end

function sling.model.GetValueExpressionNode:createNew()
	do return _g.sling.model.GetValueExpressionNode._construct0(_g.sling.model.GetValueExpressionNode._create()) end
end

function sling.model.GetValueExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetValueExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetValueExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.GetValueExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.GetValueExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.GetValueExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.InterfaceDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.InterfaceDeclarationNode.__index = sling.model.InterfaceDeclarationNode
_vm:set_metatable(sling.model.InterfaceDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.InterfaceDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.InterfaceDeclarationNode)
	return v
end

function sling.model.InterfaceDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.InterfaceDeclarationNode'
	self['_isType.sling.model.InterfaceDeclarationNode'] = true
end

function sling.model.InterfaceDeclarationNode:_construct0()
	sling.model.InterfaceDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.InterfaceDeclarationNode:forName(name)
	local v = _g.sling.model.InterfaceDeclarationNode._construct0(_g.sling.model.InterfaceDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.InterfaceDeclarationNode:getNodeTypeName()
	do return "InterfaceDeclarationNode" end
end

function sling.model.InterfaceDeclarationNode:createNew()
	do return _g.sling.model.InterfaceDeclarationNode._construct0(_g.sling.model.InterfaceDeclarationNode._create()) end
end

function sling.model.InterfaceDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.InterfaceDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.InterfaceDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.InterfaceDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.InterfaceDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
end

sling.model.LogicalExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.LogicalExpressionNode.__index = sling.model.LogicalExpressionNode
_vm:set_metatable(sling.model.LogicalExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.LogicalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalExpressionNode)
	return v
end

function sling.model.LogicalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalExpressionNode'
	self['_isType.sling.model.LogicalExpressionNode'] = true
end

function sling.model.LogicalExpressionNode:_construct0()
	sling.model.LogicalExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalExpressionNode:getNodeTypeName()
	do return "LogicalExpressionNode" end
end

function sling.model.LogicalExpressionNode:createNew()
	do return _g.sling.model.LogicalExpressionNode._construct0(_g.sling.model.LogicalExpressionNode._create()) end
end

function sling.model.LogicalExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.BitwiseAndAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.BitwiseAndAssignmentExpressionNode.__index = sling.model.BitwiseAndAssignmentExpressionNode
_vm:set_metatable(sling.model.BitwiseAndAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.BitwiseAndAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseAndAssignmentExpressionNode)
	return v
end

function sling.model.BitwiseAndAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseAndAssignmentExpressionNode'
	self['_isType.sling.model.BitwiseAndAssignmentExpressionNode'] = true
end

function sling.model.BitwiseAndAssignmentExpressionNode:_construct0()
	sling.model.BitwiseAndAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.BitwiseAndAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseAndAssignmentExpressionNode._construct0(_g.sling.model.BitwiseAndAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseAndAssignmentExpressionNode:getNodeTypeName()
	do return "BitwiseAndAssignmentExpressionNode" end
end

function sling.model.BitwiseAndAssignmentExpressionNode:createNew()
	do return _g.sling.model.BitwiseAndAssignmentExpressionNode._construct0(_g.sling.model.BitwiseAndAssignmentExpressionNode._create()) end
end

function sling.model.BitwiseAndAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseAndAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseAndAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseAndAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseAndAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.ModuloExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.ModuloExpressionNode.__index = sling.model.ModuloExpressionNode
_vm:set_metatable(sling.model.ModuloExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.ModuloExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ModuloExpressionNode)
	return v
end

function sling.model.ModuloExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ModuloExpressionNode'
	self['_isType.sling.model.ModuloExpressionNode'] = true
end

function sling.model.ModuloExpressionNode:_construct0()
	sling.model.ModuloExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.ModuloExpressionNode:instance(left, right)
	local v = _g.sling.model.ModuloExpressionNode._construct0(_g.sling.model.ModuloExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ModuloExpressionNode:getNodeTypeName()
	do return "ModuloExpressionNode" end
end

function sling.model.ModuloExpressionNode:createNew()
	do return _g.sling.model.ModuloExpressionNode._construct0(_g.sling.model.ModuloExpressionNode._create()) end
end

function sling.model.ModuloExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ModuloExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ModuloExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ModuloExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ModuloExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.TryCatchStatementNode = _g.sling.common.NodeObject._create()
sling.model.TryCatchStatementNode.__index = sling.model.TryCatchStatementNode
_vm:set_metatable(sling.model.TryCatchStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TryCatchStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.TryCatchStatementNode)
	return v
end

function sling.model.TryCatchStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TryCatchStatementNode'
	self['_isType.sling.model.TryCatchStatementNode'] = true
	self.initializer = nil
	self.tryBlock = nil
	self.catchBlocks = nil
	self.finallyBlock = nil
	self.elseBlock = nil
end

function sling.model.TryCatchStatementNode:_construct0()
	sling.model.TryCatchStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TryCatchStatementNode:forTryBlock(tryBlock)
	local v = _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create())
	do v:setTryBlock(tryBlock, false) end
	do return v end
end

function sling.model.TryCatchStatementNode:addToInitializer(node)
	if node ~= nil then
		if self.initializer == nil then
			do self:setInitializer(_g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()), false) end
		end
		do self.initializer:addNode(node) end
	end
	do return self end
end

function sling.model.TryCatchStatementNode:getNodeTypeName()
	do return "TryCatchStatementNode" end
end

function sling.model.TryCatchStatementNode:createNew()
	do return _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create()) end
end

function sling.model.TryCatchStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TryCatchStatementNode')
		if n == nil then
			do return true end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		if n.tryBlock ~= nil then
			do n.tryBlock:destroy() end
			n.tryBlock = nil
		end
		if self.tryBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.tryBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.tryBlock = pcp
			do n.tryBlock:setParent(n) end
		end
		if n.finallyBlock ~= nil then
			do n.finallyBlock:destroy() end
			n.finallyBlock = nil
		end
		if self.finallyBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.finallyBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.finallyBlock = pcp
			do n.finallyBlock:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		do
			local array = n.catchBlocks
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.catchBlocks = nil
			if self.catchBlocks ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.catchBlocks)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.catchBlocks[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.catchBlocks == nil then
								n.catchBlocks = {}
							end
							do _g.jk.lang.Vector:append(n.catchBlocks, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.TryCatchStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.tryBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.tryBlock:destroy() end
		end
		self.tryBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.tryBlock ~= nil then
			do self.tryBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.finallyBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.finallyBlock:destroy() end
		end
		self.finallyBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.finallyBlock ~= nil then
			do self.finallyBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.catchBlocks, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TryCatchStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	if self.tryBlock ~= nil then
		if self.tryBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.finallyBlock ~= nil then
		if self.finallyBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.catchBlocks, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TryCatchStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
	if self.tryBlock ~= nil then
		do self.tryBlock:destroy() end
		self.tryBlock = nil
	end
	if self.finallyBlock ~= nil then
		do self.finallyBlock:destroy() end
		self.finallyBlock = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.catchBlocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.catchBlocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.catchBlocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.catchBlocks = nil
end

function sling.model.TryCatchStatementNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getInitializer()
	do return self.initializer end
end

function sling.model.TryCatchStatementNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setTryBlock(v, doExport)
	if self.tryBlock ~= nil and doExport == false then
		do self.tryBlock:destroy() end
	end
	self.tryBlock = v
	if self.tryBlock ~= nil then
		do self.tryBlock:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getTryBlock()
	do return self.tryBlock end
end

function sling.model.TryCatchStatementNode:exportTryBlock()
	local v = self.tryBlock
	self.tryBlock = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setFinallyBlock(v, doExport)
	if self.finallyBlock ~= nil and doExport == false then
		do self.finallyBlock:destroy() end
	end
	self.finallyBlock = v
	if self.finallyBlock ~= nil then
		do self.finallyBlock:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getFinallyBlock()
	do return self.finallyBlock end
end

function sling.model.TryCatchStatementNode:exportFinallyBlock()
	local v = self.finallyBlock
	self.finallyBlock = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.TryCatchStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setCatchBlocks(v, doExport)
	if self.catchBlocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.catchBlocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.catchBlocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.catchBlocks = nil
	else
		self.catchBlocks = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.catchBlocks, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TryCatchStatementNode:getCatchBlocks()
	do return self.catchBlocks end
end

function sling.model.TryCatchStatementNode:exportCatchBlocks()
	local v = self.catchBlocks
	self.catchBlocks = nil
	do return v end
end

function sling.model.TryCatchStatementNode:addToCatchBlocks(v)
	if v == nil then
		do return end
	end
	if self.catchBlocks == nil then
		self.catchBlocks = {}
	end
	do _g.jk.lang.Vector:append(self.catchBlocks, v) end
	do v:setParent(self) end
end

function sling.model.TryCatchStatementNode:clearCatchBlocks()
	if self.catchBlocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.catchBlocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.catchBlocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.catchBlocks = nil
end

sling.model.UnknownDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.UnknownDataTypeNode.__index = sling.model.UnknownDataTypeNode
_vm:set_metatable(sling.model.UnknownDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.UnknownDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.UnknownDataTypeNode)
	return v
end

function sling.model.UnknownDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.UnknownDataTypeNode'
	self['_isType.sling.model.UnknownDataTypeNode'] = true
end

function sling.model.UnknownDataTypeNode:_construct0()
	sling.model.UnknownDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.UnknownDataTypeNode:getNodeTypeName()
	do return "UnknownDataTypeNode" end
end

function sling.model.UnknownDataTypeNode:createNew()
	do return _g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create()) end
end

function sling.model.UnknownDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.UnknownDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.UnknownDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.UnknownDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.UnknownDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.EqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.EqualsExpressionNode.__index = sling.model.EqualsExpressionNode
_vm:set_metatable(sling.model.EqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.EqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.EqualsExpressionNode)
	return v
end

function sling.model.EqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EqualsExpressionNode'
	self['_isType.sling.model.EqualsExpressionNode'] = true
end

function sling.model.EqualsExpressionNode:_construct0()
	sling.model.EqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.EqualsExpressionNode:forNull(expr)
	do return _g.sling.model.EqualsExpressionNode:instance(expr, _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())) end
end

function sling.model.EqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.EqualsExpressionNode._construct0(_g.sling.model.EqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.EqualsExpressionNode:getNodeTypeName()
	do return "EqualsExpressionNode" end
end

function sling.model.EqualsExpressionNode:createNew()
	do return _g.sling.model.EqualsExpressionNode._construct0(_g.sling.model.EqualsExpressionNode._create()) end
end

function sling.model.EqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.GetDatatypeTypeinfoExpressionNode = _g.sling.model.GetTypeinfoExpressionNode._create()
sling.model.GetDatatypeTypeinfoExpressionNode.__index = sling.model.GetDatatypeTypeinfoExpressionNode
_vm:set_metatable(sling.model.GetDatatypeTypeinfoExpressionNode, {
	__index = _g.sling.model.GetTypeinfoExpressionNode
})

function sling.model.GetDatatypeTypeinfoExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetDatatypeTypeinfoExpressionNode)
	return v
end

function sling.model.GetDatatypeTypeinfoExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetDatatypeTypeinfoExpressionNode'
	self['_isType.sling.model.GetDatatypeTypeinfoExpressionNode'] = true
	self.type = nil
end

function sling.model.GetDatatypeTypeinfoExpressionNode:forDatatype(type)
	local v = _g.sling.model.GetDatatypeTypeinfoExpressionNode._construct0(_g.sling.model.GetDatatypeTypeinfoExpressionNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:_construct0()
	sling.model.GetDatatypeTypeinfoExpressionNode._init(self)
	do _g.sling.model.GetTypeinfoExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create()), false) end
	return self
end

function sling.model.GetDatatypeTypeinfoExpressionNode:getNodeTypeName()
	do return "GetDatatypeTypeinfoExpressionNode" end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:createNew()
	do return _g.sling.model.GetDatatypeTypeinfoExpressionNode._construct0(_g.sling.model.GetDatatypeTypeinfoExpressionNode._create()) end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:copyTo(o)
	if _g.sling.model.GetTypeinfoExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetDatatypeTypeinfoExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.GetTypeinfoExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.GetTypeinfoExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:destroy()
	do _g.sling.model.GetTypeinfoExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:getType()
	do return self.type end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.DateTimeDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.DateTimeDataTypeNode.__index = sling.model.DateTimeDataTypeNode
_vm:set_metatable(sling.model.DateTimeDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DateTimeDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DateTimeDataTypeNode)
	return v
end

function sling.model.DateTimeDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DateTimeDataTypeNode'
	self['_isType.sling.model.DateTimeDataTypeNode'] = true
end

function sling.model.DateTimeDataTypeNode:_construct0()
	sling.model.DateTimeDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DateTimeDataTypeNode:getNodeTypeName()
	do return "DateTimeDataTypeNode" end
end

function sling.model.DateTimeDataTypeNode:createNew()
	do return _g.sling.model.DateTimeDataTypeNode._construct0(_g.sling.model.DateTimeDataTypeNode._create()) end
end

function sling.model.DateTimeDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DateTimeDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DateTimeDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DateTimeDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DateTimeDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.BooleanLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.BooleanLiteralExpressionNode.__index = sling.model.BooleanLiteralExpressionNode
_vm:set_metatable(sling.model.BooleanLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.BooleanLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BooleanLiteralExpressionNode)
	return v
end

function sling.model.BooleanLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BooleanLiteralExpressionNode'
	self['_isType.sling.model.BooleanLiteralExpressionNode'] = true
	self.value = false
end

function sling.model.BooleanLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.BooleanLiteralExpressionNode._construct0(_g.sling.model.BooleanLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.BooleanLiteralExpressionNode:_construct0()
	sling.model.BooleanLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
	return self
end

function sling.model.BooleanLiteralExpressionNode:getNodeTypeName()
	do return "BooleanLiteralExpressionNode" end
end

function sling.model.BooleanLiteralExpressionNode:createNew()
	do return _g.sling.model.BooleanLiteralExpressionNode._construct0(_g.sling.model.BooleanLiteralExpressionNode._create()) end
end

function sling.model.BooleanLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BooleanLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.BooleanLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BooleanLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BooleanLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.BooleanLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.BooleanLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.BlockNode = _g.sling.common.ContainerNode._create()
sling.model.BlockNode.__index = sling.model.BlockNode
_vm:set_metatable(sling.model.BlockNode, {
	__index = _g.sling.common.ContainerNode
})

function sling.model.BlockNode._create()
	local v = _vm:set_metatable({}, sling.model.BlockNode)
	return v
end

function sling.model.BlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BlockNode'
	self['_isType.sling.model.BlockNode'] = true
end

function sling.model.BlockNode:_construct0()
	sling.model.BlockNode._init(self)
	do _g.sling.common.ContainerNode._construct0(self) end
	return self
end

function sling.model.BlockNode:forStatement(statement)
	local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	if statement ~= nil then
		do v:addNode(statement) end
	end
	do return v end
end

function sling.model.BlockNode:getNodeTypeName()
	do return "BlockNode" end
end

function sling.model.BlockNode:createNew()
	do return _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()) end
end

function sling.model.BlockNode:copyTo(o)
	if _g.sling.common.ContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BlockNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BlockNode:acceptVisitor(visitor)
	if _g.sling.common.ContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BlockNode:destroy()
	do _g.sling.common.ContainerNode.destroy(self) end
end

sling.model.NamespaceNode = _g.sling.common.ContainerNode._create()
sling.model.NamespaceNode.__index = sling.model.NamespaceNode
_vm:set_metatable(sling.model.NamespaceNode, {
	__index = _g.sling.common.ContainerNode
})

function sling.model.NamespaceNode._create()
	local v = _vm:set_metatable({}, sling.model.NamespaceNode)
	return v
end

function sling.model.NamespaceNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NamespaceNode'
	self['_isType.sling.model.NamespaceNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
end

function sling.model.NamespaceNode:_construct0()
	sling.model.NamespaceNode._init(self)
	do _g.sling.common.ContainerNode._construct0(self) end
	return self
end

function sling.model.NamespaceNode:forName(name)
	local v = _g.sling.model.NamespaceNode._construct0(_g.sling.model.NamespaceNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.NamespaceNode:getNodeName()
	do return self.name end
end

function sling.model.NamespaceNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.NamespaceNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.NamespaceNode:getNodeTypeName()
	do return "NamespaceNode" end
end

function sling.model.NamespaceNode:createNew()
	do return _g.sling.model.NamespaceNode._construct0(_g.sling.model.NamespaceNode._create()) end
end

function sling.model.NamespaceNode:copyTo(o)
	if _g.sling.common.ContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NamespaceNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.NamespaceNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NamespaceNode:acceptVisitor(visitor)
	if _g.sling.common.ContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NamespaceNode:destroy()
	do _g.sling.common.ContainerNode.destroy(self) end
end

function sling.model.NamespaceNode:getName()
	do return self.name end
end

sling.model.Modifier = {}
sling.model.Modifier.__index = sling.model.Modifier
_vm:set_metatable(sling.model.Modifier, {})

sling.model.Modifier.PUBLIC = "public"
sling.model.Modifier.PRIVATE = "private"
sling.model.Modifier.PROTECTED = "protected"
sling.model.Modifier.NAMESPACEPRIVATE = "namespaceprivate"
sling.model.Modifier.STATIC = "static"
sling.model.Modifier.ABSTRACT = "abstract"
sling.model.Modifier.EXTERNAL = "external"
sling.model.Modifier.IMPLEMENT = "implement"
sling.model.Modifier.OVERRIDE = "override"
sling.model.Modifier.VIRTUAL = "virtual"
sling.model.Modifier.FUNDAMENTAL = "fundamental"
sling.model.Modifier.PARTIAL = "partial"
sling.model.Modifier.CONSTANT = "constant"
sling.model.Modifier.NEW = "new"
sling.model.Modifier.STUB = "stub"
sling.model.Modifier.WEAK = "weak"
sling.model.Modifier.EVENT = "event"
sling.model.Modifier.FINAL = "final"
sling.model.Modifier.GLOBAL = "global"
sling.model.Modifier.HEADER = "header"
sling.model.Modifier.PROPERTY = "property"
sling.model.Modifier.READONLY = "readonly"
sling.model.Modifier.WRITEONLY = "writeonly"
sling.model.Modifier.READWRITE = "readwrite"
sling.model.Modifier.VOLATILE = "volatile"
sling.model.Modifier.THROWABLE = "throwable"
sling.model.Modifier.TRANSIENT = "transient"
sling.model.Modifier.DEPRECATED = "deprecated"
sling.model.Modifier.ASYNCHRONOUS = "asynchronous"
sling.model.Modifier.SYNCHRONIZED = "synchronized"
sling.model.Modifier.IMPLEMENTATION = "implementation"
sling.model.Modifier.REFERENCE = "reference"

function sling.model.Modifier._create()
	local v = _vm:set_metatable({}, sling.model.Modifier)
	return v
end

function sling.model.Modifier:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.Modifier'
	self['_isType.sling.model.Modifier'] = true
end

function sling.model.Modifier:_construct0()
	sling.model.Modifier._init(self)
	return self
end

function sling.model.Modifier:isVisibilityModifier(mod)
	if not (mod ~= nil) then
		do return false end
	end
	if mod == _g.sling.model.Modifier.PUBLIC then
		do return true end
	end
	if mod == _g.sling.model.Modifier.PRIVATE then
		do return true end
	end
	if mod == _g.sling.model.Modifier.NAMESPACEPRIVATE then
		do return true end
	end
	if mod == _g.sling.model.Modifier.PROTECTED then
		do return true end
	end
	do return false end
end

sling.model.ParentDataTypeNode = _g.sling.model.ReferenceDataTypeNode._create()
sling.model.ParentDataTypeNode.__index = sling.model.ParentDataTypeNode
_vm:set_metatable(sling.model.ParentDataTypeNode, {
	__index = _g.sling.model.ReferenceDataTypeNode
})

function sling.model.ParentDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ParentDataTypeNode)
	return v
end

function sling.model.ParentDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ParentDataTypeNode'
	self['_isType.sling.model.ParentDataTypeNode'] = true
end

function sling.model.ParentDataTypeNode:_construct0()
	sling.model.ParentDataTypeNode._init(self)
	do _g.sling.model.ReferenceDataTypeNode._construct0(self) end
	return self
end

function sling.model.ParentDataTypeNode:getNodeTypeName()
	do return "ParentDataTypeNode" end
end

function sling.model.ParentDataTypeNode:createNew()
	do return _g.sling.model.ParentDataTypeNode._construct0(_g.sling.model.ParentDataTypeNode._create()) end
end

function sling.model.ParentDataTypeNode:copyTo(o)
	if _g.sling.model.ReferenceDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ParentDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ParentDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ReferenceDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ParentDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.ReferenceDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ParentDataTypeNode:destroy()
	do _g.sling.model.ReferenceDataTypeNode.destroy(self) end
end

sling.model.PromiseExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PromiseExpressionNode.__index = sling.model.PromiseExpressionNode
_vm:set_metatable(sling.model.PromiseExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PromiseExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PromiseExpressionNode)
	return v
end

function sling.model.PromiseExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PromiseExpressionNode'
	self['_isType.sling.model.PromiseExpressionNode'] = true
end

function sling.model.PromiseExpressionNode:_construct0()
	sling.model.PromiseExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PromiseExpressionNode:forExpression(expression)
	local v = _g.sling.model.PromiseExpressionNode._construct0(_g.sling.model.PromiseExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PromiseExpressionNode:getNodeTypeName()
	do return "PromiseExpressionNode" end
end

function sling.model.PromiseExpressionNode:createNew()
	do return _g.sling.model.PromiseExpressionNode._construct0(_g.sling.model.PromiseExpressionNode._create()) end
end

function sling.model.PromiseExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PromiseExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PromiseExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PromiseExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PromiseExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.EmptyStatementNode = _g.sling.common.NodeObject._create()
sling.model.EmptyStatementNode.__index = sling.model.EmptyStatementNode
_vm:set_metatable(sling.model.EmptyStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.EmptyStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.EmptyStatementNode)
	return v
end

function sling.model.EmptyStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EmptyStatementNode'
	self['_isType.sling.model.EmptyStatementNode'] = true
	self.comment = nil
end

function sling.model.EmptyStatementNode:_construct0()
	sling.model.EmptyStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.EmptyStatementNode:getNodeTypeName()
	do return "EmptyStatementNode" end
end

function sling.model.EmptyStatementNode:createNew()
	do return _g.sling.model.EmptyStatementNode._construct0(_g.sling.model.EmptyStatementNode._create()) end
end

function sling.model.EmptyStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EmptyStatementNode')
		if n == nil then
			do return true end
		end
		n.comment = self.comment
		do return true end
	end
end

function sling.model.EmptyStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EmptyStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EmptyStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.EmptyStatementNode:setComment(v)
	self.comment = v
end

function sling.model.EmptyStatementNode:getComment()
	do return self.comment end
end

sling.model.CaseLessOrEqualBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseLessOrEqualBlockNode.__index = sling.model.CaseLessOrEqualBlockNode
_vm:set_metatable(sling.model.CaseLessOrEqualBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseLessOrEqualBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseLessOrEqualBlockNode)
	return v
end

function sling.model.CaseLessOrEqualBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseLessOrEqualBlockNode'
	self['_isType.sling.model.CaseLessOrEqualBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseLessOrEqualBlockNode:_construct0()
	sling.model.CaseLessOrEqualBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseLessOrEqualBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseLessOrEqualBlockNode._construct0(_g.sling.model.CaseLessOrEqualBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseLessOrEqualBlockNode:getNodeTypeName()
	do return "CaseLessOrEqualBlockNode" end
end

function sling.model.CaseLessOrEqualBlockNode:createNew()
	do return _g.sling.model.CaseLessOrEqualBlockNode._construct0(_g.sling.model.CaseLessOrEqualBlockNode._create()) end
end

function sling.model.CaseLessOrEqualBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseLessOrEqualBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseLessOrEqualBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseLessOrEqualBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseLessOrEqualBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseLessOrEqualBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseLessOrEqualBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseLessOrEqualBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.SymbolExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.SymbolExpressionNode.__index = sling.model.SymbolExpressionNode
_vm:set_metatable(sling.model.SymbolExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.SymbolExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SymbolExpressionNode)
	return v
end

function sling.model.SymbolExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SymbolExpressionNode'
	self['_isType.sling.model.SymbolExpressionNode'] = true
	self.symbol = nil
end

function sling.model.SymbolExpressionNode:_construct0()
	sling.model.SymbolExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.SymbolExpressionNode:forSymbol(symbol)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	do v:setSymbol(symbol, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forBinding(binding, typemap)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forBinding(binding, typemap), false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forNameWithTypeParameters(name, typeParameters)
	if typeParameters == nil then
		do return _g.sling.model.SymbolExpressionNode:forName(name) end
	end
	do
		local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
		local nn = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
		local cc = _g.sling.model.SymbolNameComponentNode:forName(name)
		do cc:setTypeParameters(typeParameters, false) end
		do nn:addToComponents(cc) end
		do v:setSymbol(nn, false) end
		do return v end
	end
end

function sling.model.SymbolExpressionNode:forName(name)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nn = _g.sling.model.SymbolNode:forName(name)
	do v:setSymbol(nn, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forBoundName(name, binding, typemap)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nn = _g.sling.model.SymbolNode:forName(name)
	do nn:setBinding(binding, typemap) end
	do v:setSymbol(nn, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forArrayOfNames(names)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nna = {}
	if names ~= nil then
		local n = 0
		local m = #names
		do
			n = 0
			while n < m do
				local s = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(names[n + 1])
				if s ~= nil then
					do _g.jk.lang.Vector:append(nna, s) end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local nn = _g.sling.model.SymbolNode:forVectorOfNames(nna)
		do v:setSymbol(nn, false) end
		do return v end
	end
end

function sling.model.SymbolExpressionNode:forVectorOfNames(names)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nn = _g.sling.model.SymbolNode:forVectorOfNames(names)
	do v:setSymbol(nn, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:getNodeTypeName()
	do return "SymbolExpressionNode" end
end

function sling.model.SymbolExpressionNode:createNew()
	do return _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create()) end
end

function sling.model.SymbolExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SymbolExpressionNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.SymbolExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SymbolExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.SymbolExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.SymbolExpressionNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.SymbolExpressionNode:getSymbol()
	do return self.symbol end
end

function sling.model.SymbolExpressionNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.MultiplicationExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.MultiplicationExpressionNode.__index = sling.model.MultiplicationExpressionNode
_vm:set_metatable(sling.model.MultiplicationExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.MultiplicationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MultiplicationExpressionNode)
	return v
end

function sling.model.MultiplicationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultiplicationExpressionNode'
	self['_isType.sling.model.MultiplicationExpressionNode'] = true
end

function sling.model.MultiplicationExpressionNode:_construct0()
	sling.model.MultiplicationExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.MultiplicationExpressionNode:instance(left, right)
	local v = _g.sling.model.MultiplicationExpressionNode._construct0(_g.sling.model.MultiplicationExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.MultiplicationExpressionNode:getNodeTypeName()
	do return "MultiplicationExpressionNode" end
end

function sling.model.MultiplicationExpressionNode:createNew()
	do return _g.sling.model.MultiplicationExpressionNode._construct0(_g.sling.model.MultiplicationExpressionNode._create()) end
end

function sling.model.MultiplicationExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultiplicationExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MultiplicationExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultiplicationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultiplicationExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.FloorDivisionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.FloorDivisionAssignmentExpressionNode.__index = sling.model.FloorDivisionAssignmentExpressionNode
_vm:set_metatable(sling.model.FloorDivisionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.FloorDivisionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FloorDivisionAssignmentExpressionNode)
	return v
end

function sling.model.FloorDivisionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloorDivisionAssignmentExpressionNode'
	self['_isType.sling.model.FloorDivisionAssignmentExpressionNode'] = true
end

function sling.model.FloorDivisionAssignmentExpressionNode:_construct0()
	sling.model.FloorDivisionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.FloorDivisionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.FloorDivisionAssignmentExpressionNode._construct0(_g.sling.model.FloorDivisionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.FloorDivisionAssignmentExpressionNode:getNodeTypeName()
	do return "FloorDivisionAssignmentExpressionNode" end
end

function sling.model.FloorDivisionAssignmentExpressionNode:createNew()
	do return _g.sling.model.FloorDivisionAssignmentExpressionNode._construct0(_g.sling.model.FloorDivisionAssignmentExpressionNode._create()) end
end

function sling.model.FloorDivisionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloorDivisionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FloorDivisionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloorDivisionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloorDivisionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.FunctionDeclarationExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.FunctionDeclarationExpressionNode.__index = sling.model.FunctionDeclarationExpressionNode
_vm:set_metatable(sling.model.FunctionDeclarationExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.FunctionDeclarationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDeclarationExpressionNode)
	return v
end

function sling.model.FunctionDeclarationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDeclarationExpressionNode'
	self['_isType.sling.model.FunctionDeclarationExpressionNode'] = true
	self.declaration = nil
	self.type = nil
	self.references = nil
end

function sling.model.FunctionDeclarationExpressionNode:_construct0()
	sling.model.FunctionDeclarationExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.FunctionDeclarationExpressionNode:forDeclaration(decl)
	local v = _g.sling.model.FunctionDeclarationExpressionNode._construct0(_g.sling.model.FunctionDeclarationExpressionNode._create())
	do v:setDeclaration(decl, false) end
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:getNodeTypeName()
	do return "FunctionDeclarationExpressionNode" end
end

function sling.model.FunctionDeclarationExpressionNode:createNew()
	do return _g.sling.model.FunctionDeclarationExpressionNode._construct0(_g.sling.model.FunctionDeclarationExpressionNode._create()) end
end

function sling.model.FunctionDeclarationExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDeclarationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do
			local array = n.references
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.references = nil
			if self.references ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.references)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.references[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.references == nil then
								n.references = {}
							end
							do _g.jk.lang.Vector:append(n.references, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.FunctionDeclarationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.references, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDeclarationExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.references, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FunctionDeclarationExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.references ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.references)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.references[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.references = nil
end

function sling.model.FunctionDeclarationExpressionNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.FunctionDeclarationExpressionNode:getDeclaration()
	do return self.declaration end
end

function sling.model.FunctionDeclarationExpressionNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.FunctionDeclarationExpressionNode:getType()
	do return self.type end
end

function sling.model.FunctionDeclarationExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:setReferences(v, doExport)
	if self.references ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.references)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.references[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.references = nil
	else
		self.references = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.references, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationExpressionNode:getReferences()
	do return self.references end
end

function sling.model.FunctionDeclarationExpressionNode:exportReferences()
	local v = self.references
	self.references = nil
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:addToReferences(v)
	if v == nil then
		do return end
	end
	if self.references == nil then
		self.references = {}
	end
	do _g.jk.lang.Vector:append(self.references, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationExpressionNode:clearReferences()
	if self.references ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.references)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.references[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.references = nil
end

sling.model.AutomaticDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.AutomaticDataTypeNode.__index = sling.model.AutomaticDataTypeNode
_vm:set_metatable(sling.model.AutomaticDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.AutomaticDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.AutomaticDataTypeNode)
	return v
end

function sling.model.AutomaticDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AutomaticDataTypeNode'
	self['_isType.sling.model.AutomaticDataTypeNode'] = true
end

function sling.model.AutomaticDataTypeNode:_construct0()
	sling.model.AutomaticDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.AutomaticDataTypeNode:getNodeTypeName()
	do return "AutomaticDataTypeNode" end
end

function sling.model.AutomaticDataTypeNode:createNew()
	do return _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()) end
end

function sling.model.AutomaticDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AutomaticDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AutomaticDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AutomaticDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AutomaticDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.CreateObjectExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.CreateObjectExpressionNode.__index = sling.model.CreateObjectExpressionNode
_vm:set_metatable(sling.model.CreateObjectExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.CreateObjectExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.CreateObjectExpressionNode)
	return v
end

function sling.model.CreateObjectExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CreateObjectExpressionNode'
	self['_isType.sling.model.CreateObjectExpressionNode'] = true
	self.parameters = nil
	self.type = nil
	self.typeExpression = nil
	self.initializers = nil
end

function sling.model.CreateObjectExpressionNode:_construct0()
	sling.model.CreateObjectExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.CreateObjectExpressionNode:forType(type)
	local v = _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.CreateObjectExpressionNode:forReferenceTypeName(type)
	local v = _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create())
	do v:setType(_g.sling.model.ReferenceDataTypeNode:forName(type), false) end
	do return v end
end

function sling.model.CreateObjectExpressionNode:getNodeTypeName()
	do return "CreateObjectExpressionNode" end
end

function sling.model.CreateObjectExpressionNode:createNew()
	do return _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create()) end
end

function sling.model.CreateObjectExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CreateObjectExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.typeExpression ~= nil then
			do n.typeExpression:destroy() end
			n.typeExpression = nil
		end
		if self.typeExpression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.typeExpression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.typeExpression = pcp
			do n.typeExpression:setParent(n) end
		end
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.initializers
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.initializers = nil
				if self.initializers ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.initializers)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.initializers[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.initializers == nil then
									n.initializers = {}
								end
								do _g.jk.lang.Vector:append(n.initializers, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.CreateObjectExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.typeExpression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.typeExpression:destroy() end
		end
		self.typeExpression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.typeExpression ~= nil then
			do self.typeExpression:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.initializers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CreateObjectExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.typeExpression ~= nil then
		if self.typeExpression:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	if self:visitVector(self.initializers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CreateObjectExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.typeExpression ~= nil then
		do self.typeExpression:destroy() end
		self.typeExpression = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
	if self.initializers ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.initializers)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.initializers[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.initializers = nil
end

function sling.model.CreateObjectExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.CreateObjectExpressionNode:getType()
	do return self.type end
end

function sling.model.CreateObjectExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:setTypeExpression(v, doExport)
	if self.typeExpression ~= nil and doExport == false then
		do self.typeExpression:destroy() end
	end
	self.typeExpression = v
	if self.typeExpression ~= nil then
		do self.typeExpression:setParent(self) end
	end
end

function sling.model.CreateObjectExpressionNode:getTypeExpression()
	do return self.typeExpression end
end

function sling.model.CreateObjectExpressionNode:exportTypeExpression()
	local v = self.typeExpression
	self.typeExpression = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CreateObjectExpressionNode:getParameters()
	do return self.parameters end
end

function sling.model.CreateObjectExpressionNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.CreateObjectExpressionNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.CreateObjectExpressionNode:setInitializers(v, doExport)
	if self.initializers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.initializers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.initializers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.initializers = nil
	else
		self.initializers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.initializers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CreateObjectExpressionNode:getInitializers()
	do return self.initializers end
end

function sling.model.CreateObjectExpressionNode:exportInitializers()
	local v = self.initializers
	self.initializers = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:addToInitializers(v)
	if v == nil then
		do return end
	end
	if self.initializers == nil then
		self.initializers = {}
	end
	do _g.jk.lang.Vector:append(self.initializers, v) end
	do v:setParent(self) end
end

function sling.model.CreateObjectExpressionNode:clearInitializers()
	if self.initializers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.initializers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.initializers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.initializers = nil
end

sling.model.ShiftLeftExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ShiftLeftExpressionNode.__index = sling.model.ShiftLeftExpressionNode
_vm:set_metatable(sling.model.ShiftLeftExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ShiftLeftExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftLeftExpressionNode)
	return v
end

function sling.model.ShiftLeftExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftLeftExpressionNode'
	self['_isType.sling.model.ShiftLeftExpressionNode'] = true
end

function sling.model.ShiftLeftExpressionNode:_construct0()
	sling.model.ShiftLeftExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ShiftLeftExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftLeftExpressionNode._construct0(_g.sling.model.ShiftLeftExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftLeftExpressionNode:getNodeTypeName()
	do return "ShiftLeftExpressionNode" end
end

function sling.model.ShiftLeftExpressionNode:createNew()
	do return _g.sling.model.ShiftLeftExpressionNode._construct0(_g.sling.model.ShiftLeftExpressionNode._create()) end
end

function sling.model.ShiftLeftExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftLeftExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ShiftLeftExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftLeftExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftLeftExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.EnumValueNode = _g.sling.common.NodeObject._create()
sling.model.EnumValueNode.__index = sling.model.EnumValueNode
_vm:set_metatable(sling.model.EnumValueNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.EnumValueNode._create()
	local v = _vm:set_metatable({}, sling.model.EnumValueNode)
	return v
end

function sling.model.EnumValueNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EnumValueNode'
	self['_isType.sling.model.EnumValueNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
	self.type = nil
	self.value = nil
end

function sling.model.EnumValueNode:_construct0()
	sling.model.EnumValueNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.EnumValueNode:getNodeName()
	do return self.name end
end

function sling.model.EnumValueNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.EnumValueNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.EnumValueNode:getNodeTypeName()
	do return "EnumValueNode" end
end

function sling.model.EnumValueNode:createNew()
	do return _g.sling.model.EnumValueNode._construct0(_g.sling.model.EnumValueNode._create()) end
end

function sling.model.EnumValueNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EnumValueNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.EnumValueNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EnumValueNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.EnumValueNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.EnumValueNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.EnumValueNode:getType()
	do return self.type end
end

function sling.model.EnumValueNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.EnumValueNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.EnumValueNode:getValue()
	do return self.value end
end

function sling.model.EnumValueNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.EnumValueNode:getName()
	do return self.name end
end

sling.model.ExpressionContainerNode = _g.sling.common.NodeObject._create()
sling.model.ExpressionContainerNode.__index = sling.model.ExpressionContainerNode
_vm:set_metatable(sling.model.ExpressionContainerNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ExpressionContainerNode._create()
	local v = _vm:set_metatable({}, sling.model.ExpressionContainerNode)
	return v
end

function sling.model.ExpressionContainerNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExpressionContainerNode'
	self['_isType.sling.model.ExpressionContainerNode'] = true
	self.expression = nil
end

function sling.model.ExpressionContainerNode:_construct0()
	sling.model.ExpressionContainerNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ExpressionContainerNode:getNodeTypeName()
	do return "ExpressionContainerNode" end
end

function sling.model.ExpressionContainerNode:createNew()
	do return _g.sling.model.ExpressionContainerNode._construct0(_g.sling.model.ExpressionContainerNode._create()) end
end

function sling.model.ExpressionContainerNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExpressionContainerNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ExpressionContainerNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExpressionContainerNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ExpressionContainerNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ExpressionContainerNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ExpressionContainerNode:getExpression()
	do return self.expression end
end

function sling.model.ExpressionContainerNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.CommentNode = _g.sling.common.NodeObject._create()
sling.model.CommentNode.__index = sling.model.CommentNode
_vm:set_metatable(sling.model.CommentNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CommentNode._create()
	local v = _vm:set_metatable({}, sling.model.CommentNode)
	return v
end

function sling.model.CommentNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CommentNode'
	self['_isType.sling.model.CommentNode'] = true
	self.text = nil
	self.substantial = false
end

function sling.model.CommentNode:_construct0()
	sling.model.CommentNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CommentNode:forText(text, substantial)
	local v = _g.sling.model.CommentNode._construct0(_g.sling.model.CommentNode._create())
	do v:setText(text) end
	do v:setSubstantial(substantial) end
	do return v end
end

function sling.model.CommentNode:getNodeTypeName()
	do return "CommentNode" end
end

function sling.model.CommentNode:createNew()
	do return _g.sling.model.CommentNode._construct0(_g.sling.model.CommentNode._create()) end
end

function sling.model.CommentNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CommentNode')
		if n == nil then
			do return true end
		end
		n.text = self.text
		n.substantial = self.substantial
		do return true end
	end
end

function sling.model.CommentNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CommentNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CommentNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.CommentNode:setText(v)
	self.text = v
end

function sling.model.CommentNode:getText()
	do return self.text end
end

function sling.model.CommentNode:setSubstantial(v)
	self.substantial = v
end

function sling.model.CommentNode:getSubstantial()
	do return self.substantial end
end

sling.model.TryCatchExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.TryCatchExpressionNode.__index = sling.model.TryCatchExpressionNode
_vm:set_metatable(sling.model.TryCatchExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.TryCatchExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TryCatchExpressionNode)
	return v
end

function sling.model.TryCatchExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TryCatchExpressionNode'
	self['_isType.sling.model.TryCatchExpressionNode'] = true
	self.expression = nil
end

function sling.model.TryCatchExpressionNode:_construct0()
	sling.model.TryCatchExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TryCatchExpressionNode:forExpression(xpr)
	local v = _g.sling.model.TryCatchExpressionNode._construct0(_g.sling.model.TryCatchExpressionNode._create())
	do v:setExpression(xpr, false) end
	do return v end
end

function sling.model.TryCatchExpressionNode:getNodeTypeName()
	do return "TryCatchExpressionNode" end
end

function sling.model.TryCatchExpressionNode:createNew()
	do return _g.sling.model.TryCatchExpressionNode._construct0(_g.sling.model.TryCatchExpressionNode._create()) end
end

function sling.model.TryCatchExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TryCatchExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TryCatchExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TryCatchExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TryCatchExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.TryCatchExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.TryCatchExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.TryCatchExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.ImportEntityStatementNode = _g.sling.model.ImportStatementNode._create()
sling.model.ImportEntityStatementNode.__index = sling.model.ImportEntityStatementNode
_vm:set_metatable(sling.model.ImportEntityStatementNode, {
	__index = _g.sling.model.ImportStatementNode
})

function sling.model.ImportEntityStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportEntityStatementNode)
	return v
end

function sling.model.ImportEntityStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportEntityStatementNode'
	self['_isType.sling.model.ImportEntityStatementNode'] = true
	self.entity = nil
	self.container = nil
	self.allMembers = false
end

function sling.model.ImportEntityStatementNode:_construct0()
	sling.model.ImportEntityStatementNode._init(self)
	do _g.sling.model.ImportStatementNode._construct0(self) end
	return self
end

function sling.model.ImportEntityStatementNode:getNodeTypeName()
	do return "ImportEntityStatementNode" end
end

function sling.model.ImportEntityStatementNode:createNew()
	do return _g.sling.model.ImportEntityStatementNode._construct0(_g.sling.model.ImportEntityStatementNode._create()) end
end

function sling.model.ImportEntityStatementNode:copyTo(o)
	if _g.sling.model.ImportStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportEntityStatementNode')
		if n == nil then
			do return true end
		end
		if n.entity ~= nil then
			do n.entity:destroy() end
			n.entity = nil
		end
		if self.entity ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.entity), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.entity = pcp
			do n.entity:setParent(n) end
		end
		if n.container ~= nil then
			do n.container:destroy() end
			n.container = nil
		end
		if self.container ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.container), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.container = pcp
			do n.container:setParent(n) end
		end
		n.allMembers = self.allMembers
		do return true end
	end
end

function sling.model.ImportEntityStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.entity then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.entity:destroy() end
		end
		self.entity = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.entity ~= nil then
			do self.entity:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.container then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.container:destroy() end
		end
		self.container = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.container ~= nil then
			do self.container:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ImportStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportEntityStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ImportStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.entity ~= nil then
		if self.entity:accept(visitor) == false then
			do return false end
		end
	end
	if self.container ~= nil then
		if self.container:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImportEntityStatementNode:destroy()
	do _g.sling.model.ImportStatementNode.destroy(self) end
	if self.entity ~= nil then
		do self.entity:destroy() end
		self.entity = nil
	end
	if self.container ~= nil then
		do self.container:destroy() end
		self.container = nil
	end
end

function sling.model.ImportEntityStatementNode:setEntity(v, doExport)
	if self.entity ~= nil and doExport == false then
		do self.entity:destroy() end
	end
	self.entity = v
	if self.entity ~= nil then
		do self.entity:setParent(self) end
	end
end

function sling.model.ImportEntityStatementNode:getEntity()
	do return self.entity end
end

function sling.model.ImportEntityStatementNode:exportEntity()
	local v = self.entity
	self.entity = nil
	do return v end
end

function sling.model.ImportEntityStatementNode:setContainer(v, doExport)
	if self.container ~= nil and doExport == false then
		do self.container:destroy() end
	end
	self.container = v
	if self.container ~= nil then
		do self.container:setParent(self) end
	end
end

function sling.model.ImportEntityStatementNode:getContainer()
	do return self.container end
end

function sling.model.ImportEntityStatementNode:exportContainer()
	local v = self.container
	self.container = nil
	do return v end
end

function sling.model.ImportEntityStatementNode:setAllMembers(v)
	self.allMembers = v
end

function sling.model.ImportEntityStatementNode:getAllMembers()
	do return self.allMembers end
end

sling.model.SwitchStatementNode = _g.sling.common.NodeObject._create()
sling.model.SwitchStatementNode.__index = sling.model.SwitchStatementNode
_vm:set_metatable(sling.model.SwitchStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.SwitchStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.SwitchStatementNode)
	return v
end

function sling.model.SwitchStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SwitchStatementNode'
	self['_isType.sling.model.SwitchStatementNode'] = true
	self.expression = nil
	self.blocks = nil
end

function sling.model.SwitchStatementNode:_construct0()
	sling.model.SwitchStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.SwitchStatementNode:forExpression(xp)
	local v = _g.sling.model.SwitchStatementNode._construct0(_g.sling.model.SwitchStatementNode._create())
	do v:setExpression(xp, false) end
	do return v end
end

function sling.model.SwitchStatementNode:getNodeTypeName()
	do return "SwitchStatementNode" end
end

function sling.model.SwitchStatementNode:createNew()
	do return _g.sling.model.SwitchStatementNode._construct0(_g.sling.model.SwitchStatementNode._create()) end
end

function sling.model.SwitchStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SwitchStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do
			local array = n.blocks
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.blocks = nil
			if self.blocks ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.blocks)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.blocks[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.blocks == nil then
								n.blocks = {}
							end
							do _g.jk.lang.Vector:append(n.blocks, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SwitchStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.blocks, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SwitchStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.blocks, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SwitchStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.blocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.blocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.blocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.blocks = nil
end

function sling.model.SwitchStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.SwitchStatementNode:getExpression()
	do return self.expression end
end

function sling.model.SwitchStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.SwitchStatementNode:setBlocks(v, doExport)
	if self.blocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.blocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.blocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.blocks = nil
	else
		self.blocks = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.blocks, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SwitchStatementNode:getBlocks()
	do return self.blocks end
end

function sling.model.SwitchStatementNode:exportBlocks()
	local v = self.blocks
	self.blocks = nil
	do return v end
end

function sling.model.SwitchStatementNode:addToBlocks(v)
	if v == nil then
		do return end
	end
	if self.blocks == nil then
		self.blocks = {}
	end
	do _g.jk.lang.Vector:append(self.blocks, v) end
	do v:setParent(self) end
end

function sling.model.SwitchStatementNode:clearBlocks()
	if self.blocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.blocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.blocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.blocks = nil
end

sling.model.BitwiseOrExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.BitwiseOrExpressionNode.__index = sling.model.BitwiseOrExpressionNode
_vm:set_metatable(sling.model.BitwiseOrExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.BitwiseOrExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseOrExpressionNode)
	return v
end

function sling.model.BitwiseOrExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseOrExpressionNode'
	self['_isType.sling.model.BitwiseOrExpressionNode'] = true
end

function sling.model.BitwiseOrExpressionNode:_construct0()
	sling.model.BitwiseOrExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseOrExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseOrExpressionNode._construct0(_g.sling.model.BitwiseOrExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseOrExpressionNode:getNodeTypeName()
	do return "BitwiseOrExpressionNode" end
end

function sling.model.BitwiseOrExpressionNode:createNew()
	do return _g.sling.model.BitwiseOrExpressionNode._construct0(_g.sling.model.BitwiseOrExpressionNode._create()) end
end

function sling.model.BitwiseOrExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseOrExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseOrExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseOrExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseOrExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.ContinueStatementNode = _g.sling.common.NodeObject._create()
sling.model.ContinueStatementNode.__index = sling.model.ContinueStatementNode
_vm:set_metatable(sling.model.ContinueStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ContinueStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ContinueStatementNode)
	return v
end

function sling.model.ContinueStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ContinueStatementNode'
	self['_isType.sling.model.ContinueStatementNode'] = true
	self.level = 0
end

function sling.model.ContinueStatementNode:_construct0()
	sling.model.ContinueStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ContinueStatementNode:getNodeTypeName()
	do return "ContinueStatementNode" end
end

function sling.model.ContinueStatementNode:createNew()
	do return _g.sling.model.ContinueStatementNode._construct0(_g.sling.model.ContinueStatementNode._create()) end
end

function sling.model.ContinueStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ContinueStatementNode')
		if n == nil then
			do return true end
		end
		n.level = self.level
		do return true end
	end
end

function sling.model.ContinueStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ContinueStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ContinueStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ContinueStatementNode:setLevel(v)
	self.level = v
end

function sling.model.ContinueStatementNode:getLevel()
	do return self.level end
end

sling.model.ScriptDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.ScriptDeclarationNode.__index = sling.model.ScriptDeclarationNode
_vm:set_metatable(sling.model.ScriptDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.ScriptDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ScriptDeclarationNode)
	return v
end

function sling.model.ScriptDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ScriptDeclarationNode'
	self['_isType.sling.model.ScriptDeclarationNode'] = true
end

function sling.model.ScriptDeclarationNode:_construct0()
	sling.model.ScriptDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.ScriptDeclarationNode:forName(name)
	local v = _g.sling.model.ScriptDeclarationNode._construct0(_g.sling.model.ScriptDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.ScriptDeclarationNode:getNodeTypeName()
	do return "ScriptDeclarationNode" end
end

function sling.model.ScriptDeclarationNode:createNew()
	do return _g.sling.model.ScriptDeclarationNode._construct0(_g.sling.model.ScriptDeclarationNode._create()) end
end

function sling.model.ScriptDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ScriptDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ScriptDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ScriptDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ScriptDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
end

sling.model.FileSystemReferenceExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.FileSystemReferenceExpressionNode.__index = sling.model.FileSystemReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemReferenceExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.FileSystemReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemReferenceExpressionNode)
	return v
end

function sling.model.FileSystemReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemReferenceExpressionNode'
	self['_isType.sling.model.FileSystemReferenceExpressionNode'] = true
	self.name = nil
	self.relativeTo = nil
end

function sling.model.FileSystemReferenceExpressionNode:_construct0()
	sling.model.FileSystemReferenceExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemReferenceExpressionNode" end
end

function sling.model.FileSystemReferenceExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		n.relativeTo = self.relativeTo
		do return true end
	end
end

function sling.model.FileSystemReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemReferenceExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

function sling.model.FileSystemReferenceExpressionNode:setName(v)
	self.name = v
end

function sling.model.FileSystemReferenceExpressionNode:getName()
	do return self.name end
end

function sling.model.FileSystemReferenceExpressionNode:setRelativeTo(v)
	self.relativeTo = v
end

function sling.model.FileSystemReferenceExpressionNode:getRelativeTo()
	do return self.relativeTo end
end

sling.model.PointerDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.PointerDataTypeNode.__index = sling.model.PointerDataTypeNode
_vm:set_metatable(sling.model.PointerDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.PointerDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.PointerDataTypeNode)
	return v
end

function sling.model.PointerDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PointerDataTypeNode'
	self['_isType.sling.model.PointerDataTypeNode'] = true
end

function sling.model.PointerDataTypeNode:_construct0()
	sling.model.PointerDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.PointerDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.PointerDataTypeNode._construct0(_g.sling.model.PointerDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.PointerDataTypeNode:getNodeTypeName()
	do return "PointerDataTypeNode" end
end

function sling.model.PointerDataTypeNode:createNew()
	do return _g.sling.model.PointerDataTypeNode._construct0(_g.sling.model.PointerDataTypeNode._create()) end
end

function sling.model.PointerDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PointerDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PointerDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PointerDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PointerDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.ModelDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.ModelDeclarationNode.__index = sling.model.ModelDeclarationNode
_vm:set_metatable(sling.model.ModelDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.ModelDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ModelDeclarationNode)
	return v
end

function sling.model.ModelDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ModelDeclarationNode'
	self['_isType.sling.model.ModelDeclarationNode'] = true
end

function sling.model.ModelDeclarationNode:_construct0()
	sling.model.ModelDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.ModelDeclarationNode:forName(name)
	local v = _g.sling.model.ModelDeclarationNode._construct0(_g.sling.model.ModelDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.ModelDeclarationNode:getNodeTypeName()
	do return "ModelDeclarationNode" end
end

function sling.model.ModelDeclarationNode:createNew()
	do return _g.sling.model.ModelDeclarationNode._construct0(_g.sling.model.ModelDeclarationNode._create()) end
end

function sling.model.ModelDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ModelDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ModelDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ModelDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ModelDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
end

sling.model.TypeAliasDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.TypeAliasDeclarationNode.__index = sling.model.TypeAliasDeclarationNode
_vm:set_metatable(sling.model.TypeAliasDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.TypeAliasDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeAliasDeclarationNode)
	return v
end

function sling.model.TypeAliasDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeAliasDeclarationNode'
	self['_isType.sling.model.TypeAliasDeclarationNode'] = true
	self.type = nil
end

function sling.model.TypeAliasDeclarationNode:_construct0()
	sling.model.TypeAliasDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.TypeAliasDeclarationNode:instance(name, type)
	local v = _g.sling.model.TypeAliasDeclarationNode._construct0(_g.sling.model.TypeAliasDeclarationNode._create())
	do v:setName(name) end
	do v:setType(type, false) end
	do return v end
end

function sling.model.TypeAliasDeclarationNode:getNodeTypeName()
	do return "TypeAliasDeclarationNode" end
end

function sling.model.TypeAliasDeclarationNode:createNew()
	do return _g.sling.model.TypeAliasDeclarationNode._construct0(_g.sling.model.TypeAliasDeclarationNode._create()) end
end

function sling.model.TypeAliasDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeAliasDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TypeAliasDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeAliasDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TypeAliasDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.TypeAliasDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.TypeAliasDeclarationNode:getType()
	do return self.type end
end

function sling.model.TypeAliasDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.FunctionCallExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.FunctionCallExpressionNode.__index = sling.model.FunctionCallExpressionNode
_vm:set_metatable(sling.model.FunctionCallExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.FunctionCallExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionCallExpressionNode)
	return v
end

function sling.model.FunctionCallExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionCallExpressionNode'
	self['_isType.sling.model.FunctionCallExpressionNode'] = true
	self.expression = nil
	self.parameters = nil
	self.trailingParameter = nil
	self.isolated = false
end

function sling.model.FunctionCallExpressionNode:_construct0()
	sling.model.FunctionCallExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.FunctionCallExpressionNode:forName(name)
	do return _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forName(name)) end
end

function sling.model.FunctionCallExpressionNode:forNameWithParams(name, params)
	local v = _g.sling.model.FunctionCallExpressionNode:forName(name)
	if params ~= nil then
		local n = 0
		local m = #params
		do
			n = 0
			while n < m do
				local param = params[n + 1]
				if param ~= nil then
					do v:addToParameters(param) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.FunctionCallExpressionNode:forExpression(expr)
	local v = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
	do v:setExpression(expr, false) end
	do return v end
end

function sling.model.FunctionCallExpressionNode:forMethod(parent, methodName, isStatic)
	if not _g.jk.lang.String:isNotEmpty(methodName) then
		do return nil end
	end
	if not (parent ~= nil) then
		do return _g.sling.model.FunctionCallExpressionNode:forName(methodName) end
	end
	do
		local xpr = _g.sling.model.MemberAccessExpressionNode:append(_g.sling.model.SymbolExpressionNode:forName(methodName), parent)
		if (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			if isStatic then
				do xpr:setAccessType(_g.sling.model.MemberAccessExpressionNode.TYPE_STATIC) end
			else
				do xpr:setAccessType(_g.sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_FUNCTION) end
			end
		end
		do return _g.sling.model.FunctionCallExpressionNode:forExpression(xpr) end
	end
end

function sling.model.FunctionCallExpressionNode:forNames(names)
	do return _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forArrayOfNames(names)) end
end

function sling.model.FunctionCallExpressionNode:getParameterCount()
	if not (self.parameters ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.parameters) end
end

function sling.model.FunctionCallExpressionNode:exportOneParameter()
	local params = self:getParameters()
	if not (params ~= nil) then
		do return nil end
	end
	if not (_g.jk.lang.Vector:getSize(params) == 1) then
		do return nil end
	end
	do
		local param = _vm:to_table_with_key(_g.jk.lang.Vector:get(params, 0), '_isType.sling.common.ExpressionNode')
		if not (param ~= nil) then
			do return nil end
		end
		do self:exportParameters() end
		do return param end
	end
end

function sling.model.FunctionCallExpressionNode:setParameter(index, node)
	if not (self.parameters ~= nil) then
		do return end
	end
	do
		local current = _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, index), '_isType.sling.common.ExpressionNode')
		if current ~= nil then
			do current:destroy() end
			do _g.jk.lang.Vector:set(self.parameters, index, node) end
			if node ~= nil then
				do node:setParent(self) end
			end
		end
	end
end

function sling.model.FunctionCallExpressionNode:addStringToParameters(value)
	do self:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:addIntegerToParameters(value)
	do self:addToParameters(_g.sling.model.IntegerLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:addDoubleToParameters(value)
	do self:addToParameters(_g.sling.model.DoubleLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:addBooleanToParameters(value)
	do self:addToParameters(_g.sling.model.BooleanLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:prependParameter(param)
	if not (param ~= nil) then
		do return end
	end
	if self.parameters == nil then
		do self:addToParameters(param) end
		do return end
	end
	do _g.jk.lang.Vector:prepend(self.parameters, param) end
	do param:setParent(self) end
end

function sling.model.FunctionCallExpressionNode:getParameter(n)
	if not (self.parameters ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, n), '_isType.sling.common.ExpressionNode') end
end

function sling.model.FunctionCallExpressionNode:getNodeTypeName()
	do return "FunctionCallExpressionNode" end
end

function sling.model.FunctionCallExpressionNode:createNew()
	do return _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create()) end
end

function sling.model.FunctionCallExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionCallExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		if n.trailingParameter ~= nil then
			do n.trailingParameter:destroy() end
			n.trailingParameter = nil
		end
		if self.trailingParameter ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.trailingParameter), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.trailingParameter = pcp
			do n.trailingParameter:setParent(n) end
		end
		n.isolated = self.isolated
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.FunctionCallExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.trailingParameter then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.trailingParameter:destroy() end
		end
		self.trailingParameter = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.trailingParameter ~= nil then
			do self.trailingParameter:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionCallExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self.trailingParameter ~= nil then
		if self.trailingParameter:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FunctionCallExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.trailingParameter ~= nil then
		do self.trailingParameter:destroy() end
		self.trailingParameter = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.FunctionCallExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.FunctionCallExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.FunctionCallExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.FunctionCallExpressionNode:setTrailingParameter(v, doExport)
	if self.trailingParameter ~= nil and doExport == false then
		do self.trailingParameter:destroy() end
	end
	self.trailingParameter = v
	if self.trailingParameter ~= nil then
		do self.trailingParameter:setParent(self) end
	end
end

function sling.model.FunctionCallExpressionNode:getTrailingParameter()
	do return self.trailingParameter end
end

function sling.model.FunctionCallExpressionNode:exportTrailingParameter()
	local v = self.trailingParameter
	self.trailingParameter = nil
	do return v end
end

function sling.model.FunctionCallExpressionNode:setIsolated(v)
	self.isolated = v
end

function sling.model.FunctionCallExpressionNode:getIsolated()
	do return self.isolated end
end

function sling.model.FunctionCallExpressionNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionCallExpressionNode:getParameters()
	do return self.parameters end
end

function sling.model.FunctionCallExpressionNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.FunctionCallExpressionNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.FunctionCallExpressionNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

sling.model.FileSystemTextFileReferenceExpressionNode = _g.sling.model.FileSystemReferenceExpressionNode._create()
sling.model.FileSystemTextFileReferenceExpressionNode.__index = sling.model.FileSystemTextFileReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemTextFileReferenceExpressionNode, {
	__index = _g.sling.model.FileSystemReferenceExpressionNode
})

function sling.model.FileSystemTextFileReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemTextFileReferenceExpressionNode)
	return v
end

function sling.model.FileSystemTextFileReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemTextFileReferenceExpressionNode'
	self['_isType.sling.model.FileSystemTextFileReferenceExpressionNode'] = true
end

function sling.model.FileSystemTextFileReferenceExpressionNode:_construct0()
	sling.model.FileSystemTextFileReferenceExpressionNode._init(self)
	do _g.sling.model.FileSystemReferenceExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemTextFileReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemTextFileReferenceExpressionNode" end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:createNew()
	do return _g.sling.model.FileSystemTextFileReferenceExpressionNode._construct0(_g.sling.model.FileSystemTextFileReferenceExpressionNode._create()) end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:copyTo(o)
	if _g.sling.model.FileSystemReferenceExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemTextFileReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FileSystemReferenceExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.FileSystemReferenceExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:destroy()
	do _g.sling.model.FileSystemReferenceExpressionNode.destroy(self) end
end

sling.model.PrimitiveDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.PrimitiveDataTypeNode.__index = sling.model.PrimitiveDataTypeNode
_vm:set_metatable(sling.model.PrimitiveDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.PrimitiveDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.PrimitiveDataTypeNode)
	return v
end

function sling.model.PrimitiveDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PrimitiveDataTypeNode'
	self['_isType.sling.model.PrimitiveDataTypeNode'] = true
end

function sling.model.PrimitiveDataTypeNode:_construct0()
	sling.model.PrimitiveDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	do self:setIsNullable(false) end
	return self
end

function sling.model.PrimitiveDataTypeNode:getNodeTypeName()
	do return "PrimitiveDataTypeNode" end
end

function sling.model.PrimitiveDataTypeNode:createNew()
	do return _g.sling.model.PrimitiveDataTypeNode._construct0(_g.sling.model.PrimitiveDataTypeNode._create()) end
end

function sling.model.PrimitiveDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PrimitiveDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PrimitiveDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PrimitiveDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PrimitiveDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.DoubleDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.DoubleDataTypeNode.__index = sling.model.DoubleDataTypeNode
_vm:set_metatable(sling.model.DoubleDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.DoubleDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DoubleDataTypeNode)
	return v
end

function sling.model.DoubleDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DoubleDataTypeNode'
	self['_isType.sling.model.DoubleDataTypeNode'] = true
end

function sling.model.DoubleDataTypeNode:_construct0()
	sling.model.DoubleDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.DoubleDataTypeNode:getNodeTypeName()
	do return "DoubleDataTypeNode" end
end

function sling.model.DoubleDataTypeNode:createNew()
	do return _g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()) end
end

function sling.model.DoubleDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DoubleDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DoubleDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DoubleDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DoubleDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.AnnotationModifierNode = _g.sling.common.NodeObject._create()
sling.model.AnnotationModifierNode.__index = sling.model.AnnotationModifierNode
_vm:set_metatable(sling.model.AnnotationModifierNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.AnnotationModifierNode._create()
	local v = _vm:set_metatable({}, sling.model.AnnotationModifierNode)
	return v
end

function sling.model.AnnotationModifierNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AnnotationModifierNode'
	self['_isType.sling.model.AnnotationModifierNode'] = true
	self.text = nil
	self.expressions = nil
end

function sling.model.AnnotationModifierNode:_construct0()
	sling.model.AnnotationModifierNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.AnnotationModifierNode:forText(text)
	local v = _g.sling.model.AnnotationModifierNode._construct0(_g.sling.model.AnnotationModifierNode._create())
	do v:setText(text) end
	do return v end
end

function sling.model.AnnotationModifierNode:getNodeTypeName()
	do return "AnnotationModifierNode" end
end

function sling.model.AnnotationModifierNode:createNew()
	do return _g.sling.model.AnnotationModifierNode._construct0(_g.sling.model.AnnotationModifierNode._create()) end
end

function sling.model.AnnotationModifierNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AnnotationModifierNode')
		if n == nil then
			do return true end
		end
		n.text = self.text
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.AnnotationModifierNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AnnotationModifierNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AnnotationModifierNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.AnnotationModifierNode:setText(v)
	self.text = v
end

function sling.model.AnnotationModifierNode:getText()
	do return self.text end
end

function sling.model.AnnotationModifierNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.AnnotationModifierNode:getExpressions()
	do return self.expressions end
end

function sling.model.AnnotationModifierNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.AnnotationModifierNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.AnnotationModifierNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.PromiseDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.PromiseDataTypeNode.__index = sling.model.PromiseDataTypeNode
_vm:set_metatable(sling.model.PromiseDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.PromiseDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.PromiseDataTypeNode)
	return v
end

function sling.model.PromiseDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PromiseDataTypeNode'
	self['_isType.sling.model.PromiseDataTypeNode'] = true
end

function sling.model.PromiseDataTypeNode:_construct0()
	sling.model.PromiseDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.PromiseDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.PromiseDataTypeNode._construct0(_g.sling.model.PromiseDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.PromiseDataTypeNode:getNodeTypeName()
	do return "PromiseDataTypeNode" end
end

function sling.model.PromiseDataTypeNode:createNew()
	do return _g.sling.model.PromiseDataTypeNode._construct0(_g.sling.model.PromiseDataTypeNode._create()) end
end

function sling.model.PromiseDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PromiseDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PromiseDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PromiseDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PromiseDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.PreprocessorIfStatementNode = _g.sling.common.NodeObject._create()
sling.model.PreprocessorIfStatementNode.__index = sling.model.PreprocessorIfStatementNode
_vm:set_metatable(sling.model.PreprocessorIfStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PreprocessorIfStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.PreprocessorIfStatementNode)
	return v
end

function sling.model.PreprocessorIfStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreprocessorIfStatementNode'
	self['_isType.sling.model.PreprocessorIfStatementNode'] = true
	self.condition = nil
	self.ifBlock = nil
	self.elseBlock = nil
	self.elseBlockComment = nil
end

function sling.model.PreprocessorIfStatementNode:_construct0()
	sling.model.PreprocessorIfStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PreprocessorIfStatementNode:instance(condition, ifBlock, elseBlock)
	local v = _g.sling.model.PreprocessorIfStatementNode._construct0(_g.sling.model.PreprocessorIfStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setIfBlock(ifBlock, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.PreprocessorIfStatementNode:getNodeTypeName()
	do return "PreprocessorIfStatementNode" end
end

function sling.model.PreprocessorIfStatementNode:createNew()
	do return _g.sling.model.PreprocessorIfStatementNode._construct0(_g.sling.model.PreprocessorIfStatementNode._create()) end
end

function sling.model.PreprocessorIfStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreprocessorIfStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.ifBlock ~= nil then
			do n.ifBlock:destroy() end
			n.ifBlock = nil
		end
		if self.ifBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.ifBlock), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.ifBlock = pcp
			do n.ifBlock:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		if n.elseBlockComment ~= nil then
			do n.elseBlockComment:destroy() end
			n.elseBlockComment = nil
		end
		if self.elseBlockComment ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlockComment), '_isType.sling.model.CommentNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlockComment = pcp
			do n.elseBlockComment:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PreprocessorIfStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.ifBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.ifBlock:destroy() end
		end
		self.ifBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.ifBlock ~= nil then
			do self.ifBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlockComment then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlockComment:destroy() end
		end
		self.elseBlockComment = _vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode')
		if self.elseBlockComment ~= nil then
			do self.elseBlockComment:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreprocessorIfStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.ifBlock ~= nil then
		if self.ifBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlockComment ~= nil then
		if self.elseBlockComment:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PreprocessorIfStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.ifBlock ~= nil then
		do self.ifBlock:destroy() end
		self.ifBlock = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:destroy() end
		self.elseBlockComment = nil
	end
end

function sling.model.PreprocessorIfStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getCondition()
	do return self.condition end
end

function sling.model.PreprocessorIfStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.PreprocessorIfStatementNode:setIfBlock(v, doExport)
	if self.ifBlock ~= nil and doExport == false then
		do self.ifBlock:destroy() end
	end
	self.ifBlock = v
	if self.ifBlock ~= nil then
		do self.ifBlock:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getIfBlock()
	do return self.ifBlock end
end

function sling.model.PreprocessorIfStatementNode:exportIfBlock()
	local v = self.ifBlock
	self.ifBlock = nil
	do return v end
end

function sling.model.PreprocessorIfStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.PreprocessorIfStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.PreprocessorIfStatementNode:setElseBlockComment(v, doExport)
	if self.elseBlockComment ~= nil and doExport == false then
		do self.elseBlockComment:destroy() end
	end
	self.elseBlockComment = v
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getElseBlockComment()
	do return self.elseBlockComment end
end

function sling.model.PreprocessorIfStatementNode:exportElseBlockComment()
	local v = self.elseBlockComment
	self.elseBlockComment = nil
	do return v end
end

sling.model.TemplateDeclarationNode = _g.sling.model.ClassDeclarationNode._create()
sling.model.TemplateDeclarationNode.__index = sling.model.TemplateDeclarationNode
_vm:set_metatable(sling.model.TemplateDeclarationNode, {
	__index = _g.sling.model.ClassDeclarationNode
})

sling.model.TemplateDeclarationNode.TYPE_ANY = 0
sling.model.TemplateDeclarationNode.TYPE_VALUE = 1
sling.model.TemplateDeclarationNode.TYPE_CLASS = 2

function sling.model.TemplateDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.TemplateDeclarationNode)
	return v
end

function sling.model.TemplateDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TemplateDeclarationNode'
	self['_isType.sling.model.TemplateDeclarationNode'] = true
	self.type = 0
end

function sling.model.TemplateDeclarationNode:_construct0()
	sling.model.TemplateDeclarationNode._init(self)
	do _g.sling.model.ClassDeclarationNode._construct0(self) end
	return self
end

function sling.model.TemplateDeclarationNode:forName1(name)
	local v = _g.sling.model.TemplateDeclarationNode._construct0(_g.sling.model.TemplateDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.TemplateDeclarationNode:getNodeTypeName()
	do return "TemplateDeclarationNode" end
end

function sling.model.TemplateDeclarationNode:createNew()
	do return _g.sling.model.TemplateDeclarationNode._construct0(_g.sling.model.TemplateDeclarationNode._create()) end
end

function sling.model.TemplateDeclarationNode:copyTo(o)
	if _g.sling.model.ClassDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TemplateDeclarationNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.TemplateDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ClassDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TemplateDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.ClassDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TemplateDeclarationNode:destroy()
	do _g.sling.model.ClassDeclarationNode.destroy(self) end
end

function sling.model.TemplateDeclarationNode:setType(v)
	self.type = v
end

function sling.model.TemplateDeclarationNode:getType()
	do return self.type end
end

sling.model.ObjectDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ObjectDataTypeNode.__index = sling.model.ObjectDataTypeNode
_vm:set_metatable(sling.model.ObjectDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ObjectDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ObjectDataTypeNode)
	return v
end

function sling.model.ObjectDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ObjectDataTypeNode'
	self['_isType.sling.model.ObjectDataTypeNode'] = true
end

function sling.model.ObjectDataTypeNode:_construct0()
	sling.model.ObjectDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ObjectDataTypeNode:getNodeTypeName()
	do return "ObjectDataTypeNode" end
end

function sling.model.ObjectDataTypeNode:createNew()
	do return _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()) end
end

function sling.model.ObjectDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ObjectDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ObjectDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ObjectDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ObjectDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.FileSystemBinaryFileReferenceExpressionNode = _g.sling.model.FileSystemReferenceExpressionNode._create()
sling.model.FileSystemBinaryFileReferenceExpressionNode.__index = sling.model.FileSystemBinaryFileReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemBinaryFileReferenceExpressionNode, {
	__index = _g.sling.model.FileSystemReferenceExpressionNode
})

function sling.model.FileSystemBinaryFileReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemBinaryFileReferenceExpressionNode)
	return v
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemBinaryFileReferenceExpressionNode'
	self['_isType.sling.model.FileSystemBinaryFileReferenceExpressionNode'] = true
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:_construct0()
	sling.model.FileSystemBinaryFileReferenceExpressionNode._init(self)
	do _g.sling.model.FileSystemReferenceExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemBinaryFileReferenceExpressionNode" end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:createNew()
	do return _g.sling.model.FileSystemBinaryFileReferenceExpressionNode._construct0(_g.sling.model.FileSystemBinaryFileReferenceExpressionNode._create()) end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:copyTo(o)
	if _g.sling.model.FileSystemReferenceExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemBinaryFileReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FileSystemReferenceExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.FileSystemReferenceExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:destroy()
	do _g.sling.model.FileSystemReferenceExpressionNode.destroy(self) end
end

sling.model.CaseGreaterThanBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseGreaterThanBlockNode.__index = sling.model.CaseGreaterThanBlockNode
_vm:set_metatable(sling.model.CaseGreaterThanBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseGreaterThanBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseGreaterThanBlockNode)
	return v
end

function sling.model.CaseGreaterThanBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseGreaterThanBlockNode'
	self['_isType.sling.model.CaseGreaterThanBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseGreaterThanBlockNode:_construct0()
	sling.model.CaseGreaterThanBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseGreaterThanBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseGreaterThanBlockNode._construct0(_g.sling.model.CaseGreaterThanBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseGreaterThanBlockNode:getNodeTypeName()
	do return "CaseGreaterThanBlockNode" end
end

function sling.model.CaseGreaterThanBlockNode:createNew()
	do return _g.sling.model.CaseGreaterThanBlockNode._construct0(_g.sling.model.CaseGreaterThanBlockNode._create()) end
end

function sling.model.CaseGreaterThanBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseGreaterThanBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseGreaterThanBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseGreaterThanBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseGreaterThanBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseGreaterThanBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseGreaterThanBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseGreaterThanBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.LogicalOrExpressionNode = _g.sling.model.LogicalExpressionNode._create()
sling.model.LogicalOrExpressionNode.__index = sling.model.LogicalOrExpressionNode
_vm:set_metatable(sling.model.LogicalOrExpressionNode, {
	__index = _g.sling.model.LogicalExpressionNode
})

function sling.model.LogicalOrExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalOrExpressionNode)
	return v
end

function sling.model.LogicalOrExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalOrExpressionNode'
	self['_isType.sling.model.LogicalOrExpressionNode'] = true
end

function sling.model.LogicalOrExpressionNode:_construct0()
	sling.model.LogicalOrExpressionNode._init(self)
	do _g.sling.model.LogicalExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalOrExpressionNode:instance(left, right)
	local v = _g.sling.model.LogicalOrExpressionNode._construct0(_g.sling.model.LogicalOrExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LogicalOrExpressionNode:getNodeTypeName()
	do return "LogicalOrExpressionNode" end
end

function sling.model.LogicalOrExpressionNode:createNew()
	do return _g.sling.model.LogicalOrExpressionNode._construct0(_g.sling.model.LogicalOrExpressionNode._create()) end
end

function sling.model.LogicalOrExpressionNode:copyTo(o)
	if _g.sling.model.LogicalExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalOrExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalOrExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LogicalExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalOrExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LogicalExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalOrExpressionNode:destroy()
	do _g.sling.model.LogicalExpressionNode.destroy(self) end
end

sling.model.AssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.AssignmentExpressionNode.__index = sling.model.AssignmentExpressionNode
_vm:set_metatable(sling.model.AssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.AssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AssignmentExpressionNode)
	return v
end

function sling.model.AssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AssignmentExpressionNode'
	self['_isType.sling.model.AssignmentExpressionNode'] = true
	self.expectedType = nil
end

function sling.model.AssignmentExpressionNode:_construct0()
	sling.model.AssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.AssignmentExpressionNode:forNodes(left, right)
	local v = _g.sling.model.AssignmentExpressionNode._construct0(_g.sling.model.AssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.AssignmentExpressionNode:getNodeTypeName()
	do return "AssignmentExpressionNode" end
end

function sling.model.AssignmentExpressionNode:createNew()
	do return _g.sling.model.AssignmentExpressionNode._construct0(_g.sling.model.AssignmentExpressionNode._create()) end
end

function sling.model.AssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expectedType ~= nil then
			do n.expectedType:destroy() end
			n.expectedType = nil
		end
		if self.expectedType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expectedType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.expectedType = pcp
			do n.expectedType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.AssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expectedType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expectedType:destroy() end
		end
		self.expectedType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.expectedType ~= nil then
			do self.expectedType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expectedType ~= nil then
		if self.expectedType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.AssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
	if self.expectedType ~= nil then
		do self.expectedType:destroy() end
		self.expectedType = nil
	end
end

function sling.model.AssignmentExpressionNode:setExpectedType(v, doExport)
	if self.expectedType ~= nil and doExport == false then
		do self.expectedType:destroy() end
	end
	self.expectedType = v
	if self.expectedType ~= nil then
		do self.expectedType:setParent(self) end
	end
end

function sling.model.AssignmentExpressionNode:getExpectedType()
	do return self.expectedType end
end

function sling.model.AssignmentExpressionNode:exportExpectedType()
	local v = self.expectedType
	self.expectedType = nil
	do return v end
end

sling.model.FunctionDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.FunctionDataTypeNode.__index = sling.model.FunctionDataTypeNode
_vm:set_metatable(sling.model.FunctionDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.FunctionDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDataTypeNode)
	return v
end

function sling.model.FunctionDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDataTypeNode'
	self['_isType.sling.model.FunctionDataTypeNode'] = true
	self.declaration = nil
end

function sling.model.FunctionDataTypeNode:_construct0()
	sling.model.FunctionDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.FunctionDataTypeNode:forFunction(decl)
	local v = _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create())
	if decl ~= nil then
		local dd = _vm:to_table_with_key(decl:dup(), '_isType.sling.model.FunctionDeclarationNode')
		if dd ~= nil then
			do dd:setName(nil) end
			do dd:setBody(nil, false) end
			do
				local array = dd:getParameters()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
							if param ~= nil then
								do param:setName(nil) end
							end
							do n = n + 1 end
						end
					end
				end
				do v:setDeclaration(dd, false) end
			end
		end
	end
	do return v end
end

function sling.model.FunctionDataTypeNode:getFunctionReturnType()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getReturnType() end
end

function sling.model.FunctionDataTypeNode:getFunctionParameters()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getParameters() end
end

function sling.model.FunctionDataTypeNode:getNodeTypeName()
	do return "FunctionDataTypeNode" end
end

function sling.model.FunctionDataTypeNode:createNew()
	do return _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create()) end
end

function sling.model.FunctionDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.FunctionDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.FunctionDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
end

function sling.model.FunctionDataTypeNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.FunctionDataTypeNode:getDeclaration()
	do return self.declaration end
end

function sling.model.FunctionDataTypeNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

sling.model.AssertStatementNode = _g.sling.common.NodeObject._create()
sling.model.AssertStatementNode.__index = sling.model.AssertStatementNode
_vm:set_metatable(sling.model.AssertStatementNode, {
	__index = _g.sling.common.NodeObject
})

sling.model.AssertStatementNode.STYLE_RETURN = 0
sling.model.AssertStatementNode.STYLE_THROW = 1

function sling.model.AssertStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.AssertStatementNode)
	return v
end

function sling.model.AssertStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AssertStatementNode'
	self['_isType.sling.model.AssertStatementNode'] = true
	self.child = nil
	self.errorBlock = nil
	self.errorMessage = nil
	self.style = 0
end

function sling.model.AssertStatementNode:_construct0()
	sling.model.AssertStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.AssertStatementNode:forChild(xpr)
	local v = _g.sling.model.AssertStatementNode._construct0(_g.sling.model.AssertStatementNode._create())
	do v:setChild(xpr, false) end
	do return v end
end

function sling.model.AssertStatementNode:getNodeTypeName()
	do return "AssertStatementNode" end
end

function sling.model.AssertStatementNode:createNew()
	do return _g.sling.model.AssertStatementNode._construct0(_g.sling.model.AssertStatementNode._create()) end
end

function sling.model.AssertStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AssertStatementNode')
		if n == nil then
			do return true end
		end
		if n.child ~= nil then
			do n.child:destroy() end
			n.child = nil
		end
		if self.child ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.child), '_isType.sling.common.NodeObject')
			if pcp == nil then
				do return false end
			end
			n.child = pcp
			do n.child:setParent(n) end
		end
		if n.errorBlock ~= nil then
			do n.errorBlock:destroy() end
			n.errorBlock = nil
		end
		if self.errorBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.errorBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.errorBlock = pcp
			do n.errorBlock:setParent(n) end
		end
		if n.errorMessage ~= nil then
			do n.errorMessage:destroy() end
			n.errorMessage = nil
		end
		if self.errorMessage ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.errorMessage), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.errorMessage = pcp
			do n.errorMessage:setParent(n) end
		end
		n.style = self.style
		do return true end
	end
end

function sling.model.AssertStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.child then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.child:destroy() end
		end
		self.child = _vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject')
		if self.child ~= nil then
			do self.child:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.errorBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.errorBlock:destroy() end
		end
		self.errorBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.errorBlock ~= nil then
			do self.errorBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.errorMessage then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.errorMessage:destroy() end
		end
		self.errorMessage = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.errorMessage ~= nil then
			do self.errorMessage:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AssertStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.child ~= nil then
		if self.child:accept(visitor) == false then
			do return false end
		end
	end
	if self.errorBlock ~= nil then
		if self.errorBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.errorMessage ~= nil then
		if self.errorMessage:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.AssertStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.child ~= nil then
		do self.child:destroy() end
		self.child = nil
	end
	if self.errorBlock ~= nil then
		do self.errorBlock:destroy() end
		self.errorBlock = nil
	end
	if self.errorMessage ~= nil then
		do self.errorMessage:destroy() end
		self.errorMessage = nil
	end
end

function sling.model.AssertStatementNode:setChild(v, doExport)
	if self.child ~= nil and doExport == false then
		do self.child:destroy() end
	end
	self.child = v
	if self.child ~= nil then
		do self.child:setParent(self) end
	end
end

function sling.model.AssertStatementNode:getChild()
	do return self.child end
end

function sling.model.AssertStatementNode:exportChild()
	local v = self.child
	self.child = nil
	do return v end
end

function sling.model.AssertStatementNode:setErrorBlock(v, doExport)
	if self.errorBlock ~= nil and doExport == false then
		do self.errorBlock:destroy() end
	end
	self.errorBlock = v
	if self.errorBlock ~= nil then
		do self.errorBlock:setParent(self) end
	end
end

function sling.model.AssertStatementNode:getErrorBlock()
	do return self.errorBlock end
end

function sling.model.AssertStatementNode:exportErrorBlock()
	local v = self.errorBlock
	self.errorBlock = nil
	do return v end
end

function sling.model.AssertStatementNode:setErrorMessage(v, doExport)
	if self.errorMessage ~= nil and doExport == false then
		do self.errorMessage:destroy() end
	end
	self.errorMessage = v
	if self.errorMessage ~= nil then
		do self.errorMessage:setParent(self) end
	end
end

function sling.model.AssertStatementNode:getErrorMessage()
	do return self.errorMessage end
end

function sling.model.AssertStatementNode:exportErrorMessage()
	local v = self.errorMessage
	self.errorMessage = nil
	do return v end
end

function sling.model.AssertStatementNode:setStyle(v)
	self.style = v
end

function sling.model.AssertStatementNode:getStyle()
	do return self.style end
end

sling.model.BreakStatementNode = _g.sling.common.NodeObject._create()
sling.model.BreakStatementNode.__index = sling.model.BreakStatementNode
_vm:set_metatable(sling.model.BreakStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.BreakStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.BreakStatementNode)
	return v
end

function sling.model.BreakStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BreakStatementNode'
	self['_isType.sling.model.BreakStatementNode'] = true
end

function sling.model.BreakStatementNode:_construct0()
	sling.model.BreakStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.BreakStatementNode:getNodeTypeName()
	do return "BreakStatementNode" end
end

function sling.model.BreakStatementNode:createNew()
	do return _g.sling.model.BreakStatementNode._construct0(_g.sling.model.BreakStatementNode._create()) end
end

function sling.model.BreakStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BreakStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BreakStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BreakStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BreakStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

sling.model.PostIncrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PostIncrementExpressionNode.__index = sling.model.PostIncrementExpressionNode
_vm:set_metatable(sling.model.PostIncrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PostIncrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PostIncrementExpressionNode)
	return v
end

function sling.model.PostIncrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PostIncrementExpressionNode'
	self['_isType.sling.model.PostIncrementExpressionNode'] = true
end

function sling.model.PostIncrementExpressionNode:_construct0()
	sling.model.PostIncrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PostIncrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PostIncrementExpressionNode._construct0(_g.sling.model.PostIncrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PostIncrementExpressionNode:getNodeTypeName()
	do return "PostIncrementExpressionNode" end
end

function sling.model.PostIncrementExpressionNode:createNew()
	do return _g.sling.model.PostIncrementExpressionNode._construct0(_g.sling.model.PostIncrementExpressionNode._create()) end
end

function sling.model.PostIncrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PostIncrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PostIncrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PostIncrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PostIncrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.NullLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.NullLiteralExpressionNode.__index = sling.model.NullLiteralExpressionNode
_vm:set_metatable(sling.model.NullLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.NullLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NullLiteralExpressionNode)
	return v
end

function sling.model.NullLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NullLiteralExpressionNode'
	self['_isType.sling.model.NullLiteralExpressionNode'] = true
end

function sling.model.NullLiteralExpressionNode:_construct0()
	sling.model.NullLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.NullDataTypeNode._construct0(_g.sling.model.NullDataTypeNode._create()), false) end
	return self
end

function sling.model.NullLiteralExpressionNode:getNodeTypeName()
	do return "NullLiteralExpressionNode" end
end

function sling.model.NullLiteralExpressionNode:createNew()
	do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
end

function sling.model.NullLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NullLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NullLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NullLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NullLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

sling.model.PreprocessorIsDefinedExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.PreprocessorIsDefinedExpressionNode.__index = sling.model.PreprocessorIsDefinedExpressionNode
_vm:set_metatable(sling.model.PreprocessorIsDefinedExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.PreprocessorIsDefinedExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreprocessorIsDefinedExpressionNode)
	return v
end

function sling.model.PreprocessorIsDefinedExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreprocessorIsDefinedExpressionNode'
	self['_isType.sling.model.PreprocessorIsDefinedExpressionNode'] = true
	self.variable = nil
end

function sling.model.PreprocessorIsDefinedExpressionNode:_construct0()
	sling.model.PreprocessorIsDefinedExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.PreprocessorIsDefinedExpressionNode:instance(variable)
	local v = _g.sling.model.PreprocessorIsDefinedExpressionNode._construct0(_g.sling.model.PreprocessorIsDefinedExpressionNode._create())
	do v:setVariable(variable) end
	do return v end
end

function sling.model.PreprocessorIsDefinedExpressionNode:forVariable(variable)
	local v = _g.sling.model.PreprocessorIsDefinedExpressionNode._construct0(_g.sling.model.PreprocessorIsDefinedExpressionNode._create())
	do v:setVariable(variable) end
	do return v end
end

function sling.model.PreprocessorIsDefinedExpressionNode:getNodeTypeName()
	do return "PreprocessorIsDefinedExpressionNode" end
end

function sling.model.PreprocessorIsDefinedExpressionNode:createNew()
	do return _g.sling.model.PreprocessorIsDefinedExpressionNode._construct0(_g.sling.model.PreprocessorIsDefinedExpressionNode._create()) end
end

function sling.model.PreprocessorIsDefinedExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreprocessorIsDefinedExpressionNode')
		if n == nil then
			do return true end
		end
		n.variable = self.variable
		do return true end
	end
end

function sling.model.PreprocessorIsDefinedExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreprocessorIsDefinedExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreprocessorIsDefinedExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

function sling.model.PreprocessorIsDefinedExpressionNode:setVariable(v)
	self.variable = v
end

function sling.model.PreprocessorIsDefinedExpressionNode:getVariable()
	do return self.variable end
end

sling.model.MembershipCheckExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.MembershipCheckExpressionNode.__index = sling.model.MembershipCheckExpressionNode
_vm:set_metatable(sling.model.MembershipCheckExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.MembershipCheckExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MembershipCheckExpressionNode)
	return v
end

function sling.model.MembershipCheckExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MembershipCheckExpressionNode'
	self['_isType.sling.model.MembershipCheckExpressionNode'] = true
end

function sling.model.MembershipCheckExpressionNode:_construct0()
	sling.model.MembershipCheckExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.MembershipCheckExpressionNode:instance(left, right)
	local v = _g.sling.model.MembershipCheckExpressionNode._construct0(_g.sling.model.MembershipCheckExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.MembershipCheckExpressionNode:getNodeTypeName()
	do return "MembershipCheckExpressionNode" end
end

function sling.model.MembershipCheckExpressionNode:createNew()
	do return _g.sling.model.MembershipCheckExpressionNode._construct0(_g.sling.model.MembershipCheckExpressionNode._create()) end
end

function sling.model.MembershipCheckExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MembershipCheckExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MembershipCheckExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MembershipCheckExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MembershipCheckExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.BooleanDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.BooleanDataTypeNode.__index = sling.model.BooleanDataTypeNode
_vm:set_metatable(sling.model.BooleanDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.BooleanDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.BooleanDataTypeNode)
	return v
end

function sling.model.BooleanDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BooleanDataTypeNode'
	self['_isType.sling.model.BooleanDataTypeNode'] = true
end

function sling.model.BooleanDataTypeNode:_construct0()
	sling.model.BooleanDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.BooleanDataTypeNode:getNodeTypeName()
	do return "BooleanDataTypeNode" end
end

function sling.model.BooleanDataTypeNode:createNew()
	do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
end

function sling.model.BooleanDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BooleanDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BooleanDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BooleanDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BooleanDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.ShiftLeftAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ShiftLeftAssignmentExpressionNode.__index = sling.model.ShiftLeftAssignmentExpressionNode
_vm:set_metatable(sling.model.ShiftLeftAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ShiftLeftAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftLeftAssignmentExpressionNode)
	return v
end

function sling.model.ShiftLeftAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftLeftAssignmentExpressionNode'
	self['_isType.sling.model.ShiftLeftAssignmentExpressionNode'] = true
end

function sling.model.ShiftLeftAssignmentExpressionNode:_construct0()
	sling.model.ShiftLeftAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ShiftLeftAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftLeftAssignmentExpressionNode._construct0(_g.sling.model.ShiftLeftAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftLeftAssignmentExpressionNode:getNodeTypeName()
	do return "ShiftLeftAssignmentExpressionNode" end
end

function sling.model.ShiftLeftAssignmentExpressionNode:createNew()
	do return _g.sling.model.ShiftLeftAssignmentExpressionNode._construct0(_g.sling.model.ShiftLeftAssignmentExpressionNode._create()) end
end

function sling.model.ShiftLeftAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftLeftAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ShiftLeftAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftLeftAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftLeftAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.ErrorStatementNode = _g.sling.common.NodeObject._create()
sling.model.ErrorStatementNode.__index = sling.model.ErrorStatementNode
_vm:set_metatable(sling.model.ErrorStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ErrorStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ErrorStatementNode)
	return v
end

function sling.model.ErrorStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ErrorStatementNode'
	self['_isType.sling.model.ErrorStatementNode'] = true
	self.message = nil
end

function sling.model.ErrorStatementNode:_construct0()
	sling.model.ErrorStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ErrorStatementNode:forText(text)
	local v = _g.sling.model.ErrorStatementNode._construct0(_g.sling.model.ErrorStatementNode._create())
	do v:setMessage(text) end
	do return v end
end

function sling.model.ErrorStatementNode:getNodeTypeName()
	do return "ErrorStatementNode" end
end

function sling.model.ErrorStatementNode:createNew()
	do return _g.sling.model.ErrorStatementNode._construct0(_g.sling.model.ErrorStatementNode._create()) end
end

function sling.model.ErrorStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ErrorStatementNode')
		if n == nil then
			do return true end
		end
		n.message = self.message
		do return true end
	end
end

function sling.model.ErrorStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ErrorStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ErrorStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ErrorStatementNode:setMessage(v)
	self.message = v
end

function sling.model.ErrorStatementNode:getMessage()
	do return self.message end
end

sling.model.ForceUnwrapOptionalExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.ForceUnwrapOptionalExpressionNode.__index = sling.model.ForceUnwrapOptionalExpressionNode
_vm:set_metatable(sling.model.ForceUnwrapOptionalExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.ForceUnwrapOptionalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ForceUnwrapOptionalExpressionNode)
	return v
end

function sling.model.ForceUnwrapOptionalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ForceUnwrapOptionalExpressionNode'
	self['_isType.sling.model.ForceUnwrapOptionalExpressionNode'] = true
end

function sling.model.ForceUnwrapOptionalExpressionNode:_construct0()
	sling.model.ForceUnwrapOptionalExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ForceUnwrapOptionalExpressionNode:forExpression(expression)
	local v = _g.sling.model.ForceUnwrapOptionalExpressionNode._construct0(_g.sling.model.ForceUnwrapOptionalExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.ForceUnwrapOptionalExpressionNode:getNodeTypeName()
	do return "ForceUnwrapOptionalExpressionNode" end
end

function sling.model.ForceUnwrapOptionalExpressionNode:createNew()
	do return _g.sling.model.ForceUnwrapOptionalExpressionNode._construct0(_g.sling.model.ForceUnwrapOptionalExpressionNode._create()) end
end

function sling.model.ForceUnwrapOptionalExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ForceUnwrapOptionalExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ForceUnwrapOptionalExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ForceUnwrapOptionalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ForceUnwrapOptionalExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.StringConcatenationExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.StringConcatenationExpressionNode.__index = sling.model.StringConcatenationExpressionNode
_vm:set_metatable(sling.model.StringConcatenationExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.StringConcatenationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringConcatenationExpressionNode)
	return v
end

function sling.model.StringConcatenationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringConcatenationExpressionNode'
	self['_isType.sling.model.StringConcatenationExpressionNode'] = true
end

function sling.model.StringConcatenationExpressionNode:_construct0()
	sling.model.StringConcatenationExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.StringConcatenationExpressionNode:instance(left, right)
	local v = _g.sling.model.StringConcatenationExpressionNode._construct0(_g.sling.model.StringConcatenationExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StringConcatenationExpressionNode:forExpressions(xprs)
	if not (xprs ~= nil) then
		do return nil end
	end
	do
		local sz = _g.jk.lang.Vector:getSize(xprs)
		if not (sz >= 2) then
			do return nil end
		end
		do
			local v = _g.sling.model.StringConcatenationExpressionNode:instance(_g.jk.lang.Vector:get(xprs, 0), _g.jk.lang.Vector:get(xprs, 1))
			do
				local n = 2
				while n < sz do
					v = _g.sling.model.StringConcatenationExpressionNode:instance(v, _g.jk.lang.Vector:get(xprs, n))
					do n = n + 1 end
				end
			end
			do return v end
		end
	end
end

function sling.model.StringConcatenationExpressionNode:getNodeTypeName()
	do return "StringConcatenationExpressionNode" end
end

function sling.model.StringConcatenationExpressionNode:createNew()
	do return _g.sling.model.StringConcatenationExpressionNode._construct0(_g.sling.model.StringConcatenationExpressionNode._create()) end
end

function sling.model.StringConcatenationExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringConcatenationExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StringConcatenationExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringConcatenationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringConcatenationExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.DivisionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.DivisionAssignmentExpressionNode.__index = sling.model.DivisionAssignmentExpressionNode
_vm:set_metatable(sling.model.DivisionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.DivisionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DivisionAssignmentExpressionNode)
	return v
end

function sling.model.DivisionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DivisionAssignmentExpressionNode'
	self['_isType.sling.model.DivisionAssignmentExpressionNode'] = true
end

function sling.model.DivisionAssignmentExpressionNode:_construct0()
	sling.model.DivisionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.DivisionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.DivisionAssignmentExpressionNode._construct0(_g.sling.model.DivisionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DivisionAssignmentExpressionNode:getNodeTypeName()
	do return "DivisionAssignmentExpressionNode" end
end

function sling.model.DivisionAssignmentExpressionNode:createNew()
	do return _g.sling.model.DivisionAssignmentExpressionNode._construct0(_g.sling.model.DivisionAssignmentExpressionNode._create()) end
end

function sling.model.DivisionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DivisionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DivisionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DivisionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DivisionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.NotEqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.NotEqualsExpressionNode.__index = sling.model.NotEqualsExpressionNode
_vm:set_metatable(sling.model.NotEqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.NotEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NotEqualsExpressionNode)
	return v
end

function sling.model.NotEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NotEqualsExpressionNode'
	self['_isType.sling.model.NotEqualsExpressionNode'] = true
end

function sling.model.NotEqualsExpressionNode:_construct0()
	sling.model.NotEqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.NotEqualsExpressionNode:forNull(expr)
	do return _g.sling.model.NotEqualsExpressionNode:instance(expr, _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())) end
end

function sling.model.NotEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.NotEqualsExpressionNode._construct0(_g.sling.model.NotEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.NotEqualsExpressionNode:getNodeTypeName()
	do return "NotEqualsExpressionNode" end
end

function sling.model.NotEqualsExpressionNode:createNew()
	do return _g.sling.model.NotEqualsExpressionNode._construct0(_g.sling.model.NotEqualsExpressionNode._create()) end
end

function sling.model.NotEqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NotEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NotEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NotEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NotEqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.MemberAccessExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.MemberAccessExpressionNode.__index = sling.model.MemberAccessExpressionNode
_vm:set_metatable(sling.model.MemberAccessExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

sling.model.MemberAccessExpressionNode.TYPE_AUTO = 0
sling.model.MemberAccessExpressionNode.TYPE_INSTANCE = 1
sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_VARIABLE = 2
sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_FUNCTION = 3
sling.model.MemberAccessExpressionNode.TYPE_STATIC = 4
sling.model.MemberAccessExpressionNode.TYPE_STATIC_VARIABLE = 5
sling.model.MemberAccessExpressionNode.TYPE_STATIC_FUNCTION = 6
sling.model.MemberAccessExpressionNode.TYPE_POINTER = 7
sling.model.MemberAccessExpressionNode.TYPE_PROPERTY = 8
sling.model.MemberAccessExpressionNode.TYPE_NAMESPACE_ALIAS = 9

function sling.model.MemberAccessExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MemberAccessExpressionNode)
	return v
end

function sling.model.MemberAccessExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MemberAccessExpressionNode'
	self['_isType.sling.model.MemberAccessExpressionNode'] = true
	self.parentExpression = nil
	self.childExpression = nil
	self.accessType = 0
end

function sling.model.MemberAccessExpressionNode:_construct0()
	sling.model.MemberAccessExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.MemberAccessExpressionNode:forExpressions(expressions)
	local v = nil
	if expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(expressions)
		do
			n = 0
			while n < m do
				local expression = expressions[n + 1]
				if expression ~= nil then
					v = _g.sling.model.MemberAccessExpressionNode:append(expression, v)
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.MemberAccessExpressionNode:forNodes(parent, child)
	local v = _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create())
	do v:setParentExpression(parent, false) end
	do v:setChildExpression(child, false) end
	do return v end
end

function sling.model.MemberAccessExpressionNode:forSymbolNames(parent, child)
	local v = _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create())
	do v:setParentExpression(_g.sling.model.SymbolExpressionNode:forName(parent), false) end
	do v:setChildExpression(_g.sling.model.SymbolExpressionNode:forName(child), false) end
	do return v end
end

function sling.model.MemberAccessExpressionNode:forSymbols(names)
	if not (names ~= nil) then
		do return nil end
	end
	do
		local v = nil
		if names ~= nil then
			local n = 0
			local m = #names
			do
				n = 0
				while n < m do
					local str = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(names[n + 1])
					if str ~= nil then
						v = _g.sling.model.MemberAccessExpressionNode:append(_g.sling.model.SymbolExpressionNode:forName(str), v)
					end
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function sling.model.MemberAccessExpressionNode:getPreviousNode(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return nil end
		end
		if pp:getChildExpression() == node then
			do return pp:getParentExpression() end
		end
		do
			local pe = pp:getParentExpression()
			if pe ~= node then
				do return nil end
			end
			do
				local pp2 = _vm:to_table_with_key(pp:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
				if not (pp2 ~= nil) then
					do return nil end
				end
				if pp2:getChildExpression() ~= pp then
					do return nil end
				end
				do return pp2:getParentExpression() end
			end
		end
	end
end

function sling.model.MemberAccessExpressionNode:isChildOf(xpr)
	if not (xpr ~= nil) then
		do return false end
	end
	do
		local pp = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return false end
		end
		if pp:getChildExpression() ~= xpr then
			do return false end
		end
		do return true end
	end
end

function sling.model.MemberAccessExpressionNode:append(toappend, original)
	if not (toappend ~= nil) then
		do return original end
	end
	if not (original ~= nil) then
		do return toappend end
	end
	do
		local ip = _vm:to_table_with_key(original, '_isType.sling.model.MemberAccessExpressionNode')
		if not (ip ~= nil) then
			do return _g.sling.model.MemberAccessExpressionNode:forNodes(original, toappend) end
		end
		while true do
			local nn = ip:getChildExpression()
			if not (nn ~= nil) then
				do ip:setChildExpression(toappend, false) end
				do break end
			end
			if (_vm:to_table_with_key(nn, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
				ip = nn
				goto _continue1
			end
			do ip:exportChildExpression() end
			do ip:setChildExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(nn, toappend), false) end
			do break end
			::_continue1::
		end
		do return original end
	end
end

function sling.model.MemberAccessExpressionNode:isChild(node)
	if not (node ~= nil) then
		do return false end
	end
	do
		local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return false end
		end
		if pp:getParentExpression() == node and (_vm:to_table_with_key(pp:getParent(), '_isType.sling.model.MemberAccessExpressionNode') ~= nil) == false then
			do return false end
		end
		do return true end
	end
end

function sling.model.MemberAccessExpressionNode:findFromChild(node)
	local v = node
	if not (v ~= nil) then
		do return nil end
	end
	while true do
		local p = _g.sling.model.MemberAccessExpressionNode:getPreviousNode(v)
		if not (p ~= nil) then
			do break end
		end
		v = p
	end
	do return _vm:to_table_with_key(v:getParent(), '_isType.sling.model.MemberAccessExpressionNode') end
end

function sling.model.MemberAccessExpressionNode:getLastNode()
	local v = self.childExpression
	while true do
		if not (v ~= nil) then
			do break end
		elseif (_vm:to_table_with_key(v, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			v = v.childExpression
		else
			do break end
		end
	end
	do return v end
end

function sling.model.MemberAccessExpressionNode:removeLastNode()
	local p = self
	while true do
		local n = _vm:to_table_with_key(p.childExpression, '_isType.sling.model.MemberAccessExpressionNode')
		if n ~= nil then
			p = n
			goto _continue2
		end
		if p == self then
			do return p:exportParentExpression() end
		end
		do
			local pp = _vm:to_table_with_key(p:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
			if not (pp ~= nil) then
				do return nil end
			end
			do
				local oc = p:exportParentExpression()
				if not (oc ~= nil) then
					do return nil end
				end
				do pp:setChildExpression(oc, false) end
				do return self end
			end
		end
		::_continue2::
	end
	do return nil end
end

function sling.model.MemberAccessExpressionNode:getAllExpressionsTo(results)
	if self.parentExpression ~= nil then
		if (_vm:to_table_with_key(self.parentExpression, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			do self.parentExpression:getAllExpressionsTo(results) end
		else
			do _g.jk.lang.Vector:append(results, self.parentExpression) end
		end
	end
	if self.childExpression ~= nil then
		if (_vm:to_table_with_key(self.childExpression, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			do self.childExpression:getAllExpressionsTo(results) end
		else
			do _g.jk.lang.Vector:append(results, self.childExpression) end
		end
	end
end

function sling.model.MemberAccessExpressionNode:getAllExpressions()
	local v = {}
	do self:getAllExpressionsTo(v) end
	do return v end
end

function sling.model.MemberAccessExpressionNode:getNodeTypeName()
	do return "MemberAccessExpressionNode" end
end

function sling.model.MemberAccessExpressionNode:createNew()
	do return _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create()) end
end

function sling.model.MemberAccessExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MemberAccessExpressionNode')
		if n == nil then
			do return true end
		end
		if n.parentExpression ~= nil then
			do n.parentExpression:destroy() end
			n.parentExpression = nil
		end
		if self.parentExpression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.parentExpression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.parentExpression = pcp
			do n.parentExpression:setParent(n) end
		end
		if n.childExpression ~= nil then
			do n.childExpression:destroy() end
			n.childExpression = nil
		end
		if self.childExpression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.childExpression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.childExpression = pcp
			do n.childExpression:setParent(n) end
		end
		n.accessType = self.accessType
		do return true end
	end
end

function sling.model.MemberAccessExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.parentExpression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.parentExpression:destroy() end
		end
		self.parentExpression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.parentExpression ~= nil then
			do self.parentExpression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.childExpression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.childExpression:destroy() end
		end
		self.childExpression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.childExpression ~= nil then
			do self.childExpression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MemberAccessExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.parentExpression ~= nil then
		if self.parentExpression:accept(visitor) == false then
			do return false end
		end
	end
	if self.childExpression ~= nil then
		if self.childExpression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.MemberAccessExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.parentExpression ~= nil then
		do self.parentExpression:destroy() end
		self.parentExpression = nil
	end
	if self.childExpression ~= nil then
		do self.childExpression:destroy() end
		self.childExpression = nil
	end
end

function sling.model.MemberAccessExpressionNode:setParentExpression(v, doExport)
	if self.parentExpression ~= nil and doExport == false then
		do self.parentExpression:destroy() end
	end
	self.parentExpression = v
	if self.parentExpression ~= nil then
		do self.parentExpression:setParent(self) end
	end
end

function sling.model.MemberAccessExpressionNode:getParentExpression()
	do return self.parentExpression end
end

function sling.model.MemberAccessExpressionNode:exportParentExpression()
	local v = self.parentExpression
	self.parentExpression = nil
	do return v end
end

function sling.model.MemberAccessExpressionNode:setChildExpression(v, doExport)
	if self.childExpression ~= nil and doExport == false then
		do self.childExpression:destroy() end
	end
	self.childExpression = v
	if self.childExpression ~= nil then
		do self.childExpression:setParent(self) end
	end
end

function sling.model.MemberAccessExpressionNode:getChildExpression()
	do return self.childExpression end
end

function sling.model.MemberAccessExpressionNode:exportChildExpression()
	local v = self.childExpression
	self.childExpression = nil
	do return v end
end

function sling.model.MemberAccessExpressionNode:setAccessType(v)
	self.accessType = v
end

function sling.model.MemberAccessExpressionNode:getAccessType()
	do return self.accessType end
end

sling.model.IntegerDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.IntegerDataTypeNode.__index = sling.model.IntegerDataTypeNode
_vm:set_metatable(sling.model.IntegerDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

sling.model.IntegerDataTypeNode.TYPE_INT = 0
sling.model.IntegerDataTypeNode.TYPE_UINT = 1
sling.model.IntegerDataTypeNode.TYPE_SHORT = 2
sling.model.IntegerDataTypeNode.TYPE_USHORT = 3
sling.model.IntegerDataTypeNode.TYPE_LONG = 4
sling.model.IntegerDataTypeNode.TYPE_ULONG = 5
sling.model.IntegerDataTypeNode.TYPE_INT8 = 6
sling.model.IntegerDataTypeNode.TYPE_UINT8 = 7
sling.model.IntegerDataTypeNode.TYPE_INT16 = 8
sling.model.IntegerDataTypeNode.TYPE_UINT16 = 9
sling.model.IntegerDataTypeNode.TYPE_INT32 = 10
sling.model.IntegerDataTypeNode.TYPE_UINT32 = 11
sling.model.IntegerDataTypeNode.TYPE_INT64 = 12
sling.model.IntegerDataTypeNode.TYPE_UINT64 = 13

function sling.model.IntegerDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.IntegerDataTypeNode)
	return v
end

function sling.model.IntegerDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IntegerDataTypeNode'
	self['_isType.sling.model.IntegerDataTypeNode'] = true
	self.type = 0
end

function sling.model.IntegerDataTypeNode:_construct0()
	sling.model.IntegerDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.IntegerDataTypeNode:forType(type)
	local v = _g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create())
	do v:setType(type) end
	do return v end
end

function sling.model.IntegerDataTypeNode:getNodeTypeName()
	do return "IntegerDataTypeNode" end
end

function sling.model.IntegerDataTypeNode:createNew()
	do return _g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()) end
end

function sling.model.IntegerDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IntegerDataTypeNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.IntegerDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IntegerDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.IntegerDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

function sling.model.IntegerDataTypeNode:setType(v)
	self.type = v
end

function sling.model.IntegerDataTypeNode:getType()
	do return self.type end
end

sling.model.TupleDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.TupleDataTypeNode.__index = sling.model.TupleDataTypeNode
_vm:set_metatable(sling.model.TupleDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.TupleDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.TupleDataTypeNode)
	return v
end

function sling.model.TupleDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TupleDataTypeNode'
	self['_isType.sling.model.TupleDataTypeNode'] = true
	self.types = nil
end

function sling.model.TupleDataTypeNode:_construct0()
	sling.model.TupleDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.TupleDataTypeNode:forTypes(types)
	local v = _g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create())
	do v:setTypes(types, false) end
	do return v end
end

function sling.model.TupleDataTypeNode:getNodeTypeName()
	do return "TupleDataTypeNode" end
end

function sling.model.TupleDataTypeNode:createNew()
	do return _g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create()) end
end

function sling.model.TupleDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TupleDataTypeNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.types
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.types = nil
			if self.types ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.types)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.types[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.types == nil then
								n.types = {}
							end
							do _g.jk.lang.Vector:append(n.types, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.TupleDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.types, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TupleDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.types, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TupleDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

function sling.model.TupleDataTypeNode:setTypes(v, doExport)
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.types = nil
	else
		self.types = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.types, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TupleDataTypeNode:getTypes()
	do return self.types end
end

function sling.model.TupleDataTypeNode:exportTypes()
	local v = self.types
	self.types = nil
	do return v end
end

function sling.model.TupleDataTypeNode:addToTypes(v)
	if v == nil then
		do return end
	end
	if self.types == nil then
		self.types = {}
	end
	do _g.jk.lang.Vector:append(self.types, v) end
	do v:setParent(self) end
end

function sling.model.TupleDataTypeNode:clearTypes()
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

sling.model.BufferDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.BufferDataTypeNode.__index = sling.model.BufferDataTypeNode
_vm:set_metatable(sling.model.BufferDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.BufferDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.BufferDataTypeNode)
	return v
end

function sling.model.BufferDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BufferDataTypeNode'
	self['_isType.sling.model.BufferDataTypeNode'] = true
end

function sling.model.BufferDataTypeNode:_construct0()
	sling.model.BufferDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.BufferDataTypeNode:getNodeTypeName()
	do return "BufferDataTypeNode" end
end

function sling.model.BufferDataTypeNode:createNew()
	do return _g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()) end
end

function sling.model.BufferDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BufferDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BufferDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BufferDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BufferDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.VoidDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.VoidDataTypeNode.__index = sling.model.VoidDataTypeNode
_vm:set_metatable(sling.model.VoidDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.VoidDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.VoidDataTypeNode)
	return v
end

function sling.model.VoidDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VoidDataTypeNode'
	self['_isType.sling.model.VoidDataTypeNode'] = true
end

function sling.model.VoidDataTypeNode:_construct0()
	sling.model.VoidDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	do self:setIsNullable(false) end
	return self
end

function sling.model.VoidDataTypeNode:getNodeTypeName()
	do return "VoidDataTypeNode" end
end

function sling.model.VoidDataTypeNode:createNew()
	do return _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()) end
end

function sling.model.VoidDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VoidDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.VoidDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VoidDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.VoidDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.BitwiseXorExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.BitwiseXorExpressionNode.__index = sling.model.BitwiseXorExpressionNode
_vm:set_metatable(sling.model.BitwiseXorExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.BitwiseXorExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseXorExpressionNode)
	return v
end

function sling.model.BitwiseXorExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseXorExpressionNode'
	self['_isType.sling.model.BitwiseXorExpressionNode'] = true
end

function sling.model.BitwiseXorExpressionNode:_construct0()
	sling.model.BitwiseXorExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseXorExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseXorExpressionNode._construct0(_g.sling.model.BitwiseXorExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseXorExpressionNode:getNodeTypeName()
	do return "BitwiseXorExpressionNode" end
end

function sling.model.BitwiseXorExpressionNode:createNew()
	do return _g.sling.model.BitwiseXorExpressionNode._construct0(_g.sling.model.BitwiseXorExpressionNode._create()) end
end

function sling.model.BitwiseXorExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseXorExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseXorExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseXorExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseXorExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.CaseDefaultBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseDefaultBlockNode.__index = sling.model.CaseDefaultBlockNode
_vm:set_metatable(sling.model.CaseDefaultBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseDefaultBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseDefaultBlockNode)
	return v
end

function sling.model.CaseDefaultBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseDefaultBlockNode'
	self['_isType.sling.model.CaseDefaultBlockNode'] = true
end

function sling.model.CaseDefaultBlockNode:_construct0()
	sling.model.CaseDefaultBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseDefaultBlockNode:instance(bb)
	local v = _g.sling.model.CaseDefaultBlockNode._construct0(_g.sling.model.CaseDefaultBlockNode._create())
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseDefaultBlockNode:getNodeTypeName()
	do return "CaseDefaultBlockNode" end
end

function sling.model.CaseDefaultBlockNode:createNew()
	do return _g.sling.model.CaseDefaultBlockNode._construct0(_g.sling.model.CaseDefaultBlockNode._create()) end
end

function sling.model.CaseDefaultBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseDefaultBlockNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.CaseDefaultBlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseDefaultBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CaseDefaultBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
end

sling.model.PreDecrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PreDecrementExpressionNode.__index = sling.model.PreDecrementExpressionNode
_vm:set_metatable(sling.model.PreDecrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PreDecrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreDecrementExpressionNode)
	return v
end

function sling.model.PreDecrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreDecrementExpressionNode'
	self['_isType.sling.model.PreDecrementExpressionNode'] = true
end

function sling.model.PreDecrementExpressionNode:_construct0()
	sling.model.PreDecrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PreDecrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PreDecrementExpressionNode._construct0(_g.sling.model.PreDecrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PreDecrementExpressionNode:getNodeTypeName()
	do return "PreDecrementExpressionNode" end
end

function sling.model.PreDecrementExpressionNode:createNew()
	do return _g.sling.model.PreDecrementExpressionNode._construct0(_g.sling.model.PreDecrementExpressionNode._create()) end
end

function sling.model.PreDecrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreDecrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PreDecrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreDecrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreDecrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.CaseMultipleEqualsBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseMultipleEqualsBlockNode.__index = sling.model.CaseMultipleEqualsBlockNode
_vm:set_metatable(sling.model.CaseMultipleEqualsBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseMultipleEqualsBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseMultipleEqualsBlockNode)
	return v
end

function sling.model.CaseMultipleEqualsBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseMultipleEqualsBlockNode'
	self['_isType.sling.model.CaseMultipleEqualsBlockNode'] = true
	self.expressions = nil
end

function sling.model.CaseMultipleEqualsBlockNode:_construct0()
	sling.model.CaseMultipleEqualsBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseMultipleEqualsBlockNode:forVectorOfExpessions(expressions, bb)
	local v = _g.sling.model.CaseMultipleEqualsBlockNode._construct0(_g.sling.model.CaseMultipleEqualsBlockNode._create())
	if expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(expressions)
		do
			n = 0
			while n < m do
				local expression = expressions[n + 1]
				if expression ~= nil then
					do v:addToExpressions(expression) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseMultipleEqualsBlockNode:forVectorOfObjects(expressions, bb)
	local v = _g.sling.model.CaseMultipleEqualsBlockNode._construct0(_g.sling.model.CaseMultipleEqualsBlockNode._create())
	if expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(expressions)
		do
			n = 0
			while n < m do
				local expression = _vm:to_table_with_key(expressions[n + 1], '_isType.sling.common.ExpressionNode')
				if expression ~= nil then
					do v:addToExpressions(expression) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseMultipleEqualsBlockNode:getNodeTypeName()
	do return "CaseMultipleEqualsBlockNode" end
end

function sling.model.CaseMultipleEqualsBlockNode:createNew()
	do return _g.sling.model.CaseMultipleEqualsBlockNode._construct0(_g.sling.model.CaseMultipleEqualsBlockNode._create()) end
end

function sling.model.CaseMultipleEqualsBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseMultipleEqualsBlockNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.CaseMultipleEqualsBlockNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseMultipleEqualsBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CaseMultipleEqualsBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.CaseMultipleEqualsBlockNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CaseMultipleEqualsBlockNode:getExpressions()
	do return self.expressions end
end

function sling.model.CaseMultipleEqualsBlockNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.CaseMultipleEqualsBlockNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.CaseMultipleEqualsBlockNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.VariableReferenceDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.VariableReferenceDataTypeNode.__index = sling.model.VariableReferenceDataTypeNode
_vm:set_metatable(sling.model.VariableReferenceDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.VariableReferenceDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableReferenceDataTypeNode)
	return v
end

function sling.model.VariableReferenceDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableReferenceDataTypeNode'
	self['_isType.sling.model.VariableReferenceDataTypeNode'] = true
end

function sling.model.VariableReferenceDataTypeNode:_construct0()
	sling.model.VariableReferenceDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.VariableReferenceDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.VariableReferenceDataTypeNode._construct0(_g.sling.model.VariableReferenceDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.VariableReferenceDataTypeNode:getNodeTypeName()
	do return "VariableReferenceDataTypeNode" end
end

function sling.model.VariableReferenceDataTypeNode:createNew()
	do return _g.sling.model.VariableReferenceDataTypeNode._construct0(_g.sling.model.VariableReferenceDataTypeNode._create()) end
end

function sling.model.VariableReferenceDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableReferenceDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.VariableReferenceDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableReferenceDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.VariableReferenceDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.StrictNotEqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.StrictNotEqualsExpressionNode.__index = sling.model.StrictNotEqualsExpressionNode
_vm:set_metatable(sling.model.StrictNotEqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.StrictNotEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StrictNotEqualsExpressionNode)
	return v
end

function sling.model.StrictNotEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StrictNotEqualsExpressionNode'
	self['_isType.sling.model.StrictNotEqualsExpressionNode'] = true
end

function sling.model.StrictNotEqualsExpressionNode:_construct0()
	sling.model.StrictNotEqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.StrictNotEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.StrictNotEqualsExpressionNode._construct0(_g.sling.model.StrictNotEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StrictNotEqualsExpressionNode:getNodeTypeName()
	do return "StrictNotEqualsExpressionNode" end
end

function sling.model.StrictNotEqualsExpressionNode:createNew()
	do return _g.sling.model.StrictNotEqualsExpressionNode._construct0(_g.sling.model.StrictNotEqualsExpressionNode._create()) end
end

function sling.model.StrictNotEqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StrictNotEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StrictNotEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StrictNotEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StrictNotEqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.DoWhileStatementNode = _g.sling.common.NodeObject._create()
sling.model.DoWhileStatementNode.__index = sling.model.DoWhileStatementNode
_vm:set_metatable(sling.model.DoWhileStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.DoWhileStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.DoWhileStatementNode)
	return v
end

function sling.model.DoWhileStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DoWhileStatementNode'
	self['_isType.sling.model.DoWhileStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.condition = nil
	self.block = nil
end

function sling.model.DoWhileStatementNode:_construct0()
	sling.model.DoWhileStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.DoWhileStatementNode:instance(condition, block)
	local v = _g.sling.model.DoWhileStatementNode._construct0(_g.sling.model.DoWhileStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.DoWhileStatementNode:getNodeTypeName()
	do return "DoWhileStatementNode" end
end

function sling.model.DoWhileStatementNode:createNew()
	do return _g.sling.model.DoWhileStatementNode._construct0(_g.sling.model.DoWhileStatementNode._create()) end
end

function sling.model.DoWhileStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DoWhileStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DoWhileStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DoWhileStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DoWhileStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.DoWhileStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.DoWhileStatementNode:getCondition()
	do return self.condition end
end

function sling.model.DoWhileStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.DoWhileStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.DoWhileStatementNode:getBlock()
	do return self.block end
end

function sling.model.DoWhileStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.TupleExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.TupleExpressionNode.__index = sling.model.TupleExpressionNode
_vm:set_metatable(sling.model.TupleExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.TupleExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TupleExpressionNode)
	return v
end

function sling.model.TupleExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TupleExpressionNode'
	self['_isType.sling.model.TupleExpressionNode'] = true
	self.expressions = nil
end

function sling.model.TupleExpressionNode:_construct0()
	sling.model.TupleExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TupleExpressionNode:getNodeTypeName()
	do return "TupleExpressionNode" end
end

function sling.model.TupleExpressionNode:createNew()
	do return _g.sling.model.TupleExpressionNode._construct0(_g.sling.model.TupleExpressionNode._create()) end
end

function sling.model.TupleExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TupleExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.TupleExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TupleExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TupleExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.TupleExpressionNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TupleExpressionNode:getExpressions()
	do return self.expressions end
end

function sling.model.TupleExpressionNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.TupleExpressionNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.TupleExpressionNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.DecimalDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.DecimalDataTypeNode.__index = sling.model.DecimalDataTypeNode
_vm:set_metatable(sling.model.DecimalDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DecimalDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DecimalDataTypeNode)
	return v
end

function sling.model.DecimalDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DecimalDataTypeNode'
	self['_isType.sling.model.DecimalDataTypeNode'] = true
end

function sling.model.DecimalDataTypeNode:_construct0()
	sling.model.DecimalDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DecimalDataTypeNode:getNodeTypeName()
	do return "DecimalDataTypeNode" end
end

function sling.model.DecimalDataTypeNode:createNew()
	do return _g.sling.model.DecimalDataTypeNode._construct0(_g.sling.model.DecimalDataTypeNode._create()) end
end

function sling.model.DecimalDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DecimalDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DecimalDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DecimalDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DecimalDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.CharacterDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.CharacterDataTypeNode.__index = sling.model.CharacterDataTypeNode
_vm:set_metatable(sling.model.CharacterDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.CharacterDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.CharacterDataTypeNode)
	return v
end

function sling.model.CharacterDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CharacterDataTypeNode'
	self['_isType.sling.model.CharacterDataTypeNode'] = true
end

function sling.model.CharacterDataTypeNode:_construct0()
	sling.model.CharacterDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.CharacterDataTypeNode:getNodeTypeName()
	do return "CharacterDataTypeNode" end
end

function sling.model.CharacterDataTypeNode:createNew()
	do return _g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()) end
end

function sling.model.CharacterDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CharacterDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.CharacterDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CharacterDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CharacterDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.SubscriptExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.SubscriptExpressionNode.__index = sling.model.SubscriptExpressionNode
_vm:set_metatable(sling.model.SubscriptExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.SubscriptExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SubscriptExpressionNode)
	return v
end

function sling.model.SubscriptExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SubscriptExpressionNode'
	self['_isType.sling.model.SubscriptExpressionNode'] = true
	self.child = nil
	self.subscripts = nil
end

function sling.model.SubscriptExpressionNode:_construct0()
	sling.model.SubscriptExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.SubscriptExpressionNode:forExpression(child)
	local v = _g.sling.model.SubscriptExpressionNode._construct0(_g.sling.model.SubscriptExpressionNode._create())
	do v:setChild(child, false) end
	do return v end
end

function sling.model.SubscriptExpressionNode:instance(child, subscript)
	local v = _g.sling.model.SubscriptExpressionNode._construct0(_g.sling.model.SubscriptExpressionNode._create())
	do v:setChild(child, false) end
	do v:addToSubscripts(subscript) end
	do return v end
end

function sling.model.SubscriptExpressionNode:getSubscript()
	local ss = self:getSubscripts()
	if not (ss ~= nil) then
		do return nil end
	end
	if not (_g.jk.lang.Vector:getSize(ss) == 1) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(ss, 0), '_isType.sling.common.ExpressionNode') end
end

function sling.model.SubscriptExpressionNode:getNodeTypeName()
	do return "SubscriptExpressionNode" end
end

function sling.model.SubscriptExpressionNode:createNew()
	do return _g.sling.model.SubscriptExpressionNode._construct0(_g.sling.model.SubscriptExpressionNode._create()) end
end

function sling.model.SubscriptExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SubscriptExpressionNode')
		if n == nil then
			do return true end
		end
		if n.child ~= nil then
			do n.child:destroy() end
			n.child = nil
		end
		if self.child ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.child), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.child = pcp
			do n.child:setParent(n) end
		end
		do
			local array = n.subscripts
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.subscripts = nil
			if self.subscripts ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.subscripts)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.subscripts[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.subscripts == nil then
								n.subscripts = {}
							end
							do _g.jk.lang.Vector:append(n.subscripts, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SubscriptExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.child then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.child:destroy() end
		end
		self.child = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.child ~= nil then
			do self.child:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.subscripts, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SubscriptExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.child ~= nil then
		if self.child:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.subscripts, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SubscriptExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.child ~= nil then
		do self.child:destroy() end
		self.child = nil
	end
	if self.subscripts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.subscripts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.subscripts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.subscripts = nil
end

function sling.model.SubscriptExpressionNode:setChild(v, doExport)
	if self.child ~= nil and doExport == false then
		do self.child:destroy() end
	end
	self.child = v
	if self.child ~= nil then
		do self.child:setParent(self) end
	end
end

function sling.model.SubscriptExpressionNode:getChild()
	do return self.child end
end

function sling.model.SubscriptExpressionNode:exportChild()
	local v = self.child
	self.child = nil
	do return v end
end

function sling.model.SubscriptExpressionNode:setSubscripts(v, doExport)
	if self.subscripts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.subscripts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.subscripts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.subscripts = nil
	else
		self.subscripts = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.subscripts, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SubscriptExpressionNode:getSubscripts()
	do return self.subscripts end
end

function sling.model.SubscriptExpressionNode:exportSubscripts()
	local v = self.subscripts
	self.subscripts = nil
	do return v end
end

function sling.model.SubscriptExpressionNode:addToSubscripts(v)
	if v == nil then
		do return end
	end
	if self.subscripts == nil then
		self.subscripts = {}
	end
	do _g.jk.lang.Vector:append(self.subscripts, v) end
	do v:setParent(self) end
end

function sling.model.SubscriptExpressionNode:clearSubscripts()
	if self.subscripts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.subscripts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.subscripts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.subscripts = nil
end

sling.model.PropertyValueDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.PropertyValueDeclarationNode.__index = sling.model.PropertyValueDeclarationNode
_vm:set_metatable(sling.model.PropertyValueDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PropertyValueDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyValueDeclarationNode)
	return v
end

function sling.model.PropertyValueDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyValueDeclarationNode'
	self['_isType.sling.model.PropertyValueDeclarationNode'] = true
	self.key = nil
	self.index = nil
	self.keyParams = nil
	self.keyDimensions = nil
	self.value = nil
	self.comment = nil
	self.objectFlag = false
end

function sling.model.PropertyValueDeclarationNode:_construct0()
	sling.model.PropertyValueDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PropertyValueDeclarationNode:forName(name, value)
	local v = _g.sling.model.PropertyValueDeclarationNode._construct0(_g.sling.model.PropertyValueDeclarationNode._create())
	do v:setKey(name) end
	do v:setValue(value, false) end
	do return v end
end

function sling.model.PropertyValueDeclarationNode:hasName(value)
	if value == self.key then
		do return true end
	end
	do return false end
end

function sling.model.PropertyValueDeclarationNode:getValueString()
	local ss = _vm:to_table_with_key(self.value, '_isType.sling.model.StringLiteralExpressionNode')
	if ss ~= nil then
		do return ss:getValue() end
	end
	do
		local ii = _vm:to_table_with_key(self.value, '_isType.sling.model.IntegerLiteralExpressionNode')
		if ii ~= nil then
			do return _g.jk.lang.String:forInteger(ii:getValue()) end
		end
		do
			local dd = _vm:to_table_with_key(self.value, '_isType.sling.model.DoubleLiteralExpressionNode')
			if dd ~= nil then
				do return _g.jk.lang.String:forDouble(dd:getValue()) end
			end
			do
				local bb = _vm:to_table_with_key(self.value, '_isType.sling.model.BooleanLiteralExpressionNode')
				if bb ~= nil then
					do return _g.jk.lang.String:forBoolean(bb:getValue()) end
				end
				do return nil end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getValueInteger()
	local ss = _vm:to_table_with_key(self.value, '_isType.sling.model.StringLiteralExpressionNode')
	if ss ~= nil then
		do return _g.jk.lang.String:toInteger(ss:getValue()) end
	end
	do
		local ii = _vm:to_table_with_key(self.value, '_isType.sling.model.IntegerLiteralExpressionNode')
		if ii ~= nil then
			do return ii:getValue() end
		end
		do
			local dd = _vm:to_table_with_key(self.value, '_isType.sling.model.DoubleLiteralExpressionNode')
			if dd ~= nil then
				do return _util:convert_to_integer(dd:getValue()) end
			end
			do
				local bb = _vm:to_table_with_key(self.value, '_isType.sling.model.BooleanLiteralExpressionNode')
				if bb ~= nil then
					if bb:getValue() then
						do return 1 end
					end
					do return 0 end
				end
				do return 0 end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getValueDouble()
	local ss = _vm:to_table_with_key(self.value, '_isType.sling.model.StringLiteralExpressionNode')
	if ss ~= nil then
		do return _g.jk.lang.String:toDouble(ss:getValue()) end
	end
	do
		local ii = _vm:to_table_with_key(self.value, '_isType.sling.model.IntegerLiteralExpressionNode')
		if ii ~= nil then
			do return ii:getValue() end
		end
		do
			local dd = _vm:to_table_with_key(self.value, '_isType.sling.model.DoubleLiteralExpressionNode')
			if dd ~= nil then
				do return dd:getValue() end
			end
			do
				local bb = _vm:to_table_with_key(self.value, '_isType.sling.model.BooleanLiteralExpressionNode')
				if bb ~= nil then
					if bb:getValue() then
						do return 1.0 end
					end
					do return 0.0 end
				end
				do return 0.0 end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getValueBuffer()
	local xpr = _vm:to_table_with_key(self.value, '_isType.sling.model.BufferLiteralExpressionNode')
	if not (xpr ~= nil) then
		do return nil end
	end
	do return xpr:getValue() end
end

function sling.model.PropertyValueDeclarationNode:getNodeTypeName()
	do return "PropertyValueDeclarationNode" end
end

function sling.model.PropertyValueDeclarationNode:createNew()
	do return _g.sling.model.PropertyValueDeclarationNode._construct0(_g.sling.model.PropertyValueDeclarationNode._create()) end
end

function sling.model.PropertyValueDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyValueDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.index ~= nil then
			do n.index:destroy() end
			n.index = nil
		end
		if self.index ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.index), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.index = pcp
			do n.index:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.key = self.key
		n.comment = self.comment
		n.objectFlag = self.objectFlag
		do
			local array = n.keyParams
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.keyParams = nil
			if self.keyParams ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.keyParams)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.keyParams[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.keyParams == nil then
								n.keyParams = {}
							end
							do _g.jk.lang.Vector:append(n.keyParams, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.keyDimensions
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.keyDimensions = nil
				if self.keyDimensions ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.keyDimensions)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.keyDimensions[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.keyDimensions == nil then
									n.keyDimensions = {}
								end
								do _g.jk.lang.Vector:append(n.keyDimensions, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.index then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.index:destroy() end
		end
		self.index = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.index ~= nil then
			do self.index:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.keyParams, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.keyDimensions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyValueDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.index ~= nil then
		if self.index:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.keyParams, visitor) == false then
		do return false end
	end
	if self:visitVector(self.keyDimensions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertyValueDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.index ~= nil then
		do self.index:destroy() end
		self.index = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
	if self.keyParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.keyParams = nil
	if self.keyDimensions ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.keyDimensions)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.keyDimensions[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.keyDimensions = nil
end

function sling.model.PropertyValueDeclarationNode:setIndex(v, doExport)
	if self.index ~= nil and doExport == false then
		do self.index:destroy() end
	end
	self.index = v
	if self.index ~= nil then
		do self.index:setParent(self) end
	end
end

function sling.model.PropertyValueDeclarationNode:getIndex()
	do return self.index end
end

function sling.model.PropertyValueDeclarationNode:exportIndex()
	local v = self.index
	self.index = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.PropertyValueDeclarationNode:getValue()
	do return self.value end
end

function sling.model.PropertyValueDeclarationNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:setKey(v)
	self.key = v
end

function sling.model.PropertyValueDeclarationNode:getKey()
	do return self.key end
end

function sling.model.PropertyValueDeclarationNode:setComment(v)
	self.comment = v
end

function sling.model.PropertyValueDeclarationNode:getComment()
	do return self.comment end
end

function sling.model.PropertyValueDeclarationNode:setObjectFlag(v)
	self.objectFlag = v
end

function sling.model.PropertyValueDeclarationNode:getObjectFlag()
	do return self.objectFlag end
end

function sling.model.PropertyValueDeclarationNode:setKeyParams(v, doExport)
	if self.keyParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.keyParams = nil
	else
		self.keyParams = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.keyParams, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getKeyParams()
	do return self.keyParams end
end

function sling.model.PropertyValueDeclarationNode:exportKeyParams()
	local v = self.keyParams
	self.keyParams = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:addToKeyParams(v)
	if v == nil then
		do return end
	end
	if self.keyParams == nil then
		self.keyParams = {}
	end
	do _g.jk.lang.Vector:append(self.keyParams, v) end
	do v:setParent(self) end
end

function sling.model.PropertyValueDeclarationNode:clearKeyParams()
	if self.keyParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.keyParams = nil
end

function sling.model.PropertyValueDeclarationNode:setKeyDimensions(v, doExport)
	if self.keyDimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyDimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyDimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.keyDimensions = nil
	else
		self.keyDimensions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.keyDimensions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getKeyDimensions()
	do return self.keyDimensions end
end

function sling.model.PropertyValueDeclarationNode:exportKeyDimensions()
	local v = self.keyDimensions
	self.keyDimensions = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:addToKeyDimensions(v)
	if v == nil then
		do return end
	end
	if self.keyDimensions == nil then
		self.keyDimensions = {}
	end
	do _g.jk.lang.Vector:append(self.keyDimensions, v) end
	do v:setParent(self) end
end

function sling.model.PropertyValueDeclarationNode:clearKeyDimensions()
	if self.keyDimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyDimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyDimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.keyDimensions = nil
end

sling.model.AwaitExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.AwaitExpressionNode.__index = sling.model.AwaitExpressionNode
_vm:set_metatable(sling.model.AwaitExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.AwaitExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AwaitExpressionNode)
	return v
end

function sling.model.AwaitExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AwaitExpressionNode'
	self['_isType.sling.model.AwaitExpressionNode'] = true
end

function sling.model.AwaitExpressionNode:_construct0()
	sling.model.AwaitExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.AwaitExpressionNode:forExpression(expression)
	local v = _g.sling.model.AwaitExpressionNode._construct0(_g.sling.model.AwaitExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.AwaitExpressionNode:getNodeTypeName()
	do return "AwaitExpressionNode" end
end

function sling.model.AwaitExpressionNode:createNew()
	do return _g.sling.model.AwaitExpressionNode._construct0(_g.sling.model.AwaitExpressionNode._create()) end
end

function sling.model.AwaitExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AwaitExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AwaitExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AwaitExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AwaitExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.CaseLessThanBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseLessThanBlockNode.__index = sling.model.CaseLessThanBlockNode
_vm:set_metatable(sling.model.CaseLessThanBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseLessThanBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseLessThanBlockNode)
	return v
end

function sling.model.CaseLessThanBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseLessThanBlockNode'
	self['_isType.sling.model.CaseLessThanBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseLessThanBlockNode:_construct0()
	sling.model.CaseLessThanBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseLessThanBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseLessThanBlockNode._construct0(_g.sling.model.CaseLessThanBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseLessThanBlockNode:getNodeTypeName()
	do return "CaseLessThanBlockNode" end
end

function sling.model.CaseLessThanBlockNode:createNew()
	do return _g.sling.model.CaseLessThanBlockNode._construct0(_g.sling.model.CaseLessThanBlockNode._create()) end
end

function sling.model.CaseLessThanBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseLessThanBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseLessThanBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseLessThanBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseLessThanBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseLessThanBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseLessThanBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseLessThanBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.DoubleLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.DoubleLiteralExpressionNode.__index = sling.model.DoubleLiteralExpressionNode
_vm:set_metatable(sling.model.DoubleLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

sling.model.DoubleLiteralExpressionNode.FORMAT_DECIMAL = 0
sling.model.DoubleLiteralExpressionNode.FORMAT_HEXADECIMAL = 1

function sling.model.DoubleLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DoubleLiteralExpressionNode)
	return v
end

function sling.model.DoubleLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DoubleLiteralExpressionNode'
	self['_isType.sling.model.DoubleLiteralExpressionNode'] = true
	self.value = 0.0
	self.format = 0
end

function sling.model.DoubleLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.DoubleLiteralExpressionNode._construct0(_g.sling.model.DoubleLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.DoubleLiteralExpressionNode:_construct0()
	sling.model.DoubleLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()), false) end
	return self
end

function sling.model.DoubleLiteralExpressionNode:getNodeTypeName()
	do return "DoubleLiteralExpressionNode" end
end

function sling.model.DoubleLiteralExpressionNode:createNew()
	do return _g.sling.model.DoubleLiteralExpressionNode._construct0(_g.sling.model.DoubleLiteralExpressionNode._create()) end
end

function sling.model.DoubleLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DoubleLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		n.format = self.format
		do return true end
	end
end

function sling.model.DoubleLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DoubleLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DoubleLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.DoubleLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.DoubleLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.DoubleLiteralExpressionNode:setFormat(v)
	self.format = v
end

function sling.model.DoubleLiteralExpressionNode:getFormat()
	do return self.format end
end

sling.model.GoToLabelStatementNode = _g.sling.common.NodeObject._create()
sling.model.GoToLabelStatementNode.__index = sling.model.GoToLabelStatementNode
_vm:set_metatable(sling.model.GoToLabelStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.GoToLabelStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.GoToLabelStatementNode)
	return v
end

function sling.model.GoToLabelStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GoToLabelStatementNode'
	self['_isType.sling.model.GoToLabelStatementNode'] = true
	self.target = nil
end

function sling.model.GoToLabelStatementNode:_construct0()
	sling.model.GoToLabelStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.GoToLabelStatementNode:getNodeTypeName()
	do return "GoToLabelStatementNode" end
end

function sling.model.GoToLabelStatementNode:createNew()
	do return _g.sling.model.GoToLabelStatementNode._construct0(_g.sling.model.GoToLabelStatementNode._create()) end
end

function sling.model.GoToLabelStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GoToLabelStatementNode')
		if n == nil then
			do return true end
		end
		if n.target ~= nil then
			do n.target:destroy() end
			n.target = nil
		end
		if self.target ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.target), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.target = pcp
			do n.target:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GoToLabelStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.target then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.target:destroy() end
		end
		self.target = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.target ~= nil then
			do self.target:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GoToLabelStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.target ~= nil then
		if self.target:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GoToLabelStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.target ~= nil then
		do self.target:destroy() end
		self.target = nil
	end
end

function sling.model.GoToLabelStatementNode:setTarget(v, doExport)
	if self.target ~= nil and doExport == false then
		do self.target:destroy() end
	end
	self.target = v
	if self.target ~= nil then
		do self.target:setParent(self) end
	end
end

function sling.model.GoToLabelStatementNode:getTarget()
	do return self.target end
end

function sling.model.GoToLabelStatementNode:exportTarget()
	local v = self.target
	self.target = nil
	do return v end
end

sling.model.SetDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.SetDataTypeNode.__index = sling.model.SetDataTypeNode
_vm:set_metatable(sling.model.SetDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.SetDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.SetDataTypeNode)
	return v
end

function sling.model.SetDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SetDataTypeNode'
	self['_isType.sling.model.SetDataTypeNode'] = true
end

function sling.model.SetDataTypeNode:_construct0()
	sling.model.SetDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.SetDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.SetDataTypeNode._construct0(_g.sling.model.SetDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.SetDataTypeNode:getNodeTypeName()
	do return "SetDataTypeNode" end
end

function sling.model.SetDataTypeNode:createNew()
	do return _g.sling.model.SetDataTypeNode._construct0(_g.sling.model.SetDataTypeNode._create()) end
end

function sling.model.SetDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SetDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SetDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SetDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SetDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.CurrentObjectExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.CurrentObjectExpressionNode.__index = sling.model.CurrentObjectExpressionNode
_vm:set_metatable(sling.model.CurrentObjectExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.CurrentObjectExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.CurrentObjectExpressionNode)
	return v
end

function sling.model.CurrentObjectExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CurrentObjectExpressionNode'
	self['_isType.sling.model.CurrentObjectExpressionNode'] = true
end

function sling.model.CurrentObjectExpressionNode:_construct0()
	sling.model.CurrentObjectExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.CurrentObjectExpressionNode:getNodeTypeName()
	do return "CurrentObjectExpressionNode" end
end

function sling.model.CurrentObjectExpressionNode:createNew()
	do return _g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create()) end
end

function sling.model.CurrentObjectExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CurrentObjectExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.CurrentObjectExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CurrentObjectExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CurrentObjectExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

sling.model.AppendToVectorExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.AppendToVectorExpressionNode.__index = sling.model.AppendToVectorExpressionNode
_vm:set_metatable(sling.model.AppendToVectorExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.AppendToVectorExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AppendToVectorExpressionNode)
	return v
end

function sling.model.AppendToVectorExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AppendToVectorExpressionNode'
	self['_isType.sling.model.AppendToVectorExpressionNode'] = true
end

function sling.model.AppendToVectorExpressionNode:_construct0()
	sling.model.AppendToVectorExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.AppendToVectorExpressionNode:getNodeTypeName()
	do return "AppendToVectorExpressionNode" end
end

function sling.model.AppendToVectorExpressionNode:createNew()
	do return _g.sling.model.AppendToVectorExpressionNode._construct0(_g.sling.model.AppendToVectorExpressionNode._create()) end
end

function sling.model.AppendToVectorExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AppendToVectorExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AppendToVectorExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AppendToVectorExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AppendToVectorExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.FunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.FunctionDeclarationNode.__index = sling.model.FunctionDeclarationNode
_vm:set_metatable(sling.model.FunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.FunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDeclarationNode)
	return v
end

function sling.model.FunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDeclarationNode'
	self['_isType.sling.model.FunctionDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.returnType = nil
	self.symbol = nil
	self.baseClassDeclaration = nil
	self.implementedDeclarations = nil
	self.overridingDeclarations = nil
	self.baseClassDeclarationTypeMap = nil
end

function sling.model.FunctionDeclarationNode:_construct0()
	sling.model.FunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.FunctionDeclarationNode:forName(name, isPublic)
	local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
	do v:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
	do v:setSymbol(_g.sling.model.SymbolNode:forName(name)) end
	if isPublic then
		do v:addModifier(_g.sling.model.Modifier.PUBLIC) end
	end
	do return v end
end

function sling.model.FunctionDeclarationNode:getBaseClassDeclaration()
	do return self.baseClassDeclaration end
end

function sling.model.FunctionDeclarationNode:setBaseClassDeclaration(v, typemap)
	self.baseClassDeclaration = v
	self.baseClassDeclarationTypeMap = typemap
end

function sling.model.FunctionDeclarationNode:getOverridingDeclarations()
	do return self.overridingDeclarations end
end

function sling.model.FunctionDeclarationNode:setOverridingDeclarations(decls)
	self.overridingDeclarations = decls
end

function sling.model.FunctionDeclarationNode:addToOverridingDeclarations(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.overridingDeclarations ~= nil) then
		self.overridingDeclarations = {}
	end
	do _g.jk.lang.Vector:append(self.overridingDeclarations, decl) end
end

function sling.model.FunctionDeclarationNode:getImplementedDeclarations()
	do return self.implementedDeclarations end
end

function sling.model.FunctionDeclarationNode:setImplementedDeclarations(decls)
	self.implementedDeclarations = decls
end

function sling.model.FunctionDeclarationNode:addToImplementedDeclarations(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.implementedDeclarations ~= nil) then
		self.implementedDeclarations = {}
	end
	do _g.jk.lang.Vector:append(self.implementedDeclarations, decl) end
end

function sling.model.FunctionDeclarationNode:getName()
	local bc = self:getBaseClassDeclaration()
	if bc ~= nil then
		local v = bc:getName()
		if v ~= nil then
			do return v end
		end
	end
	if not (self.symbol ~= nil) then
		do return nil end
	end
	do
		local components = self.symbol:getComponents()
		if not (components ~= nil and _g.jk.lang.Vector:getSize(components) == 1) then
			do return nil end
		end
		do
			local comp = _vm:to_table_with_key(_g.jk.lang.Vector:getLast(components), '_isType.sling.model.SymbolNameComponentNode')
			if not (comp ~= nil) then
				do return nil end
			end
			do return comp:getName() end
		end
	end
end

function sling.model.FunctionDeclarationNode:getReturnType()
	local bc = self:getBaseClassDeclaration()
	if bc ~= nil then
		local v = bc:getReturnType()
		if v ~= nil then
			if not (self.baseClassDeclarationTypeMap ~= nil) then
				do return v end
			end
			do
				local ddt = self.baseClassDeclarationTypeMap:get(self:getReturnTypeQualifiedNameString(v))
				if ddt ~= nil then
					do return ddt end
				end
				do return v end
			end
		end
	end
	do return self.returnType end
end

function sling.model.FunctionDeclarationNode:getReturnTypeQualifiedNameString(baseReturnType)
	local bd = _vm:to_table_with_key(baseReturnType, '_isType.sling.model.ReferenceDataTypeNode')
	if not (bd ~= nil) then
		do return nil end
	end
	do
		local symbol = bd:getSymbol()
		if not (symbol ~= nil) then
			do return nil end
		end
		do
			local binding = _vm:to_table_with_key(symbol:getBinding(), '_isType.sling.model.EntityDeclarationNode')
			if not (binding ~= nil) then
				do return nil end
			end
			do
				local vv = {}
				local nn = binding
				while nn ~= nil do
					if not (nn ~= nil) then
						do break end
					end
					if (_vm:to_table_with_key(nn, '_isType.sling.common.NamedNode') ~= nil) then
						do _g.jk.lang.Vector:prepend(vv, nn:getNodeName()) end
					end
					do
						local pp = nn:getParent()
						nn = pp
					end
				end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					if vv ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(vv)
						do
							n = 0
							while n < m do
								local comp = (function(o)
									if (_vm:get_variable_type(o) == 'string') then
										do return o end
									end
									do return nil end
								end)(vv[n + 1])
								if comp ~= nil then
									if sb:count() > 0 then
										do sb:appendCharacter(46) end
									end
									do sb:appendString(comp) end
								end
								do n = n + 1 end
							end
						end
					end
					do return sb:toString() end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationNode:getOwnReturnType()
	do return self.returnType end
end

function sling.model.FunctionDeclarationNode:dupDeclaration()
	local v = _vm:to_table_with_key(self:dup(), '_isType.sling.model.FunctionDeclarationNode')
	if not (v ~= nil) then
		do return nil end
	end
	do v:setBody(nil, false) end
	do return v end
end

function sling.model.FunctionDeclarationNode:getNodeName()
	local bc = self:getBaseClassDeclaration()
	if bc ~= nil then
		local v = bc:getNodeName()
		if v ~= nil then
			do return v end
		end
	end
	do return self:getName() end
end

function sling.model.FunctionDeclarationNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.FunctionDeclarationNode:setName(name)
	do self:setSymbol(_g.sling.model.SymbolNode:forName(name)) end
end

function sling.model.FunctionDeclarationNode:setSymbol(sym)
	if self.symbol ~= nil then
		do self.symbol:destroy() end
	end
	self.symbol = sym
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
	do self:onIndexPropertiesChanged() end
end

function sling.model.FunctionDeclarationNode:getSymbol()
	do return self.symbol end
end

function sling.model.FunctionDeclarationNode:getNodeTypeName()
	do return "FunctionDeclarationNode" end
end

function sling.model.FunctionDeclarationNode:createNew()
	do return _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create()) end
end

function sling.model.FunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.returnType ~= nil then
			do n.returnType:destroy() end
			n.returnType = nil
		end
		if self.returnType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.returnType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.returnType = pcp
			do n.returnType:setParent(n) end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.FunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.returnType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.returnType:destroy() end
		end
		self.returnType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.returnType ~= nil then
			do self.returnType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.returnType ~= nil then
		if self.returnType:accept(visitor) == false then
			do return false end
		end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.FunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
	if self.returnType ~= nil then
		do self.returnType:destroy() end
		self.returnType = nil
	end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.FunctionDeclarationNode:setReturnType(v, doExport)
	if self.returnType ~= nil and doExport == false then
		do self.returnType:destroy() end
	end
	self.returnType = v
	if self.returnType ~= nil then
		do self.returnType:setParent(self) end
	end
end

function sling.model.FunctionDeclarationNode:exportReturnType()
	local v = self.returnType
	self.returnType = nil
	do return v end
end

function sling.model.FunctionDeclarationNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.ConstrainedDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.ConstrainedDataTypeNode.__index = sling.model.ConstrainedDataTypeNode
_vm:set_metatable(sling.model.ConstrainedDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.ConstrainedDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ConstrainedDataTypeNode)
	return v
end

function sling.model.ConstrainedDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ConstrainedDataTypeNode'
	self['_isType.sling.model.ConstrainedDataTypeNode'] = true
	self.baseTypes = nil
end

function sling.model.ConstrainedDataTypeNode:_construct0()
	sling.model.ConstrainedDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.ConstrainedDataTypeNode:forPrimaryType(pt)
	local v = _g.sling.model.ConstrainedDataTypeNode._construct0(_g.sling.model.ConstrainedDataTypeNode._create())
	do v:setPrimaryType(pt, false) end
	do return v end
end

function sling.model.ConstrainedDataTypeNode:getNodeTypeName()
	do return "ConstrainedDataTypeNode" end
end

function sling.model.ConstrainedDataTypeNode:createNew()
	do return _g.sling.model.ConstrainedDataTypeNode._construct0(_g.sling.model.ConstrainedDataTypeNode._create()) end
end

function sling.model.ConstrainedDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ConstrainedDataTypeNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.baseTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.baseTypes = nil
			if self.baseTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.baseTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.baseTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.baseTypes == nil then
								n.baseTypes = {}
							end
							do _g.jk.lang.Vector:append(n.baseTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ConstrainedDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.baseTypes, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ConstrainedDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.baseTypes, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ConstrainedDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
end

function sling.model.ConstrainedDataTypeNode:setBaseTypes(v, doExport)
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.baseTypes = nil
	else
		self.baseTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.baseTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ConstrainedDataTypeNode:getBaseTypes()
	do return self.baseTypes end
end

function sling.model.ConstrainedDataTypeNode:exportBaseTypes()
	local v = self.baseTypes
	self.baseTypes = nil
	do return v end
end

function sling.model.ConstrainedDataTypeNode:addToBaseTypes(v)
	if v == nil then
		do return end
	end
	if self.baseTypes == nil then
		self.baseTypes = {}
	end
	do _g.jk.lang.Vector:append(self.baseTypes, v) end
	do v:setParent(self) end
end

function sling.model.ConstrainedDataTypeNode:clearBaseTypes()
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
end

sling.model.PrintLineStatementNode = _g.sling.common.NodeObject._create()
sling.model.PrintLineStatementNode.__index = sling.model.PrintLineStatementNode
_vm:set_metatable(sling.model.PrintLineStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PrintLineStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.PrintLineStatementNode)
	return v
end

function sling.model.PrintLineStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PrintLineStatementNode'
	self['_isType.sling.model.PrintLineStatementNode'] = true
	self.expression = nil
end

function sling.model.PrintLineStatementNode:_construct0()
	sling.model.PrintLineStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PrintLineStatementNode:forExpression(expression)
	local v = _g.sling.model.PrintLineStatementNode._construct0(_g.sling.model.PrintLineStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PrintLineStatementNode:getNodeTypeName()
	do return "PrintLineStatementNode" end
end

function sling.model.PrintLineStatementNode:createNew()
	do return _g.sling.model.PrintLineStatementNode._construct0(_g.sling.model.PrintLineStatementNode._create()) end
end

function sling.model.PrintLineStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PrintLineStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PrintLineStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PrintLineStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PrintLineStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.PrintLineStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.PrintLineStatementNode:getExpression()
	do return self.expression end
end

function sling.model.PrintLineStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.MultiplicationAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.MultiplicationAssignmentExpressionNode.__index = sling.model.MultiplicationAssignmentExpressionNode
_vm:set_metatable(sling.model.MultiplicationAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.MultiplicationAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MultiplicationAssignmentExpressionNode)
	return v
end

function sling.model.MultiplicationAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultiplicationAssignmentExpressionNode'
	self['_isType.sling.model.MultiplicationAssignmentExpressionNode'] = true
end

function sling.model.MultiplicationAssignmentExpressionNode:_construct0()
	sling.model.MultiplicationAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.MultiplicationAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.MultiplicationAssignmentExpressionNode._construct0(_g.sling.model.MultiplicationAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.MultiplicationAssignmentExpressionNode:getNodeTypeName()
	do return "MultiplicationAssignmentExpressionNode" end
end

function sling.model.MultiplicationAssignmentExpressionNode:createNew()
	do return _g.sling.model.MultiplicationAssignmentExpressionNode._construct0(_g.sling.model.MultiplicationAssignmentExpressionNode._create()) end
end

function sling.model.MultiplicationAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultiplicationAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MultiplicationAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultiplicationAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultiplicationAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.StaticCastExpressionNode = _g.sling.model.TypeCastExpressionNode._create()
sling.model.StaticCastExpressionNode.__index = sling.model.StaticCastExpressionNode
_vm:set_metatable(sling.model.StaticCastExpressionNode, {
	__index = _g.sling.model.TypeCastExpressionNode
})

sling.model.StaticCastExpressionNode.TYPE_REFERENCE = 0
sling.model.StaticCastExpressionNode.TYPE_PRIMITIVE = 1

function sling.model.StaticCastExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StaticCastExpressionNode)
	return v
end

function sling.model.StaticCastExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StaticCastExpressionNode'
	self['_isType.sling.model.StaticCastExpressionNode'] = true
	self.castType = 0
end

function sling.model.StaticCastExpressionNode:_construct0()
	sling.model.StaticCastExpressionNode._init(self)
	do _g.sling.model.TypeCastExpressionNode._construct0(self) end
	return self
end

function sling.model.StaticCastExpressionNode:instance(type, expression)
	local v = _g.sling.model.StaticCastExpressionNode._construct0(_g.sling.model.StaticCastExpressionNode._create())
	do v:setType(type, false) end
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.StaticCastExpressionNode:getNodeTypeName()
	do return "StaticCastExpressionNode" end
end

function sling.model.StaticCastExpressionNode:createNew()
	do return _g.sling.model.StaticCastExpressionNode._construct0(_g.sling.model.StaticCastExpressionNode._create()) end
end

function sling.model.StaticCastExpressionNode:copyTo(o)
	if _g.sling.model.TypeCastExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StaticCastExpressionNode')
		if n == nil then
			do return true end
		end
		n.castType = self.castType
		do return true end
	end
end

function sling.model.StaticCastExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.TypeCastExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StaticCastExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.TypeCastExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StaticCastExpressionNode:destroy()
	do _g.sling.model.TypeCastExpressionNode.destroy(self) end
end

function sling.model.StaticCastExpressionNode:setCastType(v)
	self.castType = v
end

function sling.model.StaticCastExpressionNode:getCastType()
	do return self.castType end
end

sling.model.StringEqualsExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.StringEqualsExpressionNode.__index = sling.model.StringEqualsExpressionNode
_vm:set_metatable(sling.model.StringEqualsExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.StringEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringEqualsExpressionNode)
	return v
end

function sling.model.StringEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringEqualsExpressionNode'
	self['_isType.sling.model.StringEqualsExpressionNode'] = true
end

function sling.model.StringEqualsExpressionNode:_construct0()
	sling.model.StringEqualsExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.StringEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.StringEqualsExpressionNode._construct0(_g.sling.model.StringEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StringEqualsExpressionNode:getNodeTypeName()
	do return "StringEqualsExpressionNode" end
end

function sling.model.StringEqualsExpressionNode:createNew()
	do return _g.sling.model.StringEqualsExpressionNode._construct0(_g.sling.model.StringEqualsExpressionNode._create()) end
end

function sling.model.StringEqualsExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StringEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringEqualsExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.CaseNotEqualsBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseNotEqualsBlockNode.__index = sling.model.CaseNotEqualsBlockNode
_vm:set_metatable(sling.model.CaseNotEqualsBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseNotEqualsBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseNotEqualsBlockNode)
	return v
end

function sling.model.CaseNotEqualsBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseNotEqualsBlockNode'
	self['_isType.sling.model.CaseNotEqualsBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseNotEqualsBlockNode:_construct0()
	sling.model.CaseNotEqualsBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseNotEqualsBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseNotEqualsBlockNode._construct0(_g.sling.model.CaseNotEqualsBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseNotEqualsBlockNode:getNodeTypeName()
	do return "CaseNotEqualsBlockNode" end
end

function sling.model.CaseNotEqualsBlockNode:createNew()
	do return _g.sling.model.CaseNotEqualsBlockNode._construct0(_g.sling.model.CaseNotEqualsBlockNode._create()) end
end

function sling.model.CaseNotEqualsBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseNotEqualsBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseNotEqualsBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseNotEqualsBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseNotEqualsBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseNotEqualsBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseNotEqualsBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseNotEqualsBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.MultipleExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.MultipleExpressionNode.__index = sling.model.MultipleExpressionNode
_vm:set_metatable(sling.model.MultipleExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.MultipleExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MultipleExpressionNode)
	return v
end

function sling.model.MultipleExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultipleExpressionNode'
	self['_isType.sling.model.MultipleExpressionNode'] = true
	self.expressions = nil
end

function sling.model.MultipleExpressionNode:_construct0()
	sling.model.MultipleExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.MultipleExpressionNode:getNodeTypeName()
	do return "MultipleExpressionNode" end
end

function sling.model.MultipleExpressionNode:createNew()
	do return _g.sling.model.MultipleExpressionNode._construct0(_g.sling.model.MultipleExpressionNode._create()) end
end

function sling.model.MultipleExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultipleExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MultipleExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultipleExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultipleExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.MultipleExpressionNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MultipleExpressionNode:getExpressions()
	do return self.expressions end
end

function sling.model.MultipleExpressionNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.MultipleExpressionNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.MultipleExpressionNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.SetLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.SetLiteralExpressionNode.__index = sling.model.SetLiteralExpressionNode
_vm:set_metatable(sling.model.SetLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.SetLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SetLiteralExpressionNode)
	return v
end

function sling.model.SetLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SetLiteralExpressionNode'
	self['_isType.sling.model.SetLiteralExpressionNode'] = true
	self.values = nil
end

function sling.model.SetLiteralExpressionNode:_construct0()
	sling.model.SetLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.SetDataTypeNode._construct0(_g.sling.model.SetDataTypeNode._create()), false) end
	return self
end

function sling.model.SetLiteralExpressionNode:getNodeTypeName()
	do return "SetLiteralExpressionNode" end
end

function sling.model.SetLiteralExpressionNode:createNew()
	do return _g.sling.model.SetLiteralExpressionNode._construct0(_g.sling.model.SetLiteralExpressionNode._create()) end
end

function sling.model.SetLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SetLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.values
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.values = nil
			if self.values ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.values)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.values[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.values == nil then
								n.values = {}
							end
							do _g.jk.lang.Vector:append(n.values, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SetLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.values, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SetLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.values, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SetLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

function sling.model.SetLiteralExpressionNode:setValues(v, doExport)
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.values = nil
	else
		self.values = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.values, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SetLiteralExpressionNode:getValues()
	do return self.values end
end

function sling.model.SetLiteralExpressionNode:exportValues()
	local v = self.values
	self.values = nil
	do return v end
end

function sling.model.SetLiteralExpressionNode:addToValues(v)
	if v == nil then
		do return end
	end
	if self.values == nil then
		self.values = {}
	end
	do _g.jk.lang.Vector:append(self.values, v) end
	do v:setParent(self) end
end

function sling.model.SetLiteralExpressionNode:clearValues()
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

sling.model.ForEachStatementNode = _g.sling.common.NodeObject._create()
sling.model.ForEachStatementNode.__index = sling.model.ForEachStatementNode
_vm:set_metatable(sling.model.ForEachStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ForEachStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ForEachStatementNode)
	return v
end

function sling.model.ForEachStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ForEachStatementNode'
	self['_isType.sling.model.ForEachStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.lefts = nil
	self.right = nil
	self.block = nil
	self.condition = nil
	self.elseBlock = nil
	self.defaultDataType = nil
	self.iterateKeys = false
end

function sling.model.ForEachStatementNode:_construct0()
	sling.model.ForEachStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ForEachStatementNode:instance(left, right, block, elseBlock)
	local v = _g.sling.model.ForEachStatementNode._construct0(_g.sling.model.ForEachStatementNode._create())
	do v:setLeft(left) end
	do v:setRight(right, false) end
	do v:setBlock(block, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.ForEachStatementNode:getLeft()
	if not (self.lefts ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.lefts, 0), '_isType.sling.common.NodeObject') end
end

function sling.model.ForEachStatementNode:getLeftCount()
	if not (self.lefts ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.lefts) end
end

function sling.model.ForEachStatementNode:setLeft(value)
	do self:setLefts(nil, false) end
	do self:addToLefts(value) end
	do return self end
end

function sling.model.ForEachStatementNode:exportLeft()
	local v = self:getLeft()
	self.lefts = nil
	do return v end
end

function sling.model.ForEachStatementNode:getNodeTypeName()
	do return "ForEachStatementNode" end
end

function sling.model.ForEachStatementNode:createNew()
	do return _g.sling.model.ForEachStatementNode._construct0(_g.sling.model.ForEachStatementNode._create()) end
end

function sling.model.ForEachStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ForEachStatementNode')
		if n == nil then
			do return true end
		end
		if n.right ~= nil then
			do n.right:destroy() end
			n.right = nil
		end
		if self.right ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.right), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.right = pcp
			do n.right:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		if n.defaultDataType ~= nil then
			do n.defaultDataType:destroy() end
			n.defaultDataType = nil
		end
		if self.defaultDataType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.defaultDataType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.defaultDataType = pcp
			do n.defaultDataType:setParent(n) end
		end
		n.iterateKeys = self.iterateKeys
		do
			local array = n.lefts
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.lefts = nil
			if self.lefts ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.lefts)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.lefts[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.lefts == nil then
								n.lefts = {}
							end
							do _g.jk.lang.Vector:append(n.lefts, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ForEachStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.right then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.right:destroy() end
		end
		self.right = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.right ~= nil then
			do self.right:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.defaultDataType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.defaultDataType:destroy() end
		end
		self.defaultDataType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.defaultDataType ~= nil then
			do self.defaultDataType:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.lefts, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ForEachStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.right ~= nil then
		if self.right:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.defaultDataType ~= nil then
		if self.defaultDataType:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.lefts, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ForEachStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.right ~= nil then
		do self.right:destroy() end
		self.right = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.defaultDataType ~= nil then
		do self.defaultDataType:destroy() end
		self.defaultDataType = nil
	end
	if self.lefts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.lefts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.lefts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.lefts = nil
end

function sling.model.ForEachStatementNode:setRight(v, doExport)
	if self.right ~= nil and doExport == false then
		do self.right:destroy() end
	end
	self.right = v
	if self.right ~= nil then
		do self.right:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getRight()
	do return self.right end
end

function sling.model.ForEachStatementNode:exportRight()
	local v = self.right
	self.right = nil
	do return v end
end

function sling.model.ForEachStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getBlock()
	do return self.block end
end

function sling.model.ForEachStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.ForEachStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getCondition()
	do return self.condition end
end

function sling.model.ForEachStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.ForEachStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.ForEachStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.ForEachStatementNode:setDefaultDataType(v, doExport)
	if self.defaultDataType ~= nil and doExport == false then
		do self.defaultDataType:destroy() end
	end
	self.defaultDataType = v
	if self.defaultDataType ~= nil then
		do self.defaultDataType:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getDefaultDataType()
	do return self.defaultDataType end
end

function sling.model.ForEachStatementNode:exportDefaultDataType()
	local v = self.defaultDataType
	self.defaultDataType = nil
	do return v end
end

function sling.model.ForEachStatementNode:setIterateKeys(v)
	self.iterateKeys = v
end

function sling.model.ForEachStatementNode:getIterateKeys()
	do return self.iterateKeys end
end

function sling.model.ForEachStatementNode:setLefts(v, doExport)
	if self.lefts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.lefts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.lefts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.lefts = nil
	else
		self.lefts = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.lefts, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ForEachStatementNode:getLefts()
	do return self.lefts end
end

function sling.model.ForEachStatementNode:exportLefts()
	local v = self.lefts
	self.lefts = nil
	do return v end
end

function sling.model.ForEachStatementNode:addToLefts(v)
	if v == nil then
		do return end
	end
	if self.lefts == nil then
		self.lefts = {}
	end
	do _g.jk.lang.Vector:append(self.lefts, v) end
	do v:setParent(self) end
end

function sling.model.ForEachStatementNode:clearLefts()
	if self.lefts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.lefts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.lefts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.lefts = nil
end

sling.model.ForStatementNode = _g.sling.common.NodeObject._create()
sling.model.ForStatementNode.__index = sling.model.ForStatementNode
_vm:set_metatable(sling.model.ForStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ForStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ForStatementNode)
	return v
end

function sling.model.ForStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ForStatementNode'
	self['_isType.sling.model.ForStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.initializer = nil
	self.condition = nil
	self.finalizer = nil
	self.block = nil
end

function sling.model.ForStatementNode:_construct0()
	sling.model.ForStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ForStatementNode:instance(initializer, condition, finalizer, block)
	local v = _g.sling.model.ForStatementNode._construct0(_g.sling.model.ForStatementNode._create())
	do v:setInitializer(initializer, false) end
	do v:setCondition(condition, false) end
	do v:setFinalizer(finalizer, false) end
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.ForStatementNode:addInitializer(node)
	if node ~= nil then
		if self.initializer == nil then
			do self:setInitializer(_g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()), false) end
		end
		do self.initializer:addNode(node) end
	end
	do return self end
end

function sling.model.ForStatementNode:addFinalizer(node)
	if node ~= nil then
		if self.finalizer == nil then
			do self:setFinalizer(_g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()), false) end
		end
		do self.finalizer:addNode(node) end
	end
	do return self end
end

function sling.model.ForStatementNode:getNodeTypeName()
	do return "ForStatementNode" end
end

function sling.model.ForStatementNode:createNew()
	do return _g.sling.model.ForStatementNode._construct0(_g.sling.model.ForStatementNode._create()) end
end

function sling.model.ForStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ForStatementNode')
		if n == nil then
			do return true end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.finalizer ~= nil then
			do n.finalizer:destroy() end
			n.finalizer = nil
		end
		if self.finalizer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.finalizer), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.finalizer = pcp
			do n.finalizer:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ForStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.finalizer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.finalizer:destroy() end
		end
		self.finalizer = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.finalizer ~= nil then
			do self.finalizer:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ForStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.finalizer ~= nil then
		if self.finalizer:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ForStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.finalizer ~= nil then
		do self.finalizer:destroy() end
		self.finalizer = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.ForStatementNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.ForStatementNode:getInitializer()
	do return self.initializer end
end

function sling.model.ForStatementNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.ForStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.ForStatementNode:getCondition()
	do return self.condition end
end

function sling.model.ForStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.ForStatementNode:setFinalizer(v, doExport)
	if self.finalizer ~= nil and doExport == false then
		do self.finalizer:destroy() end
	end
	self.finalizer = v
	if self.finalizer ~= nil then
		do self.finalizer:setParent(self) end
	end
end

function sling.model.ForStatementNode:getFinalizer()
	do return self.finalizer end
end

function sling.model.ForStatementNode:exportFinalizer()
	local v = self.finalizer
	self.finalizer = nil
	do return v end
end

function sling.model.ForStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.ForStatementNode:getBlock()
	do return self.block end
end

function sling.model.ForStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.MultipleVariableDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.MultipleVariableDeclarationNode.__index = sling.model.MultipleVariableDeclarationNode
_vm:set_metatable(sling.model.MultipleVariableDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.MultipleVariableDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.MultipleVariableDeclarationNode)
	return v
end

function sling.model.MultipleVariableDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultipleVariableDeclarationNode'
	self['_isType.sling.model.MultipleVariableDeclarationNode'] = true
	self.type = nil
	self.variables = nil
	self.initializer = nil
end

function sling.model.MultipleVariableDeclarationNode:_construct0()
	sling.model.MultipleVariableDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.MultipleVariableDeclarationNode:forType(type)
	local v = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:forArrayOfVariables(type, variables)
	local v = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
	do v:setType(type, false) end
	if variables ~= nil then
		local n = 0
		local m = #variables
		do
			n = 0
			while n < m do
				local variable = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(variables[n + 1])
				if variable ~= nil then
					do v:addToVariables(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), variable, nil)) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:forVectorOfVariables(type, variables)
	local v = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
	do v:setType(type, false) end
	if variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(variables)
		do
			n = 0
			while n < m do
				local variable = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(variables[n + 1])
				if variable ~= nil then
					do v:addToVariables(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), variable, nil)) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:getNodeTypeName()
	do return "MultipleVariableDeclarationNode" end
end

function sling.model.MultipleVariableDeclarationNode:createNew()
	do return _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create()) end
end

function sling.model.MultipleVariableDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultipleVariableDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		do
			local array = n.variables
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.variables = nil
			if self.variables ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.variables)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.variables[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.variables == nil then
								n.variables = {}
							end
							do _g.jk.lang.Vector:append(n.variables, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MultipleVariableDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.variables, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultipleVariableDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.variables, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultipleVariableDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
	if self.variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.variables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.variables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.variables = nil
end

function sling.model.MultipleVariableDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.MultipleVariableDeclarationNode:getType()
	do return self.type end
end

function sling.model.MultipleVariableDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.MultipleVariableDeclarationNode:getInitializer()
	do return self.initializer end
end

function sling.model.MultipleVariableDeclarationNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:setVariables(v, doExport)
	if self.variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.variables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.variables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.variables = nil
	else
		self.variables = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.variables, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MultipleVariableDeclarationNode:getVariables()
	do return self.variables end
end

function sling.model.MultipleVariableDeclarationNode:exportVariables()
	local v = self.variables
	self.variables = nil
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:addToVariables(v)
	if v == nil then
		do return end
	end
	if self.variables == nil then
		self.variables = {}
	end
	do _g.jk.lang.Vector:append(self.variables, v) end
	do v:setParent(self) end
end

function sling.model.MultipleVariableDeclarationNode:clearVariables()
	if self.variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.variables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.variables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.variables = nil
end

sling.model.StaticBlockDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.StaticBlockDeclarationNode.__index = sling.model.StaticBlockDeclarationNode
_vm:set_metatable(sling.model.StaticBlockDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.StaticBlockDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.StaticBlockDeclarationNode)
	return v
end

function sling.model.StaticBlockDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StaticBlockDeclarationNode'
	self['_isType.sling.model.StaticBlockDeclarationNode'] = true
	self.block = nil
end

function sling.model.StaticBlockDeclarationNode:_construct0()
	sling.model.StaticBlockDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.StaticBlockDeclarationNode:forBlock(block)
	local v = _g.sling.model.StaticBlockDeclarationNode._construct0(_g.sling.model.StaticBlockDeclarationNode._create())
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.StaticBlockDeclarationNode:getNodeTypeName()
	do return "StaticBlockDeclarationNode" end
end

function sling.model.StaticBlockDeclarationNode:createNew()
	do return _g.sling.model.StaticBlockDeclarationNode._construct0(_g.sling.model.StaticBlockDeclarationNode._create()) end
end

function sling.model.StaticBlockDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StaticBlockDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StaticBlockDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StaticBlockDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StaticBlockDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.StaticBlockDeclarationNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.StaticBlockDeclarationNode:getBlock()
	do return self.block end
end

function sling.model.StaticBlockDeclarationNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.PromiseLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.PromiseLiteralExpressionNode.__index = sling.model.PromiseLiteralExpressionNode
_vm:set_metatable(sling.model.PromiseLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.PromiseLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PromiseLiteralExpressionNode)
	return v
end

function sling.model.PromiseLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PromiseLiteralExpressionNode'
	self['_isType.sling.model.PromiseLiteralExpressionNode'] = true
	self.type = nil
	self.body = nil
end

function sling.model.PromiseLiteralExpressionNode:_construct0()
	sling.model.PromiseLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	return self
end

function sling.model.PromiseLiteralExpressionNode:getNodeTypeName()
	do return "PromiseLiteralExpressionNode" end
end

function sling.model.PromiseLiteralExpressionNode:createNew()
	do return _g.sling.model.PromiseLiteralExpressionNode._construct0(_g.sling.model.PromiseLiteralExpressionNode._create()) end
end

function sling.model.PromiseLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PromiseLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PromiseLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PromiseLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PromiseLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
end

function sling.model.PromiseLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.PromiseLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.PromiseLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.PromiseLiteralExpressionNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.PromiseLiteralExpressionNode:getBody()
	do return self.body end
end

function sling.model.PromiseLiteralExpressionNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

sling.model.LogicalAndExpressionNode = _g.sling.model.LogicalExpressionNode._create()
sling.model.LogicalAndExpressionNode.__index = sling.model.LogicalAndExpressionNode
_vm:set_metatable(sling.model.LogicalAndExpressionNode, {
	__index = _g.sling.model.LogicalExpressionNode
})

function sling.model.LogicalAndExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalAndExpressionNode)
	return v
end

function sling.model.LogicalAndExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalAndExpressionNode'
	self['_isType.sling.model.LogicalAndExpressionNode'] = true
end

function sling.model.LogicalAndExpressionNode:_construct0()
	sling.model.LogicalAndExpressionNode._init(self)
	do _g.sling.model.LogicalExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalAndExpressionNode:instance(left, right)
	local v = _g.sling.model.LogicalAndExpressionNode._construct0(_g.sling.model.LogicalAndExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LogicalAndExpressionNode:forExpressions(expressions)
	local cs = _g.jk.lang.Vector:getSize(expressions)
	if not (cs > 0) then
		do return nil end
	end
	if cs == 1 then
		do return _vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, 0), '_isType.sling.common.ExpressionNode') end
	end
	do
		local v = _g.sling.model.LogicalAndExpressionNode:instance(_vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, 0), '_isType.sling.common.ExpressionNode'), _vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, 1), '_isType.sling.common.ExpressionNode'))
		do
			local n = 2
			while n < cs do
				v = _g.sling.model.LogicalAndExpressionNode:instance(v, _vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, n), '_isType.sling.common.ExpressionNode'))
				do n = n + 1 end
			end
		end
		do return v end
	end
end

function sling.model.LogicalAndExpressionNode:getNodeTypeName()
	do return "LogicalAndExpressionNode" end
end

function sling.model.LogicalAndExpressionNode:createNew()
	do return _g.sling.model.LogicalAndExpressionNode._construct0(_g.sling.model.LogicalAndExpressionNode._create()) end
end

function sling.model.LogicalAndExpressionNode:copyTo(o)
	if _g.sling.model.LogicalExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalAndExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalAndExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LogicalExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalAndExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LogicalExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalAndExpressionNode:destroy()
	do _g.sling.model.LogicalExpressionNode.destroy(self) end
end

sling.model.ClassDeclarationInstantiationExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.ClassDeclarationInstantiationExpressionNode.__index = sling.model.ClassDeclarationInstantiationExpressionNode
_vm:set_metatable(sling.model.ClassDeclarationInstantiationExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.ClassDeclarationInstantiationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ClassDeclarationInstantiationExpressionNode)
	return v
end

function sling.model.ClassDeclarationInstantiationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ClassDeclarationInstantiationExpressionNode'
	self['_isType.sling.model.ClassDeclarationInstantiationExpressionNode'] = true
	self.parameters = nil
	self.classDeclaration = nil
end

function sling.model.ClassDeclarationInstantiationExpressionNode:_construct0()
	sling.model.ClassDeclarationInstantiationExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.ClassDeclarationInstantiationExpressionNode:forDeclaration(cdecl)
	local v = _g.sling.model.ClassDeclarationInstantiationExpressionNode._construct0(_g.sling.model.ClassDeclarationInstantiationExpressionNode._create())
	do v:setClassDeclaration(cdecl, false) end
	do return v end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:getNodeTypeName()
	do return "ClassDeclarationInstantiationExpressionNode" end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:createNew()
	do return _g.sling.model.ClassDeclarationInstantiationExpressionNode._construct0(_g.sling.model.ClassDeclarationInstantiationExpressionNode._create()) end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ClassDeclarationInstantiationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.classDeclaration ~= nil then
			do n.classDeclaration:destroy() end
			n.classDeclaration = nil
		end
		if self.classDeclaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.classDeclaration), '_isType.sling.model.ClassDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.classDeclaration = pcp
			do n.classDeclaration:setParent(n) end
		end
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.classDeclaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ClassDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.classDeclaration:destroy() end
		end
		self.classDeclaration = _vm:to_table_with_key(newnode, '_isType.sling.model.ClassDeclarationNode')
		if self.classDeclaration ~= nil then
			do self.classDeclaration:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.classDeclaration ~= nil then
		if self.classDeclaration:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.classDeclaration ~= nil then
		do self.classDeclaration:destroy() end
		self.classDeclaration = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.ClassDeclarationInstantiationExpressionNode:setClassDeclaration(v, doExport)
	if self.classDeclaration ~= nil and doExport == false then
		do self.classDeclaration:destroy() end
	end
	self.classDeclaration = v
	if self.classDeclaration ~= nil then
		do self.classDeclaration:setParent(self) end
	end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:getClassDeclaration()
	do return self.classDeclaration end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:exportClassDeclaration()
	local v = self.classDeclaration
	self.classDeclaration = nil
	do return v end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:getParameters()
	do return self.parameters end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

sling.model.ArrayCreationExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.ArrayCreationExpressionNode.__index = sling.model.ArrayCreationExpressionNode
_vm:set_metatable(sling.model.ArrayCreationExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.ArrayCreationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ArrayCreationExpressionNode)
	return v
end

function sling.model.ArrayCreationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ArrayCreationExpressionNode'
	self['_isType.sling.model.ArrayCreationExpressionNode'] = true
	self.dimensions = nil
	self.arrayLiteral = nil
	self.primaryType = nil
	self.expressionType = nil
end

function sling.model.ArrayCreationExpressionNode:_construct0()
	sling.model.ArrayCreationExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.ArrayCreationExpressionNode:forPrimaryType(type)
	local v = _g.sling.model.ArrayCreationExpressionNode._construct0(_g.sling.model.ArrayCreationExpressionNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.ArrayCreationExpressionNode:forLiteral(literal)
	local v = _g.sling.model.ArrayCreationExpressionNode._construct0(_g.sling.model.ArrayCreationExpressionNode._create())
	do v:setArrayLiteral(literal, false) end
	do v:addToDimensions(_g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())) end
	do return v end
end

function sling.model.ArrayCreationExpressionNode:getDimensionCount()
	if self.dimensions == nil then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.dimensions) end
end

function sling.model.ArrayCreationExpressionNode:getPrimaryType()
	if self.primaryType ~= nil then
		do return self.primaryType end
	end
	if self.arrayLiteral ~= nil then
		do return self.arrayLiteral:getType() end
	end
	do return nil end
end

function sling.model.ArrayCreationExpressionNode:getNodeTypeName()
	do return "ArrayCreationExpressionNode" end
end

function sling.model.ArrayCreationExpressionNode:createNew()
	do return _g.sling.model.ArrayCreationExpressionNode._construct0(_g.sling.model.ArrayCreationExpressionNode._create()) end
end

function sling.model.ArrayCreationExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ArrayCreationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.arrayLiteral ~= nil then
			do n.arrayLiteral:destroy() end
			n.arrayLiteral = nil
		end
		if self.arrayLiteral ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.arrayLiteral), '_isType.sling.model.ArrayLiteralExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.arrayLiteral = pcp
			do n.arrayLiteral:setParent(n) end
		end
		if n.primaryType ~= nil then
			do n.primaryType:destroy() end
			n.primaryType = nil
		end
		if self.primaryType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.primaryType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.primaryType = pcp
			do n.primaryType:setParent(n) end
		end
		if n.expressionType ~= nil then
			do n.expressionType:destroy() end
			n.expressionType = nil
		end
		if self.expressionType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expressionType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.expressionType = pcp
			do n.expressionType:setParent(n) end
		end
		do
			local array = n.dimensions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.dimensions = nil
			if self.dimensions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.dimensions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.dimensions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.dimensions == nil then
								n.dimensions = {}
							end
							do _g.jk.lang.Vector:append(n.dimensions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ArrayCreationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.arrayLiteral then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ArrayLiteralExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.arrayLiteral:destroy() end
		end
		self.arrayLiteral = _vm:to_table_with_key(newnode, '_isType.sling.model.ArrayLiteralExpressionNode')
		if self.arrayLiteral ~= nil then
			do self.arrayLiteral:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.primaryType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.primaryType:destroy() end
		end
		self.primaryType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.primaryType ~= nil then
			do self.primaryType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.expressionType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expressionType:destroy() end
		end
		self.expressionType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.expressionType ~= nil then
			do self.expressionType:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.dimensions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ArrayCreationExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.arrayLiteral ~= nil then
		if self.arrayLiteral:accept(visitor) == false then
			do return false end
		end
	end
	if self.primaryType ~= nil then
		if self.primaryType:accept(visitor) == false then
			do return false end
		end
	end
	if self.expressionType ~= nil then
		if self.expressionType:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.dimensions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ArrayCreationExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.arrayLiteral ~= nil then
		do self.arrayLiteral:destroy() end
		self.arrayLiteral = nil
	end
	if self.primaryType ~= nil then
		do self.primaryType:destroy() end
		self.primaryType = nil
	end
	if self.expressionType ~= nil then
		do self.expressionType:destroy() end
		self.expressionType = nil
	end
	if self.dimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.dimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.dimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.dimensions = nil
end

function sling.model.ArrayCreationExpressionNode:setArrayLiteral(v, doExport)
	if self.arrayLiteral ~= nil and doExport == false then
		do self.arrayLiteral:destroy() end
	end
	self.arrayLiteral = v
	if self.arrayLiteral ~= nil then
		do self.arrayLiteral:setParent(self) end
	end
end

function sling.model.ArrayCreationExpressionNode:getArrayLiteral()
	do return self.arrayLiteral end
end

function sling.model.ArrayCreationExpressionNode:exportArrayLiteral()
	local v = self.arrayLiteral
	self.arrayLiteral = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:setPrimaryType(v, doExport)
	if self.primaryType ~= nil and doExport == false then
		do self.primaryType:destroy() end
	end
	self.primaryType = v
	if self.primaryType ~= nil then
		do self.primaryType:setParent(self) end
	end
end

function sling.model.ArrayCreationExpressionNode:exportPrimaryType()
	local v = self.primaryType
	self.primaryType = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:setExpressionType(v, doExport)
	if self.expressionType ~= nil and doExport == false then
		do self.expressionType:destroy() end
	end
	self.expressionType = v
	if self.expressionType ~= nil then
		do self.expressionType:setParent(self) end
	end
end

function sling.model.ArrayCreationExpressionNode:getExpressionType()
	do return self.expressionType end
end

function sling.model.ArrayCreationExpressionNode:exportExpressionType()
	local v = self.expressionType
	self.expressionType = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:setDimensions(v, doExport)
	if self.dimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.dimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.dimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.dimensions = nil
	else
		self.dimensions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.dimensions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ArrayCreationExpressionNode:getDimensions()
	do return self.dimensions end
end

function sling.model.ArrayCreationExpressionNode:exportDimensions()
	local v = self.dimensions
	self.dimensions = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:addToDimensions(v)
	if v == nil then
		do return end
	end
	if self.dimensions == nil then
		self.dimensions = {}
	end
	do _g.jk.lang.Vector:append(self.dimensions, v) end
	do v:setParent(self) end
end

function sling.model.ArrayCreationExpressionNode:clearDimensions()
	if self.dimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.dimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.dimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.dimensions = nil
end

sling.model.ExponentAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ExponentAssignmentExpressionNode.__index = sling.model.ExponentAssignmentExpressionNode
_vm:set_metatable(sling.model.ExponentAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ExponentAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ExponentAssignmentExpressionNode)
	return v
end

function sling.model.ExponentAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExponentAssignmentExpressionNode'
	self['_isType.sling.model.ExponentAssignmentExpressionNode'] = true
end

function sling.model.ExponentAssignmentExpressionNode:_construct0()
	sling.model.ExponentAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ExponentAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ExponentAssignmentExpressionNode._construct0(_g.sling.model.ExponentAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ExponentAssignmentExpressionNode:getNodeTypeName()
	do return "ExponentAssignmentExpressionNode" end
end

function sling.model.ExponentAssignmentExpressionNode:createNew()
	do return _g.sling.model.ExponentAssignmentExpressionNode._construct0(_g.sling.model.ExponentAssignmentExpressionNode._create()) end
end

function sling.model.ExponentAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExponentAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ExponentAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExponentAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExponentAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.DelegateDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.DelegateDeclarationNode.__index = sling.model.DelegateDeclarationNode
_vm:set_metatable(sling.model.DelegateDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.DelegateDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.DelegateDeclarationNode)
	return v
end

function sling.model.DelegateDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DelegateDeclarationNode'
	self['_isType.sling.model.DelegateDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.declaration = nil
end

function sling.model.DelegateDeclarationNode:_construct0()
	sling.model.DelegateDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.DelegateDeclarationNode:forDeclaration(declaration)
	local v = _g.sling.model.DelegateDeclarationNode._construct0(_g.sling.model.DelegateDeclarationNode._create())
	do v:setDeclaration(declaration, false) end
	do return v end
end

function sling.model.DelegateDeclarationNode:getNodeName()
	local v = _g.sling.model.EntityDeclarationNode.getNodeName(self)
	if v ~= nil then
		do return v end
	end
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getNodeName() end
end

function sling.model.DelegateDeclarationNode:renameNode(name)
	do _g.sling.model.EntityDeclarationNode.renameNode(self, name) end
	if self.declaration ~= nil then
		do self.declaration:renameNode(name) end
	end
end

function sling.model.DelegateDeclarationNode:getReturnType()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getReturnType() end
end

function sling.model.DelegateDeclarationNode:getParameters()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getParameters() end
end

function sling.model.DelegateDeclarationNode:setReturnType(type)
	if self.declaration == nil then
		do self:setDeclaration(_g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create()), false) end
	end
	do self.declaration:setReturnType(type, false) end
	do return self end
end

function sling.model.DelegateDeclarationNode:setParameters(params)
	if self.declaration == nil then
		do self:setDeclaration(_g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create()), false) end
	end
	do self.declaration:setParameters(params, false) end
	do return self end
end

function sling.model.DelegateDeclarationNode:getNodeTypeName()
	do return "DelegateDeclarationNode" end
end

function sling.model.DelegateDeclarationNode:createNew()
	do return _g.sling.model.DelegateDeclarationNode._construct0(_g.sling.model.DelegateDeclarationNode._create()) end
end

function sling.model.DelegateDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DelegateDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DelegateDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DelegateDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DelegateDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
end

function sling.model.DelegateDeclarationNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.DelegateDeclarationNode:getDeclaration()
	do return self.declaration end
end

function sling.model.DelegateDeclarationNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

sling.model.InitializerBlockDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.InitializerBlockDeclarationNode.__index = sling.model.InitializerBlockDeclarationNode
_vm:set_metatable(sling.model.InitializerBlockDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.InitializerBlockDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.InitializerBlockDeclarationNode)
	return v
end

function sling.model.InitializerBlockDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.InitializerBlockDeclarationNode'
	self['_isType.sling.model.InitializerBlockDeclarationNode'] = true
	self.block = nil
end

function sling.model.InitializerBlockDeclarationNode:_construct0()
	sling.model.InitializerBlockDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.InitializerBlockDeclarationNode:forBlock(block)
	local v = _g.sling.model.InitializerBlockDeclarationNode._construct0(_g.sling.model.InitializerBlockDeclarationNode._create())
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.InitializerBlockDeclarationNode:getNodeTypeName()
	do return "InitializerBlockDeclarationNode" end
end

function sling.model.InitializerBlockDeclarationNode:createNew()
	do return _g.sling.model.InitializerBlockDeclarationNode._construct0(_g.sling.model.InitializerBlockDeclarationNode._create()) end
end

function sling.model.InitializerBlockDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.InitializerBlockDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.InitializerBlockDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.InitializerBlockDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.InitializerBlockDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.InitializerBlockDeclarationNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.InitializerBlockDeclarationNode:getBlock()
	do return self.block end
end

function sling.model.InitializerBlockDeclarationNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.ExponentExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.ExponentExpressionNode.__index = sling.model.ExponentExpressionNode
_vm:set_metatable(sling.model.ExponentExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.ExponentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ExponentExpressionNode)
	return v
end

function sling.model.ExponentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExponentExpressionNode'
	self['_isType.sling.model.ExponentExpressionNode'] = true
end

function sling.model.ExponentExpressionNode:instance(left, right)
	local v = _g.sling.model.ExponentExpressionNode._construct0(_g.sling.model.ExponentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ExponentExpressionNode:_construct0()
	sling.model.ExponentExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()), false) end
	return self
end

function sling.model.ExponentExpressionNode:getNodeTypeName()
	do return "ExponentExpressionNode" end
end

function sling.model.ExponentExpressionNode:createNew()
	do return _g.sling.model.ExponentExpressionNode._construct0(_g.sling.model.ExponentExpressionNode._create()) end
end

function sling.model.ExponentExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExponentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ExponentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExponentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExponentExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.LabeledControlStatementNode = _g.sling.common.NodeObject._create()
sling.model.LabeledControlStatementNode.__index = sling.model.LabeledControlStatementNode
_vm:set_metatable(sling.model.LabeledControlStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.LabeledControlStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.LabeledControlStatementNode)
	return v
end

function sling.model.LabeledControlStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LabeledControlStatementNode'
	self['_isType.sling.model.LabeledControlStatementNode'] = true
	self.label = nil
end

function sling.model.LabeledControlStatementNode:_construct0()
	sling.model.LabeledControlStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.LabeledControlStatementNode:getNodeTypeName()
	do return "LabeledControlStatementNode" end
end

function sling.model.LabeledControlStatementNode:createNew()
	do return _g.sling.model.LabeledControlStatementNode._construct0(_g.sling.model.LabeledControlStatementNode._create()) end
end

function sling.model.LabeledControlStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LabeledControlStatementNode')
		if n == nil then
			do return true end
		end
		n.label = self.label
		do return true end
	end
end

function sling.model.LabeledControlStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LabeledControlStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LabeledControlStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.LabeledControlStatementNode:setLabel(v)
	self.label = v
end

function sling.model.LabeledControlStatementNode:getLabel()
	do return self.label end
end

sling.model.BitwiseOrAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.BitwiseOrAssignmentExpressionNode.__index = sling.model.BitwiseOrAssignmentExpressionNode
_vm:set_metatable(sling.model.BitwiseOrAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.BitwiseOrAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseOrAssignmentExpressionNode)
	return v
end

function sling.model.BitwiseOrAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseOrAssignmentExpressionNode'
	self['_isType.sling.model.BitwiseOrAssignmentExpressionNode'] = true
end

function sling.model.BitwiseOrAssignmentExpressionNode:_construct0()
	sling.model.BitwiseOrAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.BitwiseOrAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseOrAssignmentExpressionNode._construct0(_g.sling.model.BitwiseOrAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseOrAssignmentExpressionNode:getNodeTypeName()
	do return "BitwiseOrAssignmentExpressionNode" end
end

function sling.model.BitwiseOrAssignmentExpressionNode:createNew()
	do return _g.sling.model.BitwiseOrAssignmentExpressionNode._construct0(_g.sling.model.BitwiseOrAssignmentExpressionNode._create()) end
end

function sling.model.BitwiseOrAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseOrAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseOrAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseOrAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseOrAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.ConditionalExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.ConditionalExpressionNode.__index = sling.model.ConditionalExpressionNode
_vm:set_metatable(sling.model.ConditionalExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.ConditionalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ConditionalExpressionNode)
	return v
end

function sling.model.ConditionalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ConditionalExpressionNode'
	self['_isType.sling.model.ConditionalExpressionNode'] = true
	self.condition = nil
	self.trueExpr = nil
	self.falseExpr = nil
end

function sling.model.ConditionalExpressionNode:_construct0()
	sling.model.ConditionalExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.ConditionalExpressionNode:instance(condition, trueExpr, falseExpr)
	local v = _g.sling.model.ConditionalExpressionNode._construct0(_g.sling.model.ConditionalExpressionNode._create())
	do v:setCondition(condition, false) end
	do v:setTrueExpr(trueExpr, false) end
	do v:setFalseExpr(falseExpr, false) end
	do return v end
end

function sling.model.ConditionalExpressionNode:getNodeTypeName()
	do return "ConditionalExpressionNode" end
end

function sling.model.ConditionalExpressionNode:createNew()
	do return _g.sling.model.ConditionalExpressionNode._construct0(_g.sling.model.ConditionalExpressionNode._create()) end
end

function sling.model.ConditionalExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ConditionalExpressionNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.trueExpr ~= nil then
			do n.trueExpr:destroy() end
			n.trueExpr = nil
		end
		if self.trueExpr ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.trueExpr), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.trueExpr = pcp
			do n.trueExpr:setParent(n) end
		end
		if n.falseExpr ~= nil then
			do n.falseExpr:destroy() end
			n.falseExpr = nil
		end
		if self.falseExpr ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.falseExpr), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.falseExpr = pcp
			do n.falseExpr:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ConditionalExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.trueExpr then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.trueExpr:destroy() end
		end
		self.trueExpr = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.trueExpr ~= nil then
			do self.trueExpr:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.falseExpr then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.falseExpr:destroy() end
		end
		self.falseExpr = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.falseExpr ~= nil then
			do self.falseExpr:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ConditionalExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.trueExpr ~= nil then
		if self.trueExpr:accept(visitor) == false then
			do return false end
		end
	end
	if self.falseExpr ~= nil then
		if self.falseExpr:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ConditionalExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.trueExpr ~= nil then
		do self.trueExpr:destroy() end
		self.trueExpr = nil
	end
	if self.falseExpr ~= nil then
		do self.falseExpr:destroy() end
		self.falseExpr = nil
	end
end

function sling.model.ConditionalExpressionNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.ConditionalExpressionNode:getCondition()
	do return self.condition end
end

function sling.model.ConditionalExpressionNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.ConditionalExpressionNode:setTrueExpr(v, doExport)
	if self.trueExpr ~= nil and doExport == false then
		do self.trueExpr:destroy() end
	end
	self.trueExpr = v
	if self.trueExpr ~= nil then
		do self.trueExpr:setParent(self) end
	end
end

function sling.model.ConditionalExpressionNode:getTrueExpr()
	do return self.trueExpr end
end

function sling.model.ConditionalExpressionNode:exportTrueExpr()
	local v = self.trueExpr
	self.trueExpr = nil
	do return v end
end

function sling.model.ConditionalExpressionNode:setFalseExpr(v, doExport)
	if self.falseExpr ~= nil and doExport == false then
		do self.falseExpr:destroy() end
	end
	self.falseExpr = v
	if self.falseExpr ~= nil then
		do self.falseExpr:setParent(self) end
	end
end

function sling.model.ConditionalExpressionNode:getFalseExpr()
	do return self.falseExpr end
end

function sling.model.ConditionalExpressionNode:exportFalseExpr()
	local v = self.falseExpr
	self.falseExpr = nil
	do return v end
end

sling.model.SymbolNameComponentNode = _g.sling.common.NodeObject._create()
sling.model.SymbolNameComponentNode.__index = sling.model.SymbolNameComponentNode
_vm:set_metatable(sling.model.SymbolNameComponentNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.SymbolNameComponentNode._create()
	local v = _vm:set_metatable({}, sling.model.SymbolNameComponentNode)
	return v
end

function sling.model.SymbolNameComponentNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SymbolNameComponentNode'
	self['_isType.sling.model.SymbolNameComponentNode'] = true
	self.name = nil
	self.typeParameters = nil
end

function sling.model.SymbolNameComponentNode:_construct0()
	sling.model.SymbolNameComponentNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.SymbolNameComponentNode:forObject(obj)
	if not (obj ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(obj, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
		do return obj end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		do return _g.sling.model.SymbolNameComponentNode:forName(obj) end
	end
	do return nil end
end

function sling.model.SymbolNameComponentNode:forName(name)
	local v = _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.SymbolNameComponentNode:instance(name, params)
	local v = _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create())
	do v:setName(name) end
	do v:setTypeParameters(params, false) end
	do return v end
end

function sling.model.SymbolNameComponentNode:getNodeTypeName()
	do return "SymbolNameComponentNode" end
end

function sling.model.SymbolNameComponentNode:createNew()
	do return _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create()) end
end

function sling.model.SymbolNameComponentNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SymbolNameComponentNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		do
			local array = n.typeParameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.typeParameters = nil
			if self.typeParameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.typeParameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.typeParameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.typeParameters == nil then
								n.typeParameters = {}
							end
							do _g.jk.lang.Vector:append(n.typeParameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SymbolNameComponentNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.typeParameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SymbolNameComponentNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.typeParameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SymbolNameComponentNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.typeParameters = nil
end

function sling.model.SymbolNameComponentNode:setName(v)
	self.name = v
end

function sling.model.SymbolNameComponentNode:getName()
	do return self.name end
end

function sling.model.SymbolNameComponentNode:setTypeParameters(v, doExport)
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.typeParameters = nil
	else
		self.typeParameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.typeParameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SymbolNameComponentNode:getTypeParameters()
	do return self.typeParameters end
end

function sling.model.SymbolNameComponentNode:exportTypeParameters()
	local v = self.typeParameters
	self.typeParameters = nil
	do return v end
end

function sling.model.SymbolNameComponentNode:addToTypeParameters(v)
	if v == nil then
		do return end
	end
	if self.typeParameters == nil then
		self.typeParameters = {}
	end
	do _g.jk.lang.Vector:append(self.typeParameters, v) end
	do v:setParent(self) end
end

function sling.model.SymbolNameComponentNode:clearTypeParameters()
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.typeParameters = nil
end

sling.model.StaticArrayDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.StaticArrayDataTypeNode.__index = sling.model.StaticArrayDataTypeNode
_vm:set_metatable(sling.model.StaticArrayDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.StaticArrayDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.StaticArrayDataTypeNode)
	return v
end

function sling.model.StaticArrayDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StaticArrayDataTypeNode'
	self['_isType.sling.model.StaticArrayDataTypeNode'] = true
	self.size = nil
end

function sling.model.StaticArrayDataTypeNode:_construct0()
	sling.model.StaticArrayDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.StaticArrayDataTypeNode:forPrimaryType(type, size)
	local v = _g.sling.model.StaticArrayDataTypeNode._construct0(_g.sling.model.StaticArrayDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do v:setSize(size, false) end
	do return v end
end

function sling.model.StaticArrayDataTypeNode:getNodeTypeName()
	do return "StaticArrayDataTypeNode" end
end

function sling.model.StaticArrayDataTypeNode:createNew()
	do return _g.sling.model.StaticArrayDataTypeNode._construct0(_g.sling.model.StaticArrayDataTypeNode._create()) end
end

function sling.model.StaticArrayDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StaticArrayDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.size ~= nil then
			do n.size:destroy() end
			n.size = nil
		end
		if self.size ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.size), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.size = pcp
			do n.size:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StaticArrayDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.size then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.size:destroy() end
		end
		self.size = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.size ~= nil then
			do self.size:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StaticArrayDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.size ~= nil then
		if self.size:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StaticArrayDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
	if self.size ~= nil then
		do self.size:destroy() end
		self.size = nil
	end
end

function sling.model.StaticArrayDataTypeNode:setSize(v, doExport)
	if self.size ~= nil and doExport == false then
		do self.size:destroy() end
	end
	self.size = v
	if self.size ~= nil then
		do self.size:setParent(self) end
	end
end

function sling.model.StaticArrayDataTypeNode:getSize()
	do return self.size end
end

function sling.model.StaticArrayDataTypeNode:exportSize()
	local v = self.size
	self.size = nil
	do return v end
end

sling.model.FloatDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.FloatDataTypeNode.__index = sling.model.FloatDataTypeNode
_vm:set_metatable(sling.model.FloatDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.FloatDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.FloatDataTypeNode)
	return v
end

function sling.model.FloatDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloatDataTypeNode'
	self['_isType.sling.model.FloatDataTypeNode'] = true
end

function sling.model.FloatDataTypeNode:_construct0()
	sling.model.FloatDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.FloatDataTypeNode:getNodeTypeName()
	do return "FloatDataTypeNode" end
end

function sling.model.FloatDataTypeNode:createNew()
	do return _g.sling.model.FloatDataTypeNode._construct0(_g.sling.model.FloatDataTypeNode._create()) end
end

function sling.model.FloatDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloatDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FloatDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloatDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloatDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.CharacterLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.CharacterLiteralExpressionNode.__index = sling.model.CharacterLiteralExpressionNode
_vm:set_metatable(sling.model.CharacterLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.CharacterLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.CharacterLiteralExpressionNode)
	return v
end

function sling.model.CharacterLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CharacterLiteralExpressionNode'
	self['_isType.sling.model.CharacterLiteralExpressionNode'] = true
	self.value = 0
end

function sling.model.CharacterLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.CharacterLiteralExpressionNode._construct0(_g.sling.model.CharacterLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.CharacterLiteralExpressionNode:_construct0()
	sling.model.CharacterLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()), false) end
	return self
end

function sling.model.CharacterLiteralExpressionNode:getNodeTypeName()
	do return "CharacterLiteralExpressionNode" end
end

function sling.model.CharacterLiteralExpressionNode:createNew()
	do return _g.sling.model.CharacterLiteralExpressionNode._construct0(_g.sling.model.CharacterLiteralExpressionNode._create()) end
end

function sling.model.CharacterLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CharacterLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.CharacterLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CharacterLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CharacterLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.CharacterLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.CharacterLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.BreakLabelStatementNode = _g.sling.model.LabeledControlStatementNode._create()
sling.model.BreakLabelStatementNode.__index = sling.model.BreakLabelStatementNode
_vm:set_metatable(sling.model.BreakLabelStatementNode, {
	__index = _g.sling.model.LabeledControlStatementNode
})

function sling.model.BreakLabelStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.BreakLabelStatementNode)
	return v
end

function sling.model.BreakLabelStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BreakLabelStatementNode'
	self['_isType.sling.model.BreakLabelStatementNode'] = true
end

function sling.model.BreakLabelStatementNode:_construct0()
	sling.model.BreakLabelStatementNode._init(self)
	do _g.sling.model.LabeledControlStatementNode._construct0(self) end
	return self
end

function sling.model.BreakLabelStatementNode:forLabel(label)
	local v = _g.sling.model.BreakLabelStatementNode._construct0(_g.sling.model.BreakLabelStatementNode._create())
	do v:setLabel(label) end
	do return v end
end

function sling.model.BreakLabelStatementNode:getNodeTypeName()
	do return "BreakLabelStatementNode" end
end

function sling.model.BreakLabelStatementNode:createNew()
	do return _g.sling.model.BreakLabelStatementNode._construct0(_g.sling.model.BreakLabelStatementNode._create()) end
end

function sling.model.BreakLabelStatementNode:copyTo(o)
	if _g.sling.model.LabeledControlStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BreakLabelStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BreakLabelStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LabeledControlStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BreakLabelStatementNode:acceptVisitor(visitor)
	if _g.sling.model.LabeledControlStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BreakLabelStatementNode:destroy()
	do _g.sling.model.LabeledControlStatementNode.destroy(self) end
end

sling.model.SafeUnwrapOptionalExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.SafeUnwrapOptionalExpressionNode.__index = sling.model.SafeUnwrapOptionalExpressionNode
_vm:set_metatable(sling.model.SafeUnwrapOptionalExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.SafeUnwrapOptionalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SafeUnwrapOptionalExpressionNode)
	return v
end

function sling.model.SafeUnwrapOptionalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SafeUnwrapOptionalExpressionNode'
	self['_isType.sling.model.SafeUnwrapOptionalExpressionNode'] = true
end

function sling.model.SafeUnwrapOptionalExpressionNode:_construct0()
	sling.model.SafeUnwrapOptionalExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.SafeUnwrapOptionalExpressionNode:forExpression(expression)
	local v = _g.sling.model.SafeUnwrapOptionalExpressionNode._construct0(_g.sling.model.SafeUnwrapOptionalExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.SafeUnwrapOptionalExpressionNode:getNodeTypeName()
	do return "SafeUnwrapOptionalExpressionNode" end
end

function sling.model.SafeUnwrapOptionalExpressionNode:createNew()
	do return _g.sling.model.SafeUnwrapOptionalExpressionNode._construct0(_g.sling.model.SafeUnwrapOptionalExpressionNode._create()) end
end

function sling.model.SafeUnwrapOptionalExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SafeUnwrapOptionalExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SafeUnwrapOptionalExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SafeUnwrapOptionalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SafeUnwrapOptionalExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ConstructorDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.ConstructorDeclarationNode.__index = sling.model.ConstructorDeclarationNode
_vm:set_metatable(sling.model.ConstructorDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.ConstructorDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ConstructorDeclarationNode)
	return v
end

function sling.model.ConstructorDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ConstructorDeclarationNode'
	self['_isType.sling.model.ConstructorDeclarationNode'] = true
	self.next = nil
end

function sling.model.ConstructorDeclarationNode:_construct0()
	sling.model.ConstructorDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.ConstructorDeclarationNode:getNodeTypeName()
	do return "ConstructorDeclarationNode" end
end

function sling.model.ConstructorDeclarationNode:createNew()
	do return _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create()) end
end

function sling.model.ConstructorDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ConstructorDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.next ~= nil then
			do n.next:destroy() end
			n.next = nil
		end
		if self.next ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.next), '_isType.sling.model.FunctionCallExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.next = pcp
			do n.next:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ConstructorDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.next then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.next:destroy() end
		end
		self.next = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionCallExpressionNode')
		if self.next ~= nil then
			do self.next:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ConstructorDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.next ~= nil then
		if self.next:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ConstructorDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
	if self.next ~= nil then
		do self.next:destroy() end
		self.next = nil
	end
end

function sling.model.ConstructorDeclarationNode:setNext(v, doExport)
	if self.next ~= nil and doExport == false then
		do self.next:destroy() end
	end
	self.next = v
	if self.next ~= nil then
		do self.next:setParent(self) end
	end
end

function sling.model.ConstructorDeclarationNode:getNext()
	do return self.next end
end

function sling.model.ConstructorDeclarationNode:exportNext()
	local v = self.next
	self.next = nil
	do return v end
end

sling.model.GetExpressionTypeinfoExpressionNode = _g.sling.model.GetTypeinfoExpressionNode._create()
sling.model.GetExpressionTypeinfoExpressionNode.__index = sling.model.GetExpressionTypeinfoExpressionNode
_vm:set_metatable(sling.model.GetExpressionTypeinfoExpressionNode, {
	__index = _g.sling.model.GetTypeinfoExpressionNode
})

function sling.model.GetExpressionTypeinfoExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetExpressionTypeinfoExpressionNode)
	return v
end

function sling.model.GetExpressionTypeinfoExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetExpressionTypeinfoExpressionNode'
	self['_isType.sling.model.GetExpressionTypeinfoExpressionNode'] = true
	self.expression = nil
end

function sling.model.GetExpressionTypeinfoExpressionNode:forExpression(xpr)
	local v = _g.sling.model.GetExpressionTypeinfoExpressionNode._construct0(_g.sling.model.GetExpressionTypeinfoExpressionNode._create())
	do v:setExpression(xpr, false) end
	do return v end
end

function sling.model.GetExpressionTypeinfoExpressionNode:_construct0()
	sling.model.GetExpressionTypeinfoExpressionNode._init(self)
	do _g.sling.model.GetTypeinfoExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create()), false) end
	return self
end

function sling.model.GetExpressionTypeinfoExpressionNode:getNodeTypeName()
	do return "GetExpressionTypeinfoExpressionNode" end
end

function sling.model.GetExpressionTypeinfoExpressionNode:createNew()
	do return _g.sling.model.GetExpressionTypeinfoExpressionNode._construct0(_g.sling.model.GetExpressionTypeinfoExpressionNode._create()) end
end

function sling.model.GetExpressionTypeinfoExpressionNode:copyTo(o)
	if _g.sling.model.GetTypeinfoExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetExpressionTypeinfoExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetExpressionTypeinfoExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.GetTypeinfoExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetExpressionTypeinfoExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.GetTypeinfoExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetExpressionTypeinfoExpressionNode:destroy()
	do _g.sling.model.GetTypeinfoExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.GetExpressionTypeinfoExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.GetExpressionTypeinfoExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.GetExpressionTypeinfoExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.ImportPackageStatementNode = _g.sling.model.ImportStatementNode._create()
sling.model.ImportPackageStatementNode.__index = sling.model.ImportPackageStatementNode
_vm:set_metatable(sling.model.ImportPackageStatementNode, {
	__index = _g.sling.model.ImportStatementNode
})

function sling.model.ImportPackageStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportPackageStatementNode)
	return v
end

function sling.model.ImportPackageStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportPackageStatementNode'
	self['_isType.sling.model.ImportPackageStatementNode'] = true
	self.package = nil
	self.defaultExport = nil
end

function sling.model.ImportPackageStatementNode:_construct0()
	sling.model.ImportPackageStatementNode._init(self)
	do _g.sling.model.ImportStatementNode._construct0(self) end
	return self
end

function sling.model.ImportPackageStatementNode:getNodeTypeName()
	do return "ImportPackageStatementNode" end
end

function sling.model.ImportPackageStatementNode:createNew()
	do return _g.sling.model.ImportPackageStatementNode._construct0(_g.sling.model.ImportPackageStatementNode._create()) end
end

function sling.model.ImportPackageStatementNode:copyTo(o)
	if _g.sling.model.ImportStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportPackageStatementNode')
		if n == nil then
			do return true end
		end
		if n.package ~= nil then
			do n.package:destroy() end
			n.package = nil
		end
		if self.package ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.package), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.package = pcp
			do n.package:setParent(n) end
		end
		n.defaultExport = self.defaultExport
		do return true end
	end
end

function sling.model.ImportPackageStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.package then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.package:destroy() end
		end
		self.package = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.package ~= nil then
			do self.package:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ImportStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportPackageStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ImportStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.package ~= nil then
		if self.package:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImportPackageStatementNode:destroy()
	do _g.sling.model.ImportStatementNode.destroy(self) end
	if self.package ~= nil then
		do self.package:destroy() end
		self.package = nil
	end
end

function sling.model.ImportPackageStatementNode:setPackage(v, doExport)
	if self.package ~= nil and doExport == false then
		do self.package:destroy() end
	end
	self.package = v
	if self.package ~= nil then
		do self.package:setParent(self) end
	end
end

function sling.model.ImportPackageStatementNode:getPackage()
	do return self.package end
end

function sling.model.ImportPackageStatementNode:exportPackage()
	local v = self.package
	self.package = nil
	do return v end
end

function sling.model.ImportPackageStatementNode:setDefaultExport(v)
	self.defaultExport = v
end

function sling.model.ImportPackageStatementNode:getDefaultExport()
	do return self.defaultExport end
end

sling.model.FileSystemDirectoryReferenceExpressionNode = _g.sling.model.FileSystemReferenceExpressionNode._create()
sling.model.FileSystemDirectoryReferenceExpressionNode.__index = sling.model.FileSystemDirectoryReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemDirectoryReferenceExpressionNode, {
	__index = _g.sling.model.FileSystemReferenceExpressionNode
})

function sling.model.FileSystemDirectoryReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemDirectoryReferenceExpressionNode)
	return v
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemDirectoryReferenceExpressionNode'
	self['_isType.sling.model.FileSystemDirectoryReferenceExpressionNode'] = true
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:_construct0()
	sling.model.FileSystemDirectoryReferenceExpressionNode._init(self)
	do _g.sling.model.FileSystemReferenceExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemDirectoryReferenceExpressionNode" end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:createNew()
	do return _g.sling.model.FileSystemDirectoryReferenceExpressionNode._construct0(_g.sling.model.FileSystemDirectoryReferenceExpressionNode._create()) end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:copyTo(o)
	if _g.sling.model.FileSystemReferenceExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemDirectoryReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FileSystemReferenceExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.FileSystemReferenceExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:destroy()
	do _g.sling.model.FileSystemReferenceExpressionNode.destroy(self) end
end

sling.model.ImportStaticMemberStatementNode = _g.sling.model.ImportStatementNode._create()
sling.model.ImportStaticMemberStatementNode.__index = sling.model.ImportStaticMemberStatementNode
_vm:set_metatable(sling.model.ImportStaticMemberStatementNode, {
	__index = _g.sling.model.ImportStatementNode
})

function sling.model.ImportStaticMemberStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportStaticMemberStatementNode)
	return v
end

function sling.model.ImportStaticMemberStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportStaticMemberStatementNode'
	self['_isType.sling.model.ImportStaticMemberStatementNode'] = true
	self.member = nil
	self.container = nil
	self.allMembers = false
end

function sling.model.ImportStaticMemberStatementNode:_construct0()
	sling.model.ImportStaticMemberStatementNode._init(self)
	do _g.sling.model.ImportStatementNode._construct0(self) end
	return self
end

function sling.model.ImportStaticMemberStatementNode:getNodeTypeName()
	do return "ImportStaticMemberStatementNode" end
end

function sling.model.ImportStaticMemberStatementNode:createNew()
	do return _g.sling.model.ImportStaticMemberStatementNode._construct0(_g.sling.model.ImportStaticMemberStatementNode._create()) end
end

function sling.model.ImportStaticMemberStatementNode:copyTo(o)
	if _g.sling.model.ImportStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportStaticMemberStatementNode')
		if n == nil then
			do return true end
		end
		if n.member ~= nil then
			do n.member:destroy() end
			n.member = nil
		end
		if self.member ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.member), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.member = pcp
			do n.member:setParent(n) end
		end
		if n.container ~= nil then
			do n.container:destroy() end
			n.container = nil
		end
		if self.container ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.container), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.container = pcp
			do n.container:setParent(n) end
		end
		n.allMembers = self.allMembers
		do return true end
	end
end

function sling.model.ImportStaticMemberStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.member then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.member:destroy() end
		end
		self.member = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.member ~= nil then
			do self.member:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.container then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.container:destroy() end
		end
		self.container = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.container ~= nil then
			do self.container:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ImportStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportStaticMemberStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ImportStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.member ~= nil then
		if self.member:accept(visitor) == false then
			do return false end
		end
	end
	if self.container ~= nil then
		if self.container:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImportStaticMemberStatementNode:destroy()
	do _g.sling.model.ImportStatementNode.destroy(self) end
	if self.member ~= nil then
		do self.member:destroy() end
		self.member = nil
	end
	if self.container ~= nil then
		do self.container:destroy() end
		self.container = nil
	end
end

function sling.model.ImportStaticMemberStatementNode:setMember(v, doExport)
	if self.member ~= nil and doExport == false then
		do self.member:destroy() end
	end
	self.member = v
	if self.member ~= nil then
		do self.member:setParent(self) end
	end
end

function sling.model.ImportStaticMemberStatementNode:getMember()
	do return self.member end
end

function sling.model.ImportStaticMemberStatementNode:exportMember()
	local v = self.member
	self.member = nil
	do return v end
end

function sling.model.ImportStaticMemberStatementNode:setContainer(v, doExport)
	if self.container ~= nil and doExport == false then
		do self.container:destroy() end
	end
	self.container = v
	if self.container ~= nil then
		do self.container:setParent(self) end
	end
end

function sling.model.ImportStaticMemberStatementNode:getContainer()
	do return self.container end
end

function sling.model.ImportStaticMemberStatementNode:exportContainer()
	local v = self.container
	self.container = nil
	do return v end
end

function sling.model.ImportStaticMemberStatementNode:setAllMembers(v)
	self.allMembers = v
end

function sling.model.ImportStaticMemberStatementNode:getAllMembers()
	do return self.allMembers end
end

sling.model.FloatLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.FloatLiteralExpressionNode.__index = sling.model.FloatLiteralExpressionNode
_vm:set_metatable(sling.model.FloatLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

sling.model.FloatLiteralExpressionNode.FORMAT_DECIMAL = 0
sling.model.FloatLiteralExpressionNode.FORMAT_HEXADECIMAL = 1

function sling.model.FloatLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FloatLiteralExpressionNode)
	return v
end

function sling.model.FloatLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloatLiteralExpressionNode'
	self['_isType.sling.model.FloatLiteralExpressionNode'] = true
	self.value = 0.0
	self.format = 0
end

function sling.model.FloatLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.FloatLiteralExpressionNode._construct0(_g.sling.model.FloatLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.FloatLiteralExpressionNode:_construct0()
	sling.model.FloatLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.FloatDataTypeNode._construct0(_g.sling.model.FloatDataTypeNode._create()), false) end
	return self
end

function sling.model.FloatLiteralExpressionNode:getNodeTypeName()
	do return "FloatLiteralExpressionNode" end
end

function sling.model.FloatLiteralExpressionNode:createNew()
	do return _g.sling.model.FloatLiteralExpressionNode._construct0(_g.sling.model.FloatLiteralExpressionNode._create()) end
end

function sling.model.FloatLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloatLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		n.format = self.format
		do return true end
	end
end

function sling.model.FloatLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloatLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloatLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.FloatLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.FloatLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.FloatLiteralExpressionNode:setFormat(v)
	self.format = v
end

function sling.model.FloatLiteralExpressionNode:getFormat()
	do return self.format end
end

sling.model.ShiftRightExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ShiftRightExpressionNode.__index = sling.model.ShiftRightExpressionNode
_vm:set_metatable(sling.model.ShiftRightExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ShiftRightExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftRightExpressionNode)
	return v
end

function sling.model.ShiftRightExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftRightExpressionNode'
	self['_isType.sling.model.ShiftRightExpressionNode'] = true
	self.zeroLeftmostBit = false
end

function sling.model.ShiftRightExpressionNode:_construct0()
	sling.model.ShiftRightExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ShiftRightExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftRightExpressionNode._construct0(_g.sling.model.ShiftRightExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftRightExpressionNode:getNodeTypeName()
	do return "ShiftRightExpressionNode" end
end

function sling.model.ShiftRightExpressionNode:createNew()
	do return _g.sling.model.ShiftRightExpressionNode._construct0(_g.sling.model.ShiftRightExpressionNode._create()) end
end

function sling.model.ShiftRightExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftRightExpressionNode')
		if n == nil then
			do return true end
		end
		n.zeroLeftmostBit = self.zeroLeftmostBit
		do return true end
	end
end

function sling.model.ShiftRightExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftRightExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftRightExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

function sling.model.ShiftRightExpressionNode:setZeroLeftmostBit(v)
	self.zeroLeftmostBit = v
end

function sling.model.ShiftRightExpressionNode:getZeroLeftmostBit()
	do return self.zeroLeftmostBit end
end

sling.model.ReturnStatementNode = _g.sling.model.ExpressionContainerNode._create()
sling.model.ReturnStatementNode.__index = sling.model.ReturnStatementNode
_vm:set_metatable(sling.model.ReturnStatementNode, {
	__index = _g.sling.model.ExpressionContainerNode
})

function sling.model.ReturnStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ReturnStatementNode)
	return v
end

function sling.model.ReturnStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ReturnStatementNode'
	self['_isType.sling.model.ReturnStatementNode'] = true
end

function sling.model.ReturnStatementNode:_construct0()
	sling.model.ReturnStatementNode._init(self)
	do _g.sling.model.ExpressionContainerNode._construct0(self) end
	return self
end

function sling.model.ReturnStatementNode:ifEquals(left, right, rval)
	local eqs = _g.sling.model.EqualsExpressionNode:instance(left, right)
	local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	do block:addNode(_g.sling.model.ReturnStatementNode:forExpression(rval)) end
	do
		local ifs = _g.sling.model.IfStatementNode:instance(eqs, block, nil)
		do return ifs end
	end
end

function sling.model.ReturnStatementNode:forExpression(expression)
	local v = _g.sling.model.ReturnStatementNode._construct0(_g.sling.model.ReturnStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.ReturnStatementNode:getNodeTypeName()
	do return "ReturnStatementNode" end
end

function sling.model.ReturnStatementNode:createNew()
	do return _g.sling.model.ReturnStatementNode._construct0(_g.sling.model.ReturnStatementNode._create()) end
end

function sling.model.ReturnStatementNode:copyTo(o)
	if _g.sling.model.ExpressionContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ReturnStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ReturnStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ReturnStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ReturnStatementNode:destroy()
	do _g.sling.model.ExpressionContainerNode.destroy(self) end
end

sling.model.MainFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.MainFunctionDeclarationNode.__index = sling.model.MainFunctionDeclarationNode
_vm:set_metatable(sling.model.MainFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.MainFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.MainFunctionDeclarationNode)
	return v
end

function sling.model.MainFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MainFunctionDeclarationNode'
	self['_isType.sling.model.MainFunctionDeclarationNode'] = true
end

function sling.model.MainFunctionDeclarationNode:_construct0()
	sling.model.MainFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.MainFunctionDeclarationNode:setArgumentArrayName(varName)
	do self:setParameters(nil, false) end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), nil), varName, nil)) end
end

function sling.model.MainFunctionDeclarationNode:getArgumentArrayName()
	local pp = _vm:to_table_with_key(self:getParameter(0), '_isType.sling.model.VariableDeclarationNode')
	if not (pp ~= nil) then
		do return nil end
	end
	do return pp:getNodeName() end
end

function sling.model.MainFunctionDeclarationNode:getNodeTypeName()
	do return "MainFunctionDeclarationNode" end
end

function sling.model.MainFunctionDeclarationNode:createNew()
	do return _g.sling.model.MainFunctionDeclarationNode._construct0(_g.sling.model.MainFunctionDeclarationNode._create()) end
end

function sling.model.MainFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MainFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MainFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MainFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MainFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.MagicalClassDeclarationNode = _g.sling.model.ClassDeclarationNode._create()
sling.model.MagicalClassDeclarationNode.__index = sling.model.MagicalClassDeclarationNode
_vm:set_metatable(sling.model.MagicalClassDeclarationNode, {
	__index = _g.sling.model.ClassDeclarationNode
})

function sling.model.MagicalClassDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.MagicalClassDeclarationNode)
	return v
end

function sling.model.MagicalClassDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MagicalClassDeclarationNode'
	self['_isType.sling.model.MagicalClassDeclarationNode'] = true
	self.symbol = nil
end

function sling.model.MagicalClassDeclarationNode:_construct0()
	sling.model.MagicalClassDeclarationNode._init(self)
	do _g.sling.model.ClassDeclarationNode._construct0(self) end
	return self
end

function sling.model.MagicalClassDeclarationNode:getNodeTypeName()
	do return "MagicalClassDeclarationNode" end
end

function sling.model.MagicalClassDeclarationNode:createNew()
	do return _g.sling.model.MagicalClassDeclarationNode._construct0(_g.sling.model.MagicalClassDeclarationNode._create()) end
end

function sling.model.MagicalClassDeclarationNode:copyTo(o)
	if _g.sling.model.ClassDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MagicalClassDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.MagicalClassDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ClassDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MagicalClassDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.ClassDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.MagicalClassDeclarationNode:destroy()
	do _g.sling.model.ClassDeclarationNode.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.MagicalClassDeclarationNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.MagicalClassDeclarationNode:getSymbol()
	do return self.symbol end
end

function sling.model.MagicalClassDeclarationNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.FloorDivisionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.FloorDivisionExpressionNode.__index = sling.model.FloorDivisionExpressionNode
_vm:set_metatable(sling.model.FloorDivisionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.FloorDivisionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FloorDivisionExpressionNode)
	return v
end

function sling.model.FloorDivisionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloorDivisionExpressionNode'
	self['_isType.sling.model.FloorDivisionExpressionNode'] = true
end

function sling.model.FloorDivisionExpressionNode:instance(left, right)
	local v = _g.sling.model.FloorDivisionExpressionNode._construct0(_g.sling.model.FloorDivisionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.FloorDivisionExpressionNode:_construct0()
	sling.model.FloorDivisionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), false) end
	return self
end

function sling.model.FloorDivisionExpressionNode:getNodeTypeName()
	do return "FloorDivisionExpressionNode" end
end

function sling.model.FloorDivisionExpressionNode:createNew()
	do return _g.sling.model.FloorDivisionExpressionNode._construct0(_g.sling.model.FloorDivisionExpressionNode._create()) end
end

function sling.model.FloorDivisionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloorDivisionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FloorDivisionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloorDivisionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloorDivisionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.BaseTypeNode = _g.sling.common.NodeObject._create()
sling.model.BaseTypeNode.__index = sling.model.BaseTypeNode
_vm:set_metatable(sling.model.BaseTypeNode, {
	__index = _g.sling.common.NodeObject
})

sling.model.BaseTypeNode.INHERIT_AUTO = 0
sling.model.BaseTypeNode.INHERIT_EXTEND = 1
sling.model.BaseTypeNode.INHERIT_IMPLEMENT = 2
sling.model.BaseTypeNode.INHERIT_INFORMATIVE = 3
sling.model.BaseTypeNode.INHERIT_UNKNOWN = 4

function sling.model.BaseTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.BaseTypeNode)
	return v
end

function sling.model.BaseTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BaseTypeNode'
	self['_isType.sling.model.BaseTypeNode'] = true
	self.referenceType = nil
	self.inheritType = 0
	self.expression = nil
end

function sling.model.BaseTypeNode:_construct0()
	sling.model.BaseTypeNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.BaseTypeNode:forType(type, inheritType)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setReferenceType(type, false) end
	do v:setInheritType(inheritType) end
	do return v end
end

function sling.model.BaseTypeNode:forExpression(expression, inheritType)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setExpression(expression, false) end
	do v:setInheritType(inheritType) end
	do return v end
end

function sling.model.BaseTypeNode:forExtends(type)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setReferenceType(type, false) end
	do v:setInheritType(_g.sling.model.BaseTypeNode.INHERIT_EXTEND) end
	do return v end
end

function sling.model.BaseTypeNode:forImplements(type)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setReferenceType(type, false) end
	do v:setInheritType(_g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT) end
	do return v end
end

function sling.model.BaseTypeNode:getNodeTypeName()
	do return "BaseTypeNode" end
end

function sling.model.BaseTypeNode:createNew()
	do return _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create()) end
end

function sling.model.BaseTypeNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BaseTypeNode')
		if n == nil then
			do return true end
		end
		if n.referenceType ~= nil then
			do n.referenceType:destroy() end
			n.referenceType = nil
		end
		if self.referenceType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.referenceType), '_isType.sling.model.ReferenceDataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.referenceType = pcp
			do n.referenceType:setParent(n) end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.inheritType = self.inheritType
		do return true end
	end
end

function sling.model.BaseTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.referenceType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.referenceType:destroy() end
		end
		self.referenceType = _vm:to_table_with_key(newnode, '_isType.sling.model.ReferenceDataTypeNode')
		if self.referenceType ~= nil then
			do self.referenceType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BaseTypeNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.referenceType ~= nil then
		if self.referenceType:accept(visitor) == false then
			do return false end
		end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.BaseTypeNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.referenceType ~= nil then
		do self.referenceType:destroy() end
		self.referenceType = nil
	end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.BaseTypeNode:setReferenceType(v, doExport)
	if self.referenceType ~= nil and doExport == false then
		do self.referenceType:destroy() end
	end
	self.referenceType = v
	if self.referenceType ~= nil then
		do self.referenceType:setParent(self) end
	end
end

function sling.model.BaseTypeNode:getReferenceType()
	do return self.referenceType end
end

function sling.model.BaseTypeNode:exportReferenceType()
	local v = self.referenceType
	self.referenceType = nil
	do return v end
end

function sling.model.BaseTypeNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.BaseTypeNode:getExpression()
	do return self.expression end
end

function sling.model.BaseTypeNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.BaseTypeNode:setInheritType(v)
	self.inheritType = v
end

function sling.model.BaseTypeNode:getInheritType()
	do return self.inheritType end
end

sling.model.CriticalSectionBlockNode = _g.sling.common.NodeObject._create()
sling.model.CriticalSectionBlockNode.__index = sling.model.CriticalSectionBlockNode
_vm:set_metatable(sling.model.CriticalSectionBlockNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CriticalSectionBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CriticalSectionBlockNode)
	return v
end

function sling.model.CriticalSectionBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CriticalSectionBlockNode'
	self['_isType.sling.model.CriticalSectionBlockNode'] = true
	self.object = nil
	self.block = nil
end

function sling.model.CriticalSectionBlockNode:_construct0()
	sling.model.CriticalSectionBlockNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CriticalSectionBlockNode:instance(object, block)
	local v = _g.sling.model.CriticalSectionBlockNode._construct0(_g.sling.model.CriticalSectionBlockNode._create())
	do v:setObject(object, false) end
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.CriticalSectionBlockNode:getNodeTypeName()
	do return "CriticalSectionBlockNode" end
end

function sling.model.CriticalSectionBlockNode:createNew()
	do return _g.sling.model.CriticalSectionBlockNode._construct0(_g.sling.model.CriticalSectionBlockNode._create()) end
end

function sling.model.CriticalSectionBlockNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CriticalSectionBlockNode')
		if n == nil then
			do return true end
		end
		if n.object ~= nil then
			do n.object:destroy() end
			n.object = nil
		end
		if self.object ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.object), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.object = pcp
			do n.object:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CriticalSectionBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.object then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.object:destroy() end
		end
		self.object = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.object ~= nil then
			do self.object:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CriticalSectionBlockNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.object ~= nil then
		if self.object:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CriticalSectionBlockNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.object ~= nil then
		do self.object:destroy() end
		self.object = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.CriticalSectionBlockNode:setObject(v, doExport)
	if self.object ~= nil and doExport == false then
		do self.object:destroy() end
	end
	self.object = v
	if self.object ~= nil then
		do self.object:setParent(self) end
	end
end

function sling.model.CriticalSectionBlockNode:getObject()
	do return self.object end
end

function sling.model.CriticalSectionBlockNode:exportObject()
	local v = self.object
	self.object = nil
	do return v end
end

function sling.model.CriticalSectionBlockNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.CriticalSectionBlockNode:getBlock()
	do return self.block end
end

function sling.model.CriticalSectionBlockNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.BitwiseXorAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.BitwiseXorAssignmentExpressionNode.__index = sling.model.BitwiseXorAssignmentExpressionNode
_vm:set_metatable(sling.model.BitwiseXorAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.BitwiseXorAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseXorAssignmentExpressionNode)
	return v
end

function sling.model.BitwiseXorAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseXorAssignmentExpressionNode'
	self['_isType.sling.model.BitwiseXorAssignmentExpressionNode'] = true
end

function sling.model.BitwiseXorAssignmentExpressionNode:_construct0()
	sling.model.BitwiseXorAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.BitwiseXorAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseXorAssignmentExpressionNode._construct0(_g.sling.model.BitwiseXorAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseXorAssignmentExpressionNode:getNodeTypeName()
	do return "BitwiseXorAssignmentExpressionNode" end
end

function sling.model.BitwiseXorAssignmentExpressionNode:createNew()
	do return _g.sling.model.BitwiseXorAssignmentExpressionNode._construct0(_g.sling.model.BitwiseXorAssignmentExpressionNode._create()) end
end

function sling.model.BitwiseXorAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseXorAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseXorAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseXorAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseXorAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.NamedParameterDeclarationNode = _g.sling.common.ExpressionNode._create()
sling.model.NamedParameterDeclarationNode.__index = sling.model.NamedParameterDeclarationNode
_vm:set_metatable(sling.model.NamedParameterDeclarationNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.NamedParameterDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.NamedParameterDeclarationNode)
	return v
end

function sling.model.NamedParameterDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NamedParameterDeclarationNode'
	self['_isType.sling.model.NamedParameterDeclarationNode'] = true
	self.name = nil
	self.variable = nil
end

function sling.model.NamedParameterDeclarationNode:_construct0()
	sling.model.NamedParameterDeclarationNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.NamedParameterDeclarationNode:getNodeTypeName()
	do return "NamedParameterDeclarationNode" end
end

function sling.model.NamedParameterDeclarationNode:createNew()
	do return _g.sling.model.NamedParameterDeclarationNode._construct0(_g.sling.model.NamedParameterDeclarationNode._create()) end
end

function sling.model.NamedParameterDeclarationNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NamedParameterDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.variable ~= nil then
			do n.variable:destroy() end
			n.variable = nil
		end
		if self.variable ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.variable), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.variable = pcp
			do n.variable:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.NamedParameterDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.variable then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.variable:destroy() end
		end
		self.variable = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.variable ~= nil then
			do self.variable:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NamedParameterDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.variable ~= nil then
		if self.variable:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.NamedParameterDeclarationNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.variable ~= nil then
		do self.variable:destroy() end
		self.variable = nil
	end
end

function sling.model.NamedParameterDeclarationNode:setVariable(v, doExport)
	if self.variable ~= nil and doExport == false then
		do self.variable:destroy() end
	end
	self.variable = v
	if self.variable ~= nil then
		do self.variable:setParent(self) end
	end
end

function sling.model.NamedParameterDeclarationNode:getVariable()
	do return self.variable end
end

function sling.model.NamedParameterDeclarationNode:exportVariable()
	local v = self.variable
	self.variable = nil
	do return v end
end

function sling.model.NamedParameterDeclarationNode:setName(v)
	self.name = v
end

function sling.model.NamedParameterDeclarationNode:getName()
	do return self.name end
end

sling.model.DataTypeDefaultValueExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.DataTypeDefaultValueExpressionNode.__index = sling.model.DataTypeDefaultValueExpressionNode
_vm:set_metatable(sling.model.DataTypeDefaultValueExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.DataTypeDefaultValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DataTypeDefaultValueExpressionNode)
	return v
end

function sling.model.DataTypeDefaultValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DataTypeDefaultValueExpressionNode'
	self['_isType.sling.model.DataTypeDefaultValueExpressionNode'] = true
	self.type = nil
end

function sling.model.DataTypeDefaultValueExpressionNode:_construct0()
	sling.model.DataTypeDefaultValueExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.DataTypeDefaultValueExpressionNode:forType(dt)
	local v = _g.sling.model.DataTypeDefaultValueExpressionNode._construct0(_g.sling.model.DataTypeDefaultValueExpressionNode._create())
	do v:setType(dt, false) end
	do return v end
end

function sling.model.DataTypeDefaultValueExpressionNode:getNodeTypeName()
	do return "DataTypeDefaultValueExpressionNode" end
end

function sling.model.DataTypeDefaultValueExpressionNode:createNew()
	do return _g.sling.model.DataTypeDefaultValueExpressionNode._construct0(_g.sling.model.DataTypeDefaultValueExpressionNode._create()) end
end

function sling.model.DataTypeDefaultValueExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DataTypeDefaultValueExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DataTypeDefaultValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DataTypeDefaultValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DataTypeDefaultValueExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.DataTypeDefaultValueExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.DataTypeDefaultValueExpressionNode:getType()
	do return self.type end
end

function sling.model.DataTypeDefaultValueExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.TypeInfoDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.TypeInfoDataTypeNode.__index = sling.model.TypeInfoDataTypeNode
_vm:set_metatable(sling.model.TypeInfoDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.TypeInfoDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeInfoDataTypeNode)
	return v
end

function sling.model.TypeInfoDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeInfoDataTypeNode'
	self['_isType.sling.model.TypeInfoDataTypeNode'] = true
end

function sling.model.TypeInfoDataTypeNode:_construct0()
	sling.model.TypeInfoDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.TypeInfoDataTypeNode:getNodeTypeName()
	do return "TypeInfoDataTypeNode" end
end

function sling.model.TypeInfoDataTypeNode:createNew()
	do return _g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create()) end
end

function sling.model.TypeInfoDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeInfoDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.TypeInfoDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeInfoDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TypeInfoDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.DecimalLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.DecimalLiteralExpressionNode.__index = sling.model.DecimalLiteralExpressionNode
_vm:set_metatable(sling.model.DecimalLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.DecimalLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DecimalLiteralExpressionNode)
	return v
end

function sling.model.DecimalLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DecimalLiteralExpressionNode'
	self['_isType.sling.model.DecimalLiteralExpressionNode'] = true
	self.value = nil
end

function sling.model.DecimalLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.DecimalLiteralExpressionNode._construct0(_g.sling.model.DecimalLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.DecimalLiteralExpressionNode:_construct0()
	sling.model.DecimalLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DecimalDataTypeNode._construct0(_g.sling.model.DecimalDataTypeNode._create()), false) end
	return self
end

function sling.model.DecimalLiteralExpressionNode:getNodeTypeName()
	do return "DecimalLiteralExpressionNode" end
end

function sling.model.DecimalLiteralExpressionNode:createNew()
	do return _g.sling.model.DecimalLiteralExpressionNode._construct0(_g.sling.model.DecimalLiteralExpressionNode._create()) end
end

function sling.model.DecimalLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DecimalLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.DecimalLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DecimalLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DecimalLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.DecimalLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.DecimalLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.RangeExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.RangeExpressionNode.__index = sling.model.RangeExpressionNode
_vm:set_metatable(sling.model.RangeExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

sling.model.RangeExpressionNode.TYPE_NONE = 0
sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND = 1
sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND = 2
sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS = 3

function sling.model.RangeExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.RangeExpressionNode)
	return v
end

function sling.model.RangeExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.RangeExpressionNode'
	self['_isType.sling.model.RangeExpressionNode'] = true
	self.lowerBound = nil
	self.upperBound = nil
	self.step = nil
	self.type = nil
	self.exclusionType = 0
end

function sling.model.RangeExpressionNode:instance(from, to)
	local v = _g.sling.model.RangeExpressionNode._construct0(_g.sling.model.RangeExpressionNode._create())
	do v:setLowerBound(from, false) end
	do v:setUpperBound(to, false) end
	do return v end
end

function sling.model.RangeExpressionNode:_construct0()
	sling.model.RangeExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.RangeDataTypeNode._construct0(_g.sling.model.RangeDataTypeNode._create()), false) end
	return self
end

function sling.model.RangeExpressionNode:getNodeTypeName()
	do return "RangeExpressionNode" end
end

function sling.model.RangeExpressionNode:createNew()
	do return _g.sling.model.RangeExpressionNode._construct0(_g.sling.model.RangeExpressionNode._create()) end
end

function sling.model.RangeExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.RangeExpressionNode')
		if n == nil then
			do return true end
		end
		if n.lowerBound ~= nil then
			do n.lowerBound:destroy() end
			n.lowerBound = nil
		end
		if self.lowerBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.lowerBound), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.lowerBound = pcp
			do n.lowerBound:setParent(n) end
		end
		if n.upperBound ~= nil then
			do n.upperBound:destroy() end
			n.upperBound = nil
		end
		if self.upperBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.upperBound), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.upperBound = pcp
			do n.upperBound:setParent(n) end
		end
		if n.step ~= nil then
			do n.step:destroy() end
			n.step = nil
		end
		if self.step ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.step), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.step = pcp
			do n.step:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.exclusionType = self.exclusionType
		do return true end
	end
end

function sling.model.RangeExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.lowerBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.lowerBound:destroy() end
		end
		self.lowerBound = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.lowerBound ~= nil then
			do self.lowerBound:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.upperBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.upperBound:destroy() end
		end
		self.upperBound = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.upperBound ~= nil then
			do self.upperBound:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.step then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.step:destroy() end
		end
		self.step = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.step ~= nil then
			do self.step:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.RangeExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.lowerBound ~= nil then
		if self.lowerBound:accept(visitor) == false then
			do return false end
		end
	end
	if self.upperBound ~= nil then
		if self.upperBound:accept(visitor) == false then
			do return false end
		end
	end
	if self.step ~= nil then
		if self.step:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.RangeExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.lowerBound ~= nil then
		do self.lowerBound:destroy() end
		self.lowerBound = nil
	end
	if self.upperBound ~= nil then
		do self.upperBound:destroy() end
		self.upperBound = nil
	end
	if self.step ~= nil then
		do self.step:destroy() end
		self.step = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.RangeExpressionNode:setLowerBound(v, doExport)
	if self.lowerBound ~= nil and doExport == false then
		do self.lowerBound:destroy() end
	end
	self.lowerBound = v
	if self.lowerBound ~= nil then
		do self.lowerBound:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getLowerBound()
	do return self.lowerBound end
end

function sling.model.RangeExpressionNode:exportLowerBound()
	local v = self.lowerBound
	self.lowerBound = nil
	do return v end
end

function sling.model.RangeExpressionNode:setUpperBound(v, doExport)
	if self.upperBound ~= nil and doExport == false then
		do self.upperBound:destroy() end
	end
	self.upperBound = v
	if self.upperBound ~= nil then
		do self.upperBound:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getUpperBound()
	do return self.upperBound end
end

function sling.model.RangeExpressionNode:exportUpperBound()
	local v = self.upperBound
	self.upperBound = nil
	do return v end
end

function sling.model.RangeExpressionNode:setStep(v, doExport)
	if self.step ~= nil and doExport == false then
		do self.step:destroy() end
	end
	self.step = v
	if self.step ~= nil then
		do self.step:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getStep()
	do return self.step end
end

function sling.model.RangeExpressionNode:exportStep()
	local v = self.step
	self.step = nil
	do return v end
end

function sling.model.RangeExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getType()
	do return self.type end
end

function sling.model.RangeExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.RangeExpressionNode:setExclusionType(v)
	self.exclusionType = v
end

function sling.model.RangeExpressionNode:getExclusionType()
	do return self.exclusionType end
end

sling.model.StrictEqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.StrictEqualsExpressionNode.__index = sling.model.StrictEqualsExpressionNode
_vm:set_metatable(sling.model.StrictEqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.StrictEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StrictEqualsExpressionNode)
	return v
end

function sling.model.StrictEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StrictEqualsExpressionNode'
	self['_isType.sling.model.StrictEqualsExpressionNode'] = true
end

function sling.model.StrictEqualsExpressionNode:_construct0()
	sling.model.StrictEqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.StrictEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.StrictEqualsExpressionNode._construct0(_g.sling.model.StrictEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StrictEqualsExpressionNode:getNodeTypeName()
	do return "StrictEqualsExpressionNode" end
end

function sling.model.StrictEqualsExpressionNode:createNew()
	do return _g.sling.model.StrictEqualsExpressionNode._construct0(_g.sling.model.StrictEqualsExpressionNode._create()) end
end

function sling.model.StrictEqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StrictEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StrictEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StrictEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StrictEqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.FailureLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.FailureLiteralExpressionNode.__index = sling.model.FailureLiteralExpressionNode
_vm:set_metatable(sling.model.FailureLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.FailureLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FailureLiteralExpressionNode)
	return v
end

function sling.model.FailureLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FailureLiteralExpressionNode'
	self['_isType.sling.model.FailureLiteralExpressionNode'] = true
end

function sling.model.FailureLiteralExpressionNode:_construct0()
	sling.model.FailureLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	return self
end

function sling.model.FailureLiteralExpressionNode:getNodeTypeName()
	do return "FailureLiteralExpressionNode" end
end

function sling.model.FailureLiteralExpressionNode:createNew()
	do return _g.sling.model.FailureLiteralExpressionNode._construct0(_g.sling.model.FailureLiteralExpressionNode._create()) end
end

function sling.model.FailureLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FailureLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FailureLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FailureLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FailureLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

sling.model.LogicalNotExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.LogicalNotExpressionNode.__index = sling.model.LogicalNotExpressionNode
_vm:set_metatable(sling.model.LogicalNotExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.LogicalNotExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalNotExpressionNode)
	return v
end

function sling.model.LogicalNotExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalNotExpressionNode'
	self['_isType.sling.model.LogicalNotExpressionNode'] = true
end

function sling.model.LogicalNotExpressionNode:_construct0()
	sling.model.LogicalNotExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalNotExpressionNode:forExpression(expression)
	local v = _g.sling.model.LogicalNotExpressionNode._construct0(_g.sling.model.LogicalNotExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.LogicalNotExpressionNode:getNodeTypeName()
	do return "LogicalNotExpressionNode" end
end

function sling.model.LogicalNotExpressionNode:createNew()
	do return _g.sling.model.LogicalNotExpressionNode._construct0(_g.sling.model.LogicalNotExpressionNode._create()) end
end

function sling.model.LogicalNotExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalNotExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalNotExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalNotExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalNotExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.YieldValueExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.YieldValueExpressionNode.__index = sling.model.YieldValueExpressionNode
_vm:set_metatable(sling.model.YieldValueExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.YieldValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.YieldValueExpressionNode)
	return v
end

function sling.model.YieldValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.YieldValueExpressionNode'
	self['_isType.sling.model.YieldValueExpressionNode'] = true
end

function sling.model.YieldValueExpressionNode:_construct0()
	sling.model.YieldValueExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.YieldValueExpressionNode:getNodeTypeName()
	do return "YieldValueExpressionNode" end
end

function sling.model.YieldValueExpressionNode:createNew()
	do return _g.sling.model.YieldValueExpressionNode._construct0(_g.sling.model.YieldValueExpressionNode._create()) end
end

function sling.model.YieldValueExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.YieldValueExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.YieldValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.YieldValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.YieldValueExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ExpressionDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ExpressionDataTypeNode.__index = sling.model.ExpressionDataTypeNode
_vm:set_metatable(sling.model.ExpressionDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ExpressionDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ExpressionDataTypeNode)
	return v
end

function sling.model.ExpressionDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExpressionDataTypeNode'
	self['_isType.sling.model.ExpressionDataTypeNode'] = true
	self.expression = nil
end

function sling.model.ExpressionDataTypeNode:_construct0()
	sling.model.ExpressionDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ExpressionDataTypeNode:getNodeTypeName()
	do return "ExpressionDataTypeNode" end
end

function sling.model.ExpressionDataTypeNode:createNew()
	do return _g.sling.model.ExpressionDataTypeNode._construct0(_g.sling.model.ExpressionDataTypeNode._create()) end
end

function sling.model.ExpressionDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExpressionDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ExpressionDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExpressionDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ExpressionDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ExpressionDataTypeNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ExpressionDataTypeNode:getExpression()
	do return self.expression end
end

function sling.model.ExpressionDataTypeNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.EmptyExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.EmptyExpressionNode.__index = sling.model.EmptyExpressionNode
_vm:set_metatable(sling.model.EmptyExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.EmptyExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.EmptyExpressionNode)
	return v
end

function sling.model.EmptyExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EmptyExpressionNode'
	self['_isType.sling.model.EmptyExpressionNode'] = true
end

function sling.model.EmptyExpressionNode:_construct0()
	sling.model.EmptyExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.EmptyExpressionNode:getNodeTypeName()
	do return "EmptyExpressionNode" end
end

function sling.model.EmptyExpressionNode:createNew()
	do return _g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create()) end
end

function sling.model.EmptyExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EmptyExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EmptyExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EmptyExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EmptyExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
end

sling.model.TemplateStatementNode = _g.sling.common.NodeObject._create()
sling.model.TemplateStatementNode.__index = sling.model.TemplateStatementNode
_vm:set_metatable(sling.model.TemplateStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TemplateStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.TemplateStatementNode)
	return v
end

function sling.model.TemplateStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TemplateStatementNode'
	self['_isType.sling.model.TemplateStatementNode'] = true
	self.name = nil
	self.relativeTo = nil
	self.symbol = nil
end

function sling.model.TemplateStatementNode:_construct0()
	sling.model.TemplateStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TemplateStatementNode:getNodeTypeName()
	do return "TemplateStatementNode" end
end

function sling.model.TemplateStatementNode:createNew()
	do return _g.sling.model.TemplateStatementNode._construct0(_g.sling.model.TemplateStatementNode._create()) end
end

function sling.model.TemplateStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TemplateStatementNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		n.name = self.name
		n.relativeTo = self.relativeTo
		do return true end
	end
end

function sling.model.TemplateStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TemplateStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TemplateStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.TemplateStatementNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.TemplateStatementNode:getSymbol()
	do return self.symbol end
end

function sling.model.TemplateStatementNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

function sling.model.TemplateStatementNode:setName(v)
	self.name = v
end

function sling.model.TemplateStatementNode:getName()
	do return self.name end
end

function sling.model.TemplateStatementNode:setRelativeTo(v)
	self.relativeTo = v
end

function sling.model.TemplateStatementNode:getRelativeTo()
	do return self.relativeTo end
end

sling.model.ContinueLabelStatementNode = _g.sling.model.LabeledControlStatementNode._create()
sling.model.ContinueLabelStatementNode.__index = sling.model.ContinueLabelStatementNode
_vm:set_metatable(sling.model.ContinueLabelStatementNode, {
	__index = _g.sling.model.LabeledControlStatementNode
})

function sling.model.ContinueLabelStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ContinueLabelStatementNode)
	return v
end

function sling.model.ContinueLabelStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ContinueLabelStatementNode'
	self['_isType.sling.model.ContinueLabelStatementNode'] = true
end

function sling.model.ContinueLabelStatementNode:_construct0()
	sling.model.ContinueLabelStatementNode._init(self)
	do _g.sling.model.LabeledControlStatementNode._construct0(self) end
	return self
end

function sling.model.ContinueLabelStatementNode:forLabel(label)
	local v = _g.sling.model.ContinueLabelStatementNode._construct0(_g.sling.model.ContinueLabelStatementNode._create())
	do v:setLabel(label) end
	do return v end
end

function sling.model.ContinueLabelStatementNode:getNodeTypeName()
	do return "ContinueLabelStatementNode" end
end

function sling.model.ContinueLabelStatementNode:createNew()
	do return _g.sling.model.ContinueLabelStatementNode._construct0(_g.sling.model.ContinueLabelStatementNode._create()) end
end

function sling.model.ContinueLabelStatementNode:copyTo(o)
	if _g.sling.model.LabeledControlStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ContinueLabelStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ContinueLabelStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LabeledControlStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ContinueLabelStatementNode:acceptVisitor(visitor)
	if _g.sling.model.LabeledControlStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ContinueLabelStatementNode:destroy()
	do _g.sling.model.LabeledControlStatementNode.destroy(self) end
end

sling.model.GetAddressExpressionNode = _g.sling.common.ExpressionNode._create()
sling.model.GetAddressExpressionNode.__index = sling.model.GetAddressExpressionNode
_vm:set_metatable(sling.model.GetAddressExpressionNode, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.GetAddressExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetAddressExpressionNode)
	return v
end

function sling.model.GetAddressExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetAddressExpressionNode'
	self['_isType.sling.model.GetAddressExpressionNode'] = true
	self.expression = nil
end

function sling.model.GetAddressExpressionNode:_construct0()
	sling.model.GetAddressExpressionNode._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	return self
end

function sling.model.GetAddressExpressionNode:getNodeTypeName()
	do return "GetAddressExpressionNode" end
end

function sling.model.GetAddressExpressionNode:createNew()
	do return _g.sling.model.GetAddressExpressionNode._construct0(_g.sling.model.GetAddressExpressionNode._create()) end
end

function sling.model.GetAddressExpressionNode:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetAddressExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetAddressExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetAddressExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetAddressExpressionNode:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.GetAddressExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.GetAddressExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.GetAddressExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end
sling = sling or {}

sling.model = sling.model or {}

sling.model.ext = sling.model.ext or {}

sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration.__index = sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration
_vm:set_metatable(sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration)
	return v
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration'
	self['_isType.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration'] = true
	self.path = nil
	self.expression = nil
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:_construct0()
	sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:getNodeTypeName()
	do return "NSlingWebApiRequestHandlerObjectDeclaration" end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:createNew()
	do return _g.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration._construct0(_g.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration._create()) end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.path = self.path
		do return true end
	end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:getExpression()
	do return self.expression end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:setPath(v)
	self.path = v
end

function sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration:getPath()
	do return self.path end
end

sling.model.ext.NSlingPropertyDeclaration = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingPropertyDeclaration.__index = sling.model.ext.NSlingPropertyDeclaration
_vm:set_metatable(sling.model.ext.NSlingPropertyDeclaration, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingPropertyDeclaration._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingPropertyDeclaration)
	return v
end

function sling.model.ext.NSlingPropertyDeclaration:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingPropertyDeclaration'
	self['_isType.sling.model.ext.NSlingPropertyDeclaration'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.type = nil
	self.name = nil
	self.backingVariableName = nil
	self.description = nil
	self.getter = nil
	self.setter = nil
	self.willSetHandler = nil
	self.didSetHandler = nil
	self.initializer = nil
end

function sling.model.ext.NSlingPropertyDeclaration:_construct0()
	sling.model.ext.NSlingPropertyDeclaration._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingPropertyDeclaration:getNodeName()
	do return self.name end
end

function sling.model.ext.NSlingPropertyDeclaration:getName()
	do return self:getNodeName() end
end

function sling.model.ext.NSlingPropertyDeclaration:renameNode(name)
	do self:setName(name) end
end

function sling.model.ext.NSlingPropertyDeclaration:getNodeTypeName()
	do return "NSlingPropertyDeclaration" end
end

function sling.model.ext.NSlingPropertyDeclaration:createNew()
	do return _g.sling.model.ext.NSlingPropertyDeclaration._construct0(_g.sling.model.ext.NSlingPropertyDeclaration._create()) end
end

function sling.model.ext.NSlingPropertyDeclaration:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingPropertyDeclaration')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.getter ~= nil then
			do n.getter:destroy() end
			n.getter = nil
		end
		if self.getter ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.getter), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.getter = pcp
			do n.getter:setParent(n) end
		end
		if n.setter ~= nil then
			do n.setter:destroy() end
			n.setter = nil
		end
		if self.setter ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.setter), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.setter = pcp
			do n.setter:setParent(n) end
		end
		if n.willSetHandler ~= nil then
			do n.willSetHandler:destroy() end
			n.willSetHandler = nil
		end
		if self.willSetHandler ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.willSetHandler), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.willSetHandler = pcp
			do n.willSetHandler:setParent(n) end
		end
		if n.didSetHandler ~= nil then
			do n.didSetHandler:destroy() end
			n.didSetHandler = nil
		end
		if self.didSetHandler ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.didSetHandler), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.didSetHandler = pcp
			do n.didSetHandler:setParent(n) end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		n.name = self.name
		n.backingVariableName = self.backingVariableName
		n.description = self.description
		do return true end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.getter then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.getter:destroy() end
		end
		self.getter = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.getter ~= nil then
			do self.getter:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.setter then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.setter:destroy() end
		end
		self.setter = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.setter ~= nil then
			do self.setter:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.willSetHandler then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.willSetHandler:destroy() end
		end
		self.willSetHandler = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.willSetHandler ~= nil then
			do self.willSetHandler:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.didSetHandler then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.didSetHandler:destroy() end
		end
		self.didSetHandler = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.didSetHandler ~= nil then
			do self.didSetHandler:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingPropertyDeclaration:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.getter ~= nil then
		if self.getter:accept(visitor) == false then
			do return false end
		end
	end
	if self.setter ~= nil then
		if self.setter:accept(visitor) == false then
			do return false end
		end
	end
	if self.willSetHandler ~= nil then
		if self.willSetHandler:accept(visitor) == false then
			do return false end
		end
	end
	if self.didSetHandler ~= nil then
		if self.didSetHandler:accept(visitor) == false then
			do return false end
		end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingPropertyDeclaration:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.getter ~= nil then
		do self.getter:destroy() end
		self.getter = nil
	end
	if self.setter ~= nil then
		do self.setter:destroy() end
		self.setter = nil
	end
	if self.willSetHandler ~= nil then
		do self.willSetHandler:destroy() end
		self.willSetHandler = nil
	end
	if self.didSetHandler ~= nil then
		do self.didSetHandler:destroy() end
		self.didSetHandler = nil
	end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
end

function sling.model.ext.NSlingPropertyDeclaration:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:getType()
	do return self.type end
end

function sling.model.ext.NSlingPropertyDeclaration:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ext.NSlingPropertyDeclaration:setGetter(v, doExport)
	if self.getter ~= nil and doExport == false then
		do self.getter:destroy() end
	end
	self.getter = v
	if self.getter ~= nil then
		do self.getter:setParent(self) end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:getGetter()
	do return self.getter end
end

function sling.model.ext.NSlingPropertyDeclaration:exportGetter()
	local v = self.getter
	self.getter = nil
	do return v end
end

function sling.model.ext.NSlingPropertyDeclaration:setSetter(v, doExport)
	if self.setter ~= nil and doExport == false then
		do self.setter:destroy() end
	end
	self.setter = v
	if self.setter ~= nil then
		do self.setter:setParent(self) end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:getSetter()
	do return self.setter end
end

function sling.model.ext.NSlingPropertyDeclaration:exportSetter()
	local v = self.setter
	self.setter = nil
	do return v end
end

function sling.model.ext.NSlingPropertyDeclaration:setWillSetHandler(v, doExport)
	if self.willSetHandler ~= nil and doExport == false then
		do self.willSetHandler:destroy() end
	end
	self.willSetHandler = v
	if self.willSetHandler ~= nil then
		do self.willSetHandler:setParent(self) end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:getWillSetHandler()
	do return self.willSetHandler end
end

function sling.model.ext.NSlingPropertyDeclaration:exportWillSetHandler()
	local v = self.willSetHandler
	self.willSetHandler = nil
	do return v end
end

function sling.model.ext.NSlingPropertyDeclaration:setDidSetHandler(v, doExport)
	if self.didSetHandler ~= nil and doExport == false then
		do self.didSetHandler:destroy() end
	end
	self.didSetHandler = v
	if self.didSetHandler ~= nil then
		do self.didSetHandler:setParent(self) end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:getDidSetHandler()
	do return self.didSetHandler end
end

function sling.model.ext.NSlingPropertyDeclaration:exportDidSetHandler()
	local v = self.didSetHandler
	self.didSetHandler = nil
	do return v end
end

function sling.model.ext.NSlingPropertyDeclaration:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.ext.NSlingPropertyDeclaration:getInitializer()
	do return self.initializer end
end

function sling.model.ext.NSlingPropertyDeclaration:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.ext.NSlingPropertyDeclaration:setName(v)
	self.name = v
end

function sling.model.ext.NSlingPropertyDeclaration:setBackingVariableName(v)
	self.backingVariableName = v
end

function sling.model.ext.NSlingPropertyDeclaration:getBackingVariableName()
	do return self.backingVariableName end
end

function sling.model.ext.NSlingPropertyDeclaration:setDescription(v)
	self.description = v
end

function sling.model.ext.NSlingPropertyDeclaration:getDescription()
	do return self.description end
end

sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration.__index = sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration
_vm:set_metatable(sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration)
	return v
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration'
	self['_isType.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration'] = true
	self.method = nil
	self.path = nil
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:_construct0()
	sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:getNodeTypeName()
	do return "NSlingWebApiRequestHandlerFunctionDeclaration" end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:createNew()
	do return _g.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration._construct0(_g.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration._create()) end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration')
		if n == nil then
			do return true end
		end
		n.method = self.method
		n.path = self.path
		do return true end
	end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:setMethod(v)
	self.method = v
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:getMethod()
	do return self.method end
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:setPath(v)
	self.path = v
end

function sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration:getPath()
	do return self.path end
end

sling.model.ext.NSlingStyleSheetDeclarationExpression = _g.sling.common.ExpressionNode._create()
sling.model.ext.NSlingStyleSheetDeclarationExpression.__index = sling.model.ext.NSlingStyleSheetDeclarationExpression
_vm:set_metatable(sling.model.ext.NSlingStyleSheetDeclarationExpression, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.ext.NSlingStyleSheetDeclarationExpression._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingStyleSheetDeclarationExpression)
	return v
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingStyleSheetDeclarationExpression'
	self['_isType.sling.model.ext.NSlingStyleSheetDeclarationExpression'] = true
	self.styles = nil
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:_construct0()
	sling.model.ext.NSlingStyleSheetDeclarationExpression._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.ext.NSlingStyleSheetDataType._construct0(_g.sling.model.ext.NSlingStyleSheetDataType._create()), false) end
	return self
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:getNodeTypeName()
	do return "NSlingStyleSheetDeclarationExpression" end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:createNew()
	do return _g.sling.model.ext.NSlingStyleSheetDeclarationExpression._construct0(_g.sling.model.ext.NSlingStyleSheetDeclarationExpression._create()) end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingStyleSheetDeclarationExpression')
		if n == nil then
			do return true end
		end
		do
			local array = n.styles
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.styles = nil
			if self.styles ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.styles)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.styles[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.styles == nil then
								n.styles = {}
							end
							do _g.jk.lang.Vector:append(n.styles, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.styles, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.styles, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.styles ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.styles)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.styles[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.styles = nil
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:setStyles(v, doExport)
	if self.styles ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.styles)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.styles[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.styles = nil
	else
		self.styles = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.styles, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:getStyles()
	do return self.styles end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:exportStyles()
	local v = self.styles
	self.styles = nil
	do return v end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:addToStyles(v)
	if v == nil then
		do return end
	end
	if self.styles == nil then
		self.styles = {}
	end
	do _g.jk.lang.Vector:append(self.styles, v) end
	do v:setParent(self) end
end

function sling.model.ext.NSlingStyleSheetDeclarationExpression:clearStyles()
	if self.styles ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.styles)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.styles[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.styles = nil
end

sling.model.ext.NSlingWebApiStatement = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingWebApiStatement.__index = sling.model.ext.NSlingWebApiStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiStatement, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingWebApiStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiStatement)
	return v
end

function sling.model.ext.NSlingWebApiStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiStatement'
	self['_isType.sling.model.ext.NSlingWebApiStatement'] = true
end

function sling.model.ext.NSlingWebApiStatement:_construct0()
	sling.model.ext.NSlingWebApiStatement._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiStatement:getNodeTypeName()
	do return "NSlingWebApiStatement" end
end

function sling.model.ext.NSlingWebApiStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiStatement._construct0(_g.sling.model.ext.NSlingWebApiStatement._create()) end
end

function sling.model.ext.NSlingWebApiStatement:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiStatement')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ext.NSlingWebApiStatement:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiStatement:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiStatement:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

sling.model.ext.NSlingWebApiSampleResponse = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiSampleResponse.__index = sling.model.ext.NSlingWebApiSampleResponse
_vm:set_metatable(sling.model.ext.NSlingWebApiSampleResponse, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiSampleResponse._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiSampleResponse)
	return v
end

function sling.model.ext.NSlingWebApiSampleResponse:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiSampleResponse'
	self['_isType.sling.model.ext.NSlingWebApiSampleResponse'] = true
	self.title = nil
	self.content = nil
end

function sling.model.ext.NSlingWebApiSampleResponse:_construct0()
	sling.model.ext.NSlingWebApiSampleResponse._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiSampleResponse:getNodeTypeName()
	do return "NSlingWebApiSampleResponse" end
end

function sling.model.ext.NSlingWebApiSampleResponse:createNew()
	do return _g.sling.model.ext.NSlingWebApiSampleResponse._construct0(_g.sling.model.ext.NSlingWebApiSampleResponse._create()) end
end

function sling.model.ext.NSlingWebApiSampleResponse:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiSampleResponse')
		if n == nil then
			do return true end
		end
		n.title = self.title
		n.content = self.content
		do return true end
	end
end

function sling.model.ext.NSlingWebApiSampleResponse:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiSampleResponse:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiSampleResponse:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
end

function sling.model.ext.NSlingWebApiSampleResponse:setTitle(v)
	self.title = v
end

function sling.model.ext.NSlingWebApiSampleResponse:getTitle()
	do return self.title end
end

function sling.model.ext.NSlingWebApiSampleResponse:setContent(v)
	self.content = v
end

function sling.model.ext.NSlingWebApiSampleResponse:getContent()
	do return self.content end
end

sling.model.ext.NSlingWebApiInPathStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiInPathStatement.__index = sling.model.ext.NSlingWebApiInPathStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiInPathStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiInPathStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiInPathStatement)
	return v
end

function sling.model.ext.NSlingWebApiInPathStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiInPathStatement'
	self['_isType.sling.model.ext.NSlingWebApiInPathStatement'] = true
	self.name = nil
	self.type = nil
	self.description = nil
end

function sling.model.ext.NSlingWebApiInPathStatement:_construct0()
	sling.model.ext.NSlingWebApiInPathStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiInPathStatement:getNodeTypeName()
	do return "NSlingWebApiInPathStatement" end
end

function sling.model.ext.NSlingWebApiInPathStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiInPathStatement._construct0(_g.sling.model.ext.NSlingWebApiInPathStatement._create()) end
end

function sling.model.ext.NSlingWebApiInPathStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiInPathStatement')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.name = self.name
		n.description = self.description
		do return true end
	end
end

function sling.model.ext.NSlingWebApiInPathStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiInPathStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiInPathStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.ext.NSlingWebApiInPathStatement:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiInPathStatement:getType()
	do return self.type end
end

function sling.model.ext.NSlingWebApiInPathStatement:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ext.NSlingWebApiInPathStatement:setName(v)
	self.name = v
end

function sling.model.ext.NSlingWebApiInPathStatement:getName()
	do return self.name end
end

function sling.model.ext.NSlingWebApiInPathStatement:setDescription(v)
	self.description = v
end

function sling.model.ext.NSlingWebApiInPathStatement:getDescription()
	do return self.description end
end

sling.model.ext.NSlingTreeDeclarationExpression = _g.sling.common.ExpressionNode._create()
sling.model.ext.NSlingTreeDeclarationExpression.__index = sling.model.ext.NSlingTreeDeclarationExpression
_vm:set_metatable(sling.model.ext.NSlingTreeDeclarationExpression, {
	__index = _g.sling.common.ExpressionNode
})

function sling.model.ext.NSlingTreeDeclarationExpression._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingTreeDeclarationExpression)
	return v
end

function sling.model.ext.NSlingTreeDeclarationExpression:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingTreeDeclarationExpression'
	self['_isType.sling.model.ext.NSlingTreeDeclarationExpression'] = true
	self.root = nil
end

function sling.model.ext.NSlingTreeDeclarationExpression:_construct0()
	sling.model.ext.NSlingTreeDeclarationExpression._init(self)
	do _g.sling.common.ExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.ext.NSlingTreeDataType._construct0(_g.sling.model.ext.NSlingTreeDataType._create()), false) end
	return self
end

function sling.model.ext.NSlingTreeDeclarationExpression:getNodeTypeName()
	do return "NSlingTreeDeclarationExpression" end
end

function sling.model.ext.NSlingTreeDeclarationExpression:createNew()
	do return _g.sling.model.ext.NSlingTreeDeclarationExpression._construct0(_g.sling.model.ext.NSlingTreeDeclarationExpression._create()) end
end

function sling.model.ext.NSlingTreeDeclarationExpression:copyTo(o)
	if _g.sling.common.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingTreeDeclarationExpression')
		if n == nil then
			do return true end
		end
		if n.root ~= nil then
			do n.root:destroy() end
			n.root = nil
		end
		if self.root ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.root), '_isType.sling.model.ext.NSlingTreeNode')
			if pcp == nil then
				do return false end
			end
			n.root = pcp
			do n.root:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ext.NSlingTreeDeclarationExpression:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.root then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ext.NSlingTreeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.root:destroy() end
		end
		self.root = _vm:to_table_with_key(newnode, '_isType.sling.model.ext.NSlingTreeNode')
		if self.root ~= nil then
			do self.root:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingTreeDeclarationExpression:acceptVisitor(visitor)
	if _g.sling.common.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.root ~= nil then
		if self.root:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingTreeDeclarationExpression:destroy()
	do _g.sling.common.ExpressionNode.destroy(self) end
	if self.root ~= nil then
		do self.root:destroy() end
		self.root = nil
	end
end

function sling.model.ext.NSlingTreeDeclarationExpression:setRoot(v, doExport)
	if self.root ~= nil and doExport == false then
		do self.root:destroy() end
	end
	self.root = v
	if self.root ~= nil then
		do self.root:setParent(self) end
	end
end

function sling.model.ext.NSlingTreeDeclarationExpression:getRoot()
	do return self.root end
end

function sling.model.ext.NSlingTreeDeclarationExpression:exportRoot()
	local v = self.root
	self.root = nil
	do return v end
end

sling.model.ext.NSlingWebApiOutErrorStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiOutErrorStatement.__index = sling.model.ext.NSlingWebApiOutErrorStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiOutErrorStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiOutErrorStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiOutErrorStatement)
	return v
end

function sling.model.ext.NSlingWebApiOutErrorStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiOutErrorStatement'
	self['_isType.sling.model.ext.NSlingWebApiOutErrorStatement'] = true
	self.code = nil
	self.data = nil
end

function sling.model.ext.NSlingWebApiOutErrorStatement:_construct0()
	sling.model.ext.NSlingWebApiOutErrorStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiOutErrorStatement:getNodeTypeName()
	do return "NSlingWebApiOutErrorStatement" end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiOutErrorStatement._construct0(_g.sling.model.ext.NSlingWebApiOutErrorStatement._create()) end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiOutErrorStatement')
		if n == nil then
			do return true end
		end
		if n.code ~= nil then
			do n.code:destroy() end
			n.code = nil
		end
		if self.code ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.code), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.code = pcp
			do n.code:setParent(n) end
		end
		if n.data ~= nil then
			do n.data:destroy() end
			n.data = nil
		end
		if self.data ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.data), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.data = pcp
			do n.data:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.code then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.code:destroy() end
		end
		self.code = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.code ~= nil then
			do self.code:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.data then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.data:destroy() end
		end
		self.data = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.data ~= nil then
			do self.data:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.code ~= nil then
		if self.code:accept(visitor) == false then
			do return false end
		end
	end
	if self.data ~= nil then
		if self.data:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.code ~= nil then
		do self.code:destroy() end
		self.code = nil
	end
	if self.data ~= nil then
		do self.data:destroy() end
		self.data = nil
	end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:setCode(v, doExport)
	if self.code ~= nil and doExport == false then
		do self.code:destroy() end
	end
	self.code = v
	if self.code ~= nil then
		do self.code:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:getCode()
	do return self.code end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:exportCode()
	local v = self.code
	self.code = nil
	do return v end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:setData(v, doExport)
	if self.data ~= nil and doExport == false then
		do self.data:destroy() end
	end
	self.data = v
	if self.data ~= nil then
		do self.data:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:getData()
	do return self.data end
end

function sling.model.ext.NSlingWebApiOutErrorStatement:exportData()
	local v = self.data
	self.data = nil
	do return v end
end

sling.model.ext.NSlingUnitSettings = _g.sling.common.CodeUnitSettingsNode._create()
sling.model.ext.NSlingUnitSettings.__index = sling.model.ext.NSlingUnitSettings
_vm:set_metatable(sling.model.ext.NSlingUnitSettings, {
	__index = _g.sling.common.CodeUnitSettingsNode
})

function sling.model.ext.NSlingUnitSettings._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingUnitSettings)
	return v
end

function sling.model.ext.NSlingUnitSettings:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingUnitSettings'
	self['_isType.sling.model.ext.NSlingUnitSettings'] = true
	self.isMainUnit = false
	self.vendorId = nil
	self.projectVersion = nil
	self.projectId = nil
	self.projectTitle = nil
	self.projectDescription = nil
	self.projectCopyright = nil
	self.projectLicense = nil
	self.moduleId = nil
	self.moduleTitle = nil
	self.moduleDescription = nil
	self.useJkop = false
	self.imports = nil
	self.resources = nil
	self.defines = nil
	self.ignoreModuleIdInNamespace = false
	self.libraries = nil
	self.androidProjectId = nil
	self.androidVersion = nil
	self.androidPackageName = nil
	self.androidMinSdkVersion = 0
	self.androidTargetSdkVersion = 0
	self.androidToolsVersion = nil
	self.androidGradlePluginVersion = nil
	self.androidKotlinVersion = nil
	self.androidEnableAndroidJackForLibraries = false
	self.androidKeyStore = nil
	self.androidKeyStorePassword = nil
	self.androidKeyAlias = nil
	self.androidKeyAliasPassword = nil
	self.androidGoogleServicesVersion = nil
	self.androidMetaData = nil
	self.androidManifestCustomXmls = nil
	self.androidManifestApplicationCustomXmls = nil
	self.androidPermissions = nil
	self.androidFeatures = nil
	self.androidGradleDepends = nil
	self.androidGradleHeap = nil
	self.iosProjectName = nil
	self.iosVersion = nil
	self.iosDisplayName = nil
	self.iosCflags = nil
	self.iosLinkMethod = nil
	self.iosDeploymentTarget = nil
	self.iosResultType = nil
	self.iosPods = nil
	self.iosFrameworks = nil
	self.iosLinkLibs = nil
	self.iosLdFlags = nil
	self.iosPlists = nil
	self.iosInfoPlistData = nil
	self.iosScreenOrientation = nil
	self.mavenArtifactId = nil
	self.mavenGroupId = nil
	self.mavenVersion = nil
	self.mavenName = nil
	self.npmPackageJson = nil
	self.npmAngularJson = nil
	self.npmTsconfigJson = nil
	self.npmTslintJson = nil
end

function sling.model.ext.NSlingUnitSettings:_construct0()
	sling.model.ext.NSlingUnitSettings._init(self)
	do _g.sling.common.CodeUnitSettingsNode._construct0(self) end
	return self
end

function sling.model.ext.NSlingUnitSettings:getNodeTypeName()
	do return "NSlingUnitSettings" end
end

function sling.model.ext.NSlingUnitSettings:createNew()
	do return _g.sling.model.ext.NSlingUnitSettings._construct0(_g.sling.model.ext.NSlingUnitSettings._create()) end
end

function sling.model.ext.NSlingUnitSettings:copyTo(o)
	if _g.sling.common.CodeUnitSettingsNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingUnitSettings')
		if n == nil then
			do return true end
		end
		n.isMainUnit = self.isMainUnit
		n.vendorId = self.vendorId
		n.projectVersion = self.projectVersion
		n.projectId = self.projectId
		n.projectTitle = self.projectTitle
		n.projectDescription = self.projectDescription
		n.projectCopyright = self.projectCopyright
		n.projectLicense = self.projectLicense
		n.moduleId = self.moduleId
		n.moduleTitle = self.moduleTitle
		n.moduleDescription = self.moduleDescription
		n.useJkop = self.useJkop
		n.defines = self.defines
		n.ignoreModuleIdInNamespace = self.ignoreModuleIdInNamespace
		n.androidProjectId = self.androidProjectId
		n.androidVersion = self.androidVersion
		n.androidPackageName = self.androidPackageName
		n.androidMinSdkVersion = self.androidMinSdkVersion
		n.androidTargetSdkVersion = self.androidTargetSdkVersion
		n.androidToolsVersion = self.androidToolsVersion
		n.androidGradlePluginVersion = self.androidGradlePluginVersion
		n.androidKotlinVersion = self.androidKotlinVersion
		n.androidEnableAndroidJackForLibraries = self.androidEnableAndroidJackForLibraries
		n.androidKeyStore = self.androidKeyStore
		n.androidKeyStorePassword = self.androidKeyStorePassword
		n.androidKeyAlias = self.androidKeyAlias
		n.androidKeyAliasPassword = self.androidKeyAliasPassword
		n.androidGoogleServicesVersion = self.androidGoogleServicesVersion
		n.androidMetaData = self.androidMetaData
		n.androidGradleHeap = self.androidGradleHeap
		n.iosProjectName = self.iosProjectName
		n.iosVersion = self.iosVersion
		n.iosDisplayName = self.iosDisplayName
		n.iosCflags = self.iosCflags
		n.iosLinkMethod = self.iosLinkMethod
		n.iosDeploymentTarget = self.iosDeploymentTarget
		n.iosResultType = self.iosResultType
		n.iosScreenOrientation = self.iosScreenOrientation
		n.mavenArtifactId = self.mavenArtifactId
		n.mavenGroupId = self.mavenGroupId
		n.mavenVersion = self.mavenVersion
		n.mavenName = self.mavenName
		n.npmPackageJson = self.npmPackageJson
		n.npmAngularJson = self.npmAngularJson
		n.npmTsconfigJson = self.npmTsconfigJson
		n.npmTslintJson = self.npmTslintJson
		n.imports = {}
		if self.imports ~= nil then
			local n2 = 0
			local m = _g.jk.lang.Vector:getSize(self.imports)
			do
				n2 = 0
				while n2 < m do
					local value = self.imports[n2 + 1]
					if value ~= nil then
						do _g.jk.lang.Vector:append(n.imports, value) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do
			local array = n.resources
			if array ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(array)
				do
					n3 = 0
					while n3 < m2 do
						local xx = _vm:to_table_with_key(array[n3 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			n.resources = nil
			if self.resources ~= nil then
				local n4 = 0
				local m3 = _g.jk.lang.Vector:getSize(self.resources)
				do
					n4 = 0
					while n4 < m3 do
						local nod = _vm:to_table_with_key(self.resources[n4 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.resources == nil then
								n.resources = {}
							end
							do _g.jk.lang.Vector:append(n.resources, ndup) end
							do ndup:setParent(n) end
						end
						do n4 = n4 + 1 end
					end
				end
			end
			n.libraries = {}
			if self.libraries ~= nil then
				local n5 = 0
				local m4 = _g.jk.lang.Vector:getSize(self.libraries)
				do
					n5 = 0
					while n5 < m4 do
						local value = self.libraries[n5 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.libraries, value) end
						end
						do n5 = n5 + 1 end
					end
				end
			end
			n.androidManifestCustomXmls = {}
			if self.androidManifestCustomXmls ~= nil then
				local n6 = 0
				local m5 = _g.jk.lang.Vector:getSize(self.androidManifestCustomXmls)
				do
					n6 = 0
					while n6 < m5 do
						local value = self.androidManifestCustomXmls[n6 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.androidManifestCustomXmls, value) end
						end
						do n6 = n6 + 1 end
					end
				end
			end
			n.androidManifestApplicationCustomXmls = {}
			if self.androidManifestApplicationCustomXmls ~= nil then
				local n7 = 0
				local m6 = _g.jk.lang.Vector:getSize(self.androidManifestApplicationCustomXmls)
				do
					n7 = 0
					while n7 < m6 do
						local value = self.androidManifestApplicationCustomXmls[n7 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.androidManifestApplicationCustomXmls, value) end
						end
						do n7 = n7 + 1 end
					end
				end
			end
			n.androidPermissions = {}
			if self.androidPermissions ~= nil then
				local n8 = 0
				local m7 = _g.jk.lang.Vector:getSize(self.androidPermissions)
				do
					n8 = 0
					while n8 < m7 do
						local value = self.androidPermissions[n8 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.androidPermissions, value) end
						end
						do n8 = n8 + 1 end
					end
				end
			end
			n.androidFeatures = {}
			if self.androidFeatures ~= nil then
				local n9 = 0
				local m8 = _g.jk.lang.Vector:getSize(self.androidFeatures)
				do
					n9 = 0
					while n9 < m8 do
						local value = self.androidFeatures[n9 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.androidFeatures, value) end
						end
						do n9 = n9 + 1 end
					end
				end
			end
			n.androidGradleDepends = {}
			if self.androidGradleDepends ~= nil then
				local n10 = 0
				local m9 = _g.jk.lang.Vector:getSize(self.androidGradleDepends)
				do
					n10 = 0
					while n10 < m9 do
						local value = self.androidGradleDepends[n10 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.androidGradleDepends, value) end
						end
						do n10 = n10 + 1 end
					end
				end
			end
			n.iosPods = {}
			if self.iosPods ~= nil then
				local n11 = 0
				local m10 = _g.jk.lang.Vector:getSize(self.iosPods)
				do
					n11 = 0
					while n11 < m10 do
						local value = self.iosPods[n11 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.iosPods, value) end
						end
						do n11 = n11 + 1 end
					end
				end
			end
			n.iosFrameworks = {}
			if self.iosFrameworks ~= nil then
				local n12 = 0
				local m11 = _g.jk.lang.Vector:getSize(self.iosFrameworks)
				do
					n12 = 0
					while n12 < m11 do
						local value = self.iosFrameworks[n12 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.iosFrameworks, value) end
						end
						do n12 = n12 + 1 end
					end
				end
			end
			n.iosLinkLibs = {}
			if self.iosLinkLibs ~= nil then
				local n13 = 0
				local m12 = _g.jk.lang.Vector:getSize(self.iosLinkLibs)
				do
					n13 = 0
					while n13 < m12 do
						local value = self.iosLinkLibs[n13 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.iosLinkLibs, value) end
						end
						do n13 = n13 + 1 end
					end
				end
			end
			n.iosLdFlags = {}
			if self.iosLdFlags ~= nil then
				local n14 = 0
				local m13 = _g.jk.lang.Vector:getSize(self.iosLdFlags)
				do
					n14 = 0
					while n14 < m13 do
						local value = self.iosLdFlags[n14 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.iosLdFlags, value) end
						end
						do n14 = n14 + 1 end
					end
				end
			end
			n.iosPlists = {}
			if self.iosPlists ~= nil then
				local n15 = 0
				local m14 = _g.jk.lang.Vector:getSize(self.iosPlists)
				do
					n15 = 0
					while n15 < m14 do
						local value = self.iosPlists[n15 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.iosPlists, value) end
						end
						do n15 = n15 + 1 end
					end
				end
			end
			n.iosInfoPlistData = {}
			if self.iosInfoPlistData ~= nil then
				local n16 = 0
				local m15 = _g.jk.lang.Vector:getSize(self.iosInfoPlistData)
				do
					n16 = 0
					while n16 < m15 do
						local value = self.iosInfoPlistData[n16 + 1]
						if value ~= nil then
							do _g.jk.lang.Vector:append(n.iosInfoPlistData, value) end
						end
						do n16 = n16 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.resources, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.CodeUnitSettingsNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingUnitSettings:acceptVisitor(visitor)
	if _g.sling.common.CodeUnitSettingsNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.resources, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingUnitSettings:destroy()
	do _g.sling.common.CodeUnitSettingsNode.destroy(self) end
	if self.resources ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.resources)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.resources[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.resources = nil
end

function sling.model.ext.NSlingUnitSettings:setIsMainUnit(v)
	self.isMainUnit = v
end

function sling.model.ext.NSlingUnitSettings:getIsMainUnit()
	do return self.isMainUnit end
end

function sling.model.ext.NSlingUnitSettings:setVendorId(v)
	self.vendorId = v
end

function sling.model.ext.NSlingUnitSettings:getVendorId()
	do return self.vendorId end
end

function sling.model.ext.NSlingUnitSettings:setProjectVersion(v)
	self.projectVersion = v
end

function sling.model.ext.NSlingUnitSettings:getProjectVersion()
	do return self.projectVersion end
end

function sling.model.ext.NSlingUnitSettings:setProjectId(v)
	self.projectId = v
end

function sling.model.ext.NSlingUnitSettings:getProjectId()
	do return self.projectId end
end

function sling.model.ext.NSlingUnitSettings:setProjectTitle(v)
	self.projectTitle = v
end

function sling.model.ext.NSlingUnitSettings:getProjectTitle()
	do return self.projectTitle end
end

function sling.model.ext.NSlingUnitSettings:setProjectDescription(v)
	self.projectDescription = v
end

function sling.model.ext.NSlingUnitSettings:getProjectDescription()
	do return self.projectDescription end
end

function sling.model.ext.NSlingUnitSettings:setProjectCopyright(v)
	self.projectCopyright = v
end

function sling.model.ext.NSlingUnitSettings:getProjectCopyright()
	do return self.projectCopyright end
end

function sling.model.ext.NSlingUnitSettings:setProjectLicense(v)
	self.projectLicense = v
end

function sling.model.ext.NSlingUnitSettings:getProjectLicense()
	do return self.projectLicense end
end

function sling.model.ext.NSlingUnitSettings:setModuleId(v)
	self.moduleId = v
end

function sling.model.ext.NSlingUnitSettings:getModuleId()
	do return self.moduleId end
end

function sling.model.ext.NSlingUnitSettings:setModuleTitle(v)
	self.moduleTitle = v
end

function sling.model.ext.NSlingUnitSettings:getModuleTitle()
	do return self.moduleTitle end
end

function sling.model.ext.NSlingUnitSettings:setModuleDescription(v)
	self.moduleDescription = v
end

function sling.model.ext.NSlingUnitSettings:getModuleDescription()
	do return self.moduleDescription end
end

function sling.model.ext.NSlingUnitSettings:setUseJkop(v)
	self.useJkop = v
end

function sling.model.ext.NSlingUnitSettings:getUseJkop()
	do return self.useJkop end
end

function sling.model.ext.NSlingUnitSettings:setDefines(v)
	self.defines = v
end

function sling.model.ext.NSlingUnitSettings:getDefines()
	do return self.defines end
end

function sling.model.ext.NSlingUnitSettings:setIgnoreModuleIdInNamespace(v)
	self.ignoreModuleIdInNamespace = v
end

function sling.model.ext.NSlingUnitSettings:getIgnoreModuleIdInNamespace()
	do return self.ignoreModuleIdInNamespace end
end

function sling.model.ext.NSlingUnitSettings:setAndroidProjectId(v)
	self.androidProjectId = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidProjectId()
	do return self.androidProjectId end
end

function sling.model.ext.NSlingUnitSettings:setAndroidVersion(v)
	self.androidVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidVersion()
	do return self.androidVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidPackageName(v)
	self.androidPackageName = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidPackageName()
	do return self.androidPackageName end
end

function sling.model.ext.NSlingUnitSettings:setAndroidMinSdkVersion(v)
	self.androidMinSdkVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidMinSdkVersion()
	do return self.androidMinSdkVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidTargetSdkVersion(v)
	self.androidTargetSdkVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidTargetSdkVersion()
	do return self.androidTargetSdkVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidToolsVersion(v)
	self.androidToolsVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidToolsVersion()
	do return self.androidToolsVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidGradlePluginVersion(v)
	self.androidGradlePluginVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidGradlePluginVersion()
	do return self.androidGradlePluginVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidKotlinVersion(v)
	self.androidKotlinVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidKotlinVersion()
	do return self.androidKotlinVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidEnableAndroidJackForLibraries(v)
	self.androidEnableAndroidJackForLibraries = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidEnableAndroidJackForLibraries()
	do return self.androidEnableAndroidJackForLibraries end
end

function sling.model.ext.NSlingUnitSettings:setAndroidKeyStore(v)
	self.androidKeyStore = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidKeyStore()
	do return self.androidKeyStore end
end

function sling.model.ext.NSlingUnitSettings:setAndroidKeyStorePassword(v)
	self.androidKeyStorePassword = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidKeyStorePassword()
	do return self.androidKeyStorePassword end
end

function sling.model.ext.NSlingUnitSettings:setAndroidKeyAlias(v)
	self.androidKeyAlias = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidKeyAlias()
	do return self.androidKeyAlias end
end

function sling.model.ext.NSlingUnitSettings:setAndroidKeyAliasPassword(v)
	self.androidKeyAliasPassword = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidKeyAliasPassword()
	do return self.androidKeyAliasPassword end
end

function sling.model.ext.NSlingUnitSettings:setAndroidGoogleServicesVersion(v)
	self.androidGoogleServicesVersion = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidGoogleServicesVersion()
	do return self.androidGoogleServicesVersion end
end

function sling.model.ext.NSlingUnitSettings:setAndroidMetaData(v)
	self.androidMetaData = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidMetaData()
	do return self.androidMetaData end
end

function sling.model.ext.NSlingUnitSettings:setAndroidGradleHeap(v)
	self.androidGradleHeap = v
end

function sling.model.ext.NSlingUnitSettings:getAndroidGradleHeap()
	do return self.androidGradleHeap end
end

function sling.model.ext.NSlingUnitSettings:setIosProjectName(v)
	self.iosProjectName = v
end

function sling.model.ext.NSlingUnitSettings:getIosProjectName()
	do return self.iosProjectName end
end

function sling.model.ext.NSlingUnitSettings:setIosVersion(v)
	self.iosVersion = v
end

function sling.model.ext.NSlingUnitSettings:getIosVersion()
	do return self.iosVersion end
end

function sling.model.ext.NSlingUnitSettings:setIosDisplayName(v)
	self.iosDisplayName = v
end

function sling.model.ext.NSlingUnitSettings:getIosDisplayName()
	do return self.iosDisplayName end
end

function sling.model.ext.NSlingUnitSettings:setIosCflags(v)
	self.iosCflags = v
end

function sling.model.ext.NSlingUnitSettings:getIosCflags()
	do return self.iosCflags end
end

function sling.model.ext.NSlingUnitSettings:setIosLinkMethod(v)
	self.iosLinkMethod = v
end

function sling.model.ext.NSlingUnitSettings:getIosLinkMethod()
	do return self.iosLinkMethod end
end

function sling.model.ext.NSlingUnitSettings:setIosDeploymentTarget(v)
	self.iosDeploymentTarget = v
end

function sling.model.ext.NSlingUnitSettings:getIosDeploymentTarget()
	do return self.iosDeploymentTarget end
end

function sling.model.ext.NSlingUnitSettings:setIosResultType(v)
	self.iosResultType = v
end

function sling.model.ext.NSlingUnitSettings:getIosResultType()
	do return self.iosResultType end
end

function sling.model.ext.NSlingUnitSettings:setIosScreenOrientation(v)
	self.iosScreenOrientation = v
end

function sling.model.ext.NSlingUnitSettings:getIosScreenOrientation()
	do return self.iosScreenOrientation end
end

function sling.model.ext.NSlingUnitSettings:setMavenArtifactId(v)
	self.mavenArtifactId = v
end

function sling.model.ext.NSlingUnitSettings:getMavenArtifactId()
	do return self.mavenArtifactId end
end

function sling.model.ext.NSlingUnitSettings:setMavenGroupId(v)
	self.mavenGroupId = v
end

function sling.model.ext.NSlingUnitSettings:getMavenGroupId()
	do return self.mavenGroupId end
end

function sling.model.ext.NSlingUnitSettings:setMavenVersion(v)
	self.mavenVersion = v
end

function sling.model.ext.NSlingUnitSettings:getMavenVersion()
	do return self.mavenVersion end
end

function sling.model.ext.NSlingUnitSettings:setMavenName(v)
	self.mavenName = v
end

function sling.model.ext.NSlingUnitSettings:getMavenName()
	do return self.mavenName end
end

function sling.model.ext.NSlingUnitSettings:setNpmPackageJson(v)
	self.npmPackageJson = v
end

function sling.model.ext.NSlingUnitSettings:getNpmPackageJson()
	do return self.npmPackageJson end
end

function sling.model.ext.NSlingUnitSettings:setNpmAngularJson(v)
	self.npmAngularJson = v
end

function sling.model.ext.NSlingUnitSettings:getNpmAngularJson()
	do return self.npmAngularJson end
end

function sling.model.ext.NSlingUnitSettings:setNpmTsconfigJson(v)
	self.npmTsconfigJson = v
end

function sling.model.ext.NSlingUnitSettings:getNpmTsconfigJson()
	do return self.npmTsconfigJson end
end

function sling.model.ext.NSlingUnitSettings:setNpmTslintJson(v)
	self.npmTslintJson = v
end

function sling.model.ext.NSlingUnitSettings:getNpmTslintJson()
	do return self.npmTslintJson end
end

function sling.model.ext.NSlingUnitSettings:setImports(v)
	self.imports = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.imports, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getImports()
	do return self.imports end
end

function sling.model.ext.NSlingUnitSettings:addToImports(v)
	if v == nil then
		do return end
	end
	if self.imports == nil then
		self.imports = {}
	end
	do _g.jk.lang.Vector:append(self.imports, v) end
end

function sling.model.ext.NSlingUnitSettings:clearImports()
	self.imports = nil
end

function sling.model.ext.NSlingUnitSettings:setResources(v, doExport)
	if self.resources ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.resources)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.resources[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.resources = nil
	else
		self.resources = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.resources, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getResources()
	do return self.resources end
end

function sling.model.ext.NSlingUnitSettings:exportResources()
	local v = self.resources
	self.resources = nil
	do return v end
end

function sling.model.ext.NSlingUnitSettings:addToResources(v)
	if v == nil then
		do return end
	end
	if self.resources == nil then
		self.resources = {}
	end
	do _g.jk.lang.Vector:append(self.resources, v) end
	do v:setParent(self) end
end

function sling.model.ext.NSlingUnitSettings:clearResources()
	if self.resources ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.resources)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.resources[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.resources = nil
end

function sling.model.ext.NSlingUnitSettings:setLibraries(v)
	self.libraries = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.libraries, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getLibraries()
	do return self.libraries end
end

function sling.model.ext.NSlingUnitSettings:addToLibraries(v)
	if v == nil then
		do return end
	end
	if self.libraries == nil then
		self.libraries = {}
	end
	do _g.jk.lang.Vector:append(self.libraries, v) end
end

function sling.model.ext.NSlingUnitSettings:clearLibraries()
	self.libraries = nil
end

function sling.model.ext.NSlingUnitSettings:setAndroidManifestCustomXmls(v)
	self.androidManifestCustomXmls = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.androidManifestCustomXmls, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getAndroidManifestCustomXmls()
	do return self.androidManifestCustomXmls end
end

function sling.model.ext.NSlingUnitSettings:addToAndroidManifestCustomXmls(v)
	if v == nil then
		do return end
	end
	if self.androidManifestCustomXmls == nil then
		self.androidManifestCustomXmls = {}
	end
	do _g.jk.lang.Vector:append(self.androidManifestCustomXmls, v) end
end

function sling.model.ext.NSlingUnitSettings:clearAndroidManifestCustomXmls()
	self.androidManifestCustomXmls = nil
end

function sling.model.ext.NSlingUnitSettings:setAndroidManifestApplicationCustomXmls(v)
	self.androidManifestApplicationCustomXmls = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.androidManifestApplicationCustomXmls, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getAndroidManifestApplicationCustomXmls()
	do return self.androidManifestApplicationCustomXmls end
end

function sling.model.ext.NSlingUnitSettings:addToAndroidManifestApplicationCustomXmls(v)
	if v == nil then
		do return end
	end
	if self.androidManifestApplicationCustomXmls == nil then
		self.androidManifestApplicationCustomXmls = {}
	end
	do _g.jk.lang.Vector:append(self.androidManifestApplicationCustomXmls, v) end
end

function sling.model.ext.NSlingUnitSettings:clearAndroidManifestApplicationCustomXmls()
	self.androidManifestApplicationCustomXmls = nil
end

function sling.model.ext.NSlingUnitSettings:setAndroidPermissions(v)
	self.androidPermissions = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.androidPermissions, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getAndroidPermissions()
	do return self.androidPermissions end
end

function sling.model.ext.NSlingUnitSettings:addToAndroidPermissions(v)
	if v == nil then
		do return end
	end
	if self.androidPermissions == nil then
		self.androidPermissions = {}
	end
	do _g.jk.lang.Vector:append(self.androidPermissions, v) end
end

function sling.model.ext.NSlingUnitSettings:clearAndroidPermissions()
	self.androidPermissions = nil
end

function sling.model.ext.NSlingUnitSettings:setAndroidFeatures(v)
	self.androidFeatures = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.androidFeatures, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getAndroidFeatures()
	do return self.androidFeatures end
end

function sling.model.ext.NSlingUnitSettings:addToAndroidFeatures(v)
	if v == nil then
		do return end
	end
	if self.androidFeatures == nil then
		self.androidFeatures = {}
	end
	do _g.jk.lang.Vector:append(self.androidFeatures, v) end
end

function sling.model.ext.NSlingUnitSettings:clearAndroidFeatures()
	self.androidFeatures = nil
end

function sling.model.ext.NSlingUnitSettings:setAndroidGradleDepends(v)
	self.androidGradleDepends = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.androidGradleDepends, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getAndroidGradleDepends()
	do return self.androidGradleDepends end
end

function sling.model.ext.NSlingUnitSettings:addToAndroidGradleDepends(v)
	if v == nil then
		do return end
	end
	if self.androidGradleDepends == nil then
		self.androidGradleDepends = {}
	end
	do _g.jk.lang.Vector:append(self.androidGradleDepends, v) end
end

function sling.model.ext.NSlingUnitSettings:clearAndroidGradleDepends()
	self.androidGradleDepends = nil
end

function sling.model.ext.NSlingUnitSettings:setIosPods(v)
	self.iosPods = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.iosPods, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getIosPods()
	do return self.iosPods end
end

function sling.model.ext.NSlingUnitSettings:addToIosPods(v)
	if v == nil then
		do return end
	end
	if self.iosPods == nil then
		self.iosPods = {}
	end
	do _g.jk.lang.Vector:append(self.iosPods, v) end
end

function sling.model.ext.NSlingUnitSettings:clearIosPods()
	self.iosPods = nil
end

function sling.model.ext.NSlingUnitSettings:setIosFrameworks(v)
	self.iosFrameworks = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.iosFrameworks, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getIosFrameworks()
	do return self.iosFrameworks end
end

function sling.model.ext.NSlingUnitSettings:addToIosFrameworks(v)
	if v == nil then
		do return end
	end
	if self.iosFrameworks == nil then
		self.iosFrameworks = {}
	end
	do _g.jk.lang.Vector:append(self.iosFrameworks, v) end
end

function sling.model.ext.NSlingUnitSettings:clearIosFrameworks()
	self.iosFrameworks = nil
end

function sling.model.ext.NSlingUnitSettings:setIosLinkLibs(v)
	self.iosLinkLibs = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.iosLinkLibs, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getIosLinkLibs()
	do return self.iosLinkLibs end
end

function sling.model.ext.NSlingUnitSettings:addToIosLinkLibs(v)
	if v == nil then
		do return end
	end
	if self.iosLinkLibs == nil then
		self.iosLinkLibs = {}
	end
	do _g.jk.lang.Vector:append(self.iosLinkLibs, v) end
end

function sling.model.ext.NSlingUnitSettings:clearIosLinkLibs()
	self.iosLinkLibs = nil
end

function sling.model.ext.NSlingUnitSettings:setIosLdFlags(v)
	self.iosLdFlags = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.iosLdFlags, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getIosLdFlags()
	do return self.iosLdFlags end
end

function sling.model.ext.NSlingUnitSettings:addToIosLdFlags(v)
	if v == nil then
		do return end
	end
	if self.iosLdFlags == nil then
		self.iosLdFlags = {}
	end
	do _g.jk.lang.Vector:append(self.iosLdFlags, v) end
end

function sling.model.ext.NSlingUnitSettings:clearIosLdFlags()
	self.iosLdFlags = nil
end

function sling.model.ext.NSlingUnitSettings:setIosPlists(v)
	self.iosPlists = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.iosPlists, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getIosPlists()
	do return self.iosPlists end
end

function sling.model.ext.NSlingUnitSettings:addToIosPlists(v)
	if v == nil then
		do return end
	end
	if self.iosPlists == nil then
		self.iosPlists = {}
	end
	do _g.jk.lang.Vector:append(self.iosPlists, v) end
end

function sling.model.ext.NSlingUnitSettings:clearIosPlists()
	self.iosPlists = nil
end

function sling.model.ext.NSlingUnitSettings:setIosInfoPlistData(v)
	self.iosInfoPlistData = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.iosInfoPlistData, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingUnitSettings:getIosInfoPlistData()
	do return self.iosInfoPlistData end
end

function sling.model.ext.NSlingUnitSettings:addToIosInfoPlistData(v)
	if v == nil then
		do return end
	end
	if self.iosInfoPlistData == nil then
		self.iosInfoPlistData = {}
	end
	do _g.jk.lang.Vector:append(self.iosInfoPlistData, v) end
end

function sling.model.ext.NSlingUnitSettings:clearIosInfoPlistData()
	self.iosInfoPlistData = nil
end

sling.model.ext.NSlingWebApiSampleRequest = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiSampleRequest.__index = sling.model.ext.NSlingWebApiSampleRequest
_vm:set_metatable(sling.model.ext.NSlingWebApiSampleRequest, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiSampleRequest._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiSampleRequest)
	return v
end

function sling.model.ext.NSlingWebApiSampleRequest:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiSampleRequest'
	self['_isType.sling.model.ext.NSlingWebApiSampleRequest'] = true
	self.title = nil
	self.content = nil
end

function sling.model.ext.NSlingWebApiSampleRequest:_construct0()
	sling.model.ext.NSlingWebApiSampleRequest._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiSampleRequest:getNodeTypeName()
	do return "NSlingWebApiSampleRequest" end
end

function sling.model.ext.NSlingWebApiSampleRequest:createNew()
	do return _g.sling.model.ext.NSlingWebApiSampleRequest._construct0(_g.sling.model.ext.NSlingWebApiSampleRequest._create()) end
end

function sling.model.ext.NSlingWebApiSampleRequest:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiSampleRequest')
		if n == nil then
			do return true end
		end
		n.title = self.title
		n.content = self.content
		do return true end
	end
end

function sling.model.ext.NSlingWebApiSampleRequest:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiSampleRequest:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiSampleRequest:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
end

function sling.model.ext.NSlingWebApiSampleRequest:setTitle(v)
	self.title = v
end

function sling.model.ext.NSlingWebApiSampleRequest:getTitle()
	do return self.title end
end

function sling.model.ext.NSlingWebApiSampleRequest:setContent(v)
	self.content = v
end

function sling.model.ext.NSlingWebApiSampleRequest:getContent()
	do return self.content end
end

sling.model.ext.NSlingWebApiOutOkStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiOutOkStatement.__index = sling.model.ext.NSlingWebApiOutOkStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiOutOkStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiOutOkStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiOutOkStatement)
	return v
end

function sling.model.ext.NSlingWebApiOutOkStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiOutOkStatement'
	self['_isType.sling.model.ext.NSlingWebApiOutOkStatement'] = true
	self.data = nil
end

function sling.model.ext.NSlingWebApiOutOkStatement:_construct0()
	sling.model.ext.NSlingWebApiOutOkStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiOutOkStatement:getNodeTypeName()
	do return "NSlingWebApiOutOkStatement" end
end

function sling.model.ext.NSlingWebApiOutOkStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiOutOkStatement._construct0(_g.sling.model.ext.NSlingWebApiOutOkStatement._create()) end
end

function sling.model.ext.NSlingWebApiOutOkStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiOutOkStatement')
		if n == nil then
			do return true end
		end
		if n.data ~= nil then
			do n.data:destroy() end
			n.data = nil
		end
		if self.data ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.data), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.data = pcp
			do n.data:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ext.NSlingWebApiOutOkStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.data then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.data:destroy() end
		end
		self.data = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.data ~= nil then
			do self.data:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiOutOkStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.data ~= nil then
		if self.data:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiOutOkStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.data ~= nil then
		do self.data:destroy() end
		self.data = nil
	end
end

function sling.model.ext.NSlingWebApiOutOkStatement:setData(v, doExport)
	if self.data ~= nil and doExport == false then
		do self.data:destroy() end
	end
	self.data = v
	if self.data ~= nil then
		do self.data:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiOutOkStatement:getData()
	do return self.data end
end

function sling.model.ext.NSlingWebApiOutOkStatement:exportData()
	local v = self.data
	self.data = nil
	do return v end
end

sling.model.ext.NSlingStyleDeclarationProperty = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingStyleDeclarationProperty.__index = sling.model.ext.NSlingStyleDeclarationProperty
_vm:set_metatable(sling.model.ext.NSlingStyleDeclarationProperty, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingStyleDeclarationProperty._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingStyleDeclarationProperty)
	return v
end

function sling.model.ext.NSlingStyleDeclarationProperty:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingStyleDeclarationProperty'
	self['_isType.sling.model.ext.NSlingStyleDeclarationProperty'] = true
	self.name = nil
	self.value = nil
end

function sling.model.ext.NSlingStyleDeclarationProperty:_construct0()
	sling.model.ext.NSlingStyleDeclarationProperty._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingStyleDeclarationProperty:getNodeTypeName()
	do return "NSlingStyleDeclarationProperty" end
end

function sling.model.ext.NSlingStyleDeclarationProperty:createNew()
	do return _g.sling.model.ext.NSlingStyleDeclarationProperty._construct0(_g.sling.model.ext.NSlingStyleDeclarationProperty._create()) end
end

function sling.model.ext.NSlingStyleDeclarationProperty:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingStyleDeclarationProperty')
		if n == nil then
			do return true end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.ext.NSlingStyleDeclarationProperty:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingStyleDeclarationProperty:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingStyleDeclarationProperty:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.ext.NSlingStyleDeclarationProperty:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.ext.NSlingStyleDeclarationProperty:getValue()
	do return self.value end
end

function sling.model.ext.NSlingStyleDeclarationProperty:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.ext.NSlingStyleDeclarationProperty:setName(v)
	self.name = v
end

function sling.model.ext.NSlingStyleDeclarationProperty:getName()
	do return self.name end
end

sling.model.ext.NSlingTreeNode = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingTreeNode.__index = sling.model.ext.NSlingTreeNode
_vm:set_metatable(sling.model.ext.NSlingTreeNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingTreeNode._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingTreeNode)
	return v
end

function sling.model.ext.NSlingTreeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingTreeNode'
	self['_isType.sling.model.ext.NSlingTreeNode'] = true
	self.name = nil
	self.attributes = nil
	self.children = nil
end

function sling.model.ext.NSlingTreeNode:_construct0()
	sling.model.ext.NSlingTreeNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingTreeNode:getNodeTypeName()
	do return "NSlingTreeNode" end
end

function sling.model.ext.NSlingTreeNode:createNew()
	do return _g.sling.model.ext.NSlingTreeNode._construct0(_g.sling.model.ext.NSlingTreeNode._create()) end
end

function sling.model.ext.NSlingTreeNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingTreeNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		do
			local array = n.attributes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.attributes = nil
			if self.attributes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.attributes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.attributes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.attributes == nil then
								n.attributes = {}
							end
							do _g.jk.lang.Vector:append(n.attributes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.children
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.children = nil
				if self.children ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.children)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.children[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.children == nil then
									n.children = {}
								end
								do _g.jk.lang.Vector:append(n.children, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.ext.NSlingTreeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.attributes, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.children, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingTreeNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.attributes, visitor) == false then
		do return false end
	end
	if self:visitVector(self.children, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingTreeNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.attributes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.attributes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.attributes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.attributes = nil
	if self.children ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.children)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.children[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.children = nil
end

function sling.model.ext.NSlingTreeNode:setName(v)
	self.name = v
end

function sling.model.ext.NSlingTreeNode:getName()
	do return self.name end
end

function sling.model.ext.NSlingTreeNode:setAttributes(v, doExport)
	if self.attributes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.attributes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.attributes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.attributes = nil
	else
		self.attributes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.attributes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ext.NSlingTreeNode:getAttributes()
	do return self.attributes end
end

function sling.model.ext.NSlingTreeNode:exportAttributes()
	local v = self.attributes
	self.attributes = nil
	do return v end
end

function sling.model.ext.NSlingTreeNode:addToAttributes(v)
	if v == nil then
		do return end
	end
	if self.attributes == nil then
		self.attributes = {}
	end
	do _g.jk.lang.Vector:append(self.attributes, v) end
	do v:setParent(self) end
end

function sling.model.ext.NSlingTreeNode:clearAttributes()
	if self.attributes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.attributes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.attributes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.attributes = nil
end

function sling.model.ext.NSlingTreeNode:setChildren(v, doExport)
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.children = nil
	else
		self.children = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.children, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ext.NSlingTreeNode:getChildren()
	do return self.children end
end

function sling.model.ext.NSlingTreeNode:exportChildren()
	local v = self.children
	self.children = nil
	do return v end
end

function sling.model.ext.NSlingTreeNode:addToChildren(v)
	if v == nil then
		do return end
	end
	if self.children == nil then
		self.children = {}
	end
	do _g.jk.lang.Vector:append(self.children, v) end
	do v:setParent(self) end
end

function sling.model.ext.NSlingTreeNode:clearChildren()
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.children = nil
end

sling.model.ext.NSlingWebApiInQueryParameterStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiInQueryParameterStatement.__index = sling.model.ext.NSlingWebApiInQueryParameterStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiInQueryParameterStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiInQueryParameterStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiInQueryParameterStatement)
	return v
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiInQueryParameterStatement'
	self['_isType.sling.model.ext.NSlingWebApiInQueryParameterStatement'] = true
	self.name = nil
	self.type = nil
	self.optional = false
	self.description = nil
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:_construct0()
	sling.model.ext.NSlingWebApiInQueryParameterStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:getNodeTypeName()
	do return "NSlingWebApiInQueryParameterStatement" end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiInQueryParameterStatement._construct0(_g.sling.model.ext.NSlingWebApiInQueryParameterStatement._create()) end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiInQueryParameterStatement')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.name = self.name
		n.optional = self.optional
		n.description = self.description
		do return true end
	end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:getType()
	do return self.type end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:setName(v)
	self.name = v
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:getName()
	do return self.name end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:setOptional(v)
	self.optional = v
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:getOptional()
	do return self.optional end
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:setDescription(v)
	self.description = v
end

function sling.model.ext.NSlingWebApiInQueryParameterStatement:getDescription()
	do return self.description end
end

sling.model.ext.NSlingTreeDataType = _g.sling.common.DataTypeNode._create()
sling.model.ext.NSlingTreeDataType.__index = sling.model.ext.NSlingTreeDataType
_vm:set_metatable(sling.model.ext.NSlingTreeDataType, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ext.NSlingTreeDataType._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingTreeDataType)
	return v
end

function sling.model.ext.NSlingTreeDataType:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingTreeDataType'
	self['_isType.sling.model.ext.NSlingTreeDataType'] = true
end

function sling.model.ext.NSlingTreeDataType:_construct0()
	sling.model.ext.NSlingTreeDataType._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ext.NSlingTreeDataType:getNodeTypeName()
	do return "NSlingTreeDataType" end
end

function sling.model.ext.NSlingTreeDataType:createNew()
	do return _g.sling.model.ext.NSlingTreeDataType._construct0(_g.sling.model.ext.NSlingTreeDataType._create()) end
end

function sling.model.ext.NSlingTreeDataType:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingTreeDataType')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ext.NSlingTreeDataType:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingTreeDataType:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingTreeDataType:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.ext.NSlingWebApiOutObjectStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiOutObjectStatement.__index = sling.model.ext.NSlingWebApiOutObjectStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiOutObjectStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiOutObjectStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiOutObjectStatement)
	return v
end

function sling.model.ext.NSlingWebApiOutObjectStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiOutObjectStatement'
	self['_isType.sling.model.ext.NSlingWebApiOutObjectStatement'] = true
	self.data = nil
end

function sling.model.ext.NSlingWebApiOutObjectStatement:_construct0()
	sling.model.ext.NSlingWebApiOutObjectStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiOutObjectStatement:getNodeTypeName()
	do return "NSlingWebApiOutObjectStatement" end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiOutObjectStatement._construct0(_g.sling.model.ext.NSlingWebApiOutObjectStatement._create()) end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiOutObjectStatement')
		if n == nil then
			do return true end
		end
		if n.data ~= nil then
			do n.data:destroy() end
			n.data = nil
		end
		if self.data ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.data), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.data = pcp
			do n.data:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.data then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.data:destroy() end
		end
		self.data = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.data ~= nil then
			do self.data:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.data ~= nil then
		if self.data:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.data ~= nil then
		do self.data:destroy() end
		self.data = nil
	end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:setData(v, doExport)
	if self.data ~= nil and doExport == false then
		do self.data:destroy() end
	end
	self.data = v
	if self.data ~= nil then
		do self.data:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:getData()
	do return self.data end
end

function sling.model.ext.NSlingWebApiOutObjectStatement:exportData()
	local v = self.data
	self.data = nil
	do return v end
end

sling.model.ext.NSlingWebApiInSessionStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiInSessionStatement.__index = sling.model.ext.NSlingWebApiInSessionStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiInSessionStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiInSessionStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiInSessionStatement)
	return v
end

function sling.model.ext.NSlingWebApiInSessionStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiInSessionStatement'
	self['_isType.sling.model.ext.NSlingWebApiInSessionStatement'] = true
	self.name = nil
	self.type = nil
end

function sling.model.ext.NSlingWebApiInSessionStatement:_construct0()
	sling.model.ext.NSlingWebApiInSessionStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiInSessionStatement:getNodeTypeName()
	do return "NSlingWebApiInSessionStatement" end
end

function sling.model.ext.NSlingWebApiInSessionStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiInSessionStatement._construct0(_g.sling.model.ext.NSlingWebApiInSessionStatement._create()) end
end

function sling.model.ext.NSlingWebApiInSessionStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiInSessionStatement')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.ext.NSlingWebApiInSessionStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiInSessionStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiInSessionStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.ext.NSlingWebApiInSessionStatement:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiInSessionStatement:getType()
	do return self.type end
end

function sling.model.ext.NSlingWebApiInSessionStatement:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ext.NSlingWebApiInSessionStatement:setName(v)
	self.name = v
end

function sling.model.ext.NSlingWebApiInSessionStatement:getName()
	do return self.name end
end

sling.model.ext.NSlingWebApiInPostStatement = _g.sling.model.ext.NSlingWebApiStatement._create()
sling.model.ext.NSlingWebApiInPostStatement.__index = sling.model.ext.NSlingWebApiInPostStatement
_vm:set_metatable(sling.model.ext.NSlingWebApiInPostStatement, {
	__index = _g.sling.model.ext.NSlingWebApiStatement
})

function sling.model.ext.NSlingWebApiInPostStatement._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingWebApiInPostStatement)
	return v
end

function sling.model.ext.NSlingWebApiInPostStatement:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingWebApiInPostStatement'
	self['_isType.sling.model.ext.NSlingWebApiInPostStatement'] = true
	self.name = nil
	self.type = nil
	self.description = nil
end

function sling.model.ext.NSlingWebApiInPostStatement:_construct0()
	sling.model.ext.NSlingWebApiInPostStatement._init(self)
	do _g.sling.model.ext.NSlingWebApiStatement._construct0(self) end
	return self
end

function sling.model.ext.NSlingWebApiInPostStatement:getNodeTypeName()
	do return "NSlingWebApiInPostStatement" end
end

function sling.model.ext.NSlingWebApiInPostStatement:createNew()
	do return _g.sling.model.ext.NSlingWebApiInPostStatement._construct0(_g.sling.model.ext.NSlingWebApiInPostStatement._create()) end
end

function sling.model.ext.NSlingWebApiInPostStatement:copyTo(o)
	if _g.sling.model.ext.NSlingWebApiStatement.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingWebApiInPostStatement')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.name = self.name
		n.description = self.description
		do return true end
	end
end

function sling.model.ext.NSlingWebApiInPostStatement:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ext.NSlingWebApiStatement.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingWebApiInPostStatement:acceptVisitor(visitor)
	if _g.sling.model.ext.NSlingWebApiStatement.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingWebApiInPostStatement:destroy()
	do _g.sling.model.ext.NSlingWebApiStatement.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.ext.NSlingWebApiInPostStatement:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ext.NSlingWebApiInPostStatement:getType()
	do return self.type end
end

function sling.model.ext.NSlingWebApiInPostStatement:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ext.NSlingWebApiInPostStatement:setName(v)
	self.name = v
end

function sling.model.ext.NSlingWebApiInPostStatement:getName()
	do return self.name end
end

function sling.model.ext.NSlingWebApiInPostStatement:setDescription(v)
	self.description = v
end

function sling.model.ext.NSlingWebApiInPostStatement:getDescription()
	do return self.description end
end

sling.model.ext.NSlingStyleSheetDataType = _g.sling.common.DataTypeNode._create()
sling.model.ext.NSlingStyleSheetDataType.__index = sling.model.ext.NSlingStyleSheetDataType
_vm:set_metatable(sling.model.ext.NSlingStyleSheetDataType, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ext.NSlingStyleSheetDataType._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingStyleSheetDataType)
	return v
end

function sling.model.ext.NSlingStyleSheetDataType:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingStyleSheetDataType'
	self['_isType.sling.model.ext.NSlingStyleSheetDataType'] = true
end

function sling.model.ext.NSlingStyleSheetDataType:_construct0()
	sling.model.ext.NSlingStyleSheetDataType._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ext.NSlingStyleSheetDataType:getNodeTypeName()
	do return "NSlingStyleSheetDataType" end
end

function sling.model.ext.NSlingStyleSheetDataType:createNew()
	do return _g.sling.model.ext.NSlingStyleSheetDataType._construct0(_g.sling.model.ext.NSlingStyleSheetDataType._create()) end
end

function sling.model.ext.NSlingStyleSheetDataType:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingStyleSheetDataType')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ext.NSlingStyleSheetDataType:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingStyleSheetDataType:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingStyleSheetDataType:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.ext.NSlingStyleDeclaration = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingStyleDeclaration.__index = sling.model.ext.NSlingStyleDeclaration
_vm:set_metatable(sling.model.ext.NSlingStyleDeclaration, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingStyleDeclaration._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingStyleDeclaration)
	return v
end

function sling.model.ext.NSlingStyleDeclaration:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingStyleDeclaration'
	self['_isType.sling.model.ext.NSlingStyleDeclaration'] = true
	self.selectors = nil
	self.properties = nil
end

function sling.model.ext.NSlingStyleDeclaration:_construct0()
	sling.model.ext.NSlingStyleDeclaration._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingStyleDeclaration:getNodeTypeName()
	do return "NSlingStyleDeclaration" end
end

function sling.model.ext.NSlingStyleDeclaration:createNew()
	do return _g.sling.model.ext.NSlingStyleDeclaration._construct0(_g.sling.model.ext.NSlingStyleDeclaration._create()) end
end

function sling.model.ext.NSlingStyleDeclaration:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingStyleDeclaration')
		if n == nil then
			do return true end
		end
		n.selectors = {}
		if self.selectors ~= nil then
			local n2 = 0
			local m = _g.jk.lang.Vector:getSize(self.selectors)
			do
				n2 = 0
				while n2 < m do
					local value = self.selectors[n2 + 1]
					if value ~= nil then
						do _g.jk.lang.Vector:append(n.selectors, value) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do
			local array = n.properties
			if array ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(array)
				do
					n3 = 0
					while n3 < m2 do
						local xx = _vm:to_table_with_key(array[n3 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			n.properties = nil
			if self.properties ~= nil then
				local n4 = 0
				local m3 = _g.jk.lang.Vector:getSize(self.properties)
				do
					n4 = 0
					while n4 < m3 do
						local nod = _vm:to_table_with_key(self.properties[n4 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.properties == nil then
								n.properties = {}
							end
							do _g.jk.lang.Vector:append(n.properties, ndup) end
							do ndup:setParent(n) end
						end
						do n4 = n4 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ext.NSlingStyleDeclaration:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.properties, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingStyleDeclaration:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.properties, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ext.NSlingStyleDeclaration:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.properties ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.properties)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.properties[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.properties = nil
end

function sling.model.ext.NSlingStyleDeclaration:setSelectors(v)
	self.selectors = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.selectors, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.ext.NSlingStyleDeclaration:getSelectors()
	do return self.selectors end
end

function sling.model.ext.NSlingStyleDeclaration:addToSelectors(v)
	if v == nil then
		do return end
	end
	if self.selectors == nil then
		self.selectors = {}
	end
	do _g.jk.lang.Vector:append(self.selectors, v) end
end

function sling.model.ext.NSlingStyleDeclaration:clearSelectors()
	self.selectors = nil
end

function sling.model.ext.NSlingStyleDeclaration:setProperties(v, doExport)
	if self.properties ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.properties)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.properties[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.properties = nil
	else
		self.properties = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.properties, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ext.NSlingStyleDeclaration:getProperties()
	do return self.properties end
end

function sling.model.ext.NSlingStyleDeclaration:exportProperties()
	local v = self.properties
	self.properties = nil
	do return v end
end

function sling.model.ext.NSlingStyleDeclaration:addToProperties(v)
	if v == nil then
		do return end
	end
	if self.properties == nil then
		self.properties = {}
	end
	do _g.jk.lang.Vector:append(self.properties, v) end
	do v:setParent(self) end
end

function sling.model.ext.NSlingStyleDeclaration:clearProperties()
	if self.properties ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.properties)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.properties[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.properties = nil
end

sling.model.ext.NSlingTreeNodeAttribute = _g.sling.common.NodeObject._create()
sling.model.ext.NSlingTreeNodeAttribute.__index = sling.model.ext.NSlingTreeNodeAttribute
_vm:set_metatable(sling.model.ext.NSlingTreeNodeAttribute, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ext.NSlingTreeNodeAttribute._create()
	local v = _vm:set_metatable({}, sling.model.ext.NSlingTreeNodeAttribute)
	return v
end

function sling.model.ext.NSlingTreeNodeAttribute:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ext.NSlingTreeNodeAttribute'
	self['_isType.sling.model.ext.NSlingTreeNodeAttribute'] = true
	self.name = nil
	self.value = nil
end

function sling.model.ext.NSlingTreeNodeAttribute:_construct0()
	sling.model.ext.NSlingTreeNodeAttribute._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ext.NSlingTreeNodeAttribute:getNodeTypeName()
	do return "NSlingTreeNodeAttribute" end
end

function sling.model.ext.NSlingTreeNodeAttribute:createNew()
	do return _g.sling.model.ext.NSlingTreeNodeAttribute._construct0(_g.sling.model.ext.NSlingTreeNodeAttribute._create()) end
end

function sling.model.ext.NSlingTreeNodeAttribute:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ext.NSlingTreeNodeAttribute')
		if n == nil then
			do return true end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.common.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.ext.NSlingTreeNodeAttribute:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.common.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ext.NSlingTreeNodeAttribute:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ext.NSlingTreeNodeAttribute:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.ext.NSlingTreeNodeAttribute:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.ext.NSlingTreeNodeAttribute:getValue()
	do return self.value end
end

function sling.model.ext.NSlingTreeNodeAttribute:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.ext.NSlingTreeNodeAttribute:setName(v)
	self.name = v
end

function sling.model.ext.NSlingTreeNodeAttribute:getName()
	do return self.name end
end
jk = jk or {}

jk.slon = jk.slon or {}

jk.slon.SLONParser = {}
jk.slon.SLONParser.__index = jk.slon.SLONParser
_vm:set_metatable(jk.slon.SLONParser, {})

function jk.slon.SLONParser._create()
	local v = _vm:set_metatable({}, jk.slon.SLONParser)
	return v
end

function jk.slon.SLONParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.slon.SLONParser'
	self['_isType.jk.slon.SLONParser'] = true
	self.iterator = nil
end

function jk.slon.SLONParser:_construct0()
	jk.slon.SLONParser._init(self)
	return self
end

jk.slon.SLONParser.NullObject = {}
jk.slon.SLONParser.NullObject.__index = jk.slon.SLONParser.NullObject
_vm:set_metatable(jk.slon.SLONParser.NullObject, {})

function jk.slon.SLONParser.NullObject._create()
	local v = _vm:set_metatable({}, jk.slon.SLONParser.NullObject)
	return v
end

function jk.slon.SLONParser.NullObject:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.slon.SLONParser.NullObject'
	self['_isType.jk.slon.SLONParser.NullObject'] = true
end

function jk.slon.SLONParser.NullObject:_construct0()
	jk.slon.SLONParser.NullObject._init(self)
	return self
end

function jk.slon.SLONParser:parse(data)
	if not (data ~= nil) then
		do return nil end
	end
	if _util:is_buffer(data) then
		do return _g.jk.slon.SLONParser:parseBuffer(data) end
	end
	if (_vm:get_variable_type(data) == 'string') then
		do return _g.jk.slon.SLONParser:parseString(data) end
	end
	if (_vm:to_table_with_key(data, '_isType.jk.fs.File') ~= nil) then
		do return _g.jk.slon.SLONParser:parseFile(data) end
	end
	do return nil end
end

function jk.slon.SLONParser:parseBuffer(buffer)
	if buffer == nil then
		do return nil end
	end
	do return _g.jk.slon.SLONParser:forBuffer(buffer):tryAcceptObject() end
end

function jk.slon.SLONParser:parseString(str)
	if _g.jk.lang.String:isEmpty(str) then
		do return nil end
	end
	do return _g.jk.slon.SLONParser:forString(str):tryAcceptObject() end
end

function jk.slon.SLONParser:parseFile(file)
	if file == nil then
		do return nil end
	end
	do return _g.jk.slon.SLONParser:forFile(file):tryAcceptObject() end
end

function jk.slon.SLONParser:forString(str)
	local v = _g.jk.slon.SLONParser._construct0(_g.jk.slon.SLONParser._create())
	do v:setDataString(str) end
	do return v end
end

function jk.slon.SLONParser:forBuffer(buffer)
	local v = _g.jk.slon.SLONParser._construct0(_g.jk.slon.SLONParser._create())
	do v:setDataBuffer(buffer) end
	do return v end
end

function jk.slon.SLONParser:forFile(file)
	local v = _g.jk.slon.SLONParser._construct0(_g.jk.slon.SLONParser._create())
	if file ~= nil then
		do v:setDataString(file:getContentsUTF8()) end
	end
	do return v end
end

function jk.slon.SLONParser:setDataString(str)
	self.iterator = _g.jk.lang.CharacterIteratorForString:forString(str)
	do self.iterator:moveToNextChar() end
end

function jk.slon.SLONParser:setDataBuffer(buffer)
	self.iterator = _g.jk.lang.CharacterIteratorForBuffer:forBuffer(buffer)
	do self.iterator:moveToNextChar() end
end

function jk.slon.SLONParser:skipSpaces()
	while true do
		if self.iterator:hasEnded() then
			do break end
		end
		do
			local c = self.iterator:getCurrentChar()
			if c == 32 or c == 9 or c == 13 or c == 10 then
				do self.iterator:moveToNextChar() end
				goto _continue1
			end
			if c == 35 then
				do self.iterator:moveToNextChar() end
				while true do
					if self.iterator:hasEnded() then
						do break end
					end
					do
						local cc = self.iterator:getCurrentChar()
						do self.iterator:moveToNextChar() end
						if _g.jk.lang.Character:isEOF(cc) or cc == 10 then
							do break end
						end
					end
				end
				goto _continue1
			end
			do break end
		end
		::_continue1::
	end
end

function jk.slon.SLONParser:acceptChar(c)
	do self:skipSpaces() end
	if self.iterator:getCurrentChar() == c then
		do self.iterator:moveToNextChar() end
		do return true end
	end
	do return false end
end

function jk.slon.SLONParser:acceptDoubleQuotedString()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 34 then
			do return nil end
		end
		do
			local i = 0
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			while true do
				local c = self.iterator:getNextChar()
				do i = i + 1 end
				if _g.jk.lang.Character:isEOF(c) then
					do
						local n = 0
						while n < i do
							do self.iterator:moveToPreviousChar() end
							do n = n + 1 end
						end
					end
					do return nil end
				end
				if c == ss then
					do self.iterator:moveToNextChar() end
					do break end
				end
				if c == 92 then
					c = self.iterator:getNextChar()
					if c == 117 then
						local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						local x = 0
						while x < 4 do
							if self.iterator:hasEnded() then
								do break end
							end
							do v:appendCharacter(self.iterator:getNextChar()) end
							do x = x + 1 end
						end
						c = _g.jk.lang.String:toIntegerFromHex(v:toString())
					elseif c == 116 then
						c = 9
					elseif c == 114 then
						c = 13
					elseif c == 110 then
						c = 10
					elseif c == 98 then
						c = 8
					elseif c == 102 then
						c = 12
					end
				end
				do sb:appendCharacter(c) end
			end
			do return sb:toString() end
		end
	end
end

function jk.slon.SLONParser:acceptBoolean()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 116 and ss ~= 102 then
			do return nil end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			do
				local li = 5
				if ss == 116 then
					li = 4
				end
				do
					local btc = 0
					while true do
						local c = self.iterator:getNextChar()
						do btc = btc + 1 end
						if c ~= 97 and c ~= 108 and c ~= 115 and c ~= 101 and c ~= 114 and c ~= 117 then
							do self.iterator:moveToNextChar() end
							do btc = btc + 1 end
							do break end
						end
						do sb:appendCharacter(c) end
						if sb:count() == li then
							do self.iterator:moveToNextChar() end
							do btc = btc + 1 end
							do break end
						end
					end
					do
						local v = sb:toString()
						if li == 4 and "true" == v then
							do return _g.jk.lang.Boolean:asObject(true) end
						end
						if li == 5 and "false" == v then
							do return _g.jk.lang.Boolean:asObject(false) end
						end
						do
							local i = 0
							while i < btc do
								do self.iterator:moveToPreviousChar() end
								do i = i + 1 end
							end
							do return nil end
						end
					end
				end
			end
		end
	end
end

function jk.slon.SLONParser:acceptNumber()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 45 and ss ~= 43 and ss ~= 46 and (ss < 48 or ss > 57) then
			do return nil end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			while true do
				local c = self.iterator:getNextChar()
				if c ~= 46 and c ~= 101 and c ~= 69 and c ~= 45 and (c < 48 or c > 57) then
					do break end
				end
				do sb:appendCharacter(c) end
			end
			do
				local s = sb:toString()
				if _g.jk.lang.String:getIndexOfCharacter(s, 46, 0) > -1 then
					do return _g.jk.lang.Double:asObject(_g.jk.lang.Double:asDouble(s)) end
				end
				do
					local value = _g.jk.lang.String:toLong(s)
					if value >= -2147483648 and value <= 2147483647 then
						do return _g.jk.lang.Integer:asObject(value) end
					end
					do return _g.jk.lang.LongInteger:asObject(value) end
				end
			end
		end
	end
end

function jk.slon.SLONParser:acceptNull()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss ~= 110 then
			do return nil end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			do
				local btc = 0
				while true do
					local c = self.iterator:getNextChar()
					do btc = btc + 1 end
					if c ~= 117 and c ~= 108 then
						do self.iterator:moveToNextChar() end
						do btc = btc + 1 end
						do break end
					end
					do sb:appendCharacter(c) end
					if sb:count() == 4 then
						do self.iterator:moveToNextChar() end
						do btc = btc + 1 end
						do break end
					end
				end
				if "null" == sb:toString() then
					do return _g.jk.slon.SLONParser.NullObject._construct0(_g.jk.slon.SLONParser.NullObject._create()) end
				end
				do
					local i = 0
					while i < btc do
						do self.iterator:moveToPreviousChar() end
						do i = i + 1 end
					end
					do return nil end
				end
			end
		end
	end
end

function jk.slon.SLONParser:isIdentifierCharacter(ss)
	if ss == 0 or ss == 32 or ss == 13 or ss == 10 or ss == 9 then
		do return false end
	end
	do return true end
end

function jk.slon.SLONParser:acceptIdentifier()
	do self:skipSpaces() end
	do
		local ss = self.iterator:getCurrentChar()
		if ss == 91 then
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			while true do
				local c = self.iterator:getNextChar()
				if _g.jk.lang.Character:isEOF(c) or c == 93 then
					do break end
				end
				do sb:appendCharacter(c) end
			end
			do return sb:toString() end
		end
		if self:isIdentifierCharacter(ss) then
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendCharacter(ss) end
			while true do
				local c = self.iterator:getNextChar()
				if _g.jk.lang.Character:isEOF(c) or not self:isIdentifierCharacter(c) then
					do break end
				end
				do sb:appendCharacter(c) end
			end
			do return sb:toString() end
		end
		do return nil end
	end
end

function jk.slon.SLONParser:expectIdentifier()
	local v = self:acceptIdentifier()
	if not (v ~= nil) then
		do self:throwExpectationError("identifier") end
	end
	do return v end
end

jk.slon.SLONParser.ParseError = _g.jk.lang.Exception._create()
jk.slon.SLONParser.ParseError.__index = jk.slon.SLONParser.ParseError
_vm:set_metatable(jk.slon.SLONParser.ParseError, {
	__index = _g.jk.lang.Exception
})

function jk.slon.SLONParser.ParseError._create()
	local v = _vm:set_metatable({}, jk.slon.SLONParser.ParseError)
	return v
end

function jk.slon.SLONParser.ParseError:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.slon.SLONParser.ParseError'
	self['_isType.jk.slon.SLONParser.ParseError'] = true
	self['_isType.jk.lang.StringObject'] = true
	self._iterator = nil
	self._expected = nil
	self.lineNumber = 0
	self.columnNumber = 0
	self.lineString = nil
end

function jk.slon.SLONParser.ParseError:_construct0()
	jk.slon.SLONParser.ParseError._init(self)
	do _g.jk.lang.Exception._construct0(self) end
	return self
end

function jk.slon.SLONParser.ParseError:computeData()
	local opos = self:getIterator():getCurrentPosition()
	self.lineNumber = 0
	self.columnNumber = 0
	do self:getIterator():setCurrentPosition(0) end
	while true do
		if self:getIterator():getCurrentPosition() >= opos then
			do break end
		end
		if self:getIterator():getCurrentChar() == 10 then
			do self.lineNumber = self.lineNumber + 1 end
			self.columnNumber = 0
		else
			do self.columnNumber = self.columnNumber + 1 end
		end
		do self:getIterator():moveToNextChar() end
	end
	do self:getIterator():setCurrentPosition(opos) end
	while true do
		if self:getIterator():getCurrentPosition() < 1 then
			do break end
		end
		do self:getIterator():moveToPreviousChar() end
		if self:getIterator():getCurrentChar() == 10 then
			do self:getIterator():moveToNextChar() end
			do break end
		end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		while true do
			local c = self:getIterator():getCurrentChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if c == 10 then
				do break end
			end
			if c == 9 then
				do sb:appendCharacter(32) end
			else
				do sb:appendCharacter(c) end
			end
			do self:getIterator():moveToNextChar() end
		end
		self.lineString = sb:toString()
		do self:getIterator():setCurrentPosition(opos) end
	end
end

function jk.slon.SLONParser.ParseError:toString()
	if not (self.lineString ~= nil) then
		do self:computeData() end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do
			local n = 0
			while n < self.columnNumber do
				do sb:appendCharacter(32) end
				do n = n + 1 end
			end
		end
		do sb:appendCharacter(94) end
		do return "line=" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.lineNumber + 1))) .. ", col=" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.columnNumber + 1))) .. ", expected=`" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(self:getExpected())) .. "'\n" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(self.lineString)) .. "\n" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(sb:toString())) end
	end
end

function jk.slon.SLONParser.ParseError:getIterator()
	do return self._iterator end
end

function jk.slon.SLONParser.ParseError:doSetIterator(value)
	self._iterator = value
end

function jk.slon.SLONParser.ParseError:setIterator(v)
	do self:doSetIterator(v) end
	do return v end
end

function jk.slon.SLONParser.ParseError:getExpected()
	do return self._expected end
end

function jk.slon.SLONParser.ParseError:doSetExpected(value)
	self._expected = value
end

function jk.slon.SLONParser.ParseError:setExpected(v)
	do self:doSetExpected(v) end
	do return v end
end

function jk.slon.SLONParser:throwExpectationError(expected)
	local pe = _g.jk.slon.SLONParser.ParseError._construct0(_g.jk.slon.SLONParser.ParseError._create())
	do pe:setIterator(self.iterator) end
	do pe:setExpected(expected) end
	_vm:throw_error(pe)
end

function jk.slon.SLONParser:expectObject()
	local v = self:acceptObject()
	if not (v ~= nil) then
		do self:throwExpectationError("object") end
	end
	do return v end
end

function jk.slon.SLONParser:countIndents(str)
	if not (str ~= nil) then
		do return 0 end
	end
	do
		local it = _g.jk.lang.String:iterate(str)
		local v = 0
		while true do
			local c = it:getNextChar()
			if c == 32 or c == 9 then
				do v = v + 1 end
			else
				do break end
			end
		end
		do return v end
	end
end

function jk.slon.SLONParser:stripLongStringIndentation(str)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local commonIndents = -1
		local lines = _g.jk.lang.String:split(str, 10, 0)
		local vsize = _g.jk.lang.Vector:getSize(lines)
		local removedLastLine = false
		if vsize > 0 then
			local lastLine = _g.jk.lang.Vector:get(lines, vsize - 1)
			if lastLine ~= nil and self:countIndents(lastLine) == _g.jk.lang.String:getLength(lastLine) then
				do _g.jk.lang.Vector:remove(lines, vsize - 1) end
				removedLastLine = true
			end
		end
		if lines ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(lines)
			do
				n = 0
				while n < m do
					local line = lines[n + 1]
					if line ~= nil then
						local indents = self:countIndents(line)
						if commonIndents < 0 or indents < commonIndents then
							commonIndents = indents
						end
					end
					do n = n + 1 end
				end
			end
		end
		if commonIndents < 1 then
			do return str end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			if lines ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(lines)
				do
					n2 = 0
					while n2 < m2 do
						local line = lines[n2 + 1]
						if line ~= nil then
							if sb:count() > 0 then
								do sb:appendCharacter(10) end
							end
							do sb:appendString(_g.jk.lang.String:getEndOfString(line, commonIndents)) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			if removedLastLine then
				do sb:appendCharacter(10) end
			end
			do return sb:toString() end
		end
	end
end

function jk.slon.SLONParser:parseLongString()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if self.iterator:getCurrentChar() == 10 then
		do self.iterator:moveToNextChar() end
	end
	while true do
		local c = self.iterator:getCurrentChar()
		do self.iterator:moveToNextChar() end
		if _g.jk.lang.Character:isEOF(c) then
			do self:throwExpectationError("]]") end
		end
		if c == 93 then
			c = self.iterator:getCurrentChar()
			if c == 93 then
				do self.iterator:moveToNextChar() end
				do break end
			end
			do sb:appendCharacter(93) end
			goto _continue2
		end
		do sb:appendCharacter(c) end
		::_continue2::
	end
	do return self:stripLongStringIndentation(sb:toString()) end
end

function jk.slon.SLONParser:acceptObject()
	if self:acceptChar(91) then
		if self:acceptChar(91) then
			do return self:parseLongString() end
		end
		do
			local v = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
			while true do
				if self:acceptChar(93) then
					do break end
				end
				do v:appendObject(self:expectObject()) end
			end
			do return v end
		end
	end
	if self:acceptChar(123) then
		local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		while true do
			if self:acceptChar(125) then
				do break end
			end
			do
				local key = self:expectIdentifier()
				local val = self:expectObject()
				if (_vm:to_table_with_key(val, '_isType.jk.slon.SLONParser.NullObject') ~= nil) then
					do v:setObject(key, nil) end
				else
					do v:setObject(key, val) end
				end
			end
		end
		do return v end
	end
	do
		local s = self:acceptDoubleQuotedString()
		if s ~= nil then
			do return s end
		end
		do
			local b = self:acceptBoolean()
			if b ~= nil then
				do return b end
			end
			do
				local n = self:acceptNull()
				if n ~= nil then
					do return n end
				end
				do
					local v = self:acceptNumber()
					if v ~= nil then
						do return v end
					end
					do return nil end
				end
			end
		end
	end
end

function jk.slon.SLONParser:tryAcceptObject()
	do
		local _rval = nil
		local _status, _err = _vm:execute_protected_call(function()
			_rval = {}
			_rval.value = self:acceptObject()
			do return end
		end)
		if _err then
		end
		if _rval then
			do return _rval.value end
		end
	end
	do return nil end
end
sling = sling or {}

sling.util = sling.util or {}

sling.util.EntityUtil = {}
sling.util.EntityUtil.__index = sling.util.EntityUtil
_vm:set_metatable(sling.util.EntityUtil, {})

function sling.util.EntityUtil._create()
	local v = _vm:set_metatable({}, sling.util.EntityUtil)
	return v
end

function sling.util.EntityUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.EntityUtil'
	self['_isType.sling.util.EntityUtil'] = true
end

function sling.util.EntityUtil:_construct0()
	sling.util.EntityUtil._init(self)
	return self
end

function sling.util.EntityUtil:getBaseClassTypeForEntity(entity)
	if not (entity ~= nil) then
		do return nil end
	end
	do
		local array = entity:getBaseTypes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						local type = basetype:getInheritType()
						if type == _g.sling.model.BaseTypeNode.INHERIT_EXTEND then
							do return basetype:getReferenceType() end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return nil end
	end
end

function sling.util.EntityUtil:methodExists(entity, name)
	local array = entity:getNodes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local method = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
				if method ~= nil then
					if method:getName() == name then
						do return true end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function sling.util.EntityUtil:doesEntityImportNamespace(entity, nsname)
	if not (entity ~= nil) then
		do return false end
	end
	if not _g.jk.lang.String:isNotEmpty(nsname) then
		do return false end
	end
	do
		local array = entity:getImportNamespaces()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local symbol = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolNode')
					if symbol ~= nil then
						local symname = _g.sling.util.SymbolUtil:getSymbolNamesString(symbol, 46)
						if symname ~= nil and symname == nsname then
							do return true end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function sling.util.EntityUtil:addToImportNamespacesUnique(entity, symbol)
	if not (entity ~= nil) then
		do return end
	end
	if not (symbol ~= nil) then
		do return end
	end
	do
		local symname = _g.sling.util.SymbolUtil:getSymbolNamesString(symbol, 46)
		if not _g.jk.lang.String:isNotEmpty(symname) then
			do return end
		end
		if _g.sling.util.EntityUtil:doesEntityImportNamespace(entity, symname) == false then
			do entity:addToImportNamespaces(symbol) end
		end
	end
end

sling.util.ProjectUtil = {}
sling.util.ProjectUtil.__index = sling.util.ProjectUtil
_vm:set_metatable(sling.util.ProjectUtil, {})

function sling.util.ProjectUtil._create()
	local v = _vm:set_metatable({}, sling.util.ProjectUtil)
	return v
end

function sling.util.ProjectUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.ProjectUtil'
	self['_isType.sling.util.ProjectUtil'] = true
end

function sling.util.ProjectUtil:_construct0()
	sling.util.ProjectUtil._init(self)
	return self
end

function sling.util.ProjectUtil:findResourcesForTree(node)
	local v = {}
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ResourceFileNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local rs = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ResourceFileNode')
				if rs ~= nil then
					do _g.jk.lang.Vector:append(v, rs) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.util.ProjectUtil:copyTreeResourcesToDirectory(ctx, tree, outputDirectory)
	local array = _g.sling.util.ProjectUtil:findResourcesForTree(tree)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local resource = array[n + 1]
				if resource ~= nil then
					local file = resource:getFile()
					if not (file ~= nil) then
						goto _continue1
					end
					do
						local baseName = file:getBasename()
						if not outputDirectory:isDirectory() then
							do outputDirectory:createDirectoryRecursive() end
						end
						do
							local dest = outputDirectory:entry(baseName)
							do _g.jk.log.Log:debug(ctx, "Copying resource file `" .. _g.jk.lang.String:safeString(file:getPath()) .. "' -> `" .. _g.jk.lang.String:safeString(dest:getPath()) .. "'") end
							if not file:copyFileTo(dest) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to copy resource: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "' to `" .. _g.jk.lang.String:safeString(dest:getPath()) .. "'", resource, nil))
							end
						end
					end
				end
				::_continue1::
				do n = n + 1 end
			end
		end
	end
end

sling.util.DataTypeUtil = {}
sling.util.DataTypeUtil.__index = sling.util.DataTypeUtil
_vm:set_metatable(sling.util.DataTypeUtil, {})

function sling.util.DataTypeUtil._create()
	local v = _vm:set_metatable({}, sling.util.DataTypeUtil)
	return v
end

function sling.util.DataTypeUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.DataTypeUtil'
	self['_isType.sling.util.DataTypeUtil'] = true
end

function sling.util.DataTypeUtil:_construct0()
	sling.util.DataTypeUtil._init(self)
	return self
end

function sling.util.DataTypeUtil:dupAsReferenceDataType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("dupAsReferenceDataType: null node", nil, nil))
	end
	do
		local nnode = node:dup()
		if not (nnode ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate", node, nil))
		end
		do
			local v = _vm:to_table_with_key(nnode, '_isType.sling.model.ReferenceDataTypeNode')
			if not (v ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a reference data type", node, nil))
			end
			do return v end
		end
	end
end

function sling.util.DataTypeUtil:dupAsDataType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("dupAsDataType: null node", nil, nil))
	end
	do
		local nnode = node:dup()
		if not (nnode ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate", node, nil))
		end
		do
			local v = _vm:to_table_with_key(nnode, '_isType.sling.common.DataTypeNode')
			if not (v ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a data type", node, nil))
			end
			do return v end
		end
	end
end

function sling.util.DataTypeUtil:getSymbolName(dt)
	local refdt = _vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode')
	if not (refdt ~= nil) then
		do return nil end
	end
	do return _g.sling.util.SymbolUtil:getSymbolName(refdt:getSymbol()) end
end

function sling.util.DataTypeUtil:isReferenceValid(dt)
	if not (dt ~= nil) then
		do return false end
	end
	do
		local symbol = dt:getSymbol()
		if not (symbol ~= nil) then
			do return false end
		end
		do
			local binding = symbol:getBinding()
			if not (binding ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(binding, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) == false then
				if not (binding:getParent() ~= nil) then
					do return false end
				end
			end
			do return true end
		end
	end
end

function sling.util.DataTypeUtil:createDefaultValue(type)
	if not (type ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("createDefaultValue: null type", nil, nil))
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.VectorDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.MapDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.SetDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.PointerDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.ThisDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.ParentDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
		do return _g.sling.model.CharacterLiteralExpressionNode:forValue(0) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		local v = _g.sling.model.IntegerLiteralExpressionNode:forValue(0)
		do v:setType(type:getType()) end
		do return v end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
		do return _g.sling.model.DoubleLiteralExpressionNode:forValue(0.0) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
		do return _g.sling.model.FloatLiteralExpressionNode:forValue(0.0) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
		do return _g.sling.model.BooleanLiteralExpressionNode:forValue(false) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.StringDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.TupleDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.DateTimeDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.DecimalDataTypeNode') ~= nil) then
		do return _g.sling.model.DecimalLiteralExpressionNode:forValue("0.0") end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.VoidDataTypeNode') ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.TypeInfoDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.PromiseDataTypeNode') ~= nil) then
		do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to determine default value for unsupported data type: `" .. _g.jk.lang.String:safeString(type:getNodeTypeName()) .. "'", type, nil))
	do return nil end
end

function sling.util.DataTypeUtil:getDataTypeName(node)
	if not (node ~= nil) then
		do return "unknown" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local symbol = _g.sling.util.SymbolUtil:getSymbolNamesString(node:getSymbol(), 46)
		if _g.jk.lang.String:isEmpty(symbol) then
			symbol = "unknown"
		end
		do return "class:" .. _g.jk.lang.String:safeString(symbol) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PromiseDataTypeNode') ~= nil) then
		do return "promise" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PointerDataTypeNode') ~= nil) then
		do return "pointer" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableReferenceDataTypeNode') ~= nil) then
		do return "reference" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExpressionDataTypeNode') ~= nil) then
		do return "expression" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TypeInfoDataTypeNode') ~= nil) then
		do return "typeinfo" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
		do return "this" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ParentDataTypeNode') ~= nil) then
		do return "parent" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
		do return "array" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.UnknownDataTypeNode') ~= nil) then
		do return "unknown" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
		do return "dynamic" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
		do return "automatic" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
		do return "character" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		do return "integer" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
		do return "double" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
		do return "float" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VoidDataTypeNode') ~= nil) then
		do return "void" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
		do return "boolean" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringDataTypeNode') ~= nil) then
		do return "string" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
		do return "object" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
		do return "buffer" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TupleDataTypeNode') ~= nil) then
		do return "tuple" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DateTimeDataTypeNode') ~= nil) then
		do return "datetime" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DecimalDataTypeNode') ~= nil) then
		do return "decimal" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) then
		do return "exception" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
		do return "function" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MapDataTypeNode') ~= nil) then
		do return "map" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SetDataTypeNode') ~= nil) then
		do return "set" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
		do return "vector" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.OptionalDataTypeNode') ~= nil) then
		do return "optional" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
		do return "constrained" end
	end
	do return "unknown" end
end

sling.util.FindUtil = {}
sling.util.FindUtil.__index = sling.util.FindUtil
_vm:set_metatable(sling.util.FindUtil, {})

function sling.util.FindUtil._create()
	local v = _vm:set_metatable({}, sling.util.FindUtil)
	return v
end

function sling.util.FindUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.FindUtil'
	self['_isType.sling.util.FindUtil'] = true
end

function sling.util.FindUtil:_construct0()
	sling.util.FindUtil._init(self)
	return self
end

function sling.util.FindUtil:findRootNamespace(node)
	local pp = node
	while pp ~= nil do
		if not (pp ~= nil) then
			do break end
		end
		do
			local ns = _vm:to_table_with_key(pp, '_isType.sling.model.NamespaceNode')
			if ns ~= nil and _g.jk.lang.String:isEmpty(ns:getNodeName()) then
				do return ns end
			end
			pp = pp:getParent()
		end
	end
	do return nil end
end

function sling.util.FindUtil:findNearestNamespace(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.NamespaceNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestCodeFile(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.common.CodeFileNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestClass(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestEntity(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestFunctionBase(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestLoop(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.LoopStatementNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestFunction(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findNearestBlock(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		while true do
			if not (pp ~= nil) then
				do break end
			end
			if (_vm:to_table_with_key(pp, '_isType.sling.model.BlockNode') ~= nil) then
				do return pp end
			end
			pp = pp:getParent()
		end
		do return nil end
	end
end

function sling.util.FindUtil:findTopmostEntity(node)
	local v = node
	while true do
		local x = _g.sling.util.FindUtil:findNearestEntity(v)
		if x == nil then
			do break end
		end
		v = x
	end
	do return _vm:to_table_with_key(v, '_isType.sling.model.EntityDeclarationNode') end
end

function sling.util.FindUtil:findNodesOfType(node, type, reverse, ignoreMacros, ignoreHeaders)
	do return _g.sling.common.NodeFinder:findNodesOfType(node, type, reverse, ignoreMacros, ignoreHeaders) end
end

function sling.util.FindUtil:findNodesOfTypes(node, types, reverse, ignoreMacros, ignoreHeaders)
	do return _g.sling.common.NodeFinder:findNodesOfTypes(node, types, reverse, ignoreMacros, ignoreHeaders) end
end

function sling.util.FindUtil:findCompatibleNodes(node, type, reverse, ignoreMacros, ignoreHeaders)
	do return _g.sling.common.NodeFinder:findCompatibleNodes(node, type, reverse, ignoreMacros, ignoreHeaders) end
end

function sling.util.FindUtil:findCompatibleNodesForTypes(node, types, reverse, ignoreMacros, ignoreHeaders)
	do return _g.sling.common.NodeFinder:findCompatibleNodesForTypes(node, types, reverse, ignoreMacros, ignoreHeaders) end
end

function sling.util.FindUtil:visitAllNodes(node, visitor)
	do return _g.sling.common.NodeFinder:visitAllNodes(node, visitor) end
end

sling.util.FindUtil.NodeAnyModifierFinder = _g.sling.common.NodeVisitor._create()
sling.util.FindUtil.NodeAnyModifierFinder.__index = sling.util.FindUtil.NodeAnyModifierFinder
_vm:set_metatable(sling.util.FindUtil.NodeAnyModifierFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.util.FindUtil.NodeAnyModifierFinder._create()
	local v = _vm:set_metatable({}, sling.util.FindUtil.NodeAnyModifierFinder)
	return v
end

function sling.util.FindUtil.NodeAnyModifierFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.FindUtil.NodeAnyModifierFinder'
	self['_isType.sling.util.FindUtil.NodeAnyModifierFinder'] = true
	self.searchForModifier = {}
	self.results = {}
end

function sling.util.FindUtil.NodeAnyModifierFinder:_construct0()
	sling.util.FindUtil.NodeAnyModifierFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.util.FindUtil.NodeAnyModifierFinder:addToSearchForModifier(mod)
	do _g.jk.lang.Vector:append(self.searchForModifier, mod) end
end

function sling.util.FindUtil.NodeAnyModifierFinder:visit(node)
	if node ~= nil then
		if self.searchForModifier ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.searchForModifier)
			do
				n = 0
				while n < m do
					local mod = self.searchForModifier[n + 1]
					if mod ~= nil then
						if node:hasModifier(mod) then
							do _g.jk.lang.Vector:append(self.results, node) end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do return true end
end

function sling.util.FindUtil.NodeAnyModifierFinder:getSearchForModifier()
	do return self.searchForModifier end
end

function sling.util.FindUtil.NodeAnyModifierFinder:setSearchForModifier(v)
	self.searchForModifier = v
	do return self end
end

function sling.util.FindUtil.NodeAnyModifierFinder:getResults()
	do return self.results end
end

function sling.util.FindUtil.NodeAnyModifierFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.util.FindUtil:findNodesWithAnyModifier(node, mods)
	local ff = _g.sling.util.FindUtil.NodeAnyModifierFinder._construct0(_g.sling.util.FindUtil.NodeAnyModifierFinder._create())
	if node ~= nil and mods ~= nil then
		if mods ~= nil then
			local n = 0
			local m = #mods
			do
				n = 0
				while n < m do
					local mod = mods[n + 1]
					if mod ~= nil then
						do ff:addToSearchForModifier(mod) end
					end
					do n = n + 1 end
				end
			end
		end
		do node:accept(ff) end
	end
	do return ff:getResults() end
end

sling.util.FindUtil.NodeAllModifierFinder = _g.sling.common.NodeVisitor._create()
sling.util.FindUtil.NodeAllModifierFinder.__index = sling.util.FindUtil.NodeAllModifierFinder
_vm:set_metatable(sling.util.FindUtil.NodeAllModifierFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.util.FindUtil.NodeAllModifierFinder._create()
	local v = _vm:set_metatable({}, sling.util.FindUtil.NodeAllModifierFinder)
	return v
end

function sling.util.FindUtil.NodeAllModifierFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.FindUtil.NodeAllModifierFinder'
	self['_isType.sling.util.FindUtil.NodeAllModifierFinder'] = true
	self.searchForModifier = {}
	self.results = {}
end

function sling.util.FindUtil.NodeAllModifierFinder:_construct0()
	sling.util.FindUtil.NodeAllModifierFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.util.FindUtil.NodeAllModifierFinder:addToSearchForModifier(mod)
	do _g.jk.lang.Vector:append(self.searchForModifier, mod) end
end

function sling.util.FindUtil.NodeAllModifierFinder:visit(node)
	if node ~= nil then
		local v = true
		if self.searchForModifier ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(self.searchForModifier)
			do
				n = 0
				while n < m do
					local mod = self.searchForModifier[n + 1]
					if mod ~= nil then
						if not node:hasModifier(mod) then
							v = false
							do break end
						end
					end
					do n = n + 1 end
				end
			end
		end
		if v then
			do _g.jk.lang.Vector:append(self.results, node) end
		end
	end
	do return true end
end

function sling.util.FindUtil.NodeAllModifierFinder:getSearchForModifier()
	do return self.searchForModifier end
end

function sling.util.FindUtil.NodeAllModifierFinder:setSearchForModifier(v)
	self.searchForModifier = v
	do return self end
end

function sling.util.FindUtil.NodeAllModifierFinder:getResults()
	do return self.results end
end

function sling.util.FindUtil.NodeAllModifierFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.util.FindUtil:findNodesWithAllModifiers(node, mods)
	local ff = _g.sling.util.FindUtil.NodeAllModifierFinder._construct0(_g.sling.util.FindUtil.NodeAllModifierFinder._create())
	if node ~= nil and mods ~= nil then
		if mods ~= nil then
			local n = 0
			local m = #mods
			do
				n = 0
				while n < m do
					local mod = mods[n + 1]
					if mod ~= nil then
						do ff:addToSearchForModifier(mod) end
					end
					do n = n + 1 end
				end
			end
		end
		do node:accept(ff) end
	end
	do return ff:getResults() end
end

function sling.util.FindUtil:findEntityByName(root, name)
	if not (name ~= nil) then
		do return nil end
	end
	do
		local array = _g.sling.util.FindUtil:findCompatibleNodes(root, "class:sling.model.EntityDeclarationNode", false, true, false)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local ee = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
					if ee ~= nil then
						local qn = _g.sling.util.NodeUtil:getQualifiedNameString(ee, 46)
						if qn == name then
							do return ee end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return nil end
	end
end

sling.util.SymbolUtil = {}
sling.util.SymbolUtil.__index = sling.util.SymbolUtil
_vm:set_metatable(sling.util.SymbolUtil, {})

function sling.util.SymbolUtil._create()
	local v = _vm:set_metatable({}, sling.util.SymbolUtil)
	return v
end

function sling.util.SymbolUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.SymbolUtil'
	self['_isType.sling.util.SymbolUtil'] = true
end

function sling.util.SymbolUtil:_construct0()
	sling.util.SymbolUtil._init(self)
	return self
end

function sling.util.SymbolUtil:mergeSymbols(s1, s2)
	if not (s1 ~= nil or s2 ~= nil) then
		do return nil end
	end
	if s1 ~= nil and s2 == nil then
		do return s1 end
	end
	if s1 == nil and s2 ~= nil then
		do return s2 end
	end
	do
		local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
		local comps = {}
		local array = _g.sling.util.SymbolUtil:getSymbolComponents(s1)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local comp = array[n + 1]
					if comp ~= nil then
						do _g.jk.lang.Vector:append(comps, comp) end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local array2 = _g.sling.util.SymbolUtil:getSymbolComponents(s2)
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local comp = array2[n2 + 1]
						if comp ~= nil then
							do _g.jk.lang.Vector:append(comps, comp) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			if comps ~= nil then
				local n3 = 0
				local m3 = _g.jk.lang.Vector:getSize(comps)
				do
					n3 = 0
					while n3 < m3 do
						local comp = comps[n3 + 1]
						if comp ~= nil then
							if (_vm:get_variable_type(comp) == 'string') then
								do _g.sling.util.SymbolUtil:pushName(v, comp) end
							elseif (_vm:to_table_with_key(comp, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
								local nc = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(comp), '_isType.sling.model.SymbolNameComponentNode')
								if nc ~= nil then
									do _g.sling.util.SymbolUtil:pushComponent(v, nc) end
								end
							end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return v end
		end
	end
end

function sling.util.SymbolUtil:tryGetSymbolBindingForExpression(xpr)
	if not (xpr ~= nil) then
		do return nil end
	end
	do
		local sym = xpr:getSymbol()
		if not (sym ~= nil) then
			do return nil end
		end
		do return sym:getBinding() end
	end
end

function sling.util.SymbolUtil:tryGetSymbolBinding(sym)
	if not (sym ~= nil) then
		do return nil end
	end
	do return sym:getBinding() end
end

function sling.util.SymbolUtil:getQualifiedSymbolNameComponents(node, typeParameters)
	local v = {}
	local nn = node
	local tpidx = 0
	while nn ~= nil do
		if (_vm:to_table_with_key(nn, '_isType.sling.common.CodeFileNode') ~= nil) then
		elseif (_vm:to_table_with_key(nn, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
			do _g.jk.lang.Vector:prepend(v, _g.sling.model.SymbolNameComponentNode:forName(nn:getNodeName())) end
		elseif (_vm:to_table_with_key(nn, '_isType.sling.model.NamespaceNode') ~= nil) then
			local name = nn:getNodeName()
			if _g.jk.lang.String:isEmpty(name) then
				do break end
			end
			do _g.jk.lang.Vector:prepend(v, _g.sling.model.SymbolNameComponentNode:forName(name)) end
		elseif (_vm:to_table_with_key(nn, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
			do _g.jk.lang.Vector:prepend(v, _g.sling.model.SymbolNameComponentNode:forName(nn:getNodeName())) end
		elseif (_vm:to_table_with_key(nn, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
			local cc = _g.sling.model.SymbolNameComponentNode:forName(nn:getNodeName())
			if (_vm:to_table_with_key(nn, '_isType.sling.model.GenericCapableEntityDeclarationNode') ~= nil) then
				local types = nn:getGenericTypes()
				if types ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(types)
					do
						n = 0
						while n < m do
							local type = _vm:to_table_with_key(types[n + 1], '_isType.sling.model.TemplateDeclarationNode')
							if type ~= nil then
								local tt = _vm:to_table_with_key(_g.jk.lang.Vector:get(typeParameters, (function() local v = tpidx tpidx = tpidx + 1 return v end)()), '_isType.sling.common.DataTypeNode')
								if tt ~= nil then
									do cc:addToTypeParameters(_g.sling.util.DataTypeUtil:dupAsDataType(tt)) end
									goto _continue2
								end
								do cc:addToTypeParameters(_g.sling.model.ReferenceDataTypeNode:forNode(type, nil)) end
							end
							::_continue2::
							do n = n + 1 end
						end
					end
				end
			end
			do _g.jk.lang.Vector:prepend(v, cc) end
		else
			do break end
		end
		nn = nn:getParent()
	end
	do return v end
end

function sling.util.SymbolUtil:generateSymbolComponentsForBinding(symbol, binding)
	if not (binding ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(binding, '_isType.sling.model.TemplateDeclarationNode') ~= nil) then
		local v = {}
		do _g.jk.lang.Vector:append(v, _g.sling.model.SymbolNameComponentNode:forName(binding:getName())) end
		do return v end
	end
	if (_vm:to_table_with_key(binding, '_isType.sling.model.VariableDeclarationNode') ~= nil) or (_vm:to_table_with_key(binding, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
		if _g.sling.util.NodeUtil:isStatic(binding) then
			do return _g.sling.util.SymbolUtil:getQualifiedSymbolNameComponents(binding, symbol:getTypeParameters()) end
		else
			local n = _vm:to_table_with_key(binding, '_isType.sling.common.NamedNode')
			local v = {}
			do _g.jk.lang.Vector:append(v, _g.sling.model.SymbolNameComponentNode:forName(n:getNodeName())) end
			do return v end
		end
	end
	if (_vm:to_table_with_key(binding, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
		do return _g.sling.util.SymbolUtil:getQualifiedSymbolNameComponents(binding, symbol:getTypeParameters()) end
	end
	if (_vm:to_table_with_key(binding, '_isType.sling.model.NamespaceNode') ~= nil) then
		do return _g.sling.util.SymbolUtil:getQualifiedSymbolNameComponents(binding, symbol:getTypeParameters()) end
	end
	if (_vm:to_table_with_key(binding, '_isType.sling.common.NamedNode') ~= nil) then
		local v = {}
		do _g.jk.lang.Vector:append(v, _g.sling.model.SymbolNameComponentNode:forName(binding:getNodeName())) end
		do return v end
	end
	do return nil end
end

function sling.util.SymbolUtil:getSymbolComponents(symbol)
	if not (symbol ~= nil) then
		do return nil end
	end
	do
		local binding = symbol:getBinding()
		if binding ~= nil then
			if (_vm:to_table_with_key(binding, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) then
				local ss = binding:getSymbol()
				if ss ~= nil then
					do return symbol:getComponents() end
				end
			end
			do
				local v = self:generateSymbolComponentsForBinding(symbol, binding)
				if v ~= nil then
					do return v end
				end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("getSymbolComponents: Not implemented for node type `" .. _g.jk.lang.String:safeString(binding:getNodeTypeName()) .. "'", binding, nil):addRelatedMessage("Original symbol", symbol))
				do return nil end
			end
		end
		do return symbol:getComponents() end
	end
end

function sling.util.SymbolUtil:getSymbolNames(symbol)
	local comps = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
	if not (comps ~= nil) then
		do return nil end
	end
	do
		local v = {}
		if comps ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(comps)
			do
				n = 0
				while n < m do
					local comp = _vm:to_table_with_key(comps[n + 1], '_isType.sling.model.SymbolNameComponentNode')
					if comp ~= nil then
						do _g.jk.lang.Vector:append(v, comp:getName()) end
					end
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function sling.util.SymbolUtil:getSymbolNamesString(symbol, delim)
	local names = _g.sling.util.SymbolUtil:getSymbolNames(symbol)
	if not (names ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if names ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(names)
			do
				n = 0
				while n < m do
					local name = names[n + 1]
					if name ~= nil then
						if sb:count() > 0 then
							do sb:appendCharacter(delim) end
						end
						do sb:appendString(name) end
					end
					do n = n + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function sling.util.SymbolUtil:getSymbolName(symbol)
	if not (symbol ~= nil) then
		do return nil end
	end
	do
		local components = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
		if not (components ~= nil) then
			do return nil end
		end
		do
			local comp = _vm:to_table_with_key(_g.jk.lang.Vector:getLast(components), '_isType.sling.model.SymbolNameComponentNode')
			if not (comp ~= nil) then
				do return nil end
			end
			do return comp:getName() end
		end
	end
end

function sling.util.SymbolUtil:getFirstComponent(symbol)
	if not (symbol ~= nil) then
		do return nil end
	end
	do
		local components = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
		if not (components ~= nil) then
			do return nil end
		end
		do
			local comp = _vm:to_table_with_key(_g.jk.lang.Vector:getFirst(components), '_isType.sling.model.SymbolNameComponentNode')
			if not (comp ~= nil) then
				do return nil end
			end
			do return comp:getName() end
		end
	end
end

function sling.util.SymbolUtil:setFirstComponent(symbol, component)
	if not (symbol ~= nil) then
		do return end
	end
	if not (component ~= nil) then
		do return end
	end
	do
		local components = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
		if not (components ~= nil) then
			do return end
		end
		do _g.jk.lang.Vector:set(components, 0, component) end
		do _g.sling.util.SymbolUtil:setNames(symbol, components) end
	end
end

function sling.util.SymbolUtil:setName(symbol, name)
	if not (symbol ~= nil) then
		do return end
	end
	do symbol:clearComponents() end
	do symbol:setBinding(nil, nil) end
	do _g.sling.util.SymbolUtil:pushName(symbol, name) end
end

function sling.util.SymbolUtil:setNames(symbol, names)
	if not (symbol ~= nil) then
		do return end
	end
	do symbol:clearComponents() end
	do symbol:setBinding(nil, nil) end
	if names ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(names)
		do
			n = 0
			while n < m do
				local name = names[n + 1]
				if name ~= nil then
					do _g.sling.util.SymbolUtil:addObjectToComponents(symbol, name) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.util.SymbolUtil:addObjectToComponents(symbol, name)
	if not (symbol ~= nil) then
		do return end
	end
	if not (name ~= nil) then
		do return end
	end
	do symbol:setBinding(nil, nil) end
	if (_vm:get_variable_type(name) == 'string') then
		do _g.sling.util.SymbolUtil:pushName(symbol, name) end
	elseif (_vm:to_table_with_key(name, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
		do _g.sling.util.SymbolUtil:pushComponent(symbol, name) end
	end
end

function sling.util.SymbolUtil:pushComponent(symbol, comp)
	if not (symbol ~= nil) then
		do return end
	end
	if not (comp ~= nil) then
		do return end
	end
	do _g.sling.util.SymbolUtil:unbind(symbol) end
	do symbol:addToComponents(comp) end
end

function sling.util.SymbolUtil:pushName(symbol, name)
	do _g.sling.util.SymbolUtil:pushComponent(symbol, _g.sling.model.SymbolNameComponentNode:forName(name)) end
end

function sling.util.SymbolUtil:unbind(symbol)
end

function sling.util.SymbolUtil:processExpressionToSymbolNames(xpr, v)
	if (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
		local ma = xpr
		if not _g.sling.util.SymbolUtil:processExpressionToSymbolNames(ma:getParentExpression(), v) then
			do return false end
		end
		if not _g.sling.util.SymbolUtil:processExpressionToSymbolNames(ma:getChildExpression(), v) then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
		local symbol = xpr:getSymbol()
		if not (symbol ~= nil) then
			do return false end
		end
		do
			local names = _g.sling.util.SymbolUtil:getSymbolNames(symbol)
			if not (names ~= nil) then
				do return false end
			end
			if names ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(names)
				do
					n = 0
					while n < m do
						local name = names[n + 1]
						if name ~= nil then
							do _g.jk.lang.Vector:append(v, name) end
						end
						do n = n + 1 end
					end
				end
			end
			do return true end
		end
	end
	do return false end
end

function sling.util.SymbolUtil:expressionToSymbolNames(xpr)
	if not (xpr ~= nil) then
		do return nil end
	end
	do
		local v = {}
		if not _g.sling.util.SymbolUtil:processExpressionToSymbolNames(xpr, v) then
			do return nil end
		end
		do return v end
	end
end

sling.util.FunctionUtil = {}
sling.util.FunctionUtil.__index = sling.util.FunctionUtil
_vm:set_metatable(sling.util.FunctionUtil, {})

function sling.util.FunctionUtil._create()
	local v = _vm:set_metatable({}, sling.util.FunctionUtil)
	return v
end

function sling.util.FunctionUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.FunctionUtil'
	self['_isType.sling.util.FunctionUtil'] = true
end

function sling.util.FunctionUtil:_construct0()
	sling.util.FunctionUtil._init(self)
	return self
end

function sling.util.FunctionUtil:prependStatement(fd, stmt)
	if not (fd ~= nil and stmt ~= nil) then
		do return end
	end
	do
		local block = fd:getBody()
		if not (block ~= nil) then
			block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
			do fd:setBody(block, false) end
		end
		do block:prependNode(stmt) end
	end
end

function sling.util.FunctionUtil:addStatement(fd, stmt)
	if not (fd ~= nil and stmt ~= nil) then
		do return end
	end
	do
		local block = fd:getBody()
		if not (block ~= nil) then
			block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
			do fd:setBody(block, false) end
		end
		do block:addNode(stmt) end
	end
end

function sling.util.FunctionUtil:createBaseCallForFunction(fd)
	if not (fd ~= nil) then
		do return nil end
	end
	do
		local xpr = nil
		if (_vm:to_table_with_key(fd, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
			xpr = _g.sling.model.MemberAccessExpressionNode:forNodes(_g.sling.model.BaseClassAccessExpressionNode._construct0(_g.sling.model.BaseClassAccessExpressionNode._create()), _g.sling.model.SymbolExpressionNode:forName(fd:getName()))
		else
			xpr = _g.sling.model.BaseClassAccessExpressionNode._construct0(_g.sling.model.BaseClassAccessExpressionNode._create())
		end
		do
			local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(xpr)
			local array = fd:getParameters()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
						if param ~= nil then
							do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(param, nil)) end
						end
						do n = n + 1 end
					end
				end
			end
			do return fc end
		end
	end
end

function sling.util.FunctionUtil:hasBaseCall(fd)
	if not (fd ~= nil) then
		do return false end
	end
	do
		local body = fd:getBody()
		if not (body ~= nil) then
			do return false end
		end
		do
			local name = nil
			if (_vm:to_table_with_key(fd, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
				name = fd:getName()
			end
			do
				local array = body:getNodes()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local fc = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionCallExpressionNode')
							if fc ~= nil then
								if name ~= nil then
									local max = _vm:to_table_with_key(fc:getExpression(), '_isType.sling.model.MemberAccessExpressionNode')
									if max ~= nil and (_vm:to_table_with_key(max:getParentExpression(), '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
										local cc = _vm:to_table_with_key(max:getChildExpression(), '_isType.sling.model.SymbolExpressionNode')
										if cc ~= nil and _g.jk.lang.String:equals(_g.sling.util.SymbolUtil:getSymbolName(cc:getSymbol()), name) then
											do return true end
										end
									end
								elseif (_vm:to_table_with_key(fc:getExpression(), '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
									do return true end
								end
							end
							do n = n + 1 end
						end
					end
				end
				do return false end
			end
		end
	end
end

function sling.util.FunctionUtil:addBaseCall(fd, force)
	if force or _g.sling.util.FunctionUtil:hasBaseCall(fd) == false then
		do _g.sling.util.FunctionUtil:prependStatement(fd, _g.sling.util.FunctionUtil:createBaseCallForFunction(fd)) end
	end
end

sling.util.FunctionUtil.VariableFinderVisitor = _g.sling.common.NodeVisitor._create()
sling.util.FunctionUtil.VariableFinderVisitor.__index = sling.util.FunctionUtil.VariableFinderVisitor
_vm:set_metatable(sling.util.FunctionUtil.VariableFinderVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.util.FunctionUtil.VariableFinderVisitor._create()
	local v = _vm:set_metatable({}, sling.util.FunctionUtil.VariableFinderVisitor)
	return v
end

function sling.util.FunctionUtil.VariableFinderVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.FunctionUtil.VariableFinderVisitor'
	self['_isType.sling.util.FunctionUtil.VariableFinderVisitor'] = true
	self.names = nil
	self.lookfor = nil
end

function sling.util.FunctionUtil.VariableFinderVisitor:_construct0()
	sling.util.FunctionUtil.VariableFinderVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.util.FunctionUtil.VariableFinderVisitor:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		local nn = node:getName()
		if nn ~= nil and _g.jk.lang.String:startsWith(nn, self.lookfor, 0) then
			do self.names:setBoolean(nn, true) end
		end
	end
	do return true end
end

function sling.util.FunctionUtil.VariableFinderVisitor:getNames()
	do return self.names end
end

function sling.util.FunctionUtil.VariableFinderVisitor:setNames(v)
	self.names = v
	do return self end
end

function sling.util.FunctionUtil.VariableFinderVisitor:getLookfor()
	do return self.lookfor end
end

function sling.util.FunctionUtil.VariableFinderVisitor:setLookfor(v)
	self.lookfor = v
	do return self end
end

function sling.util.FunctionUtil:findUniqueVariableNameInFunction(_function, name)
	if not (name ~= nil) then
		do return nil end
	end
	do
		local names = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		local body = _function:getBody()
		if body ~= nil then
			do body:accept(_g.sling.util.FunctionUtil.VariableFinderVisitor._construct0(_g.sling.util.FunctionUtil.VariableFinderVisitor._create()):setNames(names):setLookfor(name)) end
		end
		do
			local array = _function:getParameters()
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local pp = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
						if pp ~= nil then
							local nn = pp:getName()
							if nn ~= nil and _g.jk.lang.String:startsWith(nn, name, 0) then
								do names:setBoolean(nn, true) end
							end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			do
				local pe = _vm:to_table_with_key(_function:getParent(), '_isType.sling.model.EntityDeclarationNode')
				if pe ~= nil then
					local array2 = pe:getNodes()
					if array2 ~= nil then
						local n3 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n3 = 0
							while n3 < m2 do
								local mv = _vm:to_table_with_key(array2[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
								if mv ~= nil then
									local nn = mv:getName()
									if _g.jk.lang.String:startsWith(nn, name, 0) then
										do names:setBoolean(nn, true) end
									end
								end
								do n3 = n3 + 1 end
							end
						end
					end
				end
				if not (names:get(name) ~= nil) then
					do return name end
				end
				do
					local n = 2
					while n < 1000000 do
						local nn = _g.jk.lang.String:safeString(name) .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(n))
						if not (names:get(nn) ~= nil) then
							do return nn end
						end
						do n = n + 1 end
					end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to find unique variable name: `" .. _g.jk.lang.String:safeString(name) .. "'", _function, nil))
					do return nil end
				end
			end
		end
	end
end

function sling.util.FunctionUtil:findUniqueVariableNameInContainer(container, name)
	if not (name ~= nil) then
		do return nil end
	end
	do
		local names = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		if container ~= nil then
			do container:accept(_g.sling.util.FunctionUtil.VariableFinderVisitor._construct0(_g.sling.util.FunctionUtil.VariableFinderVisitor._create()):setNames(names):setLookfor(name)) end
		end
		if not (names:get(name) ~= nil) then
			do return name end
		end
		do
			local n = 2
			while n < 1000000 do
				local nn = _g.jk.lang.String:safeString(name) .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(n))
				if not (names:get(nn) ~= nil) then
					do return nn end
				end
				do n = n + 1 end
			end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to find unique variable name: `" .. _g.jk.lang.String:safeString(name) .. "'", container, nil))
			do return nil end
		end
	end
end

function sling.util.FunctionUtil:findUniqueVariableNameForNode(node, name)
	if not (node ~= nil) then
		do return nil end
	end
	if not (name ~= nil) then
		do return nil end
	end
	do
		local ff = _g.sling.util.FindUtil:findNearestFunctionBase(node)
		if ff ~= nil then
			do return _g.sling.util.FunctionUtil:findUniqueVariableNameInFunction(ff, name) end
		end
		do
			local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.common.ContainerNode')
			if pp ~= nil then
				do return _g.sling.util.FunctionUtil:findUniqueVariableNameInContainer(pp, name) end
			end
			do return name end
		end
	end
end

function sling.util.FunctionUtil:addBaseClassCallParameters(resolver, decl, force, findExact)
	if not (decl ~= nil) then
		do return end
	end
	if decl:getNext() ~= nil then
		do return end
	end
	do
		local body = decl:getBody()
		if body ~= nil then
			local array = body:getNodes()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local nod = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							if (_vm:to_table_with_key(nod, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
								local mx = nod:getExpression()
								if mx ~= nil and ((_vm:to_table_with_key(mx, '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) or (_vm:to_table_with_key(mx, '_isType.sling.model.CurrentObjectExpressionNode') ~= nil)) then
									do return end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do
			local myclass = _g.sling.util.FindUtil:findNearestClass(decl)
			if not (myclass ~= nil) then
				do return end
			end
			do
				local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.BaseClassAccessExpressionNode._construct0(_g.sling.model.BaseClassAccessExpressionNode._create()))
				local baseclass = resolver:getBaseClass(myclass)
				if baseclass ~= nil and (_vm:to_table_with_key(baseclass, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) == false then
					local params = {}
					local array2 = decl:getParameters()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local vd = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
								if vd ~= nil then
									do _g.jk.lang.Vector:append(params, _g.sling.model.SymbolExpressionNode:forBinding(vd, nil)) end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					if findExact then
						if not (resolver:getMatchingConstructor(baseclass, params, nil) ~= nil) then
							do return end
						end
					else
						while not _g.jk.lang.Vector:isEmpty(params) do
							if resolver:getMatchingConstructor(baseclass, params, nil) ~= nil then
								if params ~= nil then
									local n3 = 0
									local m3 = _g.jk.lang.Vector:getSize(params)
									do
										n3 = 0
										while n3 < m3 do
											local xpr = _vm:to_table_with_key(params[n3 + 1], '_isType.sling.common.ExpressionNode')
											if xpr ~= nil then
												do fc:addToParameters(xpr) end
											end
											do n3 = n3 + 1 end
										end
									end
								end
								do decl:setNext(fc, false) end
								do return end
							end
							do _g.jk.lang.Vector:removeLast(params) end
						end
					end
					do decl:setNext(fc, false) end
					do return end
				end
				if force then
					do decl:setNext(fc, false) end
				end
			end
		end
	end
end

function sling.util.FunctionUtil:copySignatureTo(from, to)
	if not (from ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("copySignatureTo: null from", nil, nil))
	end
	if not (to ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("copySignatureTo: null to", nil, nil))
	end
	do
		local array = from:getParameters()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local nd = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if nd ~= nil then
						do to:addToParameters(_g.sling.util.NodeUtil:dupAsNode(nd)) end
					end
					do n = n + 1 end
				end
			end
		end
		if (_vm:to_table_with_key(from, '_isType.sling.model.FunctionDeclarationNode') ~= nil) and (_vm:to_table_with_key(to, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
			local dd = from:getReturnType()
			if not (dd ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No return type", from, nil))
			end
			do to:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(dd), false) end
		end
	end
end

function sling.util.FunctionUtil:isFunctionCallExpressionChild(node)
	local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.FunctionCallExpressionNode')
	if not (pp ~= nil) then
		do return false end
	end
	if not (pp:getExpression() == node) then
		do return false end
	end
	do return true end
end

function sling.util.FunctionUtil:getFunctionNameForExpression(xpr)
	if not (xpr ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
		xpr = xpr:getLastNode()
	end
	if (_vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
		do return _g.sling.util.SymbolUtil:getSymbolName(xpr:getSymbol()) end
	end
	do return nil end
end

function sling.util.FunctionUtil:getResolvedDeclarationForExpression(xpr)
	local symxpr = _vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode')
	if symxpr ~= nil then
		local symbol = symxpr:getSymbol()
		if symbol ~= nil then
			local bdecl = _vm:to_table_with_key(symbol:getBinding(), '_isType.sling.model.FunctionDeclarationNode')
			if bdecl ~= nil then
				do return bdecl end
			end
		end
		do return nil end
	end
	do
		local max = _vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode')
		if max ~= nil then
			do return _g.sling.util.FunctionUtil:getResolvedDeclarationForExpression(max:getLastNode()) end
		end
		do return nil end
	end
end

function sling.util.FunctionUtil:getResolvedDeclaration(fc)
	if not (fc ~= nil) then
		do return nil end
	end
	do return _g.sling.util.FunctionUtil:getResolvedDeclarationForExpression(fc:getExpression()) end
end

sling.util.FunctionUtil.DeclarationWithTypemap = {}
sling.util.FunctionUtil.DeclarationWithTypemap.__index = sling.util.FunctionUtil.DeclarationWithTypemap
_vm:set_metatable(sling.util.FunctionUtil.DeclarationWithTypemap, {})

function sling.util.FunctionUtil.DeclarationWithTypemap._create()
	local v = _vm:set_metatable({}, sling.util.FunctionUtil.DeclarationWithTypemap)
	return v
end

function sling.util.FunctionUtil.DeclarationWithTypemap:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.FunctionUtil.DeclarationWithTypemap'
	self['_isType.sling.util.FunctionUtil.DeclarationWithTypemap'] = true
	self.declaration = nil
	self.typemap = nil
end

function sling.util.FunctionUtil.DeclarationWithTypemap:_construct0()
	sling.util.FunctionUtil.DeclarationWithTypemap._init(self)
	return self
end

function sling.util.FunctionUtil.DeclarationWithTypemap:getDeclaration()
	do return self.declaration end
end

function sling.util.FunctionUtil.DeclarationWithTypemap:setDeclaration(v)
	self.declaration = v
	do return self end
end

function sling.util.FunctionUtil.DeclarationWithTypemap:getTypemap()
	do return self.typemap end
end

function sling.util.FunctionUtil.DeclarationWithTypemap:setTypemap(v)
	self.typemap = v
	do return self end
end

function sling.util.FunctionUtil:getResolvedDeclarationForExpressionWithTypemap(xpr)
	local symxpr = _vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode')
	if symxpr ~= nil then
		local symbol = symxpr:getSymbol()
		if symbol ~= nil then
			local bdecl = _vm:to_table_with_key(symbol:getBinding(), '_isType.sling.model.FunctionDeclarationNode')
			if bdecl ~= nil then
				local v = _g.sling.util.FunctionUtil.DeclarationWithTypemap._construct0(_g.sling.util.FunctionUtil.DeclarationWithTypemap._create())
				do v:setDeclaration(bdecl) end
				do v:setTypemap(symbol:getBindingTypemap()) end
				do return v end
			end
		end
		do return nil end
	end
	do
		local max = _vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode')
		if max ~= nil then
			do return _g.sling.util.FunctionUtil:getResolvedDeclarationForExpressionWithTypemap(max:getLastNode()) end
		end
		do return nil end
	end
end

function sling.util.FunctionUtil:getResolvedDeclarationWithTypemap(fc)
	if not (fc ~= nil) then
		do return nil end
	end
	do return _g.sling.util.FunctionUtil:getResolvedDeclarationForExpressionWithTypemap(fc:getExpression()) end
end

sling.util.ExpressionUtil = {}
sling.util.ExpressionUtil.__index = sling.util.ExpressionUtil
_vm:set_metatable(sling.util.ExpressionUtil, {})

function sling.util.ExpressionUtil._create()
	local v = _vm:set_metatable({}, sling.util.ExpressionUtil)
	return v
end

function sling.util.ExpressionUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.ExpressionUtil'
	self['_isType.sling.util.ExpressionUtil'] = true
end

function sling.util.ExpressionUtil:_construct0()
	sling.util.ExpressionUtil._init(self)
	return self
end

function sling.util.ExpressionUtil:dupAsExpression(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("dupAsExpression: null node", nil, nil))
	end
	do
		local nnode = node:dup()
		if not (nnode ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate", node, nil))
		end
		do
			local v = _vm:to_table_with_key(nnode, '_isType.sling.common.ExpressionNode')
			if not (v ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not an expression", node, nil))
			end
			do return v end
		end
	end
end

function sling.util.ExpressionUtil:tryGetExpressionDataType(xpr, resolver)
	do
		local _rval = nil
		local _status, _err = _vm:execute_protected_call(function()
			_rval = {}
			_rval.value = _g.sling.util.ExpressionUtil:getExpressionDataType(xpr, resolver)
			do return end
		end)
		if _err then
		end
		if _rval then
			do return _rval.value end
		end
	end
	do return nil end
end

function sling.util.ExpressionUtil:getExpressionDataType(xpr, resolver)
	if not (xpr ~= nil) then
		do return nil end
	end
	do
		local rdtref = _vm:to_table_with_key(xpr:getResolvedDataType(), '_isType.sling.model.ReferenceDataTypeNode')
		if rdtref ~= nil and _g.sling.util.DataTypeUtil:isReferenceValid(rdtref) == false then
			do xpr:setResolvedDataType(nil, false) end
		end
		if resolver ~= nil then
			do resolver:resolveExpression(xpr) end
		end
		do
			local rdt = xpr:getResolvedDataType()
			if rdt ~= nil then
				do return rdt end
			end
			do
				local ddt = xpr:getDefaultDataType()
				if ddt ~= nil then
					do return ddt end
				end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expression data type is not known", xpr, nil))
				do return nil end
			end
		end
	end
end

sling.util.TypeResolver = {}
sling.util.TypeResolver.__index = sling.util.TypeResolver
_vm:set_metatable(sling.util.TypeResolver, {})

function sling.util.TypeResolver._create()
	local v = _vm:set_metatable({}, sling.util.TypeResolver)
	return v
end

function sling.util.TypeResolver:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.TypeResolver'
	self['_isType.sling.util.TypeResolver'] = true
end

function sling.util.TypeResolver:_construct0()
	sling.util.TypeResolver._init(self)
	return self
end

function sling.util.TypeResolver:resolveName(context, name)
end

function sling.util.TypeResolver:resolveNames(context, names)
end

function sling.util.TypeResolver:tryResolveNames(context, names)
end

function sling.util.TypeResolver:resolveExpression(xpr)
end

function sling.util.TypeResolver:resolveDataType(rdt)
end

function sling.util.TypeResolver:execute(node)
end

function sling.util.TypeResolver:getMatchingConstructor(entity, parameters, typemap)
end

function sling.util.TypeResolver:findImplementedInterfaceMethod(fdecl)
end

function sling.util.TypeResolver:isSame(primary, other, typemap)
end

function sling.util.TypeResolver:resolveFunctionSignature(decl, tr)
	if not (decl ~= nil) then
		do return end
	end
	if not (tr ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("resolveFunctionSignature: no type resolver", decl, nil))
	end
	do
		local array = decl:getParameters()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
					if param ~= nil then
						local pdt = _vm:to_table_with_key(param:getType(), '_isType.sling.model.ReferenceDataTypeNode')
						if pdt ~= nil then
							do tr:resolveDataType(pdt) end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.util.TypeResolver:resolveExpressions(node)
	local array = _g.sling.util.FindUtil:findCompatibleNodes(node, "class:sling.common.ExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local xpr = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
				if xpr ~= nil then
					do self:resolveExpression(xpr) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.util.TypeResolver:getBaseClass(entity)
	if not (entity ~= nil) then
		do return nil end
	end
	do
		local bdt = self:getBaseClassType(entity)
		if not (bdt ~= nil) then
			do return nil end
		end
		do self:resolveDataType(bdt) end
		do return _g.sling.util.TypeResolver:getAndRequireBoundClass(bdt) end
	end
end

function sling.util.TypeResolver:getBaseClassType(entity)
	if not (entity ~= nil) then
		do return nil end
	end
	do
		local array = entity:getBaseTypes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						local type = self:getRealInheritType(basetype)
						if type == _g.sling.model.BaseTypeNode.INHERIT_EXTEND then
							do return basetype:getReferenceType() end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return nil end
	end
end

function sling.util.TypeResolver:getRealInheritType(basetype)
	if not (basetype ~= nil) then
		do return _g.sling.model.BaseTypeNode.INHERIT_UNKNOWN end
	end
	do
		local dt = basetype:getInheritType()
		if dt ~= _g.sling.model.BaseTypeNode.INHERIT_AUTO then
			do return dt end
		end
		do
			local rdt = basetype:getReferenceType()
			if not (rdt ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No reference type for auto-inherit base type", basetype, nil))
			end
			do self:resolveDataType(rdt) end
			do
				local entity = _g.sling.util.TypeResolver:getAndRequireBoundEntity(rdt)
				if (_vm:to_table_with_key(entity, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
					do return _g.sling.model.BaseTypeNode.INHERIT_EXTEND end
				end
				if (_vm:to_table_with_key(entity, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
					do return _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT end
				end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported base type entity: `" .. _g.jk.lang.String:safeString(entity:getNodeTypeName()) .. "'", entity, nil))
				do return _g.sling.model.BaseTypeNode.INHERIT_UNKNOWN end
			end
		end
	end
end

function sling.util.TypeResolver:getAllGenericTypes(entity)
	local v = {}
	local bc = self:getBaseClass(entity)
	if bc ~= nil then
		local array = self:getAllGenericTypes(bc)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local bcv = array[n + 1]
					if bcv ~= nil then
						do _g.jk.lang.Vector:append(v, bcv) end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do
		local gce = _vm:to_table_with_key(entity, '_isType.sling.model.GenericCapableEntityDeclarationNode')
		if gce ~= nil then
			local array2 = gce:getGenericTypes()
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local gt = array2[n2 + 1]
						if gt ~= nil then
							do _g.jk.lang.Vector:append(v, gt) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
		end
		do return v end
	end
end

function sling.util.TypeResolver:getActualType(node)
	if not (node ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExpressionDataTypeNode') ~= nil) then
		do return _g.sling.util.ExpressionUtil:getExpressionDataType(node:getExpression(), nil) end
	end
	do return node end
end

function sling.util.TypeResolver:getBoundNode(dt)
	if not (dt ~= nil) then
		do return nil end
	end
	do self:resolveDataType(dt) end
	do
		local rdt = _vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode')
		if not (rdt ~= nil) then
			do return nil end
		end
		if (_vm:to_table_with_key(rdt, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
			local v = _g.sling.util.FindUtil:findNearestEntity(rdt)
			if not (v ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing entity", rdt, nil))
			end
			do return v end
		end
		do
			local symbol = rdt:getSymbol()
			if not (symbol ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Reference data type has no symbol", rdt, nil))
			end
			if rdt:getMagical() then
				local v = _g.sling.model.MagicalClassDeclarationNode._construct0(_g.sling.model.MagicalClassDeclarationNode._create())
				do v:setName(_g.sling.util.SymbolUtil:getSymbolName(symbol)) end
				do v:setSymbol(symbol, false) end
				do return v end
			end
			do
				local binding = symbol:getBinding()
				if not (binding ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Symbol `" .. _g.jk.lang.String:safeString(_g.sling.util.SymbolUtil:getSymbolName(symbol)) .. "' has no binding: Unable to find referenced node", symbol, nil))
				end
				do return binding end
			end
		end
	end
end

function sling.util.TypeResolver:getAndRequireBoundNode(dt)
	local v = self:getBoundNode(dt)
	if not (v ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type does not have a reference", dt, nil))
	end
	do return v end
end

function sling.util.TypeResolver:getBoundContainer(dt)
	do return _vm:to_table_with_key(self:getBoundNode(dt), '_isType.sling.common.ContainerNode') end
end

function sling.util.TypeResolver:getAndRequireBoundContainer(dt)
	local v = self:getAndRequireBoundNode(dt)
	local vv = _vm:to_table_with_key(v, '_isType.sling.common.ContainerNode')
	if not (vv ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type does not reference a container", dt, nil):addRelatedMessage("It references this", v))
	end
	do return vv end
end

function sling.util.TypeResolver:getBoundEntity(dt)
	do return _vm:to_table_with_key(self:getBoundNode(dt), '_isType.sling.model.EntityDeclarationNode') end
end

function sling.util.TypeResolver:getAndRequireBoundEntity(dt)
	local v = self:getAndRequireBoundNode(dt)
	local vv = _vm:to_table_with_key(v, '_isType.sling.model.EntityDeclarationNode')
	if not (vv ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type does not reference an entity", dt, nil):addRelatedMessage("It references this", v))
	end
	do return vv end
end

function sling.util.TypeResolver:getBoundClass(dt)
	do return _vm:to_table_with_key(self:getBoundNode(dt), '_isType.sling.model.ClassDeclarationNode') end
end

function sling.util.TypeResolver:getAndRequireBoundClass(dt)
	local v = self:getAndRequireBoundNode(dt)
	local vv = _vm:to_table_with_key(v, '_isType.sling.model.ClassDeclarationNode')
	if not (vv ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type does not reference a class", dt, nil):addRelatedMessage("It references this", v))
	end
	do return vv end
end

function sling.util.TypeResolver:getBoundInterface(dt)
	do return _vm:to_table_with_key(self:getBoundNode(dt), '_isType.sling.model.InterfaceDeclarationNode') end
end

function sling.util.TypeResolver:getAndRequireBoundInterface(dt)
	local v = self:getAndRequireBoundNode(dt)
	local vv = _vm:to_table_with_key(v, '_isType.sling.model.InterfaceDeclarationNode')
	if not (vv ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type does not reference an interface", dt, nil):addRelatedMessage("It references this", v))
	end
	do return vv end
end

function sling.util.TypeResolver:namesMatch(pname, oname)
	if not _g.jk.lang.Vector:isNotEmpty(pname) then
		do return false end
	end
	if not _g.jk.lang.Array:isNotEmpty(oname) then
		do return false end
	end
	do
		local sz1 = _g.jk.lang.Vector:getSize(pname)
		local sz2 = #oname
		if not (sz1 == sz2) then
			do return false end
		end
		do
			local i = 0
			while i < sz1 do
				if _g.jk.lang.String:isNotEqual((function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(pname[i + 1]), oname[i + 1]) then
					do return false end
				end
				do i = i + 1 end
			end
		end
		do return true end
	end
end

function sling.util.TypeResolver:getImplementedInterfaceReference(entity, inames)
	if not (entity ~= nil) then
		do return nil end
	end
	if not _g.jk.lang.Array:isNotEmpty(inames) then
		do return nil end
	end
	do
		local exts = {}
		local array = entity:getBaseTypes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local btn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
					if btn ~= nil then
						local inh = self:getRealInheritType(btn)
						local ref = btn:getReferenceType()
						if inh == _g.sling.model.BaseTypeNode.INHERIT_EXTEND then
							do _g.jk.lang.Vector:append(exts, ref) end
						elseif inh == _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT then
							local bnd = self:getAndRequireBoundInterface(ref)
							local qlf = _g.sling.util.NodeUtil:getQualifiedNameComponents(bnd, true)
							if _g.sling.util.TypeResolver:namesMatch(qlf, inames) then
								do return ref end
							end
						end
					end
					do n = n + 1 end
				end
			end
		end
		if exts ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(exts)
			do
				n2 = 0
				while n2 < m2 do
					local ext = exts[n2 + 1]
					if ext ~= nil then
						local intf = self:getImplementedInterfaceReference(_g.sling.util.TypeResolver:getAndRequireBoundEntity(ext), inames)
						if intf ~= nil then
							do return intf end
						end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do return nil end
	end
end

function sling.util.TypeResolver:isBaseTypeOf(original, candidate)
	if not (original ~= nil and candidate ~= nil) then
		do return false end
	end
	do
		local array = original:getBaseTypes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						local bound = self:getBoundEntity(basetype:getReferenceType())
						if not (bound ~= nil) then
							goto _continue3
						end
						if candidate == bound then
							do return true end
						end
						if self:isBaseTypeOf(bound, candidate) then
							do return true end
						end
					end
					::_continue3::
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function sling.util.TypeResolver:getTypeParametersForNode(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local sym = _vm:to_table_with_key(node, '_isType.sling.model.SymbolNode')
		if sym ~= nil then
			local tps = sym:getTypeParameters()
			if tps ~= nil then
				do return tps end
			end
			do
				local v = nil
				local array = _g.sling.util.SymbolUtil:getSymbolComponents(sym)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local nwtp = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolNameComponentNode')
							if nwtp ~= nil then
								local x = nwtp:getTypeParameters()
								if _g.jk.lang.Vector:isEmpty(x) then
									goto _continue4
								end
								if v == nil then
									v = {}
								end
								if x ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(x)
									do
										n2 = 0
										while n2 < m2 do
											local dtn = _vm:to_table_with_key(x[n2 + 1], '_isType.sling.common.NodeObject')
											if dtn ~= nil then
												do _g.jk.lang.Vector:append(v, dtn) end
											end
											do n2 = n2 + 1 end
										end
									end
								end
							end
							::_continue4::
							do n = n + 1 end
						end
					end
				end
				do return v end
			end
		end
		do
			local fdt = _vm:to_table_with_key(node, '_isType.sling.model.FunctionDataTypeNode')
			if fdt ~= nil then
				local v = {}
				local array2 = fdt:getFunctionParameters()
				if array2 ~= nil then
					local n3 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n3 = 0
						while n3 < m3 do
							local p = _vm:to_table_with_key(array2[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
							if p ~= nil then
								do _g.jk.lang.Vector:append(v, p:getType()) end
							end
							do n3 = n3 + 1 end
						end
					end
				end
				do
					local r = fdt:getFunctionReturnType()
					if r ~= nil then
						do _g.jk.lang.Vector:append(v, r) end
					end
					do return v end
				end
			end
			do
				local map = _vm:to_table_with_key(node, '_isType.sling.model.MapDataTypeNode')
				if map ~= nil then
					local v = {}
					do _g.jk.lang.Vector:append(v, map:getKeyType()) end
					do _g.jk.lang.Vector:append(v, map:getValueType()) end
					do return v end
				end
				do
					local ref = _vm:to_table_with_key(node, '_isType.sling.model.ReferenceDataTypeNode')
					if ref ~= nil then
						local symbol = ref:getSymbol()
						if symbol ~= nil then
							do return self:getTypeParametersForNode(symbol) end
						end
						do return nil end
					end
					do
						local set = _vm:to_table_with_key(node, '_isType.sling.model.SetDataTypeNode')
						if set ~= nil then
							local valueType = set:getPrimaryType()
							if valueType ~= nil then
								local v = {}
								do _g.jk.lang.Vector:append(v, valueType) end
								do return v end
							end
							do return nil end
						end
						do
							local dex = _vm:to_table_with_key(node, '_isType.sling.model.DataTypeExtenderNode')
							if dex ~= nil then
								local pt = dex:getPrimaryType()
								if pt ~= nil then
									local v = {}
									do _g.jk.lang.Vector:append(v, pt) end
									do return v end
								end
								do return nil end
							end
							do return nil end
						end
					end
				end
			end
		end
	end
end

function sling.util.TypeResolver:mapMainType(dt, map)
	if not (map ~= nil) then
		do return dt end
	end
	do
		local rdt = _vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode')
		if not (rdt ~= nil) then
			do return dt end
		end
		do
			local ref = _vm:to_table_with_key(self:getBoundNode(rdt), '_isType.sling.model.TemplateDeclarationNode')
			if not (ref ~= nil) then
				do return dt end
			end
			do
				local nn = _g.sling.util.NodeUtil:getQualifiedNameString(ref, 46)
				if not (nn ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Template declaration has no qualified name!", ref, nil))
				end
				do
					local r = map:get(nn)
					if not (r ~= nil) then
						do return dt end
					end
					do return r end
				end
			end
		end
	end
end

function sling.util.TypeResolver:mapType(dt, typemap)
	if not (dt ~= nil) then
		do return nil end
	end
	do
		local changed = false
		local ttm = typemap
		if (_vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
			local sym = dt:getSymbol()
			if sym ~= nil then
				local btm = sym:getBindingTypemap()
				if btm ~= nil then
					if not (ttm ~= nil) then
						ttm = btm
					else
						ttm = ttm:dup()
						do ttm:copyFrom(btm) end
					end
				end
			end
		end
		do
			local r = self:mapMainType(dt, ttm)
			if r ~= dt then
				changed = true
			end
			do
				local rdup = _g.sling.util.DataTypeUtil:dupAsDataType(r)
				local tps = self:getTypeParametersForNode(rdup)
				if _g.jk.lang.Vector:isEmpty(tps) == false then
					if tps ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(tps)
						do
							n = 0
							while n < m do
								local tp = _vm:to_table_with_key(tps[n + 1], '_isType.sling.common.DataTypeNode')
								if tp ~= nil then
									local ntp = self:mapType(tp, typemap)
									if ntp ~= tp then
										do _g.sling.util.NodeUtil:replaceNode(tp, ntp) end
										changed = true
									end
								end
								do n = n + 1 end
							end
						end
					end
				end
				if changed == false then
					do return r end
				end
				do return rdup end
			end
		end
	end
end

function sling.util.TypeResolver:getExpectedExpressionDataType(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = node:getParent()
		if not (pp ~= nil) then
			do return nil end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.IfStatementNode') ~= nil) and pp:getCondition() == node then
			do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.ForStatementNode') ~= nil) and pp:getCondition() == node then
			do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.LogicalExpressionNode') ~= nil) then
			do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) then
			do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.WhileStatementNode') ~= nil) and pp:getCondition() == node then
			do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.ArrayLiteralExpressionNode') ~= nil) then
			do return pp:getType() end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
			local fc = pp
			local rr = _g.sling.util.FunctionUtil:getResolvedDeclarationWithTypemap(fc)
			if not (rr ~= nil) then
				do return nil end
			end
			do
				local fd = rr:getDeclaration()
				if not (fd ~= nil) then
					do return nil end
				end
				do
					local sz = fc:getParameterCount()
					local ii = -1
					do
						local i = 0
						while i < sz do
							if fc:getParameter(i) == node then
								ii = i
							end
							do i = i + 1 end
						end
					end
					if not (ii > -1) then
						do return nil end
					end
					do
						local vd = _vm:to_table_with_key(fd:getParameter(ii), '_isType.sling.model.VariableDeclarationNode')
						if not (vd ~= nil) then
							do return nil end
						end
						do
							local vv = vd:getType()
							if not (vv ~= nil) then
								do return nil end
							end
							do
								local typemap = rr:getTypemap()
								if typemap ~= nil then
									vv = self:mapType(vv, typemap)
								end
								do return vv end
							end
						end
					end
				end
			end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.CreateObjectExpressionNode') ~= nil) then
			local co = pp
			local dt = co:getType()
			if not (dt ~= nil) then
				do return nil end
			end
			do
				local rf = self:getBoundClass(dt)
				if not (rf ~= nil) then
					do return nil end
				end
				do
					local pr = co:getParameters()
					local ct = self:getMatchingConstructor(rf, pr, nil)
					if not (ct ~= nil) then
						do return nil end
					end
					do
						local sz = _g.jk.lang.Vector:getSize(pr)
						local ii = -1
						do
							local i = 0
							while i < sz do
								if _g.jk.lang.Vector:get(pr, i) == node then
									ii = i
								end
								do i = i + 1 end
							end
						end
						if not (ii > -1) then
							do return nil end
						end
						do
							local vd = _vm:to_table_with_key(ct:getParameter(ii), '_isType.sling.model.VariableDeclarationNode')
							if not (vd ~= nil) then
								do return nil end
							end
							do return vd:getType() end
						end
					end
				end
			end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.AssignmentExpressionNode') ~= nil) then
			local xp = pp:getLeft()
			if not (node ~= xp) then
				do return nil end
			end
			do return _g.sling.util.ExpressionUtil:tryGetExpressionDataType(xp, nil) end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
			do return pp:getType() end
		end
		if (_vm:to_table_with_key(pp, '_isType.sling.model.ReturnStatementNode') ~= nil) then
			local pr = node:getParent()
			while true do
				if not (pr ~= nil) then
					do break end
				end
				if (_vm:to_table_with_key(pr, '_isType.sling.model.PromiseLiteralExpressionNode') ~= nil) then
					do break end
				end
				if (_vm:to_table_with_key(pr, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
					do break end
				end
				pr = pr:getParent()
			end
			if (_vm:to_table_with_key(pr, '_isType.sling.model.PromiseLiteralExpressionNode') ~= nil) then
				do return pr:getType() end
			elseif (_vm:to_table_with_key(pr, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
				do return pr:getReturnType() end
			end
		end
		do return nil end
	end
end

sling.util.NodeUtil = {}
sling.util.NodeUtil.__index = sling.util.NodeUtil
_vm:set_metatable(sling.util.NodeUtil, {})

function sling.util.NodeUtil._create()
	local v = _vm:set_metatable({}, sling.util.NodeUtil)
	return v
end

function sling.util.NodeUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.NodeUtil'
	self['_isType.sling.util.NodeUtil'] = true
end

function sling.util.NodeUtil:_construct0()
	sling.util.NodeUtil._init(self)
	return self
end

function sling.util.NodeUtil:getQualifiedNameComponents(node, skipCodeFile)
	local v = {}
	local nn = node
	while nn ~= nil do
		if (_vm:to_table_with_key(nn, '_isType.sling.common.CodeUnitNode') ~= nil) and _g.jk.lang.String:isEmpty(nn:getNodeName()) then
			do break end
		end
		if (_vm:to_table_with_key(nn, '_isType.sling.model.NamespaceNode') ~= nil) and _g.jk.lang.String:isEmpty(nn:getNodeName()) then
			do break end
		end
		if skipCodeFile and (_vm:to_table_with_key(nn, '_isType.sling.common.CodeFileNode') ~= nil) then
			nn = nn:getParent()
			goto _continue5
		end
		do
			local str = nil
			if (_vm:to_table_with_key(nn, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
				str = "[ctor]"
			elseif (_vm:to_table_with_key(nn, '_isType.sling.model.DestructorDeclarationNode') ~= nil) then
				str = "[dtor]"
			elseif (_vm:to_table_with_key(nn, '_isType.sling.model.MainFunctionDeclarationNode') ~= nil) then
				str = "[main]"
			elseif (_vm:to_table_with_key(nn, '_isType.sling.common.NamedNode') ~= nil) then
				str = nn:getNodeName()
			else
				do break end
			end
			if _g.jk.lang.String:isEmpty(str) then
				str = "[" .. _g.jk.lang.String:safeString(nn:getNodeTypeName()) .. "]"
			end
			do _g.jk.lang.Vector:prepend(v, str) end
			nn = nn:getParent()
		end
		::_continue5::
	end
	do return v end
end

function sling.util.NodeUtil:getParent(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null node in getParent", nil, nil))
	end
	do
		local pr = node:getParent()
		if not (pr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Node of type `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "' has no parent!", node, nil))
		end
		do return pr end
	end
end

function sling.util.NodeUtil:getQualifiedNameString(node, delim)
	local comps = _g.sling.util.NodeUtil:getQualifiedNameComponents(node, true)
	if not (comps ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if comps ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(comps)
			do
				n = 0
				while n < m do
					local comp = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(comps[n + 1])
					if comp ~= nil then
						if sb:count() > 0 then
							do sb:appendCharacter(delim) end
						end
						do sb:appendString(comp) end
					end
					do n = n + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function sling.util.NodeUtil:dupAsNode(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("dupAsNode: null node", nil, nil))
	end
	do
		local nnode = node:dup()
		if not (nnode ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate", node, nil))
		end
		do return nnode end
	end
end

function sling.util.NodeUtil:dupAsVariableDeclaration(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("dupAsVariableDeclaration: null node", nil, nil))
	end
	do
		local nnode = node:dup()
		if not (nnode ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate", node, nil))
		end
		do
			local v = _vm:to_table_with_key(nnode, '_isType.sling.model.VariableDeclarationNode')
			if not (v ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a variable", node, nil))
			end
			do return v end
		end
	end
end

function sling.util.NodeUtil:dupBlock(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("dupBlock: null node", nil, nil))
	end
	do
		local nnode = node:dup()
		if not (nnode ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate", node, nil))
		end
		do
			local v = _vm:to_table_with_key(nnode, '_isType.sling.model.BlockNode')
			if not (v ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a block", node, nil))
			end
			do return v end
		end
	end
end

function sling.util.NodeUtil:exportNode(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("exportNode: null node", nil, nil))
	end
	if not node:exportNode() then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to export node", node, nil))
	end
end

function sling.util.NodeUtil:exportLeftAsVariableDeclaration(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ForEachStatementNode') ~= nil) then
		local v = node
		local left = v:getLeft()
		if (_vm:to_table_with_key(left, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
			do v:exportLeft() end
			do return left end
		end
	end
	do return nil end
end

function sling.util.NodeUtil:removeNode(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("removeNode: null node", nil, nil))
	end
	if node:getParent() ~= nil then
		if not node:remove() then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to remove node", node, nil))
		end
	end
end

function sling.util.NodeUtil:replaceNode(node, newnode)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("replaceNode: null node", nil, nil))
	end
	if not node:replaceWith(newnode, false) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to replace node", node, nil))
	end
end

function sling.util.NodeUtil:replaceAndExport(node, newnode)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("replaceAndExport: null node", nil, nil))
	end
	if not node:replaceWith(newnode, true) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to replace node", node, nil))
	end
end

function sling.util.NodeUtil:isStatic(node)
	if not (node ~= nil) then
		do return false end
	end
	do return node:hasModifier(_g.sling.model.Modifier.STATIC) end
end

function sling.util.NodeUtil:insertAboveNode(existingnode, newnode)
	if not (newnode ~= nil) then
		do return end
	end
	if not (existingnode ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to insert node above null node", newnode, nil))
	end
	do
		local pp = _vm:to_table_with_key(existingnode:getParent(), '_isType.sling.common.ContainerNode')
		if not (pp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Node has no container parent! Unable to insert above node.", existingnode, nil))
		end
		if not pp:insertAboveNode(newnode, existingnode) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insert node above the given node.", existingnode, nil))
		end
	end
end

function sling.util.NodeUtil:replaceWithNodes(original, replace)
	if not (original ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("replaceWithNodes: null original", nil, nil))
	end
	do
		local ip = original:getInsertionPoint()
		if not (ip ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("replaceWithNodes: Failed to get insertion point", original, nil))
		end
		if replace ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(replace)
			do
				n = 0
				while n < m do
					local stmt = replace[n + 1]
					if stmt ~= nil then
						if not ip:insertBefore(stmt) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("replaceWithNodes: Failed to insert before", stmt, nil))
						end
					end
					do n = n + 1 end
				end
			end
		end
		if not original:remove() then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("replaceWithNodes: Failed to remove node", original, nil))
		end
	end
end

function sling.util.NodeUtil:addChild(parent, child)
	if not (child ~= nil) then
		do return end
	end
	if not (parent ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("addChild: null parent", nil, nil))
	end
	do
		local pcont = _vm:to_table_with_key(parent, '_isType.sling.common.ContainerNode')
		if not (pcont ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("addChild: parent is not a container", parent, nil))
		end
		do pcont:addNode(child) end
	end
end

function sling.util.NodeUtil:getOrCreateNamespaceForArray(parent, names)
	if not (parent ~= nil and names ~= nil) then
		do return nil end
	end
	do
		local nsc = parent
		if names ~= nil then
			local n = 0
			local m = #names
			do
				n = 0
				while n < m do
					local name = names[n + 1]
					if name ~= nil then
						nsc = _g.sling.util.NodeUtil:getOrCreateNamespace(nsc, name)
					end
					do n = n + 1 end
				end
			end
		end
		do return nsc end
	end
end

function sling.util.NodeUtil:getOrCreateNamespace(parent, childName)
	if not (parent ~= nil and childName ~= nil) then
		do return nil end
	end
	do
		local nodes = parent:getNodeIndexForName(childName)
		if nodes ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(nodes)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(nodes[n + 1], '_isType.sling.model.NamespaceNode')
					if node ~= nil then
						if node:getNodeName() == childName then
							do return node end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local nns = _g.sling.model.NamespaceNode:forName(childName)
			do parent:addNode(nns) end
			do return nns end
		end
	end
end

function sling.util.NodeUtil:describeNode(node)
	if not (node ~= nil) then
		do return "NullNode" end
	end
	do
		local v = node:getNodeTypeName()
		if (_vm:to_table_with_key(node, '_isType.sling.common.NamedNode') ~= nil) then
			v = _g.jk.lang.String:safeString(v) .. " name=`" .. _g.jk.lang.String:safeString(node:getNodeName()) .. "'"
		end
		do return v end
	end
end

sling.util.NodeUtil.DumpTreeHelper = _g.sling.common.NodeVisitor._create()
sling.util.NodeUtil.DumpTreeHelper.__index = sling.util.NodeUtil.DumpTreeHelper
_vm:set_metatable(sling.util.NodeUtil.DumpTreeHelper, {
	__index = _g.sling.common.NodeVisitor
})

function sling.util.NodeUtil.DumpTreeHelper._create()
	local v = _vm:set_metatable({}, sling.util.NodeUtil.DumpTreeHelper)
	return v
end

function sling.util.NodeUtil.DumpTreeHelper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.util.NodeUtil.DumpTreeHelper'
	self['_isType.sling.util.NodeUtil.DumpTreeHelper'] = true
	self.ctx = nil
end

function sling.util.NodeUtil.DumpTreeHelper:_construct0()
	sling.util.NodeUtil.DumpTreeHelper._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.util.NodeUtil.DumpTreeHelper:visit(node)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do
		local n = 0
		while n < self:getLevel() do
			do sb:appendString("  ") end
			do n = n + 1 end
		end
	end
	do sb:appendString(_g.sling.util.NodeUtil:describeNode(node)) end
	do _g.jk.log.Log:info(self.ctx, sb:toString()) end
	do return true end
end

function sling.util.NodeUtil.DumpTreeHelper:getCtx()
	do return self.ctx end
end

function sling.util.NodeUtil.DumpTreeHelper:setCtx(v)
	self.ctx = v
	do return self end
end

function sling.util.NodeUtil:dumpTree(ctx, tree)
	if not (tree ~= nil) then
		do return end
	end
	do
		local helper = _g.sling.util.NodeUtil.DumpTreeHelper._construct0(_g.sling.util.NodeUtil.DumpTreeHelper._create())
		do helper:setCtx(ctx) end
		do tree:accept(helper) end
	end
end

function sling.util.NodeUtil:getVisibilityModifier(node)
	if not (node ~= nil) then
		do return nil end
	end
	if node:hasModifier(_g.sling.model.Modifier.PUBLIC) then
		do return _g.sling.model.Modifier.PUBLIC end
	end
	if node:hasModifier(_g.sling.model.Modifier.PROTECTED) then
		do return _g.sling.model.Modifier.PROTECTED end
	end
	if node:hasModifier(_g.sling.model.Modifier.PRIVATE) then
		do return _g.sling.model.Modifier.PRIVATE end
	end
	if node:hasModifier(_g.sling.model.Modifier.NAMESPACEPRIVATE) then
		do return _g.sling.model.Modifier.NAMESPACEPRIVATE end
	end
	do return nil end
end

function sling.util.NodeUtil:hasVisibilityModifier(node)
	if _g.sling.util.NodeUtil:getVisibilityModifier(node) ~= nil then
		do return true end
	end
	do return false end
end
sling = sling or {}

sling.syntax = sling.syntax or {}

sling.syntax.SlingGenerator = _g.sling.common.CodeGenerator._create()
sling.syntax.SlingGenerator.__index = sling.syntax.SlingGenerator
_vm:set_metatable(sling.syntax.SlingGenerator, {
	__index = _g.sling.common.CodeGenerator
})

sling.syntax.SlingGenerator.CONTEXT_NAMESPACE = 0
sling.syntax.SlingGenerator.CONTEXT_CLASS = 1
sling.syntax.SlingGenerator.CONTEXT_INTERFACE = 2
sling.syntax.SlingGenerator.CONTEXT_ENUM = 3
sling.syntax.SlingGenerator.CONTEXT_SCRIPT = 4
sling.syntax.SlingGenerator.CONTEXT_EXPRESSION = 5
sling.syntax.SlingGenerator.CONTEXT_STATEMENT_BLOCK = 6

function sling.syntax.SlingGenerator._create()
	local v = _vm:set_metatable({}, sling.syntax.SlingGenerator)
	return v
end

function sling.syntax.SlingGenerator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.syntax.SlingGenerator'
	self['_isType.sling.syntax.SlingGenerator'] = true
	self.isLastNL = false
	self.excludeComments = false
	self.currentIndent = 0
	self.copyrightDeclaration = nil
	self.hangingBraces = false
	self.insertSpaceAfterKeywords = true
end

function sling.syntax.SlingGenerator:_construct0()
	sling.syntax.SlingGenerator._init(self)
	do _g.sling.common.CodeGenerator._construct0(self) end
	return self
end

function sling.syntax.SlingGenerator:_construct2(ctx, output)
	sling.syntax.SlingGenerator._init(self)
	do _g.sling.common.CodeGenerator._construct2(self, ctx, output) end
	return self
end

function sling.syntax.SlingGenerator:adjustIndent(n)
	self.currentIndent = self.currentIndent + n
end

function sling.syntax.SlingGenerator:dumpOpeningBrace()
	if self.hangingBraces then
		do self:output(" {\n") end
	else
		do self:output("\n") end
		do self:output("{\n") end
	end
end

function sling.syntax.SlingGenerator:dumpKeywordParens()
	if self.insertSpaceAfterKeywords then
		do self:output(" (") end
	else
		do self:output("(") end
	end
end

function sling.syntax.SlingGenerator:onFileStarted()
	do _g.sling.common.CodeGenerator.onFileStarted(self) end
	self.currentIndent = 0
	self.isLastNL = false
	if _g.jk.lang.String:isEmpty(self.copyrightDeclaration) == false then
		local cc = _g.sling.model.CommentNode:forText(self.copyrightDeclaration, false)
		do cc:setSubstantial(true) end
		do self:dumpComment(cc, true) end
	end
end

function sling.syntax.SlingGenerator:dumpComment(node, allowExtraNewlines)
	if self.excludeComments then
		do return true end
	end
	do
		local substantial = node:getSubstantial()
		local text = node:getText()
		if substantial == false and _g.jk.lang.String:getIndexOfCharacter(text, 10, 0) >= 0 then
			substantial = true
		end
		if substantial and allowExtraNewlines then
			do self:doOutput("\n", true) end
		end
		if substantial == false then
			if _g.jk.lang.String:startsWith(text, " ", 0) == false then
				do self:doOutput("// " .. _g.jk.lang.String:safeString(text) .. "\n", true) end
			else
				do self:doOutput("//" .. _g.jk.lang.String:safeString(text) .. "\n", true) end
			end
		else
			do self:doOutput("/*\n", true) end
			do
				local array = _g.jk.lang.String:split(text, 10, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local line = array[n + 1]
							if line ~= nil then
								if _g.jk.lang.String:isEmpty(line) then
									do self:doOutput(" *\n", true) end
								else
									do self:doOutput(" * " .. _g.jk.lang.String:safeString(line) .. "\n", true) end
								end
							end
							do n = n + 1 end
						end
					end
				end
				do self:doOutput(" */\n", true) end
			end
		end
		if substantial and allowExtraNewlines then
			do self:doOutput("\n", true) end
		end
		do return true end
	end
end

function sling.syntax.SlingGenerator:output(str)
	do self:doOutput(str, false) end
end

function sling.syntax.SlingGenerator:doOutput(str, isComment)
	if not (str ~= nil) then
		do return end
	end
	do
		local decIndent = false
		if self.isLastNL and self.currentIndent > 0 then
			if isComment == false and (_g.jk.lang.String:startsWith(str, "}", 0) or _g.jk.lang.String:startsWith(str, "]", 0)) then
				do self.currentIndent = self.currentIndent - 1 end
				decIndent = true
			end
			if not (str == "\n") then
				local n = 0
				do
					n = 0
					while n < self.currentIndent do
						do self:outputDirect("\t") end
						do n = n + 1 end
					end
				end
			end
		end
		self.isLastNL = false
		do self:outputDirect(str) end
		if _g.jk.lang.String:endsWith(str, "\n") then
			self.isLastNL = true
			if isComment == false then
				if _g.jk.lang.String:endsWith(str, "{\n") or _g.jk.lang.String:endsWith(str, "[\n") then
					do self.currentIndent = self.currentIndent + 1 end
				elseif _g.jk.lang.String:endsWith(str, "}\n") or _g.jk.lang.String:endsWith(str, "]\n") then
					if decIndent == false then
						do self.currentIndent = self.currentIndent - 1 end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:getContextName(ctx)
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_NAMESPACE then
		do return "namespace" end
	end
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_CLASS then
		do return "class" end
	end
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_INTERFACE then
		do return "interface" end
	end
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_ENUM then
		do return "enum" end
	end
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_SCRIPT then
		do return "script" end
	end
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_EXPRESSION then
		do return "expression" end
	end
	if ctx == _g.sling.syntax.SlingGenerator.CONTEXT_STATEMENT_BLOCK then
		do return "statement block" end
	end
	do return "unknown context" end
end

function sling.syntax.SlingGenerator:startModuleFile(name)
	if _g.jk.lang.String:isEmpty(name) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty name for startModuleFile", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local module = self:getCurrentModuleName()
		if _g.jk.lang.String:isEmpty(module) then
			do self:startFile(name) end
		else
			do self:startFile(_g.jk.lang.String:safeString(module) .. "/" .. _g.jk.lang.String:safeString(name)) end
		end
	end
end

function sling.syntax.SlingGenerator:dumpHeader(node, name)
	do self:startFile(_g.jk.lang.String:safeString(name) .. ".sling") end
	do
		local array = _g.sling.common.NodeFinder:findCompatibleNodesForTypes(node, {
			"class:sling.model.EntityDeclarationNode",
			"class:sling.model.VariableDeclarationNode",
			"class:sling.model.FunctionDeclarationNode"
		}, false, true, false)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local decl = array[n + 1]
					if decl ~= nil then
						if (_vm:to_table_with_key(decl, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
							if (_vm:to_table_with_key(decl, '_isType.sling.model.TemplateDeclarationNode') ~= nil) then
								goto _continue1
							end
							if (_vm:to_table_with_key(decl:getParent(), '_isType.sling.model.EntityDeclarationNode') ~= nil) then
								goto _continue1
							end
							if decl:hasModifier(_g.sling.model.Modifier.HEADER) then
								goto _continue1
							end
							do self:dumpEntityDeclarationHeader(decl, true) end
						end
						if (_vm:to_table_with_key(decl, '_isType.sling.model.VariableDeclarationNode') ~= nil) or (_vm:to_table_with_key(decl, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
							if (_vm:to_table_with_key(decl:getParent(), '_isType.sling.model.NamespaceNode') ~= nil) == false then
								goto _continue1
							end
							if (_vm:to_table_with_key(decl, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
								do self:dumpFunctionSignature(decl, true) end
								do self:output("\n") end
							elseif (_vm:to_table_with_key(decl, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
								do self:dumpHeaderVariableDeclaration(decl, true) end
							end
						end
					end
					::_continue1::
					do n = n + 1 end
				end
			end
		end
		do self:endFile() end
	end
end

function sling.syntax.SlingGenerator:dumpDirectory(cd)
	if not (cd ~= nil) then
		do return end
	end
	do
		local nodes = cd:getNodes()
		if nodes ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(nodes)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(nodes[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						if (_vm:to_table_with_key(node, '_isType.sling.common.CodeDirectoryNode') ~= nil) then
							do self:dumpDirectory(node) end
						elseif (_vm:to_table_with_key(node, '_isType.sling.common.CodeFileNode') ~= nil) then
							local script = node
							local names = {}
							local dir = script:getParent()
							while dir ~= nil do
								if (_vm:to_table_with_key(dir, '_isType.sling.common.CodeDirectoryNode') ~= nil) then
									do _g.jk.lang.Vector:append(names, dir:getNodeName()) end
								end
								dir = dir:getParent()
							end
							do _g.jk.lang.Vector:reverse(names) end
							do
								local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
								if names ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(names)
									do
										n2 = 0
										while n2 < m2 do
											local name = names[n2 + 1]
											if name ~= nil then
												do sb:appendString(name) end
												do sb:appendCharacter(47) end
											end
											do n2 = n2 + 1 end
										end
									end
								end
								do self:doDumpFile(script, sb:toString()) end
							end
						else
							do _g.sling.common.RefLog:warning(self.ctx, "Unsupported node type in dumpDirectory: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", node) end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpFile(script)
	if not (script ~= nil) then
		do return end
	end
	do self:doDumpFile(script, nil) end
end

function sling.syntax.SlingGenerator:doDumpFile(script, moduleName)
	if not (script ~= nil) then
		do return end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if _g.jk.lang.String:isNotEmpty(moduleName) then
			do sb:appendString(moduleName) end
			if not _g.jk.lang.String:endsWith(moduleName, "/") then
				do sb:appendCharacter(47) end
			end
		end
		do
			local scriptName = script:getName()
			do sb:appendString(_g.jk.lang.String:safeString(scriptName) .. ".sling") end
			do self:startModuleFile(sb:toString()) end
			do
				local prev = nil
				local array = script:getNodes()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local snode = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
							if snode ~= nil then
								do self:dumpNodeInContext(snode, prev, _g.sling.syntax.SlingGenerator.CONTEXT_NAMESPACE) end
								prev = snode
							end
							do n = n + 1 end
						end
					end
				end
				do self:endFile() end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpPlingMapValue(key, value)
	do self:output(key) end
	do self:output(" = ") end
	do self:output(_g.jk.lang.String:forObject(value)) end
	do self:output("\n") end
end

function sling.syntax.SlingGenerator:dumpPlingStringValueWithInt(key, value)
	do self:dumpPlingStringValue(key, _g.jk.lang.String:forInteger(value)) end
end

function sling.syntax.SlingGenerator:dumpPlingStringValueWithBool(key, value)
	do self:dumpPlingStringValue(key, _g.jk.lang.String:forBoolean(value)) end
end

function sling.syntax.SlingGenerator:dumpPlingStringValueWithVector(key, values)
	if values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(values)
		do
			n = 0
			while n < m do
				local val = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(values[n + 1])
				if val ~= nil then
					do self:output(key) end
					do self:output(" += ") end
					do self:dumpPlingStringValueWithString(val) end
					do self:output("\n") end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpPlingStringValueWithString(value)
	do self:output("\"") end
	do self:output(value) end
	do self:output("\"") end
end

function sling.syntax.SlingGenerator:dumpPlingStringValue(key, value)
	do self:output(key) end
	do self:output(" = ") end
	do self:dumpPlingStringValueWithString(value) end
	do self:output("\n") end
end

function sling.syntax.SlingGenerator:dumpModulePling(node)
	local pling = node
	if not (pling ~= nil) then
		do return end
	end
	do self:startFile("module.pling") end
	do
		local vendorId = pling:getVendorId()
		if vendorId ~= nil then
			do self:dumpPlingStringValue("vendorId", vendorId) end
		end
		do
			local projectId = pling:getProjectId()
			if projectId ~= nil then
				do self:dumpPlingStringValue("projectId", projectId) end
			end
			do
				local projectVersion = pling:getProjectVersion()
				if projectVersion ~= nil then
					do self:dumpPlingStringValue("projectVersion", projectVersion) end
				end
				do
					local projectTitle = pling:getProjectTitle()
					if projectTitle ~= nil then
						do self:dumpPlingStringValue("projectTitle", projectTitle) end
					end
					do
						local projectDescription = pling:getProjectDescription()
						if projectDescription ~= nil then
							do self:dumpPlingStringValue("projectDescription", projectDescription) end
						end
						do
							local projectCopyright = pling:getProjectCopyright()
							if projectCopyright ~= nil then
								do self:dumpPlingStringValue("projectCopyright", projectCopyright) end
							end
							do
								local projectLicense = pling:getProjectLicense()
								if projectLicense ~= nil then
									do self:dumpPlingStringValue("projectLicense", projectLicense) end
								end
								do
									local moduleId = pling:getModuleId()
									if moduleId ~= nil then
										do self:dumpPlingStringValue("moduleId", moduleId) end
									end
									do
										local moduleTitle = pling:getModuleTitle()
										if moduleTitle ~= nil then
											do self:dumpPlingStringValue("moduleTitle", moduleTitle) end
										end
										do
											local moduleDescription = pling:getModuleDescription()
											if moduleDescription ~= nil then
												do self:dumpPlingStringValue("moduleDescription", moduleDescription) end
											end
											do
												local useJkop = pling:getUseJkop()
												if useJkop then
													do self:dumpPlingStringValueWithBool("useJkop", useJkop) end
												end
												do
													local imports = pling:getImports()
													if _g.jk.lang.Vector:isNotEmpty(imports) then
														do self:dumpPlingStringValueWithVector("imports", imports) end
													end
													do
														local ignoreModuleIdInNamespace = pling:getIgnoreModuleIdInNamespace()
														if ignoreModuleIdInNamespace then
															do self:dumpPlingStringValueWithBool("ignoreModuleIdInNamespace", ignoreModuleIdInNamespace) end
														end
														do
															local libraries = pling:getLibraries()
															if _g.jk.lang.Vector:isNotEmpty(libraries) then
																do self:dumpPlingStringValueWithVector("libraries", libraries) end
															end
															do
																local androidProjectId = pling:getAndroidProjectId()
																if androidProjectId ~= nil then
																	do self:dumpPlingStringValue("androidProjectId", androidProjectId) end
																end
																do
																	local androidVersion = pling:getAndroidVersion()
																	if androidVersion ~= nil then
																		do self:dumpPlingStringValue("androidVersion", androidVersion) end
																	end
																	do
																		local androidPackageName = pling:getAndroidPackageName()
																		if androidPackageName ~= nil then
																			do self:dumpPlingStringValue("androidPackageName", androidPackageName) end
																		end
																		do
																			local androidMinSdkVersion = pling:getAndroidMinSdkVersion()
																			if androidMinSdkVersion > 0 then
																				do self:dumpPlingStringValueWithInt("androidMinSdkVersion", androidMinSdkVersion) end
																			end
																			do
																				local androidTargetSdkVersion = pling:getAndroidTargetSdkVersion()
																				if androidTargetSdkVersion > 0 then
																					do self:dumpPlingStringValueWithInt("androidTargetSdkVersion", androidTargetSdkVersion) end
																				end
																				do
																					local androidToolsVersion = pling:getAndroidToolsVersion()
																					if androidToolsVersion ~= nil then
																						do self:dumpPlingStringValue("androidToolsVersion", androidToolsVersion) end
																					end
																					do
																						local androidGradlePluginVersion = pling:getAndroidGradlePluginVersion()
																						if androidGradlePluginVersion ~= nil then
																							do self:dumpPlingStringValue("androidGradlePluginVersion", androidGradlePluginVersion) end
																						end
																						do
																							local androidKotlinVersion = pling:getAndroidKotlinVersion()
																							if androidKotlinVersion ~= nil then
																								do self:dumpPlingStringValue("androidKotlinVersion", androidKotlinVersion) end
																							end
																							do
																								local androidEnableAndroidJackForLibraries = pling:getAndroidEnableAndroidJackForLibraries()
																								if androidEnableAndroidJackForLibraries then
																									do self:dumpPlingStringValueWithBool("androidEnableAndroidJackForLibraries", androidEnableAndroidJackForLibraries) end
																								end
																								do
																									local androidKeyStore = pling:getAndroidKeyStore()
																									if androidKeyStore ~= nil then
																										do self:dumpPlingStringValue("androidKeyStore", androidKeyStore) end
																									end
																									do
																										local androidKeyStorePassword = pling:getAndroidKeyStorePassword()
																										if androidKeyStorePassword ~= nil then
																											do self:dumpPlingStringValue("androidKeyStorePassword", androidKeyStorePassword) end
																										end
																										do
																											local androidKeyAlias = pling:getAndroidKeyAlias()
																											if androidKeyAlias ~= nil then
																												do self:dumpPlingStringValue("androidKeyAlias", androidKeyAlias) end
																											end
																											do
																												local androidKeyAliasPassword = pling:getAndroidKeyAliasPassword()
																												if androidKeyAliasPassword ~= nil then
																													do self:dumpPlingStringValue("androidKeyAliasPassword", androidKeyAliasPassword) end
																												end
																												do
																													local androidGoogleServicesVersion = pling:getAndroidGoogleServicesVersion()
																													if androidGoogleServicesVersion ~= nil then
																														do self:dumpPlingStringValue("androidGoogleServicesVersion", androidGoogleServicesVersion) end
																													end
																													do
																														local androidMetaData = pling:getAndroidMetaData()
																														if androidMetaData ~= nil then
																															do self:dumpPlingMapValue("androidMetaData", androidMetaData) end
																														end
																														do
																															local androidManifestCustomXmls = pling:getAndroidManifestCustomXmls()
																															if androidManifestCustomXmls ~= nil then
																																do self:dumpPlingStringValueWithVector("androidManifestCustomXmls", androidManifestCustomXmls) end
																															end
																															do
																																local androidManifestApplicationCustomXmls = pling:getAndroidManifestApplicationCustomXmls()
																																if androidManifestApplicationCustomXmls ~= nil then
																																	do self:dumpPlingStringValueWithVector("androidManifestApplicationCustomXml", androidManifestApplicationCustomXmls) end
																																end
																																do
																																	local androidPermissions = pling:getAndroidPermissions()
																																	if androidPermissions ~= nil then
																																		do self:dumpPlingStringValueWithVector("androidPermissions", androidPermissions) end
																																	end
																																	do
																																		local androidFeatures = pling:getAndroidPermissions()
																																		if androidFeatures ~= nil then
																																			do self:dumpPlingStringValueWithVector("androidFeatures", androidFeatures) end
																																		end
																																		do
																																			local androidGradleDepends = pling:getAndroidGradleDepends()
																																			if androidGradleDepends ~= nil then
																																				do self:dumpPlingStringValueWithVector("androidGradleDepends", androidGradleDepends) end
																																			end
																																			do
																																				local androidGradleHeap = pling:getAndroidGradleHeap()
																																				if androidGradleHeap > 0 then
																																					do self:dumpPlingStringValue("androidGradleHeap", androidGradleHeap) end
																																				end
																																				do
																																					local iosProjectName = pling:getIosProjectName()
																																					if iosProjectName ~= nil then
																																						do self:dumpPlingStringValue("iosProjectName", iosProjectName) end
																																					end
																																					do
																																						local iosVersion = pling:getIosVersion()
																																						if iosVersion ~= nil then
																																							do self:dumpPlingStringValue("iosVersion", iosVersion) end
																																						end
																																						do
																																							local iosDisplayName = pling:getIosDisplayName()
																																							if iosDisplayName ~= nil then
																																								do self:dumpPlingStringValue("iosDisplayName", iosDisplayName) end
																																							end
																																							do
																																								local iosCflags = pling:getIosCflags()
																																								if iosCflags ~= nil then
																																									do self:dumpPlingStringValue("iosCflags", iosCflags) end
																																								end
																																								do
																																									local iosLinkMethod = pling:getIosLinkMethod()
																																									if iosLinkMethod ~= nil then
																																										do self:dumpPlingStringValue("iosLinkMethod", iosLinkMethod) end
																																									end
																																									do
																																										local iosDeploymentTarget = pling:getIosDeploymentTarget()
																																										if iosDeploymentTarget ~= nil then
																																											do self:dumpPlingStringValue("iosDeploymentTarget", iosDeploymentTarget) end
																																										end
																																										do
																																											local iosResultType = pling:getIosResultType()
																																											if iosResultType ~= nil then
																																												do self:dumpPlingStringValue("iosResultType", iosResultType) end
																																											end
																																											do
																																												local iosPods = pling:getIosPods()
																																												if iosPods ~= nil then
																																													do self:dumpPlingStringValueWithVector("iosPods", iosPods) end
																																												end
																																												do
																																													local iosFrameworks = pling:getIosFrameworks()
																																													if iosFrameworks ~= nil then
																																														do self:dumpPlingStringValueWithVector("iosFrameworks", iosFrameworks) end
																																													end
																																													do
																																														local iosLinkLibs = pling:getIosLinkLibs()
																																														if iosLinkLibs ~= nil then
																																															do self:dumpPlingStringValueWithVector("iosLinkLibs", iosLinkLibs) end
																																														end
																																														do
																																															local iosLdFlags = pling:getIosLdFlags()
																																															if iosLdFlags ~= nil then
																																																do self:dumpPlingStringValueWithVector("iosLdFlags", iosLdFlags) end
																																															end
																																															do
																																																local iosPlists = pling:getIosPlists()
																																																if iosPlists ~= nil then
																																																	do self:dumpPlingStringValueWithVector("iosPlists", iosPlists) end
																																																end
																																																do
																																																	local iosInfoPlistData = pling:getIosInfoPlistData()
																																																	if iosInfoPlistData ~= nil then
																																																		do self:dumpPlingStringValueWithVector("iosInfoPlistData", iosInfoPlistData) end
																																																	end
																																																	do
																																																		local iosScreenOrientation = pling:getIosScreenOrientation()
																																																		if iosScreenOrientation ~= nil then
																																																			do self:dumpPlingStringValue("iosScreenOrientation", iosScreenOrientation) end
																																																		end
																																																		do
																																																			local mavenArtifactId = pling:getMavenArtifactId()
																																																			if mavenArtifactId ~= nil then
																																																				do self:dumpPlingStringValue("mavenArtifactId", mavenArtifactId) end
																																																			end
																																																			do
																																																				local mavenGroupId = pling:getMavenGroupId()
																																																				if mavenGroupId ~= nil then
																																																					do self:dumpPlingStringValue("mavenGroupId", mavenGroupId) end
																																																				end
																																																				do
																																																					local mavenVersion = pling:getMavenVersion()
																																																					if mavenVersion ~= nil then
																																																						do self:dumpPlingStringValue("mavenVersion", mavenVersion) end
																																																					end
																																																					do
																																																						local mavenName = pling:getMavenName()
																																																						if mavenName ~= nil then
																																																							do self:dumpPlingStringValue("mavenName", mavenName) end
																																																						end
																																																						do
																																																							local npmPackageJson = pling:getNpmPackageJson()
																																																							if npmPackageJson ~= nil then
																																																								do self:dumpPlingMapValue("npmPackageJson", npmPackageJson) end
																																																							end
																																																							do
																																																								local npmAngularJson = pling:getNpmAngularJson()
																																																								if npmAngularJson ~= nil then
																																																									do self:dumpPlingMapValue("npmAngularJson", npmAngularJson) end
																																																								end
																																																								do
																																																									local npmTsconfigJson = pling:getNpmTsconfigJson()
																																																									if npmTsconfigJson ~= nil then
																																																										do self:dumpPlingMapValue("npmTsconfigJson", npmTsconfigJson) end
																																																									end
																																																									do
																																																										local npmTslintJson = pling:getNpmTslintJson()
																																																										if npmTslintJson ~= nil then
																																																											do self:dumpPlingMapValue("npmTslintJson", npmTslintJson) end
																																																										end
																																																										do self:endFile() end
																																																									end
																																																								end
																																																							end
																																																						end
																																																					end
																																																				end
																																																			end
																																																		end
																																																	end
																																																end
																																															end
																																														end
																																													end
																																												end
																																											end
																																										end
																																									end
																																								end
																																							end
																																						end
																																					end
																																				end
																																			end
																																		end
																																	end
																																end
																															end
																														end
																													end
																												end
																											end
																										end
																									end
																								end
																							end
																						end
																					end
																				end
																			end
																		end
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpResources(node)
	local array = node:getNodes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = array[n + 1]
				if nn ~= nil then
					local rsf = _vm:to_table_with_key(nn, '_isType.sling.model.ResourceFileNode')
					if not (rsf ~= nil) then
						goto _continue2
					end
					do
						local name = rsf:getFileName()
						if _g.jk.lang.String:isEmpty(name) then
							goto _continue2
						end
						do
							local buffer = rsf:getBuffer()
							if not (buffer ~= nil) then
								goto _continue2
							end
							do self:startFile("resources/" .. _g.jk.lang.String:safeString(name)) end
							do
								local writer = self:getCurrentWriter()
								if not (writer ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get file writer for resource `" .. _g.jk.lang.String:safeString(name) .. "'", rsf, nil))
								end
								do
									local r = writer:writeBuffer(buffer)
									if not r then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write resource `" .. _g.jk.lang.String:safeString(name) .. "'", rsf, nil))
									end
									do self:endFile() end
								end
							end
						end
					end
				end
				::_continue2::
				do n = n + 1 end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpModule(module)
	if not (module ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null module given to Sling writer", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local array = module:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						if (_vm:to_table_with_key(node, '_isType.sling.common.CodeFileNode') ~= nil) then
							do self:dumpFile(node) end
							goto _continue3
						elseif (_vm:to_table_with_key(node, '_isType.sling.common.CodeDirectoryNode') ~= nil) then
							do self:dumpDirectory(node) end
							goto _continue3
						else
							do _g.sling.common.RefLog:warning(self.ctx, "Unsupported node type in code unit: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", node) end
						end
					end
					::_continue3::
					do n = n + 1 end
				end
			end
		end
		do
			local settings = _vm:to_table_with_key(module:getSettings(), '_isType.sling.model.ext.NSlingUnitSettings')
			if settings ~= nil then
				do self:dumpModulePling(settings) end
			end
			do self:dumpResources(module) end
		end
	end
end

function sling.syntax.SlingGenerator:dumpImportStaticMemberStatement(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("import static ") end
	do self:dumpSymbol(node:getMember(), true) end
	if node:getAllMembers() then
		do self:output(".*") end
	end
	do
		local container = node:getContainer()
		if container ~= nil then
			do self:output(" from ") end
			do self:dumpSymbol(container, true) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpImportPackageStatement(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("import ") end
	do self:dumpSymbol(node:getPackage(), true) end
	do
		local localName = node:getLocalName()
		if _g.jk.lang.String:isNotEmpty(localName) then
			do self:output(" as ") end
			do self:output(localName) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpImportEntityStatement(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("use ") end
	do self:dumpSymbol(node:getEntity(), true) end
	if node:getAllMembers() then
		do self:output(".*") end
	end
	do
		local container = node:getContainer()
		if container ~= nil then
			do self:output(" from ") end
			do self:dumpSymbol(container, true) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpTypeAliasDeclaration(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("typedef ") end
	do self:output(node:getNodeName()) end
	do self:dumpGenericTypes(node:getGenericTypes()) end
	do self:output(" = ") end
	do self:dumpDataType(node:getType()) end
	do self:output("\n") end
end

function sling.syntax.SlingGenerator:dumpModifier(node, mod)
	if _g.jk.lang.String:equals(_g.sling.model.Modifier.STUB, mod) then
		do self:output("stub") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.EVENT, mod) then
		do self:output("event") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.DEPRECATED, mod) then
		do self:output("deprecated") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.ABSTRACT, mod) then
		do self:output("abstract") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.PROPERTY, mod) then
		do self:output("property") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.NAMESPACEPRIVATE, mod) then
		do self:output("nsprivate") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.PRIVATE, mod) then
		do self:output("private") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.PUBLIC, mod) then
		do self:output("public") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.FUNDAMENTAL, mod) then
		do self:output("fundamental") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.STATIC, mod) then
		do self:output("static") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.CONSTANT, mod) then
		do self:output("const") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.VIRTUAL, mod) then
		do self:output("virtual") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.OVERRIDE, mod) then
		do self:output("override") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.IMPLEMENT, mod) then
		do self:output("implement") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.EXTERNAL, mod) then
		do self:output("extern") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.FINAL, mod) then
		do self:output("final") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.PROTECTED, mod) then
		do self:output("protected") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.TRANSIENT, mod) then
		do self:output("transient") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.SYNCHRONIZED, mod) then
		do self:output("synchronized") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.ASYNCHRONOUS, mod) then
		do self:output("async") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.VOLATILE, mod) then
		do self:output("volatile") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.NEW, mod) then
		do self:output("hide") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.THROWABLE, mod) then
		do self:output("throwable") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.HEADER, mod) then
		do self:output("header") end
	elseif _g.jk.lang.String:equals(_g.sling.model.Modifier.IMPLEMENTATION, mod) then
		do self:output("implementation") end
	else
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported modifier: `" .. _g.jk.lang.String:safeString(mod) .. "'", node, _g.jk.lang.StackTrace:generate()))
	end
end

function sling.syntax.SlingGenerator:dumpCommonModifiers(node, excludeModifiers)
	if not (node ~= nil) then
		do return end
	end
	do
		local mods = node:getModifierSet()
		if not (mods ~= nil) then
			do return end
		end
		do
			local array = mods:getAll()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local mod = array[n + 1]
						if mod ~= nil then
							if excludeModifiers ~= nil and excludeModifiers:contains(mod) then
								goto _continue4
							end
							do self:output(" ") end
							do self:dumpModifier(node, mod) end
						end
						::_continue4::
						do n = n + 1 end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpCustomModifierText(text)
	if not (text ~= nil) then
		do return end
	end
	do
		local simple = true
		local it = _g.jk.lang.String:iterate(text)
		while it ~= nil do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if _g.jk.lang.Character:isAlnum(c) then
				goto _continue5
			end
			if c == 95 then
				goto _continue5
			end
			simple = false
			do break end
			::_continue5::
		end
		if simple then
			do self:output(text) end
		else
			do self:output("[" .. _g.jk.lang.String:safeString(text) .. "]") end
		end
	end
end

function sling.syntax.SlingGenerator:dumpCustomModifiers(node, excludeModifiers)
	if not (node ~= nil) then
		do return end
	end
	do
		local mods = node:getCustomModifierSet()
		if not (mods ~= nil) then
			do return end
		end
		do
			local array = mods:getAll()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local mod = array[n + 1]
						if mod ~= nil then
							if excludeModifiers ~= nil and excludeModifiers:contains(mod) then
								goto _continue6
							end
							do self:output(" #") end
							do self:dumpCustomModifierText(mod) end
						end
						::_continue6::
						do n = n + 1 end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:symbolComponentToString(symbol, o)
	if (_vm:get_variable_type(o) == 'string') then
		do return o end
	end
	if (_vm:to_table_with_key(o, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local c = o
		do sb:appendString(c:getName()) end
		do
			local tps = c:getTypeParameters()
			if _g.jk.lang.Vector:isEmpty(tps) == false then
				do sb:appendCharacter(60) end
				do
					local first = true
					if tps ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(tps)
						do
							n = 0
							while n < m do
								local nd = _vm:to_table_with_key(tps[n + 1], '_isType.sling.common.DataTypeNode')
								if nd ~= nil then
									if first then
										first = false
									else
										do sb:appendCharacter(44) end
									end
									do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(nd)) end
								end
								do n = n + 1 end
							end
						end
					end
					do sb:appendCharacter(62) end
				end
			end
			do return sb:toString() end
		end
	end
	do return nil end
end

function sling.syntax.SlingGenerator:symbolToString(symbol, dumpAbsolute)
	local names = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
	if _g.jk.lang.Vector:isEmpty(names) then
		do return nil end
	end
	if not dumpAbsolute then
		local cc = _g.jk.lang.Vector:get(names, _g.jk.lang.Vector:getSize(names) - 1)
		if not (cc ~= nil) then
			do return nil end
		end
		do return _g.sling.syntax.SlingGenerator:symbolComponentToString(symbol, cc) end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if names ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(names)
			do
				n = 0
				while n < m do
					local o = names[n + 1]
					if o ~= nil then
						if sb:count() > 0 then
							do sb:appendCharacter(46) end
						end
						do sb:appendString(_g.sling.syntax.SlingGenerator:symbolComponentToString(symbol, o)) end
					end
					do n = n + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function sling.syntax.SlingGenerator:getFunctionCallDisplayString(fc)
	if not (fc ~= nil) then
		do return nil end
	end
	do
		local fname = _g.sling.util.FunctionUtil:getFunctionNameForExpression(fc:getExpression())
		if _g.jk.lang.String:isEmpty(fname) then
			fname = "<function>"
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendString(fname) end
			do sb:appendCharacter(40) end
			do
				local params = fc:getParameters()
				local first = true
				if params ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(params)
					do
						n = 0
						while n < m do
							local param = _vm:to_table_with_key(params[n + 1], '_isType.sling.common.ExpressionNode')
							if param ~= nil then
								if not first then
									do sb:appendString(", ") end
								end
								first = false
								do
									local dts = _g.sling.syntax.SlingGenerator:dataTypeToString(_g.sling.util.ExpressionUtil:getExpressionDataType(param, nil))
									if _g.jk.lang.String:isEmpty(dts) then
										dts = "UNKNOWN"
									end
									do sb:appendString(dts) end
								end
							end
							do n = n + 1 end
						end
					end
				end
				do sb:appendCharacter(41) end
				do return sb:toString() end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dataTypeToString(node)
	if not (node ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PointerDataTypeNode') ~= nil) then
		local ptype = node:getPrimaryType()
		if ptype == nil then
			do return "ptr" end
		end
		if (_vm:to_table_with_key(ptype, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and ptype:getType() == _g.sling.model.IntegerDataTypeNode.TYPE_UINT8 then
			do return "ptr" end
		end
		do return "ptr<" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingGenerator:dataTypeToString(ptype)) .. ">" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableReferenceDataTypeNode') ~= nil) then
		local ptype = node:getPrimaryType()
		if ptype == nil then
			do return "ref" end
		end
		if (_vm:to_table_with_key(ptype, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
			do return "ref" end
		end
		do return "ref<" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingGenerator:dataTypeToString(ptype)) .. ">" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExpressionDataTypeNode') ~= nil) then
		do return "typeof" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TypeInfoDataTypeNode') ~= nil) then
		do return "typeinfo" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
		do return "this" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ParentDataTypeNode') ~= nil) then
		do return "parent" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
		local adt = node
		local pt = adt:getPrimaryType()
		local sz = _vm:to_table_with_key(adt:getSize(), '_isType.sling.model.IntegerLiteralExpressionNode')
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendString("array") end
		do
			local sdt = _g.sling.syntax.SlingGenerator:dataTypeToString(pt)
			if sz ~= nil or (sdt ~= nil and not (sdt == "object")) then
				do sb:appendCharacter(60) end
				if sdt ~= nil then
					do sb:appendString(sdt) end
				else
					do sb:appendString("object") end
				end
				if sz ~= nil then
					do sb:appendCharacter(91) end
					do sb:appendString(_g.jk.lang.String:forInteger(sz:getValue())) end
					do sb:appendCharacter(93) end
				end
				do sb:appendCharacter(62) end
			end
			do return sb:toString() end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local rf = node
		local symbol = rf:getSymbol()
		if not (symbol ~= nil) then
			do return nil end
		end
		do
			local ss = _g.sling.syntax.SlingGenerator:symbolToString(symbol, true)
			if not (ss ~= nil) then
				do return nil end
			end
			if rf:getMagical() then
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendString("!\"") end
				do sb:appendString(ss) end
				do sb:appendString("\"") end
				do return sb:toString() end
			end
			do return ss end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.UnknownDataTypeNode') ~= nil) then
		do return "unknown" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
		do return "dynamic" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
		do return "var" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
		do return "char" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		local idn = node
		local type = idn:getType()
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_INT then
			do return "int" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT then
			do return "uint" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT then
			do return "short" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_USHORT then
			do return "ushort" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
			do return "long" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_ULONG then
			do return "ulong" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_INT8 then
			do return "int8" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT8 then
			do return "uint8" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_INT16 then
			do return "int16" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT16 then
			do return "uint16" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
			do return "int32" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT32 then
			do return "uint32" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
			do return "int64" end
		end
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT64 then
			do return "uint64" end
		end
		do return nil end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
		do return "double" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
		do return "float" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VoidDataTypeNode') ~= nil) then
		do return "void" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
		do return "bool" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringDataTypeNode') ~= nil) then
		do return "string" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
		do return "object" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
		do return "buffer" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TupleDataTypeNode') ~= nil) then
		do return "tuple" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DateTimeDataTypeNode') ~= nil) then
		do return "datetime" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DecimalDataTypeNode') ~= nil) then
		do return "decimal" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) then
		do return "exception" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
		local fdt = node
		local ddt = fdt:getFunctionReturnType()
		if not (ddt ~= nil) then
			ddt = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendString("function<") end
			do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(ddt)) end
			do
				local array = fdt:getFunctionParameters()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local pdecl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
							if pdecl ~= nil then
								local pdt = pdecl:getType()
								if pdt == nil then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No data type", pdecl, nil))
								end
								do sb:appendCharacter(44) end
								do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(pdt)) end
							end
							do n = n + 1 end
						end
					end
				end
				do sb:appendCharacter(62) end
				do return sb:toString() end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MapDataTypeNode') ~= nil) then
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendString("map") end
		do
			local dds1 = node:getKeyType()
			if not (dds1 ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No key type", node, nil))
			end
			do
				local dds2 = node:getValueType()
				if not (dds2 ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No value type", node, nil))
				end
				if (_vm:to_table_with_key(dds1, '_isType.sling.model.ObjectDataTypeNode') ~= nil) and (_vm:to_table_with_key(dds2, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
				else
					do sb:appendCharacter(60) end
					do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(dds1)) end
					do sb:appendCharacter(44) end
					do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(dds2)) end
					do sb:appendCharacter(62) end
				end
				do return sb:toString() end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SetDataTypeNode') ~= nil) then
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendString("set") end
		do
			local vt = node:getPrimaryType()
			if vt ~= nil and (_vm:to_table_with_key(vt, '_isType.sling.model.ObjectDataTypeNode') ~= nil) == false then
				do sb:appendCharacter(60) end
				do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(vt)) end
				do sb:appendCharacter(62) end
			end
			do return sb:toString() end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PromiseDataTypeNode') ~= nil) then
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendString("promise") end
		do
			local vt = node:getPrimaryType()
			if vt ~= nil and (_vm:to_table_with_key(vt, '_isType.sling.model.VoidDataTypeNode') ~= nil) == false then
				do sb:appendCharacter(60) end
				do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(vt)) end
				do sb:appendCharacter(62) end
			end
			do return sb:toString() end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendString("vector") end
		do
			local dt = node:getPrimaryType()
			if dt ~= nil and (_vm:to_table_with_key(dt, '_isType.sling.model.ObjectDataTypeNode') ~= nil) == false then
				do sb:appendCharacter(60) end
				do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(dt)) end
				do sb:appendCharacter(62) end
			end
			do return sb:toString() end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.OptionalDataTypeNode') ~= nil) then
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local pr = node:getPrimaryType()
		local um = node:getUnwrappingMethod()
		do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(pr)) end
		if um == _g.sling.model.OptionalDataTypeNode.EXPLICIT_UNWRAPPING then
			do sb:appendCharacter(63) end
		else
			do sb:appendCharacter(33) end
		end
		do return sb:toString() end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
		local cdt = node
		local prim = cdt:getPrimaryType()
		if not (prim ~= nil) then
			prim = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(prim)) end
			do
				local bts = cdt:getBaseTypes()
				if _g.jk.lang.Vector:isEmpty(bts) == false then
					local first = true
					if bts ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(bts)
						do
							n2 = 0
							while n2 < m2 do
								local dtn = _vm:to_table_with_key(bts[n2 + 1], '_isType.sling.common.DataTypeNode')
								if dtn ~= nil then
									if first then
										do sb:appendString(" : ") end
										first = false
									else
										do sb:appendString(" & ") end
									end
									do sb:appendString(_g.sling.syntax.SlingGenerator:dataTypeToString(dtn)) end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
				do return sb:toString() end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingStyleSheetDataType') ~= nil) then
		do return "stylesheet" end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingTreeDataType') ~= nil) then
		do return "tree" end
	end
	do return nil end
end

function sling.syntax.SlingGenerator:dumpSymbol(symbol, dumpAbsolute)
	local str = _g.sling.syntax.SlingGenerator:symbolToString(symbol, dumpAbsolute)
	if not (str ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to convert symbol to string", symbol, _g.jk.lang.StackTrace:generate()))
	end
	do self:output(str) end
end

function sling.syntax.SlingGenerator:dumpDataType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null data type node to dump", nil, _g.jk.lang.StackTrace:generate()))
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExpressionDataTypeNode') ~= nil) then
		do self:output("typeof(") end
		do self:dumpExpression(node:getExpression(), nil, false) end
		do self:output(")") end
		do return end
	end
	do
		local dts = _g.sling.syntax.SlingGenerator:dataTypeToString(node)
		if not (dts ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "data type" .. "'", node, nil))
		end
		do self:output(dts) end
	end
end

function sling.syntax.SlingGenerator:dumpEntityBaseTypes(node)
	local bts = node:getBaseTypes()
	if _g.jk.lang.Vector:isEmpty(bts) == false then
		if bts ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(bts)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(bts[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						if basetype:getInheritType() == _g.sling.model.BaseTypeNode.INHERIT_AUTO then
							do self:output(" is ") end
							do self:dumpDataType(basetype:getReferenceType()) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		if bts ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(bts)
			do
				n2 = 0
				while n2 < m2 do
					local basetype = _vm:to_table_with_key(bts[n2 + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						local it = basetype:getInheritType()
						if it == _g.sling.model.BaseTypeNode.INHERIT_AUTO then
							goto _continue7
						end
						if it == _g.sling.model.BaseTypeNode.INHERIT_EXTEND then
							do self:output(" extends ") end
						elseif it == _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT then
							do self:output(" implements ") end
						elseif it == _g.sling.model.BaseTypeNode.INHERIT_INFORMATIVE then
							do self:output(" isAlso ") end
						else
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown inheritance type: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(it)), basetype, _g.jk.lang.StackTrace:generate()))
						end
						do self:dumpDataType(basetype:getReferenceType()) end
					end
					::_continue7::
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:escapeDoubleQuotes(str)
	if not (str ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:getIndexOfCharacter(str, 34, 0) < 0 then
		do return str end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local it = _g.jk.lang.String:iterate(str)
		while it ~= nil do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if c == 34 then
				do sb:appendCharacter(92) end
			end
			do sb:appendCharacter(c) end
		end
		do return sb:toString() end
	end
end

function sling.syntax.SlingGenerator:dumpEntityImports(node, addNewline)
	if not (node ~= nil) then
		do return 0 end
	end
	do
		local v = 0
		local nl = addNewline
		local array = node:getImportStaticNamespaces()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local importStatic = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ImportStaticMemberStatementNode')
					if importStatic ~= nil then
						if nl then
							do self:output("\n") end
							nl = false
						end
						do self:dumpImportStaticMemberStatement(importStatic) end
						do v = v + 1 end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local array2 = node:getImportEntities()
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local importEntity = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.ImportEntityStatementNode')
						if importEntity ~= nil then
							if nl then
								do self:output("\n") end
								nl = false
							end
							do self:dumpImportEntityStatement(importEntity) end
							do v = v + 1 end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			do
				local array3 = node:getImportNamespaces()
				if array3 ~= nil then
					local n3 = 0
					local m3 = _g.jk.lang.Vector:getSize(array3)
					do
						n3 = 0
						while n3 < m3 do
							local symbol = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.SymbolNode')
							if symbol ~= nil then
								if nl then
									do self:output("\n") end
									nl = false
								end
								do self:output("import ") end
								do self:dumpSymbol(symbol, true) end
								do self:output("\n") end
								do v = v + 1 end
							end
							do n3 = n3 + 1 end
						end
					end
				end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpEntityDeclarationHeader(node, isTopLevel)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
		do self:output("class") end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
		do self:output("interface") end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.EnumDeclarationNode') ~= nil) then
		do self:output("enum") end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.ScriptDeclarationNode') ~= nil) then
		do self:output("script") end
	else
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "entity type for header" .. "'", node, nil))
	end
	do self:output(" name ") end
	if isTopLevel then
		do self:output(_g.sling.util.NodeUtil:getQualifiedNameString(node, 46)) end
	else
		do self:output(node:getName()) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GenericCapableEntityDeclarationNode') ~= nil) then
		do self:dumpGenericTypes(node:getGenericTypes()) end
	end
	if node:hasModifier(_g.sling.model.Modifier.HEADER) == false then
		do self:output(" header") end
	end
	do self:dumpEntityModifiers(node, isTopLevel) end
	do self:output("\n") end
	do self:output("{\n") end
	do self:dumpEntityImports(node, false) end
	do
		local array = node:getDependencies()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local dep = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(array[n + 1])
					if dep ~= nil then
						do self:output("depend \"" .. _g.jk.lang.String:safeString(self:escapeDoubleQuotes(dep)) .. "\"\n") end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local array2 = node:getNodes()
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local child = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
						if child ~= nil then
							if (_vm:to_table_with_key(child, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) and child:hasCustomModifier("macro") then
								do self:dumpFunctionDeclaration(child, false) end
								goto _continue8
							end
							if child:hasModifier("public") == false and child:hasModifier("protected") == false then
								goto _continue8
							end
							if (_vm:to_table_with_key(child, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) then
								do self:dumpFunctionSignature(child, false) end
								do self:output("\n") end
							elseif (_vm:to_table_with_key(child, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
								do self:dumpHeaderVariableDeclaration(child, false) end
							elseif (_vm:to_table_with_key(child, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
								do self:dumpEntityDeclarationHeader(child, false) end
							elseif (_vm:to_table_with_key(child, '_isType.sling.model.EnumValueNode') ~= nil) then
								do self:dumpEnumValue(child) end
							elseif (_vm:to_table_with_key(child, '_isType.sling.model.ext.NSlingPropertyDeclaration') ~= nil) then
								do self:dumpPropertyDeclarationHeader(child) end
							end
						end
						::_continue8::
						do n2 = n2 + 1 end
					end
				end
			end
			do self:output("}\n") end
		end
	end
end

function sling.syntax.SlingGenerator:dumpEntityModifiers(node, isTopLevel)
	do self:dumpEntityBaseTypes(node) end
	do self:dumpCommonModifiers(node, nil) end
	do self:dumpCustomModifiers(node, nil) end
end

function sling.syntax.SlingGenerator:dumpEntityDeclaration(node, isTopLevel)
	if not (node ~= nil) then
		do return end
	end
	if isTopLevel then
		if self:dumpEntityImports(node, false) > 0 then
			do self:output("\n") end
		end
	end
	do
		local nc = 0
		if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
			do self:output("class") end
			nc = _g.sling.syntax.SlingGenerator.CONTEXT_CLASS
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
			do self:output("interface") end
			nc = _g.sling.syntax.SlingGenerator.CONTEXT_INTERFACE
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.EnumDeclarationNode') ~= nil) then
			do self:output("enum") end
			nc = _g.sling.syntax.SlingGenerator.CONTEXT_ENUM
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.ScriptDeclarationNode') ~= nil) then
			do self:output("script") end
			nc = _g.sling.syntax.SlingGenerator.CONTEXT_SCRIPT
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "entity type" .. "'", node, nil))
		end
		if not isTopLevel then
			local pp = node:getParent()
			if (_vm:to_table_with_key(pp, '_isType.sling.common.CodeFileNode') ~= nil) then
				do self:output(" name") end
			end
			do self:output(" ") end
			do self:output(node:getName()) end
		end
		if (_vm:to_table_with_key(node, '_isType.sling.model.GenericCapableEntityDeclarationNode') ~= nil) then
			do self:dumpGenericTypes(node:getGenericTypes()) end
		end
		do self:dumpEntityModifiers(node, isTopLevel) end
		if isTopLevel then
			do self:output(":\n") end
			do self:output("\n") end
		else
			do self:output("\n") end
			do self:output("{\n") end
		end
		do
			local addSpace = false
			local description = node:getDescription()
			local metadata = node:getMetadata()
			if _g.jk.lang.String:isNotEmpty(description) or _g.jk.lang.String:isNotEmpty(metadata) then
				do self:output("meta\n") end
				do self:output("{\n") end
				if _g.jk.lang.String:isNotEmpty(description) then
					do self:output("description ") end
					do self:outputLongStringWithWrapping(description) end
					do self:output("}\n") end
				end
				if _g.jk.lang.String:isNotEmpty(metadata) then
					do self:output("data ") end
					do self:outputLongStringWithWrapping(metadata) end
					do self:output("}\n") end
				end
				addSpace = true
			end
			if isTopLevel == false then
				if self:dumpEntityImports(node, addSpace) > 0 then
					addSpace = true
				end
			end
			do
				local nl = addSpace
				local array = node:getImportEntities()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local symbol = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolNode')
							if symbol ~= nil then
								if nl then
									do self:output("\n") end
									nl = false
								end
								do self:output("use ") end
								do self:dumpSymbol(symbol, true) end
								do self:output("\n") end
								addSpace = true
							end
							do n = n + 1 end
						end
					end
				end
				do
					local array2 = node:getDependencies()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local dep = (function(o)
									if (_vm:get_variable_type(o) == 'string') then
										do return o end
									end
									do return nil end
								end)(array2[n2 + 1])
								if dep ~= nil then
									if nl then
										do self:output("\n") end
										nl = false
									end
									do self:output("depend \"" .. _g.jk.lang.String:safeString(self:escapeDoubleQuotes(dep)) .. "\"\n") end
									addSpace = true
								end
								do n2 = n2 + 1 end
							end
						end
					end
					if addSpace then
						do self:output("\n") end
					end
					do
						local prev = nil
						local array3 = node:getNodes()
						if array3 ~= nil then
							local n3 = 0
							local m3 = _g.jk.lang.Vector:getSize(array3)
							do
								n3 = 0
								while n3 < m3 do
									local child = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.NodeObject')
									if child ~= nil then
										if (_vm:to_table_with_key(child, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) and (_vm:to_table_with_key(prev, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) then
											local pbody = _vm:to_table_with_key(prev, '_isType.sling.model.FunctionDeclarationBaseNode'):getBody()
											local cbody = _vm:to_table_with_key(child, '_isType.sling.model.FunctionDeclarationBaseNode'):getBody()
											if not (pbody ~= nil) and cbody ~= nil then
												do self:output("\n") end
											end
										end
										do self:dumpNodeInContext(child, prev, nc) end
										prev = child
									end
									do n3 = n3 + 1 end
								end
							end
						end
						if prev ~= nil and (_vm:to_table_with_key(prev, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) then
							if not (_vm:to_table_with_key(prev, '_isType.sling.model.FunctionDeclarationBaseNode'):getBody() ~= nil) then
								do self:output("\n") end
							end
						end
						if not isTopLevel then
							do self:output("}\n") end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:shouldHaveBraces(node)
	if not (node ~= nil) then
		do return false end
	end
	if node:getChildCount() ~= 1 then
		do return true end
	end
	do
		local parent = node:getParent()
		if not (parent ~= nil) then
			do return false end
		end
		if (_vm:to_table_with_key(parent, '_isType.sling.model.TryCatchStatementNode') ~= nil) then
			do return true end
		end
		if (_vm:to_table_with_key(parent, '_isType.sling.model.CatchBlockNode') ~= nil) then
			do return true end
		end
		if (_vm:to_table_with_key(parent, '_isType.sling.model.ForEachStatementNode') ~= nil) then
			local fes = parent
			if fes:getElseBlock() ~= nil then
				do return true end
			end
		end
		if (_vm:to_table_with_key(parent, '_isType.sling.model.WhileStatementNode') ~= nil) then
			local wsn = parent
			if wsn:getElseBlock() ~= nil then
				do return true end
			end
		end
		if (_vm:to_table_with_key(parent, '_isType.sling.model.IfStatementNode') ~= nil) then
			local ifs = parent
			if ifs:getElseBlock() ~= nil then
				do return true end
			end
			do
				local ifsb = _vm:to_table_with_key(ifs:getParent(), '_isType.sling.model.BlockNode')
				if ifsb ~= nil and ifsb:getChildCount() == 1 and ifsb:getFirstNode() == ifs then
					local ifsp = _vm:to_table_with_key(ifsb:getParent(), '_isType.sling.model.IfStatementNode')
					if ifsp ~= nil and ifsp:getElseBlock() == ifsb then
						do return true end
					end
				end
				do return false end
			end
		end
		do return false end
	end
end

function sling.syntax.SlingGenerator:isSimpleBlock(node)
	if not (node ~= nil) then
		do return false end
	end
	if not (node:getChildCount() == 1) then
		do return false end
	end
	do
		local child = node:getFirstNode()
		if child ~= nil then
			if (_vm:to_table_with_key(child, '_isType.sling.model.IfStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.WhileStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.DoWhileStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.ForStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.ForEachStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.SwitchStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.TryCatchStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.AssertStatementNode') ~= nil) then
				local ass = child
				if ass:getErrorBlock() ~= nil then
					do return false end
				end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.PreprocessorIfStatementNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.EmbedBlockNode') ~= nil) then
				if _g.jk.lang.String:contains(child:getCode(), "\n") then
					do return false end
				end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.EnumDeclarationNode') ~= nil) then
				do return false end
			end
			if (_vm:to_table_with_key(child, '_isType.sling.model.CommentNode') ~= nil) then
				do return false end
			end
		end
		do return true end
	end
end

function sling.syntax.SlingGenerator:dumpControlStructureBlock(node)
	local hasBraces = self:shouldHaveBraces(node)
	if hasBraces == false and self:isSimpleBlock(node) then
		do self:output(":\n") end
		do self:adjustIndent(1) end
		do self:dumpStatementContainer(node) end
		do self:adjustIndent(-1) end
	else
		do self:output(" {\n") end
		do self:dumpStatementContainer(node) end
		do self:output("}\n") end
	end
end

function sling.syntax.SlingGenerator:outputLongStringWithWrapping(value)
	do self:output("[[\n") end
	do
		local array = _g.jk.text.StringUtil:wrapToLines(value, 80)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local line = array[n + 1]
					if line ~= nil then
						do self:output(line) end
						do self:output("\n") end
					end
					do n = n + 1 end
				end
			end
		end
		do self:output("]]\n") end
	end
end

function sling.syntax.SlingGenerator:dumpFunctionBlock(node, description)
	if _g.jk.lang.String:isEmpty(description) and self:isSimpleBlock(node) then
		do self:output(":\n") end
		do self:adjustIndent(1) end
		do self:dumpStatementContainer(node) end
		do self:adjustIndent(-1) end
	else
		do self:output("\n") end
		do self:output("{\n") end
		if _g.jk.lang.String:isNotEmpty(description) then
			do self:output("meta {\n") end
			do self:output("description ") end
			do self:outputLongStringWithWrapping(description) end
			do self:output("}\n") end
		end
		do self:dumpStatementContainer(node) end
		do self:output("}\n") end
	end
end

function sling.syntax.SlingGenerator:dumpStandaloneBlock(node)
	local first = true
	local array = node:getAllCommonModifiers()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local mod = array[n + 1]
				if mod ~= nil then
					if not first then
						do self:output(" ") end
					end
					do self:dumpModifier(node, mod) end
					first = false
				end
				do n = n + 1 end
			end
		end
	end
	if not first then
		do self:output(" ") end
	end
	do self:output("{\n") end
	do self:dumpStatementContainer(node) end
	do self:output("}\n") end
end

function sling.syntax.SlingGenerator:dumpFunctionExpressionBlock(node)
	do self:output(" {\n") end
	do self:dumpStatementContainer(node) end
	do self:output("}") end
end

function sling.syntax.SlingGenerator:dumpFunctionSignatureParameter(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		do self:dumpVariableDeclaration(node, nil, false, nil) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableArgumentsDeclarationNode') ~= nil) then
		local dd = node:getVariableDeclaration()
		if dd ~= nil then
			do self:dumpVariableDeclaration(dd, nil, false, nil) end
			do self:output(" ") end
		end
		do self:output("...") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NamedParameterDeclarationNode') ~= nil) then
		local npd = node
		do self:output(npd:getName()) end
		do self:output(":") end
		do self:dumpVariableDeclaration(npd:getVariable(), nil, false, nil) end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "function declaration parameters" .. "'", node, nil))
end

function sling.syntax.SlingGenerator:dumpGenericTypes(genericTypes)
	if not (_g.jk.lang.Vector:getSize(genericTypes) > 0) then
		do return end
	end
	do self:output("<") end
	do
		local tf = true
		if genericTypes ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(genericTypes)
			do
				n = 0
				while n < m do
					local gt = _vm:to_table_with_key(genericTypes[n + 1], '_isType.sling.model.ClassDeclarationNode')
					if gt ~= nil then
						if tf == false then
							do self:output(",") end
						end
						tf = false
						do self:output(gt:getNodeName()) end
						do
							local first = true
							local array = gt:getBaseTypes()
							if array ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array)
								do
									n2 = 0
									while n2 < m2 do
										local btn = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.BaseTypeNode')
										if btn ~= nil then
											if first then
												do self:output(" : ") end
												first = false
											else
												do self:output(" & ") end
											end
											do self:dumpDataType(btn:getReferenceType()) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do self:output(">") end
	end
end

function sling.syntax.SlingGenerator:dumpFunctionSignature(node, isTopLevel)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null node for function declaration", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local excludeCustom = nil
		if (_vm:to_table_with_key(node, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
			do self:output("ctor") end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.DestructorDeclarationNode') ~= nil) then
			do self:output("dtor") end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
			local fdn = node
			local isMacro = node:hasCustomModifier("macro")
			if isMacro then
				do self:output("macro") end
				excludeCustom = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
				do excludeCustom:add("macro") end
			else
				do self:output("func") end
			end
			do
				local name = nil
				if isTopLevel then
					name = _g.sling.util.NodeUtil:getQualifiedNameString(fdn, 46)
				else
					name = fdn:getNodeName()
				end
				if _g.jk.lang.String:isEmpty(name) == false then
					do self:output(" ") end
					do self:output(name) end
				end
				do
					local gts = node:getGenericTypes()
					if _g.jk.lang.Vector:isEmpty(gts) == false then
						do self:output(" ") end
						do self:dumpGenericTypes(gts) end
						do self:output(" ") end
					end
				end
			end
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported function declaration type", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local params = node:getParameters()
			if _g.jk.lang.Vector:isEmpty(params) == false then
				do self:output("(") end
				do
					local first = true
					if params ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(params)
						do
							n = 0
							while n < m do
								local cnode = _vm:to_table_with_key(params[n + 1], '_isType.sling.common.NodeObject')
								if cnode ~= nil then
									if first == false then
										do self:output(", ") end
									end
									first = false
									do self:dumpFunctionSignatureParameter(cnode) end
								end
								do n = n + 1 end
							end
						end
					end
					do self:output(")") end
				end
			end
			do
				local xx = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
				do xx:add(_g.sling.model.Modifier.PUBLIC) end
				do self:dumpCommonModifiers(node, xx) end
				if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
					local fdn = node
					local dt = fdn:getReturnType()
					if dt ~= nil and (_vm:to_table_with_key(dt, '_isType.sling.model.VoidDataTypeNode') ~= nil) == false then
						do self:output(" as ") end
						do self:dumpDataType(dt) end
					end
				end
				do
					local throws = node:getThrowables()
					if _g.jk.lang.Vector:isEmpty(throws) == false then
						if throws ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(throws)
							do
								n2 = 0
								while n2 < m2 do
									local dt = _vm:to_table_with_key(throws[n2 + 1], '_isType.sling.common.DataTypeNode')
									if dt ~= nil then
										do self:output(" throws ") end
										do self:dumpDataType(dt) end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
					if (_vm:to_table_with_key(node, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
						local nextcall = node:getNext()
						if nextcall ~= nil then
							do self:output(" next ") end
							do self:dumpExpression(nextcall, nil, false) end
						end
					end
					do self:dumpCustomModifiers(node, excludeCustom) end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpStaticBlockDeclaration(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("initStatic") end
	do self:dumpFunctionBlock(node:getBlock(), nil) end
end

function sling.syntax.SlingGenerator:dumpFunctionDeclaration(node, isExpression)
	do self:dumpFunctionSignature(node, false) end
	do
		local body = node:getBody()
		if body ~= nil then
			if isExpression then
				do self:dumpFunctionExpressionBlock(body) end
			else
				do self:dumpFunctionBlock(body, node:getDescription()) end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpInitializerBlockDeclaration(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("init") end
	do self:dumpFunctionBlock(node:getBlock(), nil) end
end

function sling.syntax.SlingGenerator:dumpMainFunctionDeclaration(_function)
	if not (_function ~= nil) then
		do return end
	end
	do
		local aan = _function:getArgumentArrayName()
		if aan ~= nil and _g.jk.lang.String:equals(aan, "args") == false then
			do self:output("main(") end
			do self:output(aan) end
			do self:output(")") end
		else
			do self:output("main") end
		end
		do self:dumpFunctionBlock(_function:getBody(), nil) end
	end
end

function sling.syntax.SlingGenerator:dumpWebApiRequestHandlerFunction(_function)
	if not (_function ~= nil) then
		do return end
	end
	do self:output(_g.jk.lang.String:safeString(_function:getMethod()) .. " \"" .. _g.jk.lang.String:safeString(_function:getPath()) .. "\"") end
	do self:dumpFunctionBlock(_function:getBody(), nil) end
end

function sling.syntax.SlingGenerator:dumpStatementContainer(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local prev = nil
		local array = node:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local cc = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if cc ~= nil then
						do self:dumpNodeInContext(cc, prev, _g.sling.syntax.SlingGenerator.CONTEXT_STATEMENT_BLOCK) end
						prev = cc
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpMemberVariableDeclaration(node)
	local exclude = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
	local isProperty = node:hasModifier(_g.sling.model.Modifier.PROPERTY)
	local isConstant = node:hasModifier(_g.sling.model.Modifier.CONSTANT)
	if isProperty or isConstant then
		do exclude:add(_g.sling.model.Modifier.PUBLIC) end
	else
		do exclude:add(_g.sling.model.Modifier.PRIVATE) end
	end
	if isProperty then
		do self:output("pvar ") end
		do exclude:add(_g.sling.model.Modifier.PROPERTY) end
	elseif isConstant then
		do self:output("const ") end
		do exclude:add(_g.sling.model.Modifier.CONSTANT) end
		do exclude:add(_g.sling.model.Modifier.STATIC) end
		do exclude:add(_g.sling.model.Modifier.FINAL) end
	else
		do self:output("var ") end
	end
	do self:dumpVariableDeclaration(node, exclude, false, nil) end
	do self:output("\n") end
end

function sling.syntax.SlingGenerator:dumpExplicitPropertyParameterDeclaration(_function)
	if not (_function ~= nil) then
		do return end
	end
	do
		local pname = nil
		local parameter = _vm:to_table_with_key(_function:getParameter(0), '_isType.sling.model.VariableDeclarationNode')
		if parameter ~= nil then
			pname = parameter:getName()
		end
		if pname ~= nil and not (pname == "value") then
			do self:output("(") end
			do self:output(pname) end
			do self:output(")") end
		end
	end
end

function sling.syntax.SlingGenerator:dumpPropertyDeclaration(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("property ") end
	do self:output(node:getName()) end
	do
		local bvn = node:getBackingVariableName()
		if _g.jk.lang.String:isNotEmpty(bvn) then
			do self:output(":") end
			do self:output(bvn) end
		end
		do
			local exclude = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
			do exclude:add(_g.sling.model.Modifier.PUBLIC) end
			do self:dumpCommonModifiers(node, exclude) end
			do self:output(" as ") end
			do self:dumpDataType(node:getType()) end
			do self:dumpCustomModifiers(node, nil) end
			do
				local init = node:getInitializer()
				if init ~= nil then
					do self:output(" = ") end
					do self:dumpExpression(init, nil, false) end
				end
				do self:output("\n{\n") end
				do
					local desc = node:getDescription()
					if _g.jk.lang.String:isNotEmpty(desc) then
						do self:output("description ") end
						do self:outputLongStringWithWrapping(desc) end
					end
					do
						local willset = node:getWillSetHandler()
						if willset ~= nil then
							do self:output("willset") end
							do self:dumpExplicitPropertyParameterDeclaration(willset) end
							do self:dumpControlStructureBlock(willset:getBody()) end
						end
						do
							local setter = node:getSetter()
							if setter ~= nil then
								do self:output("set") end
								do self:dumpExplicitPropertyParameterDeclaration(setter) end
								do self:dumpControlStructureBlock(setter:getBody()) end
							end
							do
								local didset = node:getDidSetHandler()
								if didset ~= nil then
									do self:output("didset") end
									do self:dumpExplicitPropertyParameterDeclaration(didset) end
									do self:dumpControlStructureBlock(didset:getBody()) end
								end
								do
									local getter = node:getGetter()
									if getter ~= nil then
										do self:output("get") end
										do self:dumpControlStructureBlock(getter:getBody()) end
									end
									do self:output("}\n") end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpPropertyDeclarationHeader(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output("property ") end
	do self:output(node:getName()) end
	do
		local exclude = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
		do exclude:add(_g.sling.model.Modifier.PUBLIC) end
		do self:dumpCommonModifiers(node, exclude) end
		do self:output(" as ") end
		do self:dumpDataType(node:getType()) end
		do self:dumpCustomModifiers(node, nil) end
		do self:output(" {") end
		do
			local setter = node:getSetter()
			if setter ~= nil then
				do self:output(" hasset") end
			end
			do
				local getter = node:getGetter()
				if getter ~= nil then
					do self:output(" hasget") end
				end
				if setter ~= nil or getter ~= nil then
					do self:output(" ") end
				end
				do self:output("}") end
				do self:output("\n") end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpAssertStatement(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local child = node:getChild()
		if not (child ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null child", node, _g.jk.lang.StackTrace:generate()))
		end
		if (_vm:to_table_with_key(child, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
			local nl = true
			local eb = node:getErrorBlock()
			if eb ~= nil then
				nl = false
			end
			do self:dumpVariableDeclarationStatement(child, nl, true, eb) end
		elseif (_vm:to_table_with_key(child, '_isType.sling.common.ExpressionNode') ~= nil) then
			do self:output("assert ") end
			do self:dumpExpression(child, nil, false) end
			do
				local eb = node:getErrorBlock()
				if eb ~= nil then
					do self:dumpControlStructureBlock(eb) end
				else
					do self:output("\n") end
				end
			end
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("unsupported assert statement child", child, _g.jk.lang.StackTrace:generate()))
		end
	end
end

function sling.syntax.SlingGenerator:dumpPrintLineStatement(node)
	do self:output("println") end
	do
		local xpr = node:getExpression()
		if xpr ~= nil then
			do self:output(" ") end
			do self:dumpExpression(xpr, nil, false) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpPrintStatement(node)
	do self:output("print") end
	do
		local xpr = node:getExpression()
		if xpr ~= nil then
			do self:output(" ") end
			do self:dumpExpression(xpr, nil, false) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpReturnStatement(node)
	do self:output("return") end
	do
		local xpr = node:getExpression()
		if xpr ~= nil then
			do self:output(" ") end
			do self:dumpExpression(xpr, nil, false) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpThrowStatement(node)
	do self:output("throw ") end
	do self:dumpExpression(node:getExpression(), nil, false) end
	do self:output("\n") end
end

function sling.syntax.SlingGenerator:dumpForEachStatement(node)
	local lefts = node:getLefts()
	if not (lefts ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No left nodes", node, _g.jk.lang.StackTrace:generate()))
	end
	do
		local right = node:getRight()
		if not (right ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No right node", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local block = node:getBlock()
			if not (block ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No block", node, _g.jk.lang.StackTrace:generate()))
			end
			do
				local condition = node:getCondition()
				do self:output("foreach ") end
				do
					local first = true
					if lefts ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(lefts)
						do
							n = 0
							while n < m do
								local lefto = lefts[n + 1]
								if lefto ~= nil then
									local left = _vm:to_table_with_key(lefto, '_isType.sling.model.VariableDeclarationNode')
									if not (left ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Foreach statement does not have a left variable declaration value", node, _g.jk.lang.StackTrace:generate()))
										do return end
									end
									if not first then
										do self:output(", ") end
									end
									first = false
									do self:dumpVariableDeclaration(left, nil, false, nil) end
								end
								do n = n + 1 end
							end
						end
					end
					do self:output(" in ") end
					do self:dumpExpression(right, nil, false) end
					if condition ~= nil then
						do self:output(" where ") end
						do self:dumpExpression(condition, nil, false) end
					end
					do self:dumpControlStructureBlock(block) end
					do
						local elseBlock = node:getElseBlock()
						if elseBlock ~= nil then
							do self:output("else") end
							do self:dumpControlStructureBlock(elseBlock) end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpEmbedBlock(node, isStatement)
	local type = node:getType()
	if _g.jk.lang.String:isEmpty(type) then
		type = "unknown"
	end
	do self:output("lang") end
	do self:output(" \"" .. _g.jk.lang.String:safeString(type) .. "\"") end
	do
		local dt = node:getDefaultDataType()
		if dt ~= nil then
			do self:output(" ") end
			do self:dumpDataType(dt) end
		end
		do
			local cc = node:getCode()
			if cc ~= nil then
				cc = _g.jk.lang.String:strip(cc)
				do
					local lines = _g.jk.lang.String:split(cc, 10, 0)
					if dt ~= nil and _g.jk.lang.Vector:getSize(lines) < 2 then
						do self:output(" {{{") end
						do
							local line = _g.jk.lang.Vector:get(lines, 0)
							if line ~= nil then
								do self:output(" " .. _g.jk.lang.String:safeString(line) .. " ") end
							end
						end
					else
						local oi = self:getCurrentIndent()
						do self:output(" {{{\n") end
						if lines ~= nil then
							local n = 0
							local m = _g.jk.lang.Vector:getSize(lines)
							do
								n = 0
								while n < m do
									local line = lines[n + 1]
									if line ~= nil then
										line = _g.jk.lang.String:strip(line)
										do self:output(_g.jk.lang.String:safeString(line) .. "\n") end
									end
									do n = n + 1 end
								end
							end
						end
						do self:setCurrentIndent(oi + 1) end
					end
				end
			else
				do self:output(" {{{ ") end
			end
			do self:output("}}}") end
			if isStatement then
				do self:output("\n") end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpForStatement(node)
	do self:output("for(") end
	do
		local init = node:getInitializer()
		if init ~= nil then
			local first = true
			local array = init:getNodes()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local inode = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
						if inode ~= nil then
							if first == false then
								do self:output(", ") end
							end
							first = false
							if (_vm:to_table_with_key(inode, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
								do self:dumpVariableDeclarationStatement(inode, false, false, nil) end
							elseif (_vm:to_table_with_key(inode, '_isType.sling.common.ExpressionNode') ~= nil) then
								do self:dumpExpression(inode, nil, false) end
							elseif (_vm:to_table_with_key(inode, '_isType.sling.model.EmptyStatementNode') ~= nil) then
							else
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown initializer in `for' node.", inode, _g.jk.lang.StackTrace:generate()))
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do self:output(" ; ") end
		do
			local cond = node:getCondition()
			if not (cond ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(cond, nil, false) end
			do self:output(" ; ") end
			do
				local ff = node:getFinalizer()
				if ff ~= nil then
					local first = true
					local array2 = ff:getNodes()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local fnode = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
								if fnode ~= nil then
									if first == false then
										do self:output(", ") end
									end
									first = false
									if (_vm:to_table_with_key(fnode, '_isType.sling.common.ExpressionNode') ~= nil) then
										do self:dumpExpression(fnode, nil, false) end
									else
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown node in finalizer", fnode, _g.jk.lang.StackTrace:generate()))
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
				do self:output(")") end
				do self:dumpControlStructureBlock(node:getBlock()) end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpErrorStatement(node)
	local msg = node:getMessage()
	if _g.jk.lang.String:isNotEmpty(msg) then
		do self:output("ERROR \"" .. _g.jk.lang.String:safeString(_g.sling.common.CodeStringUtil:escapeStringLiteralCStyle(msg)) .. "\"\n") end
	end
end

function sling.syntax.SlingGenerator:dumpBaseTypeNode(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local type = node:getInheritType()
		if type == _g.sling.model.BaseTypeNode.INHERIT_AUTO then
			do self:output("is ") end
		elseif type == _g.sling.model.BaseTypeNode.INHERIT_EXTEND then
			do self:output("extend ") end
		elseif type == _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT then
			do self:output("implement ") end
		elseif type == _g.sling.model.BaseTypeNode.INHERIT_INFORMATIVE then
			do self:output("isAlso ") end
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported base type node type: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(type)) .. "'", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local dt = node:getReferenceType()
			if not (dt ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No data type for base type node", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpDataType(dt) end
			do self:output("\n") end
		end
	end
end

function sling.syntax.SlingGenerator:dumpDependencyDeclaration(node)
	do self:output("depend ") end
	do
		local value = node:getValue()
		if not (value ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null value", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("\"" .. _g.jk.lang.String:safeString(_g.sling.common.CodeStringUtil:escapeStringLiteralCStyle(value)) .. "\"\n") end
	end
end

function sling.syntax.SlingGenerator:getVariableDeclarationType(node)
	if not (node ~= nil) then
		do return 0 end
	end
	if node:hasModifier(_g.sling.model.Modifier.CONSTANT) then
		do return 1 end
	end
	if node:hasModifier(_g.sling.model.Modifier.PROPERTY) then
		do return 2 end
	end
	do return 3 end
end

function sling.syntax.SlingGenerator:dumpNodeInContext(node, previousNode, context)
	if context == _g.sling.syntax.SlingGenerator.CONTEXT_CLASS or context == _g.sling.syntax.SlingGenerator.CONTEXT_INTERFACE or context == _g.sling.syntax.SlingGenerator.CONTEXT_NAMESPACE or context == _g.sling.syntax.SlingGenerator.CONTEXT_ENUM or context == _g.sling.syntax.SlingGenerator.CONTEXT_SCRIPT then
		if previousNode == nil then
		elseif _g.jk.lang.String:equals(previousNode:getNodeTypeName(), node:getNodeTypeName()) == false then
			do self:output("\n") end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.EntityDeclarationNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingPropertyDeclaration') ~= nil) then
			do self:output("\n") end
		elseif (_vm:to_table_with_key(previousNode, '_isType.sling.model.VariableDeclarationNode') ~= nil) and (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) and context ~= _g.sling.syntax.SlingGenerator.CONTEXT_ENUM then
			local t1 = self:getVariableDeclarationType(previousNode)
			local t2 = self:getVariableDeclarationType(node)
			if t1 ~= t2 then
				do self:output("\n") end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreprocessorIfStatementNode') ~= nil) then
		do self:dumpPreprocessorIfStatement(node, false, context) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SwitchStatementNode') ~= nil) then
		do self:dumpSwitchStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ErrorStatementNode') ~= nil) then
		do self:dumpErrorStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ForStatementNode') ~= nil) then
		do self:dumpForStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.WhileStatementNode') ~= nil) then
		do self:dumpWhileStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TryCatchStatementNode') ~= nil) then
		do self:dumpTryCatchStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmbedBlockNode') ~= nil) then
		do self:dumpEmbedBlock(node, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DoWhileStatementNode') ~= nil) then
		do self:dumpDoWhileStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TemplateStatementNode') ~= nil) then
		local temp = node
		do self:output("TEMPLATE \"") end
		do
			local name = temp:getName()
			if name ~= nil then
				do self:output(name) end
			end
			do self:output("\" ") end
			do self:dumpSymbol(temp:getSymbol(), true) end
			do self:output("\n") end
			do
				local relativeTo = temp:getRelativeTo()
				if name ~= nil and relativeTo ~= nil then
					do self:writeRelativeFileToRelativeFile(relativeTo, name) end
				end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TypeAliasDeclarationNode') ~= nil) then
		do self:dumpTypeAliasDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.UIExpressionNode') ~= nil) then
		do self:dumpUIExpressionNodeInClass(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ImportStaticMemberStatementNode') ~= nil) then
		do self:dumpImportStaticMemberStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ImportPackageStatementNode') ~= nil) then
		do self:dumpImportPackageStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ImportEntityStatementNode') ~= nil) then
		do self:dumpImportEntityStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DependencyDeclarationNode') ~= nil) then
		do self:dumpDependencyDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BaseTypeNode') ~= nil) then
		do self:dumpBaseTypeNode(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CommentNode') ~= nil) then
		do self:dumpComment(node, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EnumValueNode') ~= nil) then
		do self:dumpEnumValue(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
		local entity = node
		local parentFile = _vm:to_table_with_key(entity:getParent(), '_isType.sling.common.CodeFileNode')
		local isTopLevel = false
		if parentFile ~= nil then
			local entities = 0
			local array = parentFile:getNodes()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local snode = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
						if snode ~= nil then
							if (_vm:to_table_with_key(snode, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
								local ee = snode
								do entities = entities + 1 end
								if _g.jk.lang.String:equals(ee:getName(), parentFile:getName()) then
									isTopLevel = true
									goto _continue9
								end
							end
							isTopLevel = false
						end
						::_continue9::
						do n = n + 1 end
					end
				end
			end
			if entities > 1 then
				isTopLevel = false
			end
		end
		do self:dumpEntityDeclaration(entity, isTopLevel) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BreakStatementNode') ~= nil) then
		do self:output("break\n") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ContinueStatementNode') ~= nil) then
		do self:output("continue\n") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmptyStatementNode') ~= nil) then
		do self:output(";\n") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BlockNode') ~= nil) then
		do self:dumpStandaloneBlock(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.common.ExpressionNode') ~= nil) then
		do self:dumpExpression(node, nil, false) end
		do self:output("\n") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		if context == _g.sling.syntax.SlingGenerator.CONTEXT_CLASS or context == _g.sling.syntax.SlingGenerator.CONTEXT_INTERFACE then
			do self:dumpMemberVariableDeclaration(node) end
		else
			do self:dumpVariableDeclarationStatement(node, true, false, nil) end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingPropertyDeclaration') ~= nil) then
		do self:dumpPropertyDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AssertStatementNode') ~= nil) then
		do self:dumpAssertStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PrintLineStatementNode') ~= nil) then
		do self:dumpPrintLineStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PrintStatementNode') ~= nil) then
		do self:dumpPrintStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ReturnStatementNode') ~= nil) then
		do self:dumpReturnStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.IfStatementNode') ~= nil) then
		do self:dumpIfStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ForEachStatementNode') ~= nil) then
		do self:dumpForEachStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ThrowStatementNode') ~= nil) then
		do self:dumpThrowStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MainFunctionDeclarationNode') ~= nil) then
		do self:dumpMainFunctionDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration') ~= nil) then
		do self:dumpWebApiRequestHandlerFunction(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StaticBlockDeclarationNode') ~= nil) then
		do self:dumpStaticBlockDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) then
		do self:dumpFunctionDeclaration(node, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.InitializerBlockDeclarationNode') ~= nil) then
		do self:dumpInitializerBlockDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CriticalSectionBlockNode') ~= nil) then
		local nn = node
		do self:output("critical") end
		do
			local obj = nn:getObject()
			if obj ~= nil then
				do self:output("(") end
				do self:dumpExpression(obj, nil, false) end
				do self:output(")") end
			end
			do self:dumpControlStructureBlock(nn:getBlock()) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultipleVariableDeclarationNode') ~= nil) then
		do self:dumpMultipleVariableDeclarationStatement(node, true, false, nil) end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "' in context `" .. _g.jk.lang.String:safeString(self:getContextName(context)) .. "'", node, _g.jk.lang.StackTrace:generate()))
end

function sling.syntax.SlingGenerator:dumpSwitchStatement(node)
	local xp = node:getExpression()
	if not (xp ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("switch(") end
	do self:dumpExpression(xp, nil, false) end
	do self:output(") {\n") end
	do
		local array = node:getBlocks()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local cbnn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.CaseBlockNode')
					if cbnn ~= nil then
						local xpr = nil
						if (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseEqualsBlockNode') ~= nil) then
							do self:output("case ") end
							xpr = cbnn:getExpression()
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseNotEqualsBlockNode') ~= nil) then
							do self:output("case != ") end
							xpr = cbnn:getExpression()
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseLessThanBlockNode') ~= nil) then
							do self:output("case < ") end
							xpr = cbnn:getExpression()
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseLessOrEqualBlockNode') ~= nil) then
							do self:output("case <= ") end
							xpr = cbnn:getExpression()
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseGreaterThanBlockNode') ~= nil) then
							do self:output("case > ") end
							xpr = cbnn:getExpression()
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseGreaterOrEqualBlockNode') ~= nil) then
							do self:output("case >= ") end
							xpr = cbnn:getExpression()
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseRangeBlockNode') ~= nil) then
							local rnge = cbnn
							do self:output("case ") end
							do
								local from = rnge:getLowerBound()
								if not (from ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Case range block has no from expression", cbnn, _g.jk.lang.StackTrace:generate()))
								end
								do self:dumpExpression(from, nil, false) end
								do
									local type = rnge:getExclusionType()
									if type == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS then
										do self:output(">.<") end
									elseif type == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND then
										do self:output("..<") end
									elseif type == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND then
										do self:output(">..") end
									else
										do self:output("...") end
									end
									do
										local to = rnge:getUpperBound()
										if not (to ~= nil) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Case range block has no to expression", cbnn, _g.jk.lang.StackTrace:generate()))
										end
										do self:dumpExpression(to, nil, false) end
									end
								end
							end
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseMultipleEqualsBlockNode') ~= nil) then
							do self:output("case ") end
							do
								local exps = cbnn:getExpressions()
								if _g.jk.lang.Vector:isEmpty(exps) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Case multiple equals block has no expressions", cbnn, _g.jk.lang.StackTrace:generate()))
								end
								do
									local first = true
									if exps ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(exps)
										do
											n2 = 0
											while n2 < m2 do
												local expr = _vm:to_table_with_key(exps[n2 + 1], '_isType.sling.common.ExpressionNode')
												if expr ~= nil then
													if not first then
														do self:output(", ") end
													end
													first = false
													do self:dumpExpression(expr, nil, false) end
												end
												do n2 = n2 + 1 end
											end
										end
									end
								end
							end
						elseif (_vm:to_table_with_key(cbnn, '_isType.sling.model.CaseDefaultBlockNode') ~= nil) then
							do self:output("default") end
						end
						if xpr ~= nil then
							do self:dumpExpression(xpr, nil, false) end
						end
						do self:output(" {\n") end
						do
							local block = cbnn:getBlock()
							if not (block ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null block", cbnn, _g.jk.lang.StackTrace:generate()))
							end
							do self:dumpStatementContainer(block) end
							do self:output("}\n") end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do self:output("}\n") end
	end
end

function sling.syntax.SlingGenerator:dumpEnumValue(node)
	if not (node ~= nil) then
		do return end
	end
	do self:output(node:getName()) end
	do
		local value = node:getValue()
		if value ~= nil then
			do self:output(" = ") end
			do self:dumpExpression(value, nil, false) end
		end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpVariableDeclarationStatement(node, outputNL, isAssert, errorBlock)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null variable declaration statement", nil, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("var ") end
	do self:dumpVariableDeclaration(node, nil, isAssert, errorBlock) end
	if outputNL then
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpMultipleVariableDeclarationStatement(node, outputNL, isAssert, errorBlock)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null variable declaration statement", nil, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("var ") end
	do
		local variables = node:getVariables()
		local isFirst = true
		if variables ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(variables)
			do
				n = 0
				while n < m do
					local variable = _vm:to_table_with_key(variables[n + 1], '_isType.sling.model.VariableDeclarationNode')
					if variable ~= nil then
						if not isFirst then
							do self:output(", ") end
						end
						do self:dumpVariableDeclaration(variable, nil, isAssert, errorBlock) end
						isFirst = false
					end
					do n = n + 1 end
				end
			end
		end
		do
			local init = node:getInitializer()
			if init ~= nil then
				do self:output(" = ") end
				do self:dumpExpression(init, nil, false) end
			end
			if outputNL then
				do self:output("\n") end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpHeaderVariableDeclaration(node, isTopLevel)
	local name = nil
	if isTopLevel then
		name = _g.sling.util.NodeUtil:getQualifiedNameString(node, 46)
	else
		name = node:getNodeName()
	end
	if not (name ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable declaration has no name", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("var ") end
	do self:output(name) end
	do self:dumpCommonModifiers(node, nil) end
	do
		local type = node:getType()
		if not (type ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
			type = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(node:getInitializer(), nil)
			if not (type ~= nil) then
				type = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
			end
		end
		do self:output(" as ") end
		do self:dumpDataType(type) end
		do self:dumpCustomModifiers(node, nil) end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpVariableDeclaration(node, excludeModifiers, isAssert, errorBlock)
	local name = node:getNodeName()
	if not (name ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable declaration has no name", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output(name) end
	do self:dumpCommonModifiers(node, excludeModifiers) end
	do
		local init = node:getInitializer()
		local type = node:getType()
		local isDefaultType = false
		if type ~= nil and (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
			isDefaultType = true
		elseif type ~= nil and (_vm:to_table_with_key(type, '_isType.sling.model.DynamicDataTypeNode') ~= nil) and not (init ~= nil) then
			isDefaultType = true
		end
		if type ~= nil and isDefaultType == false then
			do self:output(" as ") end
			do self:dumpDataType(type) end
		end
		do self:dumpCustomModifiers(node, nil) end
		if init ~= nil then
			do self:output(" = ") end
			if isAssert then
				do self:output("assert ") end
			end
			do self:dumpExpression(init, nil, false) end
			if errorBlock ~= nil then
				do self:dumpControlStructureBlock(errorBlock) end
			end
		end
	end
end

function sling.syntax.SlingGenerator:getOperatorPrecedence(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.PostDecrementExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.PostIncrementExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.SubscriptExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
		do return 1 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreDecrementExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.PreIncrementExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.NegativeNumberExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseNotExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.StaticCastExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.DynamicCastExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.GetExpressionTypeinfoExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.GetDatatypeTypeinfoExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.GetSizeExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.DataTypeDefaultValueExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.AwaitExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.PromiseExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.GetAddressExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.GetReferenceExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.GetValueExpressionNode') ~= nil) then
		do return 2 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultiplicationExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.DivisionExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.ModuloExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.RangeExpressionNode') ~= nil) then
		do return 3 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AdditionExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.SubtractionExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.StringConcatenationExpressionNode') ~= nil) then
		do return 4 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ShiftLeftExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.ShiftRightExpressionNode') ~= nil) then
		do return 5 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AllocateBufferExpressionNode') ~= nil) then
		do return 6 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ComparisonExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.TypeCheckExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.MembershipCheckExpressionNode') ~= nil) then
		do return 7 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EqualsExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.NotEqualsExpressionNode') ~= nil) then
		do return 8 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseAndExpressionNode') ~= nil) then
		do return 9 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseXorExpressionNode') ~= nil) then
		do return 10 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseOrExpressionNode') ~= nil) then
		do return 11 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalAndExpressionNode') ~= nil) then
		do return 12 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalOrExpressionNode') ~= nil) then
		do return 13 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ConditionalExpressionNode') ~= nil) then
		do return 14 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AssignmentExpressionBaseNode') ~= nil) then
		do return 15 end
	end
	do return 0 end
end

function sling.syntax.SlingGenerator:isLowerPriority(node, parent, isRvalue)
	if not (parent ~= nil) then
		do return false end
	end
	if isRvalue then
		if self:getOperatorPrecedence(node) >= self:getOperatorPrecedence(parent) then
			do return true end
		end
	elseif self:getOperatorPrecedence(node) > self:getOperatorPrecedence(parent) then
		do return true end
	end
	do return false end
end

function sling.syntax.SlingGenerator:dumpExpression(node, parent, isRvalue)
	local lower = self:isLowerPriority(node, parent, isRvalue)
	if lower then
		do self:output("(") end
	end
	do self:doDumpExpression(node, parent) end
	if lower then
		do self:output(")") end
	end
end

function sling.syntax.SlingGenerator:dumpLongString(value)
	if not (value ~= nil) then
		do return end
	end
	do self:output("[[\n") end
	do
		local indent = self:getCurrentIndent()
		local array = _g.jk.lang.String:split(value, 10, 0)
		if array ~= nil then
			local n2 = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n2 = 0
				while n2 < m do
					local line = array[n2 + 1]
					if line ~= nil then
						do
							local n = 0
							while n < indent do
								do self:outputDirect("\t") end
								do n = n + 1 end
							end
						end
						do self:outputDirect(line) end
						do self:outputDirect("\n") end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do self:output("]]") end
	end
end

function sling.syntax.SlingGenerator:dumpMemberAccessExpression(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null node for member access expression", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local parent = node:getParentExpression()
		if not (parent ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null parent expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(parent, node, false) end
		do
			local p = node:getChildExpression()
			if not (p ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null child expression", node, _g.jk.lang.StackTrace:generate()))
			end
			if (_vm:to_table_with_key(p, '_isType.sling.model.CreateObjectExpressionNode') ~= nil) or (_vm:to_table_with_key(p, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) and (_vm:to_table_with_key(parent, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
				do self:output("\n") end
				do self:output("\t") end
			end
			do self:output(".") end
			do self:dumpExpression(p, node, false) end
		end
	end
end

function sling.syntax.SlingGenerator:dumpComparisonOperator(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.EqualsExpressionNode') ~= nil) then
		do self:output("==") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringEqualsExpressionNode') ~= nil) then
		do self:output("==") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NotEqualsExpressionNode') ~= nil) then
		do self:output("!=") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LessThanExpressionNode') ~= nil) then
		do self:output("<") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LessOrEqualExpressionNode') ~= nil) then
		do self:output("<=") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GreaterThanExpressionNode') ~= nil) then
		do self:output(">") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GreaterOrEqualExpressionNode') ~= nil) then
		do self:output(">=") end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported comparison operator expression type: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", node, _g.jk.lang.StackTrace:generate()))
end

function sling.syntax.SlingGenerator:dumpArrayLiteral(node, open, close, allowType)
	if not (node ~= nil) then
		do return end
	end
	do self:output(open) end
	if allowType then
		local type = node:getType()
		if type ~= nil then
			do self:dumpDataType(type) end
			do self:output(":") end
		end
	end
	do
		local xprs = node:getExpressions()
		local sz = _g.jk.lang.Vector:getSize(xprs)
		if sz < 1 then
			do self:output(close) end
			do return end
		end
		if sz == 1 then
			do self:output(" ") end
			do self:dumpExpression(_vm:to_table_with_key(_g.jk.lang.Vector:get(xprs, 0), '_isType.sling.common.ExpressionNode'), nil, false) end
			do self:output(" " .. _g.jk.lang.String:safeString(close)) end
			do return end
		end
		do self:output("\n") end
		do self:adjustIndent(1) end
		do
			local first = true
			if xprs ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(xprs)
				do
					n = 0
					while n < m do
						local xpr = _vm:to_table_with_key(xprs[n + 1], '_isType.sling.common.ExpressionNode')
						if xpr ~= nil then
							if first == false then
								do self:output(",\n") end
							end
							do self:dumpExpression(xpr, nil, false) end
							first = false
						end
						do n = n + 1 end
					end
				end
			end
			do self:output("\n") end
			do self:output(close) end
		end
	end
end

function sling.syntax.SlingGenerator:shouldDumpAbsoluteSymbol(symbol)
	if not (symbol ~= nil) then
		do return true end
	end
	do
		local pp = _vm:to_table_with_key(symbol:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return true end
		end
		if pp:getChildExpression() == symbol then
			do return false end
		end
		if pp:getParentExpression() == symbol and (_vm:to_table_with_key(pp:getParent(), '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			do return false end
		end
		do return true end
	end
end

function sling.syntax.SlingGenerator:doDumpExpression(node, parent)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null node for expression node", nil, _g.jk.lang.StackTrace:generate()))
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NullLiteralExpressionNode') ~= nil) then
		do self:output("null") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BooleanLiteralExpressionNode') ~= nil) then
		local vv = node:getValue()
		if vv then
			do self:output("true") end
		else
			do self:output("false") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringLiteralExpressionNode') ~= nil) then
		local slit = node
		if slit:getIsLongString() then
			do self:dumpLongString(slit:getValue()) end
		else
			do self:output("\"" .. _g.jk.lang.String:safeString(_g.sling.common.CodeStringUtil:escapeStringLiteralCStyle(slit:getValue())) .. "\"") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CharacterLiteralExpressionNode') ~= nil) then
		local cc = node:getValue()
		if cc == 39 then
			do self:output("'\\''") end
		elseif cc == 0 then
			do self:output("'\\0'") end
		elseif cc == 7 then
			do self:output("'\\a'") end
		elseif cc == 8 then
			do self:output("'\\b'") end
		elseif cc == 12 then
			do self:output("'\\f'") end
		elseif cc == 10 then
			do self:output("'\\n'") end
		elseif cc == 13 then
			do self:output("'\\r'") end
		elseif cc == 9 then
			do self:output("'\\t'") end
		elseif cc == 11 then
			do self:output("'\\v'") end
		elseif cc == 92 then
			do self:output("'\\\\'") end
		elseif cc == 34 then
			do self:output("'\"'") end
		else
			do self:output("'" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forCharacter(cc)) .. "'") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.IntegerLiteralExpressionNode') ~= nil) then
		local ilen = node
		local type = ilen:getType()
		local frmt = ilen:getFormat()
		if frmt == _g.sling.model.IntegerLiteralExpressionNode.FORMAT_HEXADECIMAL then
			do self:output("0x" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forIntegerHex(ilen:getValue(), 0))) end
		else
			local v = _g.jk.lang.String:forInteger(ilen:getValue())
			if type == _g.sling.model.IntegerDataTypeNode.TYPE_ULONG or type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT64 then
				v = _g.jk.lang.String:safeString(v) .. "L"
			end
			do self:output(v) end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DoubleLiteralExpressionNode') ~= nil) then
		local dl = node
		do self:output(_g.jk.lang.String:forDouble(dl:getValue())) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DecimalLiteralExpressionNode') ~= nil) then
		local dl = node
		do self:output(dl:getValue()) end
		do self:output("M") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FloatLiteralExpressionNode') ~= nil) then
		local dl = node
		local v = _g.jk.lang.String:forFloat(dl:getValue())
		if _g.jk.lang.String:getIndexOfCharacter(v, 46, 0) < 0 then
			v = _g.jk.lang.String:safeString(v) .. ".0"
		end
		do self:output(_g.jk.lang.String:safeString(v) .. "f") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreprocessorValueExpressionNode') ~= nil) then
		do self:output("VALUE \"") end
		do self:output(node:getVariable()) end
		do self:output("\"") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
		do self:output("base") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CurrentObjectExpressionNode') ~= nil) then
		do self:output("this") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
		local snode = node
		local ss = snode:getSymbol()
		if not (ss ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No symbol", snode, _g.jk.lang.StackTrace:generate()))
		end
		if ss:hasModifier(_g.sling.model.Modifier.GLOBAL) then
			do self:output("::") end
		end
		do self:dumpSymbol(ss, self:shouldDumpAbsoluteSymbol(node)) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
		local mc = node
		local expr = mc:getExpression()
		if not (expr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null child expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local tprm = mc:getTrailingParameter()
			do self:dumpExpression(expr, node, false) end
			do self:output("(") end
			do
				local first = true
				local array = mc:getParameters()
				if array ~= nil then
					local n2 = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n2 = 0
						while n2 < m do
							local param = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.ExpressionNode')
							if param ~= nil then
								if first == false then
									do self:output(", ") end
								end
								first = false
								do self:dumpExpression(param, nil, false) end
							end
							do n2 = n2 + 1 end
						end
					end
				end
				if tprm ~= nil then
					local fxpr = _vm:to_table_with_key(tprm, '_isType.sling.model.FunctionDeclarationExpressionNode')
					if not (fxpr ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("trailing parameter is not a function declaration expression", tprm, _g.jk.lang.StackTrace:generate()))
					end
					do
						local fdec = fxpr:getDeclaration()
						if not (fdec ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("no function declaration for function declaration expression", fxpr, _g.jk.lang.StackTrace:generate()))
						end
						do self:output(") ") end
						do self:dumpFunctionDeclaration(fdec, true) end
					end
				else
					do self:output(")") end
				end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
		do self:dumpMemberAccessExpression(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CreateObjectExpressionNode') ~= nil) then
		local oc = node
		do self:output("new ") end
		do
			local type = oc:getType()
			local typeExpr = oc:getTypeExpression()
			if type ~= nil then
				do self:dumpDataType(type) end
			elseif typeExpr ~= nil then
				do self:dumpExpression(typeExpr, nil, false) end
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Create object expression has no data type", oc, _g.jk.lang.StackTrace:generate()))
			end
			do
				local params = oc:getParameters()
				local opened = false
				if params ~= nil or (_vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.ThisDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.ParentDataTypeNode') ~= nil) then
					do self:output("(") end
					opened = true
				end
				if params ~= nil then
					local first = true
					if params ~= nil then
						local n3 = 0
						local m2 = _g.jk.lang.Vector:getSize(params)
						do
							n3 = 0
							while n3 < m2 do
								local param = _vm:to_table_with_key(params[n3 + 1], '_isType.sling.common.ExpressionNode')
								if param ~= nil then
									if first == false then
										do self:output(", ") end
									end
									first = false
									do self:dumpExpression(param, nil, false) end
								end
								do n3 = n3 + 1 end
							end
						end
					end
				end
				if opened then
					do self:output(")") end
				end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AssignmentExpressionBaseNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(left, node, false) end
		if (_vm:to_table_with_key(ae, '_isType.sling.model.AssignmentExpressionNode') ~= nil) then
			do self:output(" = ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.AdditionAssignmentExpressionNode') ~= nil) then
			do self:output(" += ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.SubtractionAssignmentExpressionNode') ~= nil) then
			do self:output(" -= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.BitwiseOrAssignmentExpressionNode') ~= nil) then
			do self:output(" |= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.BitwiseAndAssignmentExpressionNode') ~= nil) then
			do self:output(" &= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.BitwiseXorAssignmentExpressionNode') ~= nil) then
			do self:output(" ^= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.DivisionAssignmentExpressionNode') ~= nil) then
			do self:output(" /= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.MultiplicationAssignmentExpressionNode') ~= nil) then
			do self:output(" *= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.ModuloAssignmentExpressionNode') ~= nil) then
			do self:output(" %= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.ShiftLeftAssignmentExpressionNode') ~= nil) then
			do self:output(" <<= ") end
		elseif (_vm:to_table_with_key(ae, '_isType.sling.model.ShiftRightAssignmentExpressionNode') ~= nil) then
			do self:output(" >>= ") end
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported assignment expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local rr = ae:getRight()
			if not (rr ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(rr, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BufferLiteralExpressionNode') ~= nil) then
		local bval = node:getValue()
		local size = _g.jk.lang.Buffer:getSize(bval)
		local newl = false
		if size > 10 then
			newl = true
			do self:output("new buffer {\n") end
		else
			do self:output("new buffer {") end
		end
		do
			local c = 1
			local i = 0
			while true do
				if i >= size then
					do break end
				end
				if i > 0 then
					do self:output(",") end
				end
				if c <= 10 then
					if i > 0 then
						do self:output(" ") end
					end
				else
					do self:output("\n") end
					c = 0
				end
				do
					local b = _g.jk.lang.String:forIntegerHex(_g.jk.lang.Buffer:getByte(bval, i), 0)
					if _g.jk.lang.String:getLength(b) < 2 then
						b = "0" .. _g.jk.lang.String:safeString(b)
					end
					do self:output("0x" .. _g.jk.lang.String:safeString(b)) end
					do c = c + 1 end
					do i = i + 1 end
				end
			end
			if newl then
				do self:output("\n") end
			end
			do self:output("}") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MapLiteralExpressionNode') ~= nil) then
		local vals = node:getValues()
		if vals == nil or _g.jk.lang.Vector:getSize(vals) < 1 then
			do self:output("new map {") end
		else
			do self:output("new map {\n") end
		end
		do
			local first = true
			if vals ~= nil then
				local n4 = 0
				local m3 = _g.jk.lang.Vector:getSize(vals)
				do
					n4 = 0
					while n4 < m3 do
						local val = _vm:to_table_with_key(vals[n4 + 1], '_isType.sling.model.KeyValueNode')
						if val ~= nil then
							if first == false then
								do self:output(",\n") end
							end
							first = false
							do
								local key = val:getKey()
								if not (key ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null key", val, _g.jk.lang.StackTrace:generate()))
								end
								do self:dumpExpression(key, nil, false) end
								do self:output(" : ") end
								do
									local value = val:getValue()
									if not (value ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null value", val, _g.jk.lang.StackTrace:generate()))
									end
									do self:dumpExpression(value, nil, false) end
								end
							end
						end
						do n4 = n4 + 1 end
					end
				end
			end
			if first == false then
				do self:output("\n") end
			end
			do self:output("}") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SetLiteralExpressionNode') ~= nil) then
		local vals = node:getValues()
		do self:output("new set {") end
		do
			local multiline = false
			if vals ~= nil and _g.jk.lang.Vector:getSize(vals) > 6 then
				multiline = true
			end
			if multiline then
				do self:output("\n") end
			end
			do
				local n = 0
				if vals ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(vals)
					do
						n5 = 0
						while n5 < m4 do
							local val = _vm:to_table_with_key(vals[n5 + 1], '_isType.sling.common.ExpressionNode')
							if val ~= nil then
								if n == 0 then
									do self:output(" ") end
								elseif multiline and _util:convert_to_integer(n % 6) == 0 then
									do self:output(",\n") end
								else
									do self:output(", ") end
								end
								do self:dumpExpression(val, nil, false) end
								do n = n + 1 end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				if multiline then
					do self:output("\n") end
				else
					do self:output(" ") end
				end
				do self:output("}") end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TypeCheckExpressionNode') ~= nil) then
		local dc = node
		local xp = dc:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", dc, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xp, node, false) end
		do self:output(" is ") end
		do
			local dt = dc:getType()
			if not (dt ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type", dc, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpDataType(dt) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MembershipCheckExpressionNode') ~= nil) then
		local dc = node
		local left = dc:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", dc, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(left, node, false) end
		do self:output(" in ") end
		do
			local right = dc:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type", dc, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(right, node, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SubscriptExpressionNode') ~= nil) then
		local n = node
		local xp = n:getChild()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null child", n, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xp, node, false) end
		do self:output("[") end
		do
			local ss = n:getSubscript()
			if not (ss ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null subscript", n, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(ss, nil, false) end
			do self:output("]") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ComparisonExpressionNode') ~= nil) then
		local ce = node
		local left = ce:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", ce, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ce:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", ce, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" ") end
			do self:dumpComparisonOperator(ce) end
			do self:output(" ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AdditionExpressionNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ae:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" + ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TupleExpressionNode') ~= nil) then
		do self:output("(") end
		do
			local first = true
			local array2 = node:getExpressions()
			if array2 ~= nil then
				local n6 = 0
				local m5 = _g.jk.lang.Vector:getSize(array2)
				do
					n6 = 0
					while n6 < m5 do
						local xpr = _vm:to_table_with_key(array2[n6 + 1], '_isType.sling.common.ExpressionNode')
						if xpr ~= nil then
							if not first then
								do self:output(", ") end
							end
							first = false
							do self:dumpExpression(xpr, nil, false) end
						end
						do n6 = n6 + 1 end
					end
				end
			end
			do self:output(")") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultipleExpressionNode') ~= nil) then
		local exps = node:getExpressions()
		if _g.jk.lang.Vector:isEmpty(exps) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple expression is empty", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local first = true
			if exps ~= nil then
				local n7 = 0
				local m6 = _g.jk.lang.Vector:getSize(exps)
				do
					n7 = 0
					while n7 < m6 do
						local expr = _vm:to_table_with_key(exps[n7 + 1], '_isType.sling.common.ExpressionNode')
						if expr ~= nil then
							if not first then
								do self:output(", ") end
							end
							first = false
							do self:dumpExpression(expr, nil, false) end
						end
						do n7 = n7 + 1 end
					end
				end
			end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationExpressionNode') ~= nil) then
		local vdec = node:getDeclaration()
		if not (vdec ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable declaration expression has no declaration", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("var ") end
		do self:dumpVariableDeclaration(vdec, nil, false, nil) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.RangeExpressionNode') ~= nil) then
		local rnge = node
		local from = rnge:getLowerBound()
		if not (from ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Range has no from expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local to = rnge:getUpperBound()
			if not (to ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Range has no to expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(from, node, false) end
			do
				local type = rnge:getExclusionType()
				if type == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS then
					do self:output(">.<") end
				elseif type == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND then
					do self:output("..<") end
				elseif type == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND then
					do self:output(">..") end
				else
					do self:output("...") end
				end
				do self:dumpExpression(to, node, false) end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NamedParameterExpressionNode') ~= nil) then
		local np = node
		do self:output(np:getName()) end
		do self:output(":") end
		do self:dumpExpression(np:getValue(), nil, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringConcatenationExpressionNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ae:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" .. ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmptyExpressionNode') ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) then
		do self:output("not ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationExpressionNode') ~= nil) then
		local _function = node:getDeclaration()
		if not (_function ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null function", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpFunctionDeclaration(_function, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalExpressionNode') ~= nil) then
		local le = node
		local left = le:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", le, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = le:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", le, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			if (_vm:to_table_with_key(le, '_isType.sling.model.LogicalAndExpressionNode') ~= nil) then
				do self:output(" && ") end
			elseif (_vm:to_table_with_key(le, '_isType.sling.model.LogicalOrExpressionNode') ~= nil) then
				do self:output(" || ") end
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown logical expression node type: `" .. _g.jk.lang.String:safeString(le:getNodeTypeName()) .. "'", le, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ArrayLiteralExpressionNode') ~= nil) then
		do self:dumpArrayLiteral(node, "[", "]", true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ConditionalExpressionNode') ~= nil) then
		local ce = node
		local cond = ce:getCondition()
		if not (cond ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", ce, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(cond, node, false) end
		do self:output(" ? ") end
		do
			local te = ce:getTrueExpr()
			if not (te ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null true expression", ce, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(te, node, false) end
			do self:output(" : ") end
			do
				local fe = ce:getFalseExpr()
				if not (fe ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null false expression", ce, _g.jk.lang.StackTrace:generate()))
				end
				do self:dumpExpression(fe, node, false) end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SubtractionExpressionNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ae:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" - ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AwaitExpressionNode') ~= nil) then
		do self:output("await ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null await expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetAddressExpressionNode') ~= nil) then
		do self:output("addr ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetReferenceExpressionNode') ~= nil) then
		do self:output("ref ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetValueExpressionNode') ~= nil) then
		do self:output("val ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NegativeNumberExpressionNode') ~= nil) then
		do self:output("-") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultiplicationExpressionNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ae:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" * ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DivisionExpressionNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ae:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" / ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ModuloExpressionNode') ~= nil) then
		local ae = node
		local left = ae:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", ae, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = ae:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", ae, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" % ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmbedBlockNode') ~= nil) then
		do self:dumpEmbedBlock(node, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ArrayCreationExpressionNode') ~= nil) then
		local ac = node
		local inits = ac:getDimensions()
		if _g.jk.lang.Vector:isEmpty(inits) then
			inits = {}
			do _g.jk.lang.Vector:append(inits, _g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())) end
		end
		do
			local lit = ac:getArrayLiteral()
			do self:output("new ") end
			do
				local dt = ac:getPrimaryType()
				if not (dt ~= nil) then
					dt = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
				end
				do self:dumpDataType(dt) end
				if inits ~= nil then
					local n8 = 0
					local m7 = _g.jk.lang.Vector:getSize(inits)
					do
						n8 = 0
						while n8 < m7 do
							local init = _vm:to_table_with_key(inits[n8 + 1], '_isType.sling.common.ExpressionNode')
							if init ~= nil then
								do self:output("[") end
								do self:dumpExpression(init, nil, false) end
								do self:output("]") end
							end
							do n8 = n8 + 1 end
						end
					end
				end
				if lit ~= nil then
					do self:output(" ") end
					do self:dumpArrayLiteral(lit, "{", "}", false) end
				end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DynamicCastExpressionNode') ~= nil) then
		local dc = node
		local xp = dc:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", dc, _g.jk.lang.StackTrace:generate()))
		end
		do
			local type = dc:getType()
			if not (type ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type", dc, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, false) end
			do self:output(" as ") end
			do self:dumpDataType(type) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StaticCastExpressionNode') ~= nil) then
		local sc = node
		local dns = sc:getType()
		if not (dns ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type", sc, _g.jk.lang.StackTrace:generate()))
		end
		do
			local xp = sc:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", sc, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, false) end
			if (_vm:to_table_with_key(dns, '_isType.sling.model.PrimitiveDataTypeNode') ~= nil) then
				do self:output(" as ") end
			else
				do self:output(" as! ") end
			end
			do self:dumpDataType(dns) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseAndExpressionNode') ~= nil) then
		local be = node
		local left = be:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", be, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = be:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", be, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" & ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseOrExpressionNode') ~= nil) then
		local be = node
		local left = be:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", be, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = be:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", be, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" | ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseXorExpressionNode') ~= nil) then
		local be = node
		local left = be:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", be, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = be:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", be, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" ^ ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ShiftLeftExpressionNode') ~= nil) then
		local be = node
		local left = be:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", be, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = be:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", be, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" << ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ShiftRightExpressionNode') ~= nil) then
		local be = node
		local left = be:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left expression", be, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = be:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right expression", be, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" >> ") end
			do self:dumpExpression(right, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseNotExpressionNode') ~= nil) then
		do self:output("~") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, node, true) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetSizeExpressionNode') ~= nil) then
		do self:output("sizeof ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, nil, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreIncrementExpressionNode') ~= nil) then
		local xp = node:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("++") end
		do self:dumpExpression(xp, node, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreDecrementExpressionNode') ~= nil) then
		local xp = node:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("--") end
		do self:dumpExpression(xp, node, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PostIncrementExpressionNode') ~= nil) then
		local xp = node:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xp, node, false) end
		do self:output("++") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PostDecrementExpressionNode') ~= nil) then
		local xp = node:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xp, node, false) end
		do self:output("--") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AllocateBufferExpressionNode') ~= nil) then
		do self:output("malloc ") end
		do self:dumpExpression(node:getExpression(), nil, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FailureLiteralExpressionNode') ~= nil) then
		do self:output("fail") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AppendToVectorExpressionNode') ~= nil) then
		do self:dumpExpression(node:getLeft(), node, false) end
		do self:output(" += ") end
		do self:dumpExpression(node:getRight(), node, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DataTypeDefaultValueExpressionNode') ~= nil) then
		do self:output("defaultvalue ") end
		do
			local dt = node:getType()
			if not (dt ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No type", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpDataType(dt) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FileSystemReferenceExpressionNode') ~= nil) then
		local nsr = node
		if (_vm:to_table_with_key(node, '_isType.sling.model.FileSystemDirectoryReferenceExpressionNode') ~= nil) then
			do self:output("DIRECTORY ") end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.FileSystemBinaryFileReferenceExpressionNode') ~= nil) then
			do self:output("FILE ") end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.FileSystemTextFileReferenceExpressionNode') ~= nil) then
			do self:output("TEXTFILE ") end
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "filesystem reference expression" .. "'", node, nil))
		end
		do self:dumpExpression(_g.sling.model.StringLiteralExpressionNode:forValue(nsr:getName()), nil, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetExpressionTypeinfoExpressionNode') ~= nil) then
		do self:output("typeof ") end
		do
			local xp = node:getExpression()
			if not (xp ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xp, nil, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetDatatypeTypeinfoExpressionNode') ~= nil) then
		do self:output("typeinfo ") end
		do
			local dt = node:getType()
			if not (dt ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No type", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpDataType(dt) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ForceUnwrapOptionalExpressionNode') ~= nil) then
		local xp = node:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression inside force unwrap optional expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xp, node, false) end
		do self:output("!") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SafeUnwrapOptionalExpressionNode') ~= nil) then
		local xp = node:getExpression()
		if not (xp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression inside force unwrap optional expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xp, node, false) end
		do self:output("?") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationInstantiationExpressionNode') ~= nil) then
		do self:dumpClassDeclarationInstantiationExpressionNode(node) end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "expression" .. "'", node, nil))
end

function sling.syntax.SlingGenerator:dumpClassDeclarationInstantiationExpressionNode(node)
	local cdec = node:getClassDeclaration()
	local params = node:getParameters()
	do self:output("new ") end
	do
		local basetypes = cdec:getBaseTypes()
		if _g.jk.lang.Vector:getSize(basetypes) > 1 then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple basetypes are not supported", node, _g.jk.lang.StackTrace:generate()))
		end
		if basetypes ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(basetypes)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(basetypes[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						do self:dumpDataType(basetype:getReferenceType()) end
					end
					do n = n + 1 end
				end
			end
		end
		if params ~= nil then
			do self:output("(") end
			do
				local first = true
				if params ~= nil then
					local n2 = 0
					local m2 = _g.jk.lang.Vector:getSize(params)
					do
						n2 = 0
						while n2 < m2 do
							local param = _vm:to_table_with_key(params[n2 + 1], '_isType.sling.common.ExpressionNode')
							if param ~= nil then
								if first == false then
									do self:output(", ") end
								end
								first = false
								do self:dumpExpression(param, nil, false) end
							end
							do n2 = n2 + 1 end
						end
					end
				end
				do self:output(")") end
			end
		end
		do self:output(" {\n") end
		do
			local array = cdec:getNodes()
			if array ~= nil then
				local n3 = 0
				local m3 = _g.jk.lang.Vector:getSize(array)
				do
					n3 = 0
					while n3 < m3 do
						local child = _vm:to_table_with_key(array[n3 + 1], '_isType.sling.common.NodeObject')
						if child ~= nil then
							do self:dumpNodeInContext(child, nil, _g.sling.syntax.SlingGenerator.CONTEXT_CLASS) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do self:output(" }") end
		end
	end
end

function sling.syntax.SlingGenerator:dumpIfStatement(node)
	local cond = node:getCondition()
	if not (cond ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
		do return end
	end
	do self:output("if ") end
	do self:dumpExpression(cond, nil, false) end
	do
		local ifBlock = node:getIfBlock()
		if not (ifBlock ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null ifBlock", node, _g.jk.lang.StackTrace:generate()))
			do return end
		end
		do self:dumpControlStructureBlock(ifBlock) end
		do
			local eb = node:getElseBlock()
			if eb ~= nil then
				local ebnodes = eb:getNodes()
				if ebnodes ~= nil and _g.jk.lang.Vector:getSize(ebnodes) == 1 and (_vm:to_table_with_key(_g.jk.lang.Vector:get(ebnodes, 0), '_isType.sling.model.IfStatementNode') ~= nil) then
					do self:output("else ") end
					do self:dumpStatementContainer(eb) end
				else
					do self:output("else") end
					do self:dumpControlStructureBlock(eb) end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpTryCatchStatement(node)
	local init = node:getInitializer()
	if init ~= nil then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Initializers in try-catch statements are not supported", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("try") end
	do self:dumpControlStructureBlock(node:getTryBlock()) end
	do
		local array = node:getCatchBlocks()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local catchBlock = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.CatchBlockNode')
					if catchBlock ~= nil then
						local block = catchBlock:getBlock()
						if not (block ~= nil) then
							block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
						end
						do self:output("catch") end
						do
							local first = true
							local array2 = catchBlock:getExceptions()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local exception = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
										if exception ~= nil then
											if first then
												do self:output(" ") end
											else
												do self:output(", ") end
											end
											first = false
											do self:dumpVariableDeclaration(exception, nil, false, nil) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
							do self:dumpControlStructureBlock(block) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local finally = node:getFinallyBlock()
			if finally ~= nil then
				do self:output("finally") end
				do self:dumpControlStructureBlock(finally) end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpWhileStatement(node)
	local cond = node:getCondition()
	if not (cond ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
		do return end
	end
	if (_vm:to_table_with_key(cond, '_isType.sling.model.BooleanLiteralExpressionNode') ~= nil) and cond:getValue() == true then
		do self:output("loop") end
	else
		do self:output("while ") end
		do self:dumpExpression(cond, nil, false) end
	end
	do self:dumpControlStructureBlock(node:getBlock()) end
	do
		local elseBlock = node:getElseBlock()
		if elseBlock ~= nil then
			do self:output("else") end
			do self:dumpControlStructureBlock(elseBlock) end
		end
	end
end

function sling.syntax.SlingGenerator:dumpDoWhileStatement(node)
	do self:output("do {\n") end
	do self:dumpStatementContainer(node:getBlock()) end
	do self:output("}\n") end
	do self:output("while ") end
	do
		local cond = node:getCondition()
		if not (cond ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(cond, nil, false) end
		do self:output("\n") end
	end
end

function sling.syntax.SlingGenerator:dumpPreprocessorIfStatement(node, isElif, context)
	if not (node ~= nil) then
		do return end
	end
	do
		local condition = node:getCondition()
		if not (condition ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
		end
		if isElif then
			do self:output("ELSE ") end
		end
		if (_vm:to_table_with_key(condition, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) then
			do self:output("IFNDEF \"") end
			condition = condition:getExpression()
		else
			do self:output("IFDEF \"") end
		end
		do
			local ifdefCondition = _vm:to_table_with_key(condition, '_isType.sling.model.PreprocessorIsDefinedExpressionNode')
			if not (ifdefCondition ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Condition is not an ifdef condition: `" .. _g.jk.lang.String:safeString(condition:getNodeTypeName()) .. "'", condition, _g.jk.lang.StackTrace:generate()))
			end
			do self:output(ifdefCondition:getVariable()) end
			do self:output("\"") end
			if context == _g.sling.syntax.SlingGenerator.CONTEXT_CLASS or context == _g.sling.syntax.SlingGenerator.CONTEXT_INTERFACE or context == _g.sling.syntax.SlingGenerator.CONTEXT_NAMESPACE then
				do self:output("\n{\n") end
			else
				do self:output(" {\n") end
			end
			do
				local ifBlock = node:getIfBlock()
				if ifBlock ~= nil then
					local prev = nil
					local array = ifBlock:getNodes()
					if array ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(array)
						do
							n = 0
							while n < m do
								local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
								if nn ~= nil then
									do self:dumpNodeInContext(nn, prev, context) end
									prev = nn
								end
								do n = n + 1 end
							end
						end
					end
				end
				do self:output("}\n") end
				do
					local elseBlock = node:getElseBlock()
					if elseBlock ~= nil then
						local enodes = elseBlock:getNodes()
						if enodes ~= nil and _g.jk.lang.Vector:getSize(enodes) == 1 then
							local pp = _vm:to_table_with_key(_g.jk.lang.Vector:get(enodes, 0), '_isType.sling.model.PreprocessorIfStatementNode')
							if pp ~= nil then
								do self:dumpPreprocessorIfStatement(pp, true, context) end
								do return end
							end
						end
						do self:output("ELSE") end
						do self:output(" {\n") end
						do
							local prev2 = nil
							local array2 = elseBlock:getNodes()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local nn = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
										if nn ~= nil then
											do self:dumpNodeInContext(nn, prev2, context) end
											prev2 = nn
										end
										do n2 = n2 + 1 end
									end
								end
							end
							do self:output("}\n") end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpUIExpressionContents(node)
	local array = node:getChildren()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
				if child ~= nil then
					if (_vm:to_table_with_key(child, '_isType.sling.model.UIExpressionNode') ~= nil) then
						local cc = child
						local dt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(cc, nil)
						if dt ~= nil then
							do self:dumpDataType(dt) end
						else
							local xpr = cc:getExpression()
							if not (xpr ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Neither data type nor expression is set. Don't know what to do.", nil, _g.jk.lang.StackTrace:generate()))
							end
							do self:dumpExpression(xpr, nil, false) end
						end
						do
							local name = cc:getName()
							if _g.jk.lang.String:isNotEmpty(name) then
								do self:output(" " .. _g.jk.lang.String:safeString(name)) end
							end
							do
								local lps = cc:getLayoutParams()
								if lps ~= nil and _g.jk.lang.Vector:getSize(lps) > 0 then
									do self:output(" : ") end
									do
										local first = true
										if lps ~= nil then
											local n2 = 0
											local m2 = _g.jk.lang.Vector:getSize(lps)
											do
												n2 = 0
												while n2 < m2 do
													local xpr = _vm:to_table_with_key(lps[n2 + 1], '_isType.sling.common.ExpressionNode')
													if xpr ~= nil then
														if first == false then
															do self:output(", ") end
														end
														do self:dumpExpression(xpr, nil, false) end
														first = false
													end
													do n2 = n2 + 1 end
												end
											end
										end
									end
								end
								do self:output(" {\n") end
								do self:dumpUIExpressionContents(cc) end
								do self:output("}\n") end
							end
						end
					elseif (_vm:to_table_with_key(child, '_isType.sling.model.PropertyValueDeclarationNode') ~= nil) then
						local pdec = child
						local pkey = pdec:getKey()
						if _g.jk.lang.String:isEmpty(pkey) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("UI expression property has no name", pdec, _g.jk.lang.StackTrace:generate()))
						end
						do
							local pval = pdec:getValue()
							if not (pval ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("UI expression property has no value", pdec, _g.jk.lang.StackTrace:generate()))
							end
							do self:output(pkey) end
							do self:dumpCustomModifiers(child, nil) end
							do self:output(" = ") end
							do self:dumpExpression(pval, nil, false) end
							do self:output("\n") end
						end
					else
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. child:getNodeTypeName() .. "' in context `" .. "ui expression" .. "'", child, nil))
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.syntax.SlingGenerator:dumpUIExpressionNodeInClass(node)
	do self:output("ui") end
	do
		local dt = node:getDefaultDataType()
		if dt ~= nil then
			do self:output(" ") end
			do self:dumpDataType(dt) end
		end
		do self:output("\n") end
		do self:output("{\n") end
		do self:dumpUIExpressionContents(node) end
		do self:output("}\n") end
	end
end

function sling.syntax.SlingGenerator:getExcludeComments()
	do return self.excludeComments end
end

function sling.syntax.SlingGenerator:setExcludeComments(v)
	self.excludeComments = v
	do return self end
end

function sling.syntax.SlingGenerator:getCurrentIndent()
	do return self.currentIndent end
end

function sling.syntax.SlingGenerator:setCurrentIndent(v)
	self.currentIndent = v
	do return self end
end

function sling.syntax.SlingGenerator:getCopyrightDeclaration()
	do return self.copyrightDeclaration end
end

function sling.syntax.SlingGenerator:setCopyrightDeclaration(v)
	self.copyrightDeclaration = v
	do return self end
end

function sling.syntax.SlingGenerator:getHangingBraces()
	do return self.hangingBraces end
end

function sling.syntax.SlingGenerator:setHangingBraces(v)
	self.hangingBraces = v
	do return self end
end

function sling.syntax.SlingGenerator:getInsertSpaceAfterKeywords()
	do return self.insertSpaceAfterKeywords end
end

function sling.syntax.SlingGenerator:setInsertSpaceAfterKeywords(v)
	self.insertSpaceAfterKeywords = v
	do return self end
end

sling.syntax.SlingParser = _g.sling.common.CodeParser._create()
sling.syntax.SlingParser.__index = sling.syntax.SlingParser
_vm:set_metatable(sling.syntax.SlingParser, {
	__index = _g.sling.common.CodeParser
})

sling.syntax.SlingParser.NODECONTEXT_ENTITY = 0
sling.syntax.SlingParser.NODECONTEXT_NAMESPACE = 1
sling.syntax.SlingParser.NODECONTEXT_STATEMENTBLOCK = 2

function sling.syntax.SlingParser._create()
	local v = _vm:set_metatable({}, sling.syntax.SlingParser)
	return v
end

function sling.syntax.SlingParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.syntax.SlingParser'
	self['_isType.sling.syntax.SlingParser'] = true
	self.allowCustomEntityNamespaces = true
	self.currentEntityName = nil
	self.showFixmeWarnings = false
	self.acceptDeprecatedConstructs = true
	self.isMacro = false
	self.isGenericTypeParameter = false
	self.reservedWords = nil
	self.entityStack = nil
	self.acceptNewlinesAsSpaces = false
end

function sling.syntax.SlingParser:_construct0()
	sling.syntax.SlingParser._init(self)
	do _g.sling.common.CodeParser._construct0(self) end
	do self:setImproperCommentPolicy(_g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_WARN_IGNORE) end
	return self
end

function sling.syntax.SlingParser:getReservedWords()
	if not (self.reservedWords ~= nil) then
		self.reservedWords = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
		do self.reservedWords:add("true") end
		do self.reservedWords:add("false") end
		do self.reservedWords:add("null") end
		do self.reservedWords:add("fail") end
		do self.reservedWords:add("this") end
		do self.reservedWords:add("base") end
		if self.acceptDeprecatedConstructs then
			do self.reservedWords:add("PRINT") end
			do self.reservedWords:add("return") end
			do self.reservedWords:add("TYPEINFO") end
			do self.reservedWords:add("MALLOC") end
			do self.reservedWords:add("SIZE") end
		end
	end
	do return self.reservedWords end
end

function sling.syntax.SlingParser:isReservedWord(name)
	do return self:getReservedWords():contains(name) end
end

function sling.syntax.SlingParser:doAcceptNewlineToken(acceptSeveral)
	local nl = self:acceptToken2(10)
	if nl ~= nil then
		if acceptSeveral then
			while true do
				local el = self:acceptToken2(10)
				if el ~= nil then
					do self:onUnnecessaryEmptyLine(el) end
				else
					do break end
				end
			end
		end
		do return nl end
	end
	do return nil end
end

function sling.syntax.SlingParser:doParseNewlineToken(acceptSeveral)
	local v = self:doAcceptNewlineToken(acceptSeveral)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("newline"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:onUnnecessaryEmptyLine(token)
end

function sling.syntax.SlingParser:acceptUnnecessaryNewlineToken()
	local v = self:acceptNewlineToken()
	if v ~= nil then
		do self:onUnnecessaryEmptyLine(v) end
	end
	do return v end
end

function sling.syntax.SlingParser:acceptNewlineToken()
	do return self:doAcceptNewlineToken(false) end
end

function sling.syntax.SlingParser:parseNewlineToken()
	do return self:doParseNewlineToken(false) end
end

function sling.syntax.SlingParser:acceptMultipleNewlineTokens()
	do return self:doAcceptNewlineToken(true) end
end

function sling.syntax.SlingParser:isSpaceCharacter(n)
	if n == 32 or n == 9 or n == 13 then
		do return true end
	end
	if self.acceptNewlinesAsSpaces and n == 10 then
		do return true end
	end
	do return false end
end

function sling.syntax.SlingParser:isValidIdentifierPrefix(c)
	do return c == 95 or c == 126 or c == 36 or c == 64 or c == 35 or _g.jk.lang.Character:isAlpha(c) end
end

function sling.syntax.SlingParser:isValidIdentifierCharacter(c)
	do return c == 95 or c == 36 or c == 35 or _g.jk.lang.Character:isAlnum(c) end
end

function sling.syntax.SlingParser:isValidIdentifier(t)
	if not _g.sling.common.CodeParser.isValidIdentifier(self, t) then
		do return false end
	end
	if t == "~" then
		do return false end
	end
	do return true end
end

function sling.syntax.SlingParser:acceptDocumentationCommentToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 42 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 42 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					do
						local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						do sb:appendCharacter(c0) end
						do sb:appendCharacter(c1) end
						while true do
							local cn = self:getNextCharacter()
							if cn < 1 then
								do break end
							end
							if cn == 10 then
								do break end
							end
							do sb:appendCharacter(cn) end
						end
						do
							local ids = sb:toString()
							local v = self.stagingToken
							self.stagingToken = nil
							do self:updateStagingToken() end
							v.line = ctl
							v.column = ctc
							v.position = ctp
							v.value = ids
							do self:onTokenAccepted(v) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptMultilineStringToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 91 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 91 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					while self:peekNextCharacter() == 13 do
						do self:getNextCharacter() end
					end
					do
						local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						do sb:appendCharacter(c0) end
						do sb:appendCharacter(c1) end
						do
							local pc = 0
							local nl = false
							local emptycount = -1
							local cc = 0
							local necc = 0
							if self:peekNextCharacter() == 10 then
								do self:getNextCharacter() end
								nl = true
							end
							while true do
								local cn = self:getNextCharacter()
								if cn < 1 then
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
									do return nil end
								end
								if cn == 13 then
									goto _continue10
								end
								if nl and (cn == 32 or cn == 9) then
									if emptycount < 0 or cc < emptycount then
										do cc = cc + 1 end
										goto _continue10
									end
								end
								do sb:appendCharacter(cn) end
								do necc = necc + 1 end
								if cn == 10 then
									nl = true
									if emptycount < 0 and necc > 1 then
										emptycount = cc
									end
									necc = 0
									cc = 0
								else
									nl = false
								end
								if pc == 93 and cn == 93 then
									do break end
								end
								pc = cn
								::_continue10::
							end
							do
								local ids = sb:toString()
								local v = self.stagingToken
								self.stagingToken = nil
								do self:updateStagingToken() end
								v.line = ctl
								v.column = ctc
								v.position = ctp
								v.value = ids
								do self:onTokenAccepted(v) end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptTripleBraceBlockToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 123 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 123 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					do
						local c2 = self:peekNextCharacter()
						if c2 ~= 123 then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do self:getNextCharacter() end
						do
							local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
							do sb:appendCharacter(c0) end
							do sb:appendCharacter(c1) end
							do sb:appendCharacter(c2) end
							do
								local cbc = 0
								while true do
									local cn = self:getNextCharacter()
									if cn < 1 then
										self.currentTokenColumn = ctc
										self.currentTokenLine = ctl
										do self.iterator:setCurrentPosition(ctp) end
										while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
											do self.commentQueue:pop() end
										end
										self.previousToken = cpt
										do return nil end
									end
									do sb:appendCharacter(cn) end
									if cn == 125 then
										do cbc = cbc + 1 end
										if cbc == 3 then
											do break end
										end
									else
										cbc = 0
									end
								end
								do
									local ids = sb:toString()
									local v = self.stagingToken
									self.stagingToken = nil
									do self:updateStagingToken() end
									v.line = ctl
									v.column = ctc
									v.position = ctp
									v.value = ids
									do self:onTokenAccepted(v) end
									do return v end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:pushEntity(entity)
	local ee = entity
	if not (ee ~= nil) then
		ee = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
	end
	if not (self.entityStack ~= nil) then
		self.entityStack = _g.jk.lang.Stack._construct0(_g.jk.lang.Stack._create())
	end
	do self.entityStack:push(ee) end
end

function sling.syntax.SlingParser:popEntity()
	if not (self.entityStack ~= nil) then
		do return nil end
	end
	do return self.entityStack:pop() end
end

function sling.syntax.SlingParser:peekEntity()
	if not (self.entityStack ~= nil) then
		do return nil end
	end
	do return self.entityStack:peek() end
end

function sling.syntax.SlingParser:validateForReservedWords(token)
	if not (token ~= nil) then
		do return end
	end
	if self:isReservedWord(token.value) then
		do self:onParseMessage(_g.sling.common.WarningMessage:forText("Identifier name `" .. _g.jk.lang.String:safeString(token.value) .. "' is used internally by the language. Rename your declaration to avoid conflicts.", token)) end
	end
end

function sling.syntax.SlingParser:acceptDeclarationIdentifier()
	local v = self:acceptIdentifierToken()
	if not (v ~= nil) then
		do return nil end
	end
	do self:validateForReservedWords(v) end
	do return v.value end
end

function sling.syntax.SlingParser:parseDeclarationIdentifier()
	local v = self:parseIdentifierToken()
	do self:validateForReservedWords(v) end
	do return v.value end
end

function sling.syntax.SlingParser:acceptEndOfStatementToken()
	local sc = self:acceptSemicolonToken()
	local nl = self:acceptNewlineToken()
	if nl ~= nil then
		if sc ~= nil then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Unnecessary semicolon at the end of a line", sc)) end
		end
		do return nl end
	end
	if sc ~= nil then
		do return sc end
	end
	do return nil end
end

function sling.syntax.SlingParser:parseEndOfStatementToken()
	local v = self:acceptEndOfStatementToken()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("<NL> or `;'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptSemicolonToken()
	local v = self:acceptToken2(59)
	local multiple = false
	while self:acceptToken2(59) ~= nil do
		multiple = true
	end
	if multiple then
		do self:onParseMessage(_g.sling.common.WarningMessage:forText("Multiple consecutive semicolons", v)) end
	end
	do return v end
end

function sling.syntax.SlingParser:sanitizeFileId(id)
	if not (id ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local it = _g.jk.lang.String:iterate(id)
		while it ~= nil do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if self:isValidIdentifierCharacter(c) then
				do sb:appendCharacter(c) end
			else
				do sb:appendCharacter(95) end
			end
		end
		do return sb:toString() end
	end
end

function sling.syntax.SlingParser:getCurrentFileId()
	local v = _g.sling.common.CodeParser.getCurrentFileId(self)
	if not (v ~= nil) then
		do return nil end
	end
	do
		local at = _g.jk.lang.String:getIndexOfCharacter(v, 64, 0)
		if at > 0 then
			v = _g.jk.lang.String:getSubString(v, 0, at)
		end
		do return self:sanitizeFileId(v) end
	end
end

function sling.syntax.SlingParser:getCurrentFileIdComplete()
	do return _g.sling.common.CodeParser.getCurrentFileId(self) end
end

function sling.syntax.SlingParser:acceptSymbolReference()
	local src = nil
	local names = nil
	while true do
		local id = self:acceptIdentifierToken()
		if not (id ~= nil) then
			do break end
		end
		if not (src ~= nil) then
			src = id
		end
		if names == nil then
			names = {}
		end
		if self:acceptToken2(60) ~= nil then
			local genericTypes = nil
			while true do
				local tt = self:parseDataType(true)
				local bts = nil
				if self:acceptToken2(58) ~= nil then
					bts = {}
					repeat
						local bdt = self:parseDataType(true)
						do _g.jk.lang.Vector:append(bts, bdt) end
					until not (self:acceptToken2(38) ~= nil)
				end
				if genericTypes == nil then
					genericTypes = {}
				end
				if bts ~= nil then
					local vb = _g.sling.model.ConstrainedDataTypeNode:forPrimaryType(tt)
					do vb:setSource(tt:getSource()) end
					if bts ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(bts)
						do
							n = 0
							while n < m do
								local node = _vm:to_table_with_key(bts[n + 1], '_isType.sling.common.DataTypeNode')
								if node ~= nil then
									do vb:addToBaseTypes(node) end
								end
								do n = n + 1 end
							end
						end
					end
					tt = vb
				end
				do _g.jk.lang.Vector:append(genericTypes, tt) end
				if self:acceptToken2(44) == nil then
					do break end
				end
			end
			do self:parseToken2(62) end
			do
				local snc = _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create())
				do snc:setSource(id) end
				do snc:setName(id.value) end
				do snc:setTypeParameters(genericTypes, false) end
				do _g.jk.lang.Vector:append(names, snc) end
			end
		else
			do _g.jk.lang.Vector:append(names, id.value) end
		end
		if self:peekToken1("...") then
			do break end
		end
		if self:acceptToken2(46) ~= nil then
			goto _continue11
		end
		do break end
		::_continue11::
	end
	if not (src ~= nil) then
		do return nil end
	end
	if not (names ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.model.SymbolNode:forVectorOfNames(names)
		do v:setSource(src) end
		do return v end
	end
end

function sling.syntax.SlingParser:parseSymbolReference()
	local v = self:acceptSymbolReference()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("symbol reference"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptFunctionDeclarationParameter()
	local namedDeclaration = self:acceptNamedParameterDeclaration()
	if namedDeclaration ~= nil then
		if self:acceptToken1("...") ~= nil then
			do return self:createVariableArgumentsDeclaration(namedDeclaration) end
		end
		do return namedDeclaration end
	end
	do
		local variableDeclaration = self:acceptParameterVariableDeclaration(false)
		if variableDeclaration ~= nil then
			if self:acceptToken1("...") ~= nil then
				do return self:createVariableArgumentsDeclaration(variableDeclaration) end
			end
			do return variableDeclaration end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:parseFunctionDeclarationParameter()
	local v = self:acceptFunctionDeclarationParameter()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("parameter variable declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		do return nil end
	end
	do return v end
end

function sling.syntax.SlingParser:createVariableArgumentsDeclaration(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local va = _g.sling.model.VariableArgumentsDeclarationNode._construct0(_g.sling.model.VariableArgumentsDeclarationNode._create())
		if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
			local v = node
			do va:setSource(v:getSource()) end
			do va:setVariableDeclaration(v, false) end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.NamedParameterDeclarationNode') ~= nil) then
			local v = node:exportVariable()
			do va:setSource(v:getSource()) end
			do va:setVariableDeclaration(v, false) end
		end
		do return va end
	end
end

function sling.syntax.SlingParser:acceptFunctionDeclarationParameters()
	local open = self:acceptToken2(40)
	if not (open ~= nil) then
		do return nil end
	end
	do
		local v = {}
		if self:acceptToken2(41) ~= nil then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Empty parameter list: Parenthesis should be omitted", open)) end
			do return v end
		end
		while true do
			local vr = self:parseFunctionDeclarationParameter()
			do _g.jk.lang.Vector:append(v, vr) end
			if self:acceptToken2(44) ~= nil then
				do self:acceptMultipleNewlineTokens() end
				goto _continue12
			end
			if self:acceptToken2(41) ~= nil then
				do break end
			end
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `)'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			::_continue12::
		end
		do return v end
	end
end

function sling.syntax.SlingParser:acceptStringLiteralExpression(acceptModifiers)
	local dqt = self:acceptDoubleQuotedStringToken(92, false)
	if dqt ~= nil then
		local v = _g.sling.model.StringLiteralExpressionNode:forValue(_g.sling.common.CodeStringUtil:unescapeStringLiteralCStyle(dqt.value, true))
		do v:setSource(dqt) end
		if acceptModifiers then
			while true do
				local mod = self:acceptCustomModifier()
				if mod == nil then
					do break end
				end
				do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
			end
		end
		do return v end
	end
	do
		local mlt = self:acceptMultilineStringToken()
		if mlt ~= nil then
			local n = 4
			local literal = mlt.value
			if _g.jk.lang.String:endsWith(literal, "\n]]") then
				do n = n + 1 end
			end
			do
				local v = _g.sling.model.StringLiteralExpressionNode:forValue(_g.jk.lang.String:getSubString(literal, 2, _g.jk.lang.String:getLength(literal) - n))
				do v:setSource(mlt) end
				do v:setIsLongString(true) end
				if acceptModifiers then
					while true do
						local mod = self:acceptCustomModifier()
						if mod == nil then
							do break end
						end
						do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
					end
				end
				do return v end
			end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:parseStringLiteralExpression(acceptModifiers)
	local v = self:acceptStringLiteralExpression(acceptModifiers)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("string literal"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptStringLiteral()
	local lit = self:acceptStringLiteralExpression(true)
	if not (lit ~= nil) then
		do return nil end
	end
	do return lit:getValue() end
end

function sling.syntax.SlingParser:parseStringLiteral()
	local lit = self:parseStringLiteralExpression(true)
	do return lit:getValue() end
end

function sling.syntax.SlingParser:parseStringLiteralWithoutModifiers()
	local lit = self:parseStringLiteralExpression(false)
	do return lit:getValue() end
end

function sling.syntax.SlingParser:acceptBooleanLiteralExpression()
	if self:acceptToken1("true") ~= nil then
		local v = _g.sling.model.BooleanLiteralExpressionNode:forValue(true)
		do v:setSource(self:getAcceptedToken()) end
		while true do
			local mod = self:acceptCustomModifier()
			if mod == nil then
				do break end
			end
			do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
		end
		do return v end
	end
	if self:acceptToken1("false") ~= nil then
		local v = _g.sling.model.BooleanLiteralExpressionNode:forValue(false)
		do v:setSource(self:getAcceptedToken()) end
		while true do
			local mod = self:acceptCustomModifier()
			if mod == nil then
				do break end
			end
			do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
		end
		do return v end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptNullLiteralExpression()
	if self:acceptToken1("null") ~= nil then
		local v = _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())
		do v:setSource(self:getAcceptedToken()) end
		while true do
			local mod = self:acceptCustomModifier()
			if mod == nil then
				do break end
			end
			do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
		end
		do return v end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptFailureLiteralExpression()
	if self:acceptToken1("fail") ~= nil then
		local v = _g.sling.model.FailureLiteralExpressionNode._construct0(_g.sling.model.FailureLiteralExpressionNode._create())
		do v:setSource(self:getAcceptedToken()) end
		while true do
			local mod = self:acceptCustomModifier()
			if mod == nil then
				do break end
			end
			do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
		end
		do return v end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptCharacterLiteralExpression()
	local token = self:acceptSingleQuotedStringToken()
	if not (token ~= nil) then
		do return nil end
	end
	do
		local literal = token.value
		local c = 0
		if _g.jk.lang.String:getLength(literal) == 3 then
			c = _g.jk.lang.String:getChar(literal, 1)
		elseif literal == "'\\a'" then
			c = 7
		elseif literal == "'\\b'" then
			c = 8
		elseif literal == "'\\f'" then
			c = 12
		elseif literal == "'\\n'" then
			c = 10
		elseif literal == "'\\r'" then
			c = 13
		elseif literal == "'\\t'" then
			c = 9
		elseif literal == "'\\v'" then
			c = 11
		elseif literal == "'\\\\'" then
			c = 92
		elseif literal == "'\\''" then
			c = 39
		elseif literal == "'\\\"'" then
			c = 34
		elseif literal == "'\\?'" then
			c = 63
		elseif literal == "'\\0'" then
			c = 0
		else
			local ll = _g.jk.lang.String:getLength(literal)
			local c1 = _g.jk.lang.String:getChar(literal, 1)
			if ll == 6 and c1 == 92 and _g.jk.lang.String:getChar(literal, 2) == 120 then
				c = _g.jk.lang.String:toIntegerFromHex(_g.jk.lang.String:getSubString(literal, 3, 2))
			elseif ll == 8 and c1 == 92 and _g.jk.lang.String:getChar(literal, 2) == 117 then
				c = _g.jk.lang.String:toIntegerFromHex(_g.jk.lang.String:getSubString(literal, 3, 4))
			elseif ll == 6 and c1 == 92 then
				local n = 0
				n = n + _util:convert_to_integer(_g.jk.lang.String:getChar(literal, 4) - 48)
				n = n + (_g.jk.lang.String:getChar(literal, 3) - 48) * 8
				c = n
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported character literal", token, _g.jk.lang.StackTrace:generate()))
			end
		end
		do
			local v = _g.sling.model.CharacterLiteralExpressionNode:forValue(c)
			do v:setSource(token) end
			while true do
				local mod = self:acceptCustomModifier()
				if mod == nil then
					do break end
				end
				do v:addCustomModifier(_g.jk.lang.String:getEndOfString(mod, 1)) end
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptIntegerLiteralExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local num = _vm:to_table_with_key(self:acceptNumberLiteralExpression(), '_isType.sling.model.IntegerLiteralExpressionNode')
		if not (num ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do return num end
	end
end

function sling.syntax.SlingParser:acceptNumberLiteralExpression()
	local hex = self:acceptHexNumberLiteralToken(true)
	if hex ~= nil then
		local v = _g.sling.model.IntegerLiteralExpressionNode._construct0(_g.sling.model.IntegerLiteralExpressionNode._create())
		do v:setFormat(_g.sling.model.IntegerLiteralExpressionNode.FORMAT_HEXADECIMAL) end
		do v:setSource(hex) end
		do
			local st = _g.jk.lang.String:getEndOfString(hex.value, 2)
			if _g.jk.lang.String:getLength(st) >= 16 then
				do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_LONG) end
				do v:setValue(_g.jk.lang.String:toLongIntegerFromHex(st)) end
			else
				do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_INT) end
				do v:setValue(_g.jk.lang.String:toIntegerFromHex(st)) end
			end
			do return v end
		end
	end
	do
		local ii = self:acceptDecimalNumberLiteralToken(true, true, true, false)
		if ii ~= nil and _g.jk.lang.String:getIndexOfCharacter(ii.value, 46, 0) > -1 then
			if self:acceptToken2(109) ~= nil or self:acceptToken2(77) ~= nil then
				local v = _g.sling.model.DecimalLiteralExpressionNode._construct0(_g.sling.model.DecimalLiteralExpressionNode._create())
				do v:setSource(ii) end
				do v:setValue(ii.value) end
				do return v end
			end
			if self:acceptToken2(102) ~= nil or self:acceptToken2(70) ~= nil then
				local v = _g.sling.model.FloatLiteralExpressionNode:forValue(_g.jk.lang.String:toDouble(ii.value))
				do v:setSource(ii) end
				do return v end
			end
			do
				local v = _g.sling.model.DoubleLiteralExpressionNode:forValue(_g.jk.lang.String:toDouble(ii.value))
				do v:setSource(ii) end
				do return v end
			end
		end
		if not (ii ~= nil) then
			ii = self:acceptIntegerLiteralToken(true)
		end
		if ii ~= nil then
			local v = _g.sling.model.IntegerLiteralExpressionNode:forValue(_g.jk.lang.String:toLong(ii.value))
			do v:setFormat(_g.sling.model.IntegerLiteralExpressionNode.FORMAT_DECIMAL) end
			do v:setSource(ii) end
			do
				local unsigned = false
				local long = false
				if self:acceptToken2(117) ~= nil or self:acceptToken2(85) ~= nil then
					unsigned = true
				end
				if self:acceptToken2(108) ~= nil or self:acceptToken2(76) ~= nil then
					long = true
				end
				if unsigned then
					if long then
						do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_ULONG) end
						do v:setDefaultDataType(_g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_ULONG), false) end
					else
						do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT) end
						do v:setDefaultDataType(_g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT), false) end
					end
				elseif long then
					do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_LONG) end
					do v:setDefaultDataType(_g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_LONG), false) end
				end
				do return v end
			end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:acceptPromiseLiteralExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1("promise")
		if not (src ~= nil) then
			do return nil end
		end
		do
			local dtp = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
			if self:acceptToken1("<") ~= nil then
				if not ((function()
					dtp = self:acceptDataType(true)
					do return dtp end
				end)() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:acceptToken1(">") ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
			end
			do
				local blk = self:acceptBlock(false, nil)
				if not (blk ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do
					local prm = _g.sling.model.PromiseLiteralExpressionNode._construct0(_g.sling.model.PromiseLiteralExpressionNode._create())
					do prm:setType(dtp, false) end
					do prm:setBody(blk, false) end
					do prm:setSource(src) end
					do return prm end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptLiteralExpression()
	local slit = self:acceptStringLiteralExpression(true)
	if slit ~= nil then
		do return slit end
	end
	do
		local blit = self:acceptBooleanLiteralExpression()
		if blit ~= nil then
			do return blit end
		end
		do
			local nlit = self:acceptNullLiteralExpression()
			if nlit ~= nil then
				do return nlit end
			end
			do
				local flit = self:acceptFailureLiteralExpression()
				if flit ~= nil then
					do return flit end
				end
				do
					local clit = self:acceptCharacterLiteralExpression()
					if clit ~= nil then
						do return clit end
					end
					do
						local number = self:acceptNumberLiteralExpression()
						if number ~= nil then
							do return number end
						end
						do return nil end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptMultidimensionalArrayLiteralExpression(count)
	local src = self:acceptToken2(123)
	if not (src ~= nil) then
		do return nil end
	end
	do
		local ops = _g.jk.lang.Stack._construct0(_g.jk.lang.Stack._create())
		local rar = _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create())
		do rar:setSource(src) end
		do ops:push(rar) end
		while true do
			do self:acceptMultipleNewlineTokens() end
			if self:acceptToken2(123) ~= nil then
				local lit = _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create())
				do lit:setSource(self:getAcceptedToken()) end
				do ops:push(lit) end
				if ops:getSize() > count then
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multi-dimension array count exceeds count", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				do self:acceptMultipleNewlineTokens() end
				if ops:getSize() == count then
					local top = ops:peek()
					if not (top ~= nil) then
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No previous array literal expression instance to add the expression", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
					while true do
						local xpr = self:parseExpression(false)
						do top:addToExpressions(xpr) end
						if self:acceptToken2(44) ~= nil then
							do self:acceptMultipleNewlineTokens() end
							goto _continue13
						end
						do break end
						::_continue13::
					end
				end
				goto _continue14
			end
			if self:acceptToken2(44) ~= nil then
				do self:acceptMultipleNewlineTokens() end
				if ops:getSize() < count and self:peekNextCharacter() ~= 123 then
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`{'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				goto _continue14
			end
			if self:acceptToken2(125) ~= nil then
				local top = ops:pop()
				local prv = ops:peek()
				if prv ~= nil then
					do prv:addToExpressions(top) end
				end
				if ops:getSize() < 1 then
					do break end
				else
					do self:acceptMultipleNewlineTokens() end
					if self:peekNextCharacter() ~= 44 and self:peekNextCharacter() ~= 125 then
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
				end
				goto _continue14
			end
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`{', `}', `,' or expression"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			::_continue14::
		end
		do return rar end
	end
end

function sling.syntax.SlingParser:acceptArrayLiteralExpression(openToken, closeToken, allowDataType)
	local open = self:acceptToken2(openToken)
	if not (open ~= nil) then
		do return nil end
	end
	do
		local dt = nil
		if allowDataType then
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				dt = self:acceptDataType(true)
				if dt ~= nil then
					if self:acceptToken2(58) == nil then
						dt = nil
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
				end
			end
		end
		do self:acceptMultipleNewlineTokens() end
		do
			local exprs = {}
			if self:acceptToken2(closeToken) == nil then
				while true do
					local xp = self:parseExpression(false)
					do _g.jk.lang.Vector:append(exprs, xp) end
					if self:acceptToken2(44) ~= nil then
						do self:acceptMultipleNewlineTokens() end
						goto _continue15
					end
					if self:acceptToken2(closeToken) ~= nil then
						do break end
					end
					if self:acceptMultipleNewlineTokens() ~= nil then
						do self:parseToken2(closeToken) end
						do break end
					end
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forCharacter(closeToken)) .. "'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					::_continue15::
				end
			end
			do
				local v = _g.sling.model.ArrayLiteralExpressionNode:forExpressions(exprs)
				if dt ~= nil then
					do v:setType(dt, false) end
				end
				do v:setSource(open) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:createDefaultMapDataType()
	local v = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do v:setKeyType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
	do v:setValueType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
	do return v end
end

function sling.syntax.SlingParser:acceptLegacyMapLiteralExpression()
	local open = self:acceptToken2(123)
	if not (open ~= nil) then
		do return nil end
	end
	do self:acceptMultipleNewlineTokens() end
	do
		local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
		do v:setDefaultDataType(self:createDefaultMapDataType(), false) end
		do v:setSource(open) end
		if self:acceptToken2(125) == nil then
			while true do
				if self:acceptToken2(125) ~= nil then
					do break end
				end
				do
					local key = self:parseExpression(false)
					do self:parseToken2(58) end
					do
						local val = self:parseExpression(false)
						local vn = _g.sling.model.KeyValueNode:forValues(key, val)
						do vn:setSource(key:getSource()) end
						do v:addToValues(vn) end
						if self:acceptToken2(44) ~= nil then
							do self:acceptMultipleNewlineTokens() end
							goto _continue16
						end
						do self:acceptMultipleNewlineTokens() end
						if self:acceptToken2(125) ~= nil then
							do break end
						end
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
				end
				::_continue16::
			end
		end
		do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", open)) end
		do return v end
	end
end

function sling.syntax.SlingParser:acceptBufferLiteralExpression(keyword)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1(keyword)
		if not (src ~= nil) then
			do return nil end
		end
		do
			local open = self:acceptToken2(123)
			if not (open ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local xprs = {}
				while true do
					local lit = self:acceptIntegerLiteralExpression()
					if lit ~= nil then
						do _g.jk.lang.Vector:append(xprs, lit) end
						goto _continue17
					end
					if self:acceptToken2(44) ~= nil then
						goto _continue17
					end
					if self:acceptToken2(125) ~= nil then
						do break end
					end
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("literal, `,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					::_continue17::
				end
				do
					local size = _g.jk.lang.Vector:getSize(xprs)
					if size < 1 then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Buffer literal with no data", src, _g.jk.lang.StackTrace:generate()))
					end
					do
						local buffer = _util:allocate_buffer(size)
						local n = 0
						if xprs ~= nil then
							local n2 = 0
							local m = _g.jk.lang.Vector:getSize(xprs)
							do
								n2 = 0
								while n2 < m do
									local lit = xprs[n2 + 1]
									if lit ~= nil then
										buffer[(function() local v = n n = n + 1 return v end)() + 1] = _vm:bitwise_and(lit:getValue(), 255)
									end
									do n2 = n2 + 1 end
								end
							end
						end
						do
							local v = _g.sling.model.BufferLiteralExpressionNode:forValue(buffer)
							do v:setSource(src) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptMapLiteralExpression(keyword)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1(keyword)
		if not (src ~= nil) then
			do return nil end
		end
		do
			local type = nil
			if self:acceptToken2(60) ~= nil then
				local keytype = self:parseDataType(true)
				do self:parseToken2(44) end
				do
					local valtype = self:parseDataType(true)
					do self:parseToken2(62) end
					type = _g.sling.model.MapDataTypeNode:forTypes(keytype, valtype)
				end
			else
				type = self:createDefaultMapDataType()
			end
			do
				local open = self:acceptToken2(123)
				if not (open ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:acceptMultipleNewlineTokens() end
				do
					local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
					do v:setDefaultDataType(type, false) end
					do v:setSource(src) end
					if self:acceptToken2(125) == nil then
						while true do
							if self:acceptToken2(125) ~= nil then
								do break end
							end
							do
								local key = self:parseExpression(false)
								do self:parseToken2(58) end
								do
									local val = self:parseExpression(false)
									local vn = _g.sling.model.KeyValueNode:forValues(key, val)
									do vn:setSource(key:getSource()) end
									do v:addToValues(vn) end
									if self:acceptToken2(44) ~= nil then
										do self:acceptMultipleNewlineTokens() end
										goto _continue18
									end
									do self:acceptMultipleNewlineTokens() end
									if self:acceptToken2(125) ~= nil then
										do break end
									end
									do self:skipSpaces() end
									do self:updateStagingToken() end
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
								end
							end
							::_continue18::
						end
					end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptSetLiteralExpression(keyword)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1(keyword)
		if not (src ~= nil) then
			do return nil end
		end
		do
			local open = self:acceptToken2(123)
			if not (open ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:acceptMultipleNewlineTokens() end
			do
				local v = _g.sling.model.SetLiteralExpressionNode._construct0(_g.sling.model.SetLiteralExpressionNode._create())
				do v:setSource(src) end
				if self:acceptToken2(125) == nil then
					while true do
						if self:acceptToken2(125) ~= nil then
							do break end
						end
						do
							local value = self:parseExpression(false)
							do v:addToValues(value) end
							if self:acceptToken2(44) ~= nil then
								do self:acceptMultipleNewlineTokens() end
								goto _continue19
							end
							do self:acceptMultipleNewlineTokens() end
							if self:acceptToken2(125) ~= nil then
								do break end
							end
							do self:skipSpaces() end
							do self:updateStagingToken() end
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
						end
						::_continue19::
					end
				end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptSubOrTupleExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local open = self:acceptToken2(40)
		if not (open ~= nil) then
			do return nil end
		end
		do self:acceptMultipleNewlineTokens() end
		do
			local e0 = self:acceptExpression(false)
			if not (e0 ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			if self:acceptToken2(44) ~= nil then
				local tv = _g.sling.model.TupleExpressionNode._construct0(_g.sling.model.TupleExpressionNode._create())
				do tv:addToExpressions(e0) end
				while true do
					do self:acceptMultipleNewlineTokens() end
					do
						local x = self:acceptExpression(false)
						if not (x ~= nil) then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do tv:addToExpressions(x) end
						if not (self:acceptToken2(44) ~= nil) then
							do break end
						end
					end
				end
				do self:acceptMultipleNewlineTokens() end
				if not (self:acceptToken2(41) ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do return tv end
			end
			do self:acceptMultipleNewlineTokens() end
			if self:acceptToken2(41) ~= nil then
				do return e0 end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
	end
end

function sling.syntax.SlingParser:acceptCreateObjectExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1("new")
		if not (src ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local mlit = self:acceptMapLiteralExpression("map")
			if mlit ~= nil then
				do return mlit end
			end
			do
				local slit = self:acceptSetLiteralExpression("set")
				if slit ~= nil then
					do return slit end
				end
				do
					local blit = self:acceptBufferLiteralExpression("buffer")
					if blit ~= nil then
						do return blit end
					end
					do
						local malit = self:acceptMarkupLiteralExpression("tree", true)
						if malit ~= nil then
							do return malit end
						end
						do
							local stlit = self:acceptStyleLiteralExpression("stylesheet", true)
							if stlit ~= nil then
								do return stlit end
							end
							do
								local plit = self:acceptPromiseLiteralExpression()
								if plit ~= nil then
									do return plit end
								end
								do
									local xprn = nil
									local name = self:acceptDataType(false)
									if not (name ~= nil) then
										xprn = self:acceptExpression(true)
									end
									if name ~= nil and self:acceptToken2(91) ~= nil then
										local v = _g.sling.model.ArrayCreationExpressionNode:forPrimaryType(name)
										do v:setSource(src) end
										while true do
											local xpr = self:acceptExpression(false)
											if not (xpr ~= nil) then
												xpr = _g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())
											end
											do v:addToDimensions(xpr) end
											if not (self:acceptToken2(44) ~= nil) then
												do break end
											end
										end
										do self:parseToken2(93) end
										if _g.jk.lang.Vector:isEmpty(v:getDimensions()) then
											do v:addToDimensions(_g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())) end
										end
										if v:getDimensionCount() > 1 then
											local mdlit = self:acceptMultidimensionalArrayLiteralExpression(v:getDimensionCount())
											if mdlit ~= nil then
												do v:setArrayLiteral(mdlit, false) end
											end
										else
											local alit = self:acceptArrayLiteralExpression(123, 125, false)
											if alit ~= nil then
												do v:setArrayLiteral(alit, false) end
											end
										end
										do return v end
									end
									do
										local params = self:acceptFunctionCallParameters()
										if self:acceptToken2(123) ~= nil then
											do self:parseNewlineToken() end
											do
												local classdecl = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
												local nameref = _vm:to_table_with_key(name, '_isType.sling.model.ReferenceDataTypeNode')
												if not (nameref ~= nil) then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("reference data type"), name:getSource(), _g.jk.lang.StackTrace:generate()))
													do return nil end
												end
												do classdecl:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(nameref, _g.sling.model.BaseTypeNode.INHERIT_AUTO)) end
												while true do
													if self:acceptToken2(125) ~= nil then
														do break end
													end
													do
														local dec = self:parseEntityDeclaration(true)
														do self:addDeclarationToContainer(classdecl, dec) end
													end
												end
												do
													local v = _g.sling.model.ClassDeclarationInstantiationExpressionNode._construct0(_g.sling.model.ClassDeclarationInstantiationExpressionNode._create())
													do v:setSource(src) end
													do v:setParameters(params, false) end
													do v:setClassDeclaration(classdecl, false) end
													do return v end
												end
											end
										end
										do
											local v = _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create())
											if name ~= nil then
												do v:setType(name, false) end
											elseif xprn ~= nil then
												do v:setTypeExpression(xprn, false) end
											else
												self.currentTokenColumn = ctc
												self.currentTokenLine = ctl
												do self.iterator:setCurrentPosition(ctp) end
												while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
													do self.commentQueue:pop() end
												end
												self.previousToken = cpt
												do return nil end
											end
											do v:setSource(src) end
											do v:setParameters(params, false) end
											do return v end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptFunctionCallParameters()
	local opos = self:acceptToken2(40)
	if not (opos ~= nil) then
		do return nil end
	end
	do
		local params = {}
		if self:acceptToken2(41) ~= nil then
			do return params end
		end
		while true do
			do self:acceptMultipleNewlineTokens() end
			do
				local csym = self:parseExpression(false)
				do _g.jk.lang.Vector:append(params, csym) end
				if self:acceptToken2(44) ~= nil then
					goto _continue20
				end
				do self:acceptMultipleNewlineTokens() end
				if self:acceptToken2(41) ~= nil then
					do break end
				end
				do self:skipSpaces() end
				do self:updateStagingToken() end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `)'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			end
			::_continue20::
		end
		do return params end
	end
end

function sling.syntax.SlingParser:acceptSymbolExpression(isFirst)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local isGlobal = false
		if isFirst and self:acceptToken1("::") ~= nil then
			isGlobal = true
		end
		do
			local id = self:acceptIdentifierToken()
			if id ~= nil then
				local symbol = _g.sling.model.SymbolNode:forName(id.value)
				do symbol:setSource(id) end
				if isGlobal then
					do symbol:addModifier(_g.sling.model.Modifier.GLOBAL) end
				end
				do
					local v = _g.sling.model.SymbolExpressionNode:forSymbol(symbol)
					do v:setSource(id) end
					if isFirst and self.isMacro == false and id.value == self:getCurrentEntityName() then
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Accessing current entity by name. Should not do this.", v)) end
					end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
	end
end

function sling.syntax.SlingParser:acceptExpressions16()
	local lit = self:acceptLiteralExpression()
	if lit ~= nil then
		do return lit end
	end
	do
		local alit = self:acceptArrayLiteralExpression(91, 93, true)
		if alit ~= nil then
			local v = _g.sling.model.ArrayCreationExpressionNode:forLiteral(alit)
			do v:setSource(alit:getSource()) end
			do return v end
		end
		if self.acceptDeprecatedConstructs then
			local mll = self:acceptLegacyMapLiteralExpression()
			if mll ~= nil then
				do return mll end
			end
			do
				local mlit = self:acceptMapLiteralExpression("MAP")
				if mlit ~= nil then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", mlit)) end
					do return mlit end
				end
				do
					local slit = self:acceptSetLiteralExpression("SET")
					if slit ~= nil then
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", slit)) end
						do return slit end
					end
					do
						local blit = self:acceptBufferLiteralExpression("BUFFER")
						if blit ~= nil then
							do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", blit)) end
							do return blit end
						end
					end
				end
			end
		end
		do
			local stex = self:acceptSubOrTupleExpression()
			if stex ~= nil then
				do return stex end
			end
			do
				local xob = self:acceptCreateObjectExpression()
				if xob ~= nil then
					do return xob end
				end
				do
					local ctc = self.currentTokenColumn
					local ctl = self.currentTokenLine
					local ctp = self.iterator:getCurrentPosition()
					local cqs = 0
					if self.commentQueue ~= nil then
						cqs = self.commentQueue:getSize()
					end
					do
						local cpt = self.previousToken
						if self:acceptToken1("var") ~= nil then
							if self:peekNextCharacter() ~= 40 then
								local src = self:getAcceptedToken()
								local idt = self:acceptIdentifier()
								if idt ~= nil then
									local dtp = nil
									if self:acceptToken1("as") ~= nil then
										dtp = self:parseDataType(true)
									end
									if not (dtp ~= nil) then
										dtp = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
									end
									if self:acceptToken1("=") ~= nil then
										local ini = self:parseExpression(true)
										local d = _g.sling.model.VariableDeclarationNode:instance(dtp, idt, ini)
										local r = _g.sling.model.VariableDeclarationExpressionNode._construct0(_g.sling.model.VariableDeclarationExpressionNode._create())
										do r:setDeclaration(d, false) end
										do r:setSource(src) end
										do return r end
									end
								end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self.acceptDeprecatedConstructs and self:acceptToken1("trycatch") ~= nil then
							if self:peekNextCharacter() ~= 40 then
								local src = self:getAcceptedToken()
								local xpr = self:acceptExpression(true)
								if xpr ~= nil then
									do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
									do
										local r = _g.sling.model.TryCatchExpressionNode:forExpression(xpr)
										do r:setSource(src) end
										do return r end
									end
								end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self:acceptToken1("try") ~= nil then
							if self:peekNextCharacter() ~= 40 then
								local src = self:getAcceptedToken()
								local xpr = self:acceptExpression(true)
								if xpr ~= nil then
									local r = _g.sling.model.TryCatchExpressionNode:forExpression(xpr)
									do r:setSource(src) end
									do return r end
								end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self:acceptToken1("VALUE") ~= nil then
							local src = self:getAcceptedToken()
							local value = nil
							if self.acceptDeprecatedConstructs and self:acceptToken2(40) ~= nil then
								value = self:acceptStringLiteral()
								if value ~= nil then
									do self:parseToken2(41) end
									do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
								end
							else
								value = self:acceptStringLiteral()
							end
							if value ~= nil then
								local r = _g.sling.model.PreprocessorValueExpressionNode:forVariable(value)
								do r:setSource(src) end
								do return r end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self:acceptToken1("TEXTFILE") ~= nil then
							local src = self:getAcceptedToken()
							local value = nil
							if self.acceptDeprecatedConstructs and self:acceptToken2(40) ~= nil then
								value = self:acceptStringLiteral()
								if value ~= nil then
									do self:parseToken2(41) end
									do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
								end
							else
								value = self:acceptStringLiteral()
							end
							if value ~= nil then
								if _g.jk.lang.String:isEmpty(value) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty text file name", src, _g.jk.lang.StackTrace:generate()))
								end
								do
									local v = _g.sling.model.FileSystemTextFileReferenceExpressionNode._construct0(_g.sling.model.FileSystemTextFileReferenceExpressionNode._create())
									do v:setSource(src) end
									do v:setName(value) end
									do v:setRelativeTo(self:getCurrentFile()) end
									do return v end
								end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self:acceptToken1("FILE") ~= nil then
							if self:peekNextCharacter() ~= 40 then
								local src = self:getAcceptedToken()
								local value = self:acceptStringLiteral()
								if value ~= nil then
									if _g.jk.lang.String:isEmpty(value) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty file name", src, _g.jk.lang.StackTrace:generate()))
									end
									do
										local v = _g.sling.model.FileSystemBinaryFileReferenceExpressionNode._construct0(_g.sling.model.FileSystemBinaryFileReferenceExpressionNode._create())
										do v:setSource(src) end
										do v:setName(value) end
										do v:setRelativeTo(self:getCurrentFile()) end
										do return v end
									end
								end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self:acceptToken1("DIRECTORY") ~= nil then
							if self:peekNextCharacter() ~= 40 then
								local src = self:getAcceptedToken()
								local value = self:acceptStringLiteral()
								if value ~= nil then
									if _g.jk.lang.String:isEmpty(value) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty directory name", src, _g.jk.lang.StackTrace:generate()))
									end
									do
										local v = _g.sling.model.FileSystemDirectoryReferenceExpressionNode._construct0(_g.sling.model.FileSystemDirectoryReferenceExpressionNode._create())
										do v:setSource(src) end
										do v:setName(value) end
										do v:setRelativeTo(self:getCurrentFile()) end
										do return v end
									end
								end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						if self:acceptToken1("ui") ~= nil then
							local v = self:acceptUiExpression()
							if v ~= nil then
								do return v end
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do
							local langDeclaration = self:acceptLangDeclaration(false, true)
							if langDeclaration ~= nil then
								do return langDeclaration end
							end
							if self:acceptToken1("this") ~= nil then
								local v = _g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create())
								do v:setSource(self:getAcceptedToken()) end
								do return v end
							end
							if self:acceptToken1("base") ~= nil then
								local v = _g.sling.model.BaseClassAccessExpressionNode._construct0(_g.sling.model.BaseClassAccessExpressionNode._create())
								do v:setSource(self:getAcceptedToken()) end
								do return v end
							end
							do
								local funcd = self:acceptFunctionDeclarationExpression()
								if funcd ~= nil then
									do return funcd end
								end
								do
									local symx = self:acceptSymbolExpression(true)
									if symx ~= nil then
										do return symx end
									end
									do return nil end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptBinaryOperator(text)
	local v = self:acceptToken1(text)
	if v ~= nil then
		do self:acceptMultipleNewlineTokens() end
		do return v end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptUnwrappingExpression(node)
	if not (node ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LiteralExpressionNode') ~= nil) then
		do return node end
	end
	if self:peekNextCharacter() == 33 then
		do self:getNextCharacter() end
		do
			local v = _g.sling.model.ForceUnwrapOptionalExpressionNode:forExpression(node)
			do v:setSource(node:getSource()) end
			do return v end
		end
	end
	if self:peekNextCharacter() == 63 then
		do self:getNextCharacter() end
		do
			local v = _g.sling.model.SafeUnwrapOptionalExpressionNode:forExpression(node)
			do v:setSource(node:getSource()) end
			do return v end
		end
	end
	do return node end
end

function sling.syntax.SlingParser:getUnwrappingExpression()
	if self:peekNextCharacter() == 33 then
		do self:getNextCharacter() end
		do return _g.sling.model.ForceUnwrapOptionalExpressionNode._construct0(_g.sling.model.ForceUnwrapOptionalExpressionNode._create()) end
	end
	if self:peekNextCharacter() == 63 then
		do self:getNextCharacter() end
		do return _g.sling.model.SafeUnwrapOptionalExpressionNode._construct0(_g.sling.model.SafeUnwrapOptionalExpressionNode._create()) end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptExpressions15()
	local pe = self:acceptUnwrappingExpression(self:acceptExpressions16())
	if not (pe ~= nil) then
		do return nil end
	end
	do
		local pi = nil
		while true do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				local hadNewLine = self:acceptMultipleNewlineTokens()
				local dot = self:acceptToken1(".")
				if dot ~= nil then
					local ne = self:acceptUnwrappingExpression(self:acceptSymbolExpression(false))
					if not (ne ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do break end
					end
					if pi == nil then
						pi = _g.sling.model.MemberAccessExpressionNode:forNodes(pe, ne)
						pe = pi
					else
						local nx = _g.sling.model.MemberAccessExpressionNode:forNodes(pi:exportChildExpression(), ne)
						do pi:setChildExpression(nx, false) end
						pi = nx
					end
					do pi:setSource(dot) end
					goto _continue21
				end
				if hadNewLine == nil then
					local params = self:acceptFunctionCallParameters()
					if params ~= nil then
						local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(pe)
						do fc:setParameters(params, false) end
						do
							local uw = self:getUnwrappingExpression()
							local fdexpr = self:acceptFunctionDeclarationExpression()
							if fdexpr ~= nil then
								do fc:setTrailingParameter(fdexpr, false) end
							end
							do fc:setSource(pe:getSource()) end
							if uw ~= nil then
								do uw:setExpression(fc, false) end
								do uw:setSource(fc:getSource()) end
								pe = uw
							else
								pe = fc
							end
							pi = nil
							goto _continue21
						end
					end
				end
				if hadNewLine == nil and self:acceptToken2(91) ~= nil then
					local subscript = nil
					if self:acceptToken2(93) == nil then
						subscript = self:parseExpression(true)
						do self:parseToken2(93) end
					end
					do
						local se = _g.sling.model.SubscriptExpressionNode:instance(pe, subscript)
						do se:setSource(pe:getSource()) end
						pe = self:acceptUnwrappingExpression(se)
						pi = nil
						goto _continue21
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do break end
			end
			::_continue21::
		end
		if self:acceptToken1("++") ~= nil then
			local r = _g.sling.model.PostIncrementExpressionNode:forExpression(pe)
			do r:setSource(pe:getSource()) end
			do return r end
		end
		if self:acceptToken1("--") ~= nil then
			local r = _g.sling.model.PostDecrementExpressionNode:forExpression(pe)
			do r:setSource(pe:getSource()) end
			do return r end
		end
		do return pe end
	end
end

function sling.syntax.SlingParser:acceptLegacyTypeCastOperator()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local open = self:acceptToken2(40)
		if not (open ~= nil) then
			do return nil end
		end
		do
			local dt = nil
			do
				local _status, _err = _vm:execute_protected_call(function()
					dt = self:acceptDataType(true)
				end)
				if _err then
					if (_vm:to_table_with_key(_err, '_isType.jk.lang.Exception') ~= nil) then
						local e = _err
						dt = nil
					else
						_vm:throw_error(_err)
					end
				end
			end
			if not (dt ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			if not (self:acceptToken2(41) ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do return dt end
		end
	end
end

function sling.syntax.SlingParser:acceptExpressions14()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if self.acceptDeprecatedConstructs then
			if self:acceptToken1("TYPEINFO") ~= nil then
				local src = self:getAcceptedToken()
				if self:acceptToken2(40) ~= nil then
					local xpr = self:acceptExpression(false)
					if xpr ~= nil then
						do self:parseToken2(41) end
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
						do
							local v = _g.sling.model.GetExpressionTypeinfoExpressionNode:forExpression(xpr)
							do v:setSource(src) end
							do return v end
						end
					end
				end
				if self:acceptToken2(91) ~= nil then
					local dt = self:acceptDataType(true)
					if dt ~= nil then
						do self:parseToken2(93) end
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
						do
							local v = _g.sling.model.GetDatatypeTypeinfoExpressionNode:forDatatype(dt)
							do v:setSource(src) end
							do return v end
						end
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			if self:acceptToken1("MALLOC") ~= nil then
				local src = self:getAcceptedToken()
				local parens = self:acceptToken2(40)
				local sz = self:acceptExpression(false)
				if sz ~= nil then
					if parens ~= nil then
						do self:parseToken2(41) end
					end
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
					do
						local v = _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create())
						do v:setSource(src) end
						do v:setExpression(sz, false) end
						do return v end
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			if self:acceptToken1("SIZE") ~= nil then
				local src = self:getAcceptedToken()
				local parens = self:acceptToken2(40)
				local expr = self:acceptExpression(false)
				if expr ~= nil then
					if parens ~= nil then
						do self:parseToken2(41) end
					end
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
					do
						local v = _g.sling.model.GetSizeExpressionNode:forExpression(expr)
						do v:setSource(src) end
						do return v end
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			if self:acceptToken1("DEFAULT") ~= nil then
				local src = self:getAcceptedToken()
				local parens = self:acceptToken2(40)
				local dt = self:acceptDataType(true)
				if dt ~= nil then
					if parens ~= nil then
						do self:parseToken2(41) end
					end
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
					do
						local v = _g.sling.model.DataTypeDefaultValueExpressionNode:forType(dt)
						do v:setSource(src) end
						do return v end
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
		end
		if self:acceptToken1("typeof") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local xpr = self:acceptExpression(false)
				if xpr ~= nil then
					local v = _g.sling.model.GetExpressionTypeinfoExpressionNode:forExpression(xpr)
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("typeinfo") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local dt = self:acceptDataType(true)
				if dt ~= nil then
					local v = _g.sling.model.GetDatatypeTypeinfoExpressionNode:forDatatype(dt)
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("sizeof") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local expr = self:acceptExpressions14()
				if expr ~= nil then
					local v = _g.sling.model.GetSizeExpressionNode:forExpression(expr)
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("defaultvalue") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local dt = self:acceptDataType(true)
				if dt ~= nil then
					local v = _g.sling.model.DataTypeDefaultValueExpressionNode:forType(dt)
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("++") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.PreIncrementExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("--") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.PreDecrementExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("+") ~= nil then
			local right = self:acceptExpressions14()
			if right ~= nil then
				do return right end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("await") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local right = self:acceptExpressions14()
				if right ~= nil then
					local v = _g.sling.model.AwaitExpressionNode:forExpression(right)
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("promise") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local right = self:acceptExpressions13()
				if right ~= nil then
					local v = _g.sling.model.PromiseExpressionNode:forExpression(right)
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("addr") ~= nil then
			if self:isSpaceCharacter(self:peekNextCharacter()) == false then
				local src = self:getAcceptedToken()
				local right = self:acceptExpressions14()
				if right ~= nil then
					local v = _g.sling.model.GetAddressExpressionNode._construct0(_g.sling.model.GetAddressExpressionNode._create())
					do v:setExpression(right, false) end
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("ref") ~= nil then
			if self:isSpaceCharacter(self:peekNextCharacter()) == false then
				local src = self:getAcceptedToken()
				local right = self:acceptExpressions14()
				if right ~= nil then
					local v = _g.sling.model.GetReferenceExpressionNode._construct0(_g.sling.model.GetReferenceExpressionNode._create())
					do v:setExpression(right, false) end
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("val") ~= nil then
			if self:isSpaceCharacter(self:peekNextCharacter()) == false then
				local src = self:getAcceptedToken()
				local right = self:acceptExpressions14()
				if right ~= nil then
					local v = _g.sling.model.GetValueExpressionNode._construct0(_g.sling.model.GetValueExpressionNode._create())
					do v:setExpression(right, false) end
					do v:setSource(src) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("-") ~= nil then
			local src = self:getAcceptedToken()
			local right = self:acceptExpressions14()
			if right ~= nil then
				local v = _g.sling.model.NegativeNumberExpressionNode:forExpression(right)
				do v:setSource(src) end
				do return v end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("!") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.LogicalNotExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("not") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local v = self:acceptExpressions14()
				if v ~= nil then
					local r = _g.sling.model.LogicalNotExpressionNode:forExpression(v)
					do r:setSource(src) end
					do return r end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("~") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.BitwiseNotExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self.acceptDeprecatedConstructs then
			local castdt = self:acceptLegacyTypeCastOperator()
			if castdt ~= nil then
				local v = self:acceptExpressions14()
				if v ~= nil then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated syntax for static cast expressions: Use either `as' or `as!' instead.", castdt)) end
					do
						local r = _g.sling.model.StaticCastExpressionNode:instance(castdt, v)
						do r:setSource(castdt:getSource()) end
						do return r end
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
		end
		do
			local left = self:acceptExpressions15()
			while true do
				local ctc = self.currentTokenColumn
				local ctl = self.currentTokenLine
				local ctp = self.iterator:getCurrentPosition()
				local cqs = 0
				if self.commentQueue ~= nil then
					cqs = self.commentQueue:getSize()
				end
				do
					local cpt = self.previousToken
					local o1 = self:acceptBinaryOperator("as!")
					if o1 ~= nil then
						local right = self:acceptDataType(true)
						if right ~= nil then
							local v = _g.sling.model.StaticCastExpressionNode:instance(right, left)
							do v:setSource(o1) end
							left = v
							goto _continue22
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do
						local o2 = self:acceptBinaryOperator("as")
						if o2 ~= nil then
							local right = self:acceptDataType(true)
							if right ~= nil then
								if (_vm:to_table_with_key(right, '_isType.sling.model.PrimitiveDataTypeNode') ~= nil) then
									local v = _g.sling.model.StaticCastExpressionNode:instance(right, left)
									do v:setSource(o2) end
									left = v
								else
									local v = _g.sling.model.DynamicCastExpressionNode:instance(right, left)
									do v:setSource(o2) end
									left = v
								end
								goto _continue22
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do break end
					end
				end
				::_continue22::
			end
			do return left end
		end
	end
end

function sling.syntax.SlingParser:acceptExpressions13()
	local left = self:acceptExpressions14()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("*")
			if o1 ~= nil then
				local right = self:acceptExpressions14()
				if right ~= nil then
					local v = _g.sling.model.MultiplicationExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue23
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptBinaryOperator("/")
				if o2 ~= nil then
					local right = self:acceptExpressions14()
					if right ~= nil then
						local v = _g.sling.model.DivisionExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue23
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptBinaryOperator("%")
					if o3 ~= nil then
						local right = self:acceptExpressions14()
						if right ~= nil then
							local v = _g.sling.model.ModuloExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue23
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do
						local o4 = self:acceptBinaryOperator("...")
						if o4 ~= nil then
							local right = self:acceptExpressions14()
							if right ~= nil then
								local v = _g.sling.model.RangeExpressionNode:instance(left, right)
								do v:setSource(o4) end
								do v:setExclusionType(_g.sling.model.RangeExpressionNode.TYPE_NONE) end
								left = v
								goto _continue23
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do
							local o5 = self:acceptBinaryOperator("..<")
							if o5 ~= nil then
								local right = self:acceptExpressions14()
								if right ~= nil then
									local v = _g.sling.model.RangeExpressionNode:instance(left, right)
									do v:setSource(o5) end
									do v:setExclusionType(_g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND) end
									left = v
									goto _continue23
								end
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
							end
							do
								local o6 = self:acceptBinaryOperator(">..")
								if o6 ~= nil then
									local right = self:acceptExpressions14()
									if right ~= nil then
										local v = _g.sling.model.RangeExpressionNode:instance(left, right)
										do v:setSource(o6) end
										do v:setExclusionType(_g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND) end
										left = v
										goto _continue23
									end
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
								end
								do
									local o7 = self:acceptBinaryOperator(">.<")
									if o7 ~= nil then
										local right = self:acceptExpressions14()
										if right ~= nil then
											local v = _g.sling.model.RangeExpressionNode:instance(left, right)
											do v:setSource(o7) end
											do v:setExclusionType(_g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS) end
											left = v
											goto _continue23
										end
										self.currentTokenColumn = ctc
										self.currentTokenLine = ctl
										do self.iterator:setCurrentPosition(ctp) end
										while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
											do self.commentQueue:pop() end
										end
										self.previousToken = cpt
									end
									do break end
								end
							end
						end
					end
				end
			end
		end
		::_continue23::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions12()
	local left = self:acceptExpressions13()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("..")
			if o1 ~= nil then
				local right = self:acceptExpressions13()
				if right ~= nil then
					local v = _g.sling.model.StringConcatenationExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue24
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptBinaryOperator("+")
				if o2 ~= nil then
					local right = self:acceptExpressions13()
					if right ~= nil then
						local v = _g.sling.model.AdditionExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue24
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptBinaryOperator("-")
					if o3 ~= nil then
						local right = self:acceptExpressions13()
						if right ~= nil then
							local v = _g.sling.model.SubtractionExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue24
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do break end
				end
			end
		end
		::_continue24::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions11()
	local left = self:acceptExpressions12()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("<<")
			if o1 ~= nil then
				local right = self:acceptExpressions12()
				if right ~= nil then
					local v = _g.sling.model.ShiftLeftExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue25
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptBinaryOperator(">>")
				if o2 ~= nil then
					local right = self:acceptExpressions12()
					if right ~= nil then
						local v = _g.sling.model.ShiftRightExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue25
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptBinaryOperator(">>>")
					if o3 ~= nil then
						local right = self:acceptExpressions12()
						if right ~= nil then
							local v = _g.sling.model.ShiftRightExpressionNode:instance(left, right)
							do v:setZeroLeftmostBit(true) end
							do v:setSource(o3) end
							left = v
							goto _continue25
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do break end
				end
			end
		end
		::_continue25::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions10()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if self:acceptToken1("malloc") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local sz = self:acceptExpressions11()
				if sz ~= nil then
					local v = _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create())
					do v:setSource(src) end
					do v:setExpression(sz, false) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		do return self:acceptExpressions11() end
	end
end

function sling.syntax.SlingParser:acceptExpressions9()
	local left = self:acceptExpressions10()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("<")
			if o1 ~= nil then
				local right = self:acceptExpressions10()
				if right ~= nil then
					local v = _g.sling.model.LessThanExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue26
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptBinaryOperator(">")
				if o2 ~= nil then
					local right = self:acceptExpressions10()
					if right ~= nil then
						local v = _g.sling.model.GreaterThanExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue26
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptBinaryOperator("<=")
					if o3 ~= nil then
						local right = self:acceptExpressions10()
						if right ~= nil then
							local v = _g.sling.model.LessOrEqualExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue26
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do
						local o4 = self:acceptBinaryOperator(">=")
						if o4 ~= nil then
							local right = self:acceptExpressions10()
							if right ~= nil then
								local v = _g.sling.model.GreaterOrEqualExpressionNode:instance(left, right)
								do v:setSource(o4) end
								left = v
								goto _continue26
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do
							local o5 = self:acceptBinaryOperator("in")
							if o5 ~= nil then
								local right = self:acceptExpressions10()
								if right ~= nil then
									local v = _g.sling.model.MembershipCheckExpressionNode:instance(left, right)
									do v:setSource(o5) end
									left = v
									goto _continue26
								end
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
							end
							do
								local o6 = self:acceptBinaryOperator("is")
								if o6 ~= nil then
									local right = self:acceptDataType(true)
									if right ~= nil then
										local v = _g.sling.model.TypeCheckExpressionNode:instance(right, left, false)
										do v:setSource(o6) end
										left = v
										goto _continue26
									end
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
								end
								do break end
							end
						end
					end
				end
			end
		end
		::_continue26::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions8()
	local left = self:acceptExpressions9()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("==")
			if o1 ~= nil then
				local right = self:acceptExpressions9()
				if right ~= nil then
					local v = _g.sling.model.EqualsExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue27
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptBinaryOperator("!=")
				if o2 ~= nil then
					local right = self:acceptExpressions9()
					if right ~= nil then
						local v = _g.sling.model.NotEqualsExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue27
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do break end
			end
		end
		::_continue27::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions7()
	local left = self:acceptExpressions8()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("&")
			if o1 ~= nil then
				local right = self:acceptExpressions8()
				if right ~= nil then
					local v = _g.sling.model.BitwiseAndExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue28
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue28::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions6()
	local left = self:acceptExpressions7()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("^")
			if o1 ~= nil then
				local right = self:acceptExpressions7()
				if right ~= nil then
					local v = _g.sling.model.BitwiseXorExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue29
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue29::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions5()
	local left = self:acceptExpressions6()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("|")
			if o1 ~= nil then
				local right = self:acceptExpressions6()
				if right ~= nil then
					local v = _g.sling.model.BitwiseOrExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue30
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue30::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions4()
	local left = self:acceptExpressions5()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("&&")
			if o1 ~= nil then
				local right = self:acceptExpressions5()
				if right ~= nil then
					local v = _g.sling.model.LogicalAndExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue31
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue31::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions3()
	local left = self:acceptExpressions4()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("||")
			if o1 ~= nil then
				local right = self:acceptExpressions4()
				if right ~= nil then
					local v = _g.sling.model.LogicalOrExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue32
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue32::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions2()
	local left = self:acceptExpressions3()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken2(63)
			if o1 ~= nil then
				local trueExpr = self:acceptExpression(false)
				if trueExpr ~= nil and self:acceptToken2(58) ~= nil then
					local falseExpr = self:acceptExpression(false)
					if falseExpr ~= nil then
						local v = _g.sling.model.ConditionalExpressionNode:instance(left, trueExpr, falseExpr)
						do v:setSource(o1) end
						left = v
						goto _continue33
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue33::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpressions1()
	local left = self:acceptExpressions2()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptBinaryOperator("=")
			if o1 ~= nil then
				local right = self:acceptExpressions2()
				if right ~= nil then
					local v = _g.sling.model.AssignmentExpressionNode:forNodes(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue34
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptBinaryOperator("*=")
				if o2 ~= nil then
					local right = self:acceptExpressions2()
					if right ~= nil then
						local v = _g.sling.model.MultiplicationAssignmentExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue34
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptBinaryOperator("/=")
					if o3 ~= nil then
						local right = self:acceptExpressions2()
						if right ~= nil then
							local v = _g.sling.model.DivisionAssignmentExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue34
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do
						local o4 = self:acceptBinaryOperator("%=")
						if o4 ~= nil then
							local right = self:acceptExpressions2()
							if right ~= nil then
								local v = _g.sling.model.ModuloAssignmentExpressionNode:instance(left, right)
								do v:setSource(o4) end
								left = v
								goto _continue34
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do
							local o5 = self:acceptBinaryOperator("+=")
							if o5 ~= nil then
								local right = self:acceptExpressions2()
								if right ~= nil then
									local v = _g.sling.model.AdditionAssignmentExpressionNode:instance(left, right)
									do v:setSource(o5) end
									left = v
									goto _continue34
								end
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
							end
							do
								local o6 = self:acceptBinaryOperator("-=")
								if o6 ~= nil then
									local right = self:acceptExpressions2()
									if right ~= nil then
										local v = _g.sling.model.SubtractionAssignmentExpressionNode:instance(left, right)
										do v:setSource(o6) end
										left = v
										goto _continue34
									end
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
								end
								do
									local o7 = self:acceptBinaryOperator("<<=")
									if o7 ~= nil then
										local right = self:acceptExpressions2()
										if right ~= nil then
											local v = _g.sling.model.ShiftLeftAssignmentExpressionNode:instance(left, right)
											do v:setSource(o7) end
											left = v
											goto _continue34
										end
										self.currentTokenColumn = ctc
										self.currentTokenLine = ctl
										do self.iterator:setCurrentPosition(ctp) end
										while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
											do self.commentQueue:pop() end
										end
										self.previousToken = cpt
									end
									do
										local o8 = self:acceptBinaryOperator(">>=")
										if o8 ~= nil then
											local right = self:acceptExpressions2()
											if right ~= nil then
												local v = _g.sling.model.ShiftRightAssignmentExpressionNode:instance(left, right)
												do v:setSource(o8) end
												left = v
												goto _continue34
											end
											self.currentTokenColumn = ctc
											self.currentTokenLine = ctl
											do self.iterator:setCurrentPosition(ctp) end
											while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
												do self.commentQueue:pop() end
											end
											self.previousToken = cpt
										end
										do
											local o9 = self:acceptBinaryOperator(">>>=")
											if o9 ~= nil then
												local right = self:acceptExpressions2()
												if right ~= nil then
													local v = _g.sling.model.ShiftRightAssignmentExpressionNode:instance(left, right)
													do v:setSource(o9) end
													do v:setZeroLeftmostBit(true) end
													left = v
													goto _continue34
												end
												self.currentTokenColumn = ctc
												self.currentTokenLine = ctl
												do self.iterator:setCurrentPosition(ctp) end
												while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
													do self.commentQueue:pop() end
												end
												self.previousToken = cpt
											end
											do
												local o10 = self:acceptBinaryOperator("&=")
												if o10 ~= nil then
													local right = self:acceptExpressions2()
													if right ~= nil then
														local v = _g.sling.model.BitwiseAndAssignmentExpressionNode:instance(left, right)
														do v:setSource(o10) end
														left = v
														goto _continue34
													end
													self.currentTokenColumn = ctc
													self.currentTokenLine = ctl
													do self.iterator:setCurrentPosition(ctp) end
													while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
														do self.commentQueue:pop() end
													end
													self.previousToken = cpt
												end
												do
													local o11 = self:acceptBinaryOperator("^=")
													if o11 ~= nil then
														local right = self:acceptExpressions2()
														if right ~= nil then
															local v = _g.sling.model.BitwiseXorAssignmentExpressionNode:instance(left, right)
															do v:setSource(o11) end
															left = v
															goto _continue34
														end
														self.currentTokenColumn = ctc
														self.currentTokenLine = ctl
														do self.iterator:setCurrentPosition(ctp) end
														while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
															do self.commentQueue:pop() end
														end
														self.previousToken = cpt
													end
													do
														local o12 = self:acceptBinaryOperator("|=")
														if o12 ~= nil then
															local right = self:acceptExpressions2()
															if right ~= nil then
																local v = _g.sling.model.BitwiseOrAssignmentExpressionNode:instance(left, right)
																do v:setSource(o12) end
																left = v
																goto _continue34
															end
															self.currentTokenColumn = ctc
															self.currentTokenLine = ctl
															do self.iterator:setCurrentPosition(ctp) end
															while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
																do self.commentQueue:pop() end
															end
															self.previousToken = cpt
														end
														do break end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		::_continue34::
	end
	do return left end
end

function sling.syntax.SlingParser:acceptExpression(allowMultipleExpression)
	local exp = self:acceptExpressions1()
	if allowMultipleExpression and self:acceptToken2(44) ~= nil then
		local v = _g.sling.model.MultipleExpressionNode._construct0(_g.sling.model.MultipleExpressionNode._create())
		do v:addToExpressions(exp) end
		do v:setSource(exp:getSource()) end
		while true do
			local x = self:acceptExpressions1()
			if not (x ~= nil) then
				do self:skipSpaces() end
				do self:updateStagingToken() end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("expression"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			end
			do v:addToExpressions(x) end
			if not (self:acceptToken2(44) ~= nil) then
				do break end
			end
		end
		exp = v
	end
	do return exp end
end

function sling.syntax.SlingParser:parseExpression(allowMultipleExpression)
	local v = self:acceptExpression(allowMultipleExpression)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("expression"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptErrorStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("ERROR")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local message = self:acceptStringLiteral()
			if not (message ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ErrorStatementNode._construct0(_g.sling.model.ErrorStatementNode._create())
				do v:setSource(start) end
				do v:setMessage(message) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptTraceStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("TRACE")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local message = self:acceptStringLiteral()
			if not (message ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ErrorStatementNode._construct0(_g.sling.model.ErrorStatementNode._create())
				do v:setSource(start) end
				do v:setMessage(message) end
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("TRACE statement", start)) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptLoopVariableDeclaration()
	local src = self:acceptToken1("var")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local name = self:parseDeclarationIdentifier()
		local dt = nil
		local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
		if self:acceptToken1("as") ~= nil then
			dt = self:parseDataType(true)
		end
		while true do
			local cm = self:acceptCustomModifier()
			if cm ~= nil then
				do mods:addCustom(cm) end
			else
				do break end
			end
		end
		do
			local expr = nil
			if self:acceptToken2(61) ~= nil then
				expr = self:parseExpression(true)
			end
			if dt == nil then
				if expr ~= nil then
					dt = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
				else
					dt = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
				end
			end
			do
				local v = _g.sling.model.VariableDeclarationNode:instance(dt, name, nil)
				do v:setSource(src) end
				do v:setModifiers(mods) end
				do v:setInitializer(expr, false) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptForStatementInitializer()
	local v = self:acceptLoopVariableDeclaration()
	if v ~= nil then
		do return v end
	end
	do
		local xp = self:acceptExpression(false)
		if xp ~= nil then
			do return xp end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:acceptForStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("for")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local parens = self:acceptToken2(40)
			local st1 = {}
			if self:acceptToken2(59) ~= nil then
				do _g.jk.lang.Vector:append(st1, _g.sling.model.EmptyStatementNode._construct0(_g.sling.model.EmptyStatementNode._create())) end
			else
				while true do
					local i = self:acceptForStatementInitializer()
					if not (i ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do _g.jk.lang.Vector:append(st1, i) end
					if self:acceptToken2(44) == nil then
						do break end
					end
				end
				if parens ~= nil then
					if not (self:acceptToken2(59) ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
				else
					do self:parseToken2(59) end
				end
			end
			do
				local st2 = self:parseExpression(true)
				do self:parseToken2(59) end
				do
					local st3 = self:parseExpression(true)
					if parens ~= nil then
						do self:parseToken2(41) end
					end
					do
						local block = self:parseControlStructureBlock()
						local v = _g.sling.model.ForStatementNode:instance(nil, st2, nil, block)
						if st1 ~= nil then
							local n = 0
							local m = _g.jk.lang.Vector:getSize(st1)
							do
								n = 0
								while n < m do
									local st = _vm:to_table_with_key(st1[n + 1], '_isType.sling.common.NodeObject')
									if st ~= nil then
										do v:addInitializer(st) end
									end
									do n = n + 1 end
								end
							end
						end
						do v:addFinalizer(st3) end
						do v:setSource(start) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseControlStructureBlock()
	local block = self:acceptBlockOrStatement(false, nil)
	if block ~= nil then
		do return block end
	end
	do
		local eos = self:acceptEndOfStatementToken()
		if eos ~= nil then
			do return nil end
		end
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("block, single-statement block or end of statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		do return nil end
	end
end

function sling.syntax.SlingParser:parseFunctionBlock(meta)
	local block = self:acceptBlockOrStatement(true, meta)
	if block ~= nil then
		do return block end
	end
	do
		local eos = self:acceptEndOfStatementToken()
		if eos ~= nil then
			do return nil end
		end
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("block, single-statement block or end of statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		do return nil end
	end
end

function sling.syntax.SlingParser:acceptAssertStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("assert")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local expression = self:acceptExpression(true)
			if not (expression ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local block = self:parseControlStructureBlock()
				local v = _g.sling.model.AssertStatementNode:forChild(expression)
				do v:setSource(start) end
				do v:setStyle(_g.sling.model.AssertStatementNode.STYLE_RETURN) end
				do v:setErrorBlock(block, false) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptBlockOrStatement(newlineForBrace, meta)
	local statement = self:acceptToken2(58)
	if statement ~= nil then
		do self:parseNewlineToken() end
		do
			local stmt = self:parseStatement()
			local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
			do v:setSource(statement) end
			do self:addDeclarationToContainer(v, stmt) end
			do return v end
		end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local newline = self:acceptNewlineToken()
			local block = self:acceptBlock(true, meta)
			if not (block ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			if newlineForBrace then
				if newline == nil then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Expected: " .. "newline", block)) end
				end
			elseif newline ~= nil then
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Improper newline", newline)) end
			end
			do return block end
		end
	end
end

function sling.syntax.SlingParser:parseBlockOrStatement(newlineForBrace, meta)
	local v = self:acceptBlockOrStatement(newlineForBrace, meta)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("block or statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptIfStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("if")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local condition = nil
			if self:getNextCharacter() == 40 then
				if not self.acceptDeprecatedConstructs then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not ((function()
					condition = self:acceptExpression(true)
					do return condition end
				end)() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:acceptToken2(41) ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:peekToken2(58) or self:peekToken2(123)) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated if syntax with parenthesis", start)) end
			else
				if not ((function()
					condition = self:acceptExpression(true)
					do return condition end
				end)() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:peekToken2(58) or self:peekToken2(123)) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
			end
			do
				local block = self:parseControlStructureBlock()
				if block == nil then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `if' statement has no block. This doesn't make sense.", start)) end
				end
				do
					local elseBlock = nil
					local elseComment = nil
					do
						local ctc = self.currentTokenColumn
						local ctl = self.currentTokenLine
						local ctp = self.iterator:getCurrentPosition()
						local cqs = 0
						if self.commentQueue ~= nil then
							cqs = self.commentQueue:getSize()
						end
						do
							local cpt = self.previousToken
							elseComment = self:acceptCommentWithNewlines()
							do self:skipUnnecessaryEmptyLines() end
							do
								local elseToken = self:acceptToken1("else")
								if elseToken ~= nil then
									local childIf = self:acceptIfStatement()
									if childIf ~= nil then
										elseBlock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
										do elseBlock:addNode(childIf) end
										do elseBlock:setSource(elseToken) end
									else
										elseBlock = self:parseControlStructureBlock()
										if elseBlock == nil then
											do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `else' statement has no block. This doesn't make sense.", elseToken)) end
										end
									end
								else
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
								end
							end
						end
					end
					do
						local v = _g.sling.model.IfStatementNode:instance(condition, block, elseBlock)
						do v:setSource(start) end
						do v:setElseBlockComment(elseComment, false) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptWhileStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("while")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local condition = nil
			if self:getNextCharacter() == 40 then
				if not self.acceptDeprecatedConstructs then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not ((function()
					condition = self:acceptExpression(true)
					do return condition end
				end)() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:acceptToken2(41) ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:peekToken2(58) or self:peekToken2(123)) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated while syntax with parenthesis", start)) end
			elseif not ((function()
				condition = self:acceptExpression(true)
				do return condition end
			end)() ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local block = self:parseControlStructureBlock()
				local elseBlock = nil
				if self:acceptToken1("else") ~= nil then
					elseBlock = self:parseControlStructureBlock()
				end
				do
					local v = _g.sling.model.WhileStatementNode:instance(condition, block, elseBlock)
					do v:setSource(start) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptBreakStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("break")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:acceptEndOfStatementToken() ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local v = _g.sling.model.BreakStatementNode._construct0(_g.sling.model.BreakStatementNode._create())
			do v:setSource(start) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptContinueStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("continue")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:acceptEndOfStatementToken() ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local v = _g.sling.model.ContinueStatementNode._construct0(_g.sling.model.ContinueStatementNode._create())
			do v:setSource(start) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptDoStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("do")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekToken2(58) or self:peekToken2(123)) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local block = self:parseControlStructureBlock()
			local parens = false
			if self.acceptDeprecatedConstructs and self:acceptToken1("while(") ~= nil then
				parens = true
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated syntax with parenthesis", self:getAcceptedToken())) end
			else
				do self:parseToken1("while") end
			end
			do
				local condition = self:parseExpression(true)
				if parens then
					do self:parseToken2(41) end
				end
				do self:parseEndOfStatementToken() end
				do
					local v = _g.sling.model.DoWhileStatementNode:instance(condition, block)
					do v:setSource(start) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptPrintLineStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if self.acceptDeprecatedConstructs then
			local ps = self:acceptToken1("PRINT")
			if ps ~= nil then
				local expr = self:acceptExpression(true)
				if not (self:acceptEndOfStatementToken() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", ps)) end
				do
					local v = _g.sling.model.PrintLineStatementNode:forExpression(expr)
					do v:setSource(ps) end
					do return v end
				end
			end
		end
		do
			local start = self:acceptToken1("println")
			if not (start ~= nil) then
				do return nil end
			end
			if not (self:peekNextCharacter() ~= 40) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local expr = self:acceptExpression(true)
				if not (self:acceptEndOfStatementToken() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do
					local v = _g.sling.model.PrintLineStatementNode:forExpression(expr)
					do v:setSource(start) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptPrintStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("print")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local expr = self:acceptExpression(true)
			if not (self:acceptEndOfStatementToken() ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local v = _g.sling.model.PrintStatementNode:forExpression(expr)
				do v:setSource(start) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptReturnStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("return")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local isDeprecated = false
			if self:peekNextCharacter() == 40 then
				if not self.acceptDeprecatedConstructs then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				isDeprecated = true
			end
			do
				local expr = nil
				if not (self:acceptEndOfStatementToken() ~= nil) then
					if not ((function()
						expr = self:acceptExpression(true)
						do return expr end
					end)() ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:parseEndOfStatementToken() end
				end
				if isDeprecated then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated return syntax with parenthesis", start)) end
				end
				do
					local v = _g.sling.model.ReturnStatementNode:forExpression(expr)
					do v:setSource(start) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptTryStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("try")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekToken2(58) or self:peekToken2(123)) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local v = _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create())
			do v:setSource(start) end
			do
				local tryBlock = self:parseControlStructureBlock()
				if tryBlock == nil then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `try' statement has no block.", start)) end
					tryBlock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
				end
				do v:setTryBlock(tryBlock, false) end
				while true do
					if self:acceptToken1("catch") == nil then
						do break end
					end
					do
						local cb = _g.sling.model.CatchBlockNode._construct0(_g.sling.model.CatchBlockNode._create())
						do cb:setSource(self:getAcceptedToken()) end
						do
							local parens = self:acceptToken2(40)
							local variable = self:acceptParameterVariableDeclaration(false)
							if variable ~= nil then
								do cb:addToExceptions(variable) end
								if self:acceptToken2(44) ~= nil then
									while true do
										do cb:addToExceptions(self:parseParameterVariableDeclaration(false)) end
										if not (self:acceptToken2(44) ~= nil) then
											do break end
										end
									end
								end
							end
							if parens ~= nil then
								do self:parseToken2(41) end
							end
							do cb:setBlock(self:parseControlStructureBlock(), false) end
							do v:addToCatchBlocks(cb) end
						end
					end
				end
				while true do
					if v:getFinallyBlock() == nil then
						local finally = self:acceptToken1("finally")
						if finally ~= nil then
							local fb = self:parseControlStructureBlock()
							if not (fb ~= nil) then
								do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `finally' statement has no block.", finally)) end
								fb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
							end
							do v:setFinallyBlock(fb, false) end
							goto _continue35
						end
					end
					if v:getElseBlock() == nil then
						local elset = self:acceptToken1("else")
						if elset ~= nil then
							local fb = self:parseControlStructureBlock()
							if not (fb ~= nil) then
								do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `else' statement has no block.", elset)) end
								fb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
							end
							do v:setElseBlock(fb, false) end
							goto _continue35
						end
					end
					do break end
					::_continue35::
				end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptThrowStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("throw")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local expr = self:acceptExpression(true)
			if not (expr ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ThrowStatementNode:forExpression(expr)
				do v:setSource(start) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptCriticalSection()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("critical")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local ob = nil
			if self:acceptToken2(40) ~= nil then
				ob = self:acceptExpression(true)
				do self:parseToken2(41) end
			end
			if not (self:peekToken2(58) or self:peekToken2(123)) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local block = self:parseControlStructureBlock()
				if block == nil then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `critical' statement has no block. This doesn't make sense.", start)) end
				end
				if ob == nil then
					ob = _g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create())
				end
				do
					local v = _g.sling.model.CriticalSectionBlockNode:instance(ob, block)
					do v:setSource(start) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptEmptyStatement()
	local semi = self:acceptSemicolonToken()
	if semi ~= nil then
		do self:acceptNewlineToken() end
		do
			local v = _g.sling.model.EmptyStatementNode._construct0(_g.sling.model.EmptyStatementNode._create())
			do v:setSource(semi) end
			do return v end
		end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local nopt = self:acceptToken1("nop")
			if nopt ~= nil then
				while self:skipSpaceCharacter() do
				end
				do
					local v = _g.sling.model.EmptyStatementNode._construct0(_g.sling.model.EmptyStatementNode._create())
					do v:setSource(nopt) end
					do
						local comment = self:acceptImmediateSlashSlashCommentToken()
						if comment ~= nil then
							local str = comment:getValue()
							if str == nil then
								str = ""
							end
							do v:setComment(_g.sling.syntax.SlingParserUtil:cleanComment(str)) end
						elseif not (self:acceptNewlineToken() ~= nil) then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do return v end
					end
				end
			end
			do return nil end
		end
	end
end

function sling.syntax.SlingParser:acceptLoopStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("loop")
		if not (start ~= nil) then
			do return nil end
		end
		if not (self:peekToken2(58) or self:peekToken2(123)) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local block = self:parseControlStructureBlock()
			local v = _g.sling.model.WhileStatementNode:instance(_g.sling.model.BooleanLiteralExpressionNode:forValue(true), block, nil)
			do v:setSource(start) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptStatement()
	local currentEntity = self:peekEntity()
	if currentEntity ~= nil then
		if currentEntity:hasCustomModifier("domcomponent") then
			local stmt = self:acceptDomComponentStatement()
			if stmt ~= nil then
				do return stmt end
			end
		end
		if currentEntity:hasCustomModifier("webapi") or currentEntity:hasCustomModifier("webapi2") then
			local stmt = self:acceptWebApiStatement()
			if stmt ~= nil then
				do return stmt end
			end
		end
	end
	do
		local templateStatement = self:acceptTemplateStatement()
		if templateStatement ~= nil then
			do return templateStatement end
		end
		do
			local ifdef = self:acceptIfdef(_g.sling.syntax.SlingParser.NODECONTEXT_STATEMENTBLOCK)
			if ifdef ~= nil then
				do return ifdef end
			end
			do
				local ifndef = self:acceptIfndef(_g.sling.syntax.SlingParser.NODECONTEXT_STATEMENTBLOCK)
				if ifndef ~= nil then
					do return ifndef end
				end
				do
					local emptyStatement = self:acceptEmptyStatement()
					if emptyStatement ~= nil then
						do return emptyStatement end
					end
					do
						local block = self:acceptBlock(true, nil)
						if block ~= nil then
							do return block end
						end
						do
							local criticalSection = self:acceptCriticalSection()
							if criticalSection ~= nil then
								do return criticalSection end
							end
							do
								local assertStatement = self:acceptAssertStatement()
								if assertStatement ~= nil then
									do return assertStatement end
								end
								do
									local ifStatement = self:acceptIfStatement()
									if ifStatement ~= nil then
										do return ifStatement end
									end
									do
										local switchStatement = self:acceptSwitchStatement()
										if switchStatement ~= nil then
											do return switchStatement end
										end
										do
											local whileStatement = self:acceptWhileStatement()
											if whileStatement ~= nil then
												do return whileStatement end
											end
											do
												local doStatement = self:acceptDoStatement()
												if doStatement ~= nil then
													do return doStatement end
												end
												do
													local forStatement = self:acceptForStatement()
													if forStatement ~= nil then
														do return forStatement end
													end
													do
														local breakStatement = self:acceptBreakStatement()
														if breakStatement ~= nil then
															do return breakStatement end
														end
														do
															local nested = self:acceptFunctionDeclarationStatement(nil)
															if nested ~= nil then
																do return nested end
															end
															do
																local continueStatement = self:acceptContinueStatement()
																if continueStatement ~= nil then
																	do return continueStatement end
																end
																do
																	local tryStatement = self:acceptTryStatement()
																	if tryStatement ~= nil then
																		do return tryStatement end
																	end
																	do
																		local throwStatement = self:acceptThrowStatement()
																		if throwStatement ~= nil then
																			do return throwStatement end
																		end
																		do
																			local error = self:acceptErrorStatement()
																			if error ~= nil then
																				do return error end
																			end
																			do
																				local trace = self:acceptTraceStatement()
																				if trace ~= nil then
																					do return trace end
																				end
																				do
																					local printLineStatement = self:acceptPrintLineStatement()
																					if printLineStatement ~= nil then
																						do return printLineStatement end
																					end
																					do
																						local printStatement = self:acceptPrintStatement()
																						if printStatement ~= nil then
																							do return printStatement end
																						end
																						do
																							local returnStatement = self:acceptReturnStatement()
																							if returnStatement ~= nil then
																								do return returnStatement end
																							end
																							do
																								local langDeclaration = self:acceptLangDeclaration(false, false)
																								if langDeclaration ~= nil then
																									do return langDeclaration end
																								end
																								do
																									local foreachStatement = self:acceptForeachStatement()
																									if foreachStatement ~= nil then
																										do return foreachStatement end
																									end
																									do
																										local loopStatement = self:acceptLoopStatement()
																										if loopStatement ~= nil then
																											do return loopStatement end
																										end
																										do
																											local vds = self:acceptVariableDeclarationStatement(nil)
																											if vds ~= nil then
																												do return vds end
																											end
																											do
																												local xp = self:acceptExpression(true)
																												if xp ~= nil then
																													do self:parseEndOfStatementToken() end
																													do return xp end
																												end
																												do return nil end
																											end
																										end
																									end
																								end
																							end
																						end
																					end
																				end
																			end
																		end
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseStatement()
	local v = self:acceptStatement()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptEntityBlockDeclaration()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local container = nil
		while true do
			local mod = self:acceptCommonModifierIdForEntity()
			if not (mod ~= nil) then
				do break end
			end
			if not (container ~= nil) then
				container = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
			end
			do container:addCommon(mod) end
		end
		do
			local start = self:acceptToken2(123)
			if not (start ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
				do v:setSource(start) end
				if container ~= nil then
					do v:setModifiers(container) end
				end
				do self:parseNewlineToken() end
				while true do
					local comment = self:acceptCommentWithNewlines()
					if comment ~= nil then
						do self:addDeclarationToContainer(v, comment) end
						goto _continue36
					end
					if self:skipUnnecessaryEmptyLines() > 0 then
						goto _continue36
					end
					if self:acceptToken2(125) ~= nil then
						do break end
					end
					do
						local vds = self:parseEntityDeclaration(false)
						if vds ~= nil then
							do self:addDeclarationToContainer(v, vds) end
							goto _continue36
						end
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`}' or statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
					::_continue36::
				end
				do self:parseNewlineToken() end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptBlock(endWithNewLine, meta)
	local start = self:acceptToken2(123)
	if not (start ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
		do v:setSource(start) end
		do
			local comment = self:acceptComment()
			if comment ~= nil then
				do v:addNode(comment) end
			end
			do self:parseNewlineToken() end
			while true do
				local comment = self:acceptCommentWithNewlines()
				if comment ~= nil then
					do self:addDeclarationToContainer(v, comment) end
					goto _continue37
				end
				if self:skipUnnecessaryEmptyLines() > 0 then
					goto _continue37
				end
				if self:acceptBlockMetaInformation(meta) then
					goto _continue37
				end
				if self:acceptToken2(125) ~= nil then
					do break end
				end
				do
					local stmt = self:acceptStatement()
					if stmt ~= nil then
						do self:addDeclarationToContainer(v, stmt) end
						goto _continue37
					end
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`}' or statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				::_continue37::
			end
			if endWithNewLine then
				do self:parseNewlineToken() end
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:parseBlock(endWithNewLine, meta)
	local v = self:acceptBlock(endWithNewLine, meta)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("block"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptInclude(root, context)
	if not (root ~= nil) then
		do return false end
	end
	do
		local isEntity = (_vm:to_table_with_key(root, '_isType.sling.model.EntityDeclarationNode') ~= nil)
		if isEntity then
			do self:pushEntity(root) end
		end
		do
			local v = self:doAcceptInclude(root, context)
			if isEntity then
				do self:popEntity() end
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:doAcceptInclude(root, context)
	local start = self:acceptToken1("INCLUDE")
	if not (start ~= nil) then
		do return false end
	end
	do
		local parens = self:acceptToken2(40)
		local filename = self:parseStringLiteral()
		if _g.jk.lang.String:isEmpty(filename) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty filename", start, _g.jk.lang.StackTrace:generate()))
		end
		if parens ~= nil then
			do self:parseToken2(41) end
		end
		do self:parseEndOfStatementToken() end
		do
			local ff = self:getRelativeFile(filename)
			if ff == nil or ff:isFile() == false then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Specified file does not exist", start, _g.jk.lang.StackTrace:generate()))
			end
			do
				local parser = _g.sling.syntax.SlingParser._construct0(_g.sling.syntax.SlingParser._create())
				if context == nil or context == _g.sling.syntax.SlingParser.NODECONTEXT_NAMESPACE then
					local bb = parser:parseFileAsNamespaceDeclarations(ff)
					if not (bb ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed in processing the included file", start, _g.jk.lang.StackTrace:generate()))
					end
					do
						local array = bb:exportNodes()
						if array ~= nil then
							local n = 0
							local m = _g.jk.lang.Vector:getSize(array)
							do
								n = 0
								while n < m do
									local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
									if node ~= nil then
										do root:addNode(node) end
									end
									do n = n + 1 end
								end
							end
						end
					end
				elseif context == _g.sling.syntax.SlingParser.NODECONTEXT_ENTITY then
					local bb = parser:parseFileAsEntityDeclarations(ff)
					if not (bb ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed in processing the included file", start, _g.jk.lang.StackTrace:generate()))
					end
					do
						local array2 = bb:exportNodes()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
									if node ~= nil then
										do root:addNode(node) end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
				elseif context == _g.sling.syntax.SlingParser.NODECONTEXT_STATEMENTBLOCK then
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not supported: INCLUDE inside a statement block", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				else
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown node context in parseInclude: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(context)), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				do
					local array3 = parser:getParseMessages()
					if array3 ~= nil then
						local n3 = 0
						local m3 = _g.jk.lang.Vector:getSize(array3)
						do
							n3 = 0
							while n3 < m3 do
								local message = array3[n3 + 1]
								if message ~= nil then
									do self:onParseMessage(message) end
								end
								do n3 = n3 + 1 end
							end
						end
					end
					do return true end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptTemplateStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("TEMPLATE")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local filename = self:acceptStringLiteral()
			if not (filename ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			if _g.jk.lang.String:isEmpty(filename) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty filename", start, _g.jk.lang.StackTrace:generate()))
			end
			do self:acceptToken2(44) end
			do
				local sym = self:parseSymbolReference()
				do self:parseEndOfStatementToken() end
				do
					local v = _g.sling.model.TemplateStatementNode._construct0(_g.sling.model.TemplateStatementNode._create())
					do v:setSource(start) end
					do v:setName(filename) end
					do v:setRelativeTo(self:getCurrentFile()) end
					do v:setSymbol(sym, false) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptCommentWithNewlines()
	local icp = self:getImproperCommentPolicy()
	do self:setImproperCommentPolicy(_g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_NOOP) end
	do
		local v = self:doAcceptCommentWithNewlines()
		do self:setImproperCommentPolicy(icp) end
		do return v end
	end
end

function sling.syntax.SlingParser:doAcceptCommentWithNewlines()
	local v = self:acceptComment()
	if v ~= nil then
		if not (self:acceptNewlineToken() ~= nil) then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("No newline after comment", self:getStagingToken())) end
		end
		do return v end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local nls = nil
			while true do
				local v2 = self:acceptComment()
				if v2 ~= nil then
					if nls ~= nil then
						do _g.jk.lang.Vector:removeLast(nls) end
						if nls ~= nil then
							local n = 0
							local m = _g.jk.lang.Vector:getSize(nls)
							do
								n = 0
								while n < m do
									local nl = nls[n + 1]
									if nl ~= nil then
										do self:onUnnecessaryEmptyLine(nl) end
									end
									do n = n + 1 end
								end
							end
						end
					end
					do self:acceptNewlineToken() end
					do self:acceptNewlineToken() end
					do return v2 end
				end
				do
					local nl = self:acceptNewlineToken()
					if nl ~= nil then
						if nls == nil then
							nls = {}
						end
						do _g.jk.lang.Vector:append(nls, nl) end
						goto _continue38
					end
					do break end
				end
				::_continue38::
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
	end
end

function sling.syntax.SlingParser:skipUnnecessaryEmptyLines()
	local v = 0
	while true do
		if self:acceptNewlineToken() ~= nil then
			do v = v + 1 end
		else
			do break end
		end
	end
	do return v end
end

function sling.syntax.SlingParser:doAcceptIfdef(context, isIfndef)
	local token = "IFDEF"
	if isIfndef then
		token = "IFNDEF"
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local start = self:acceptToken1(token)
			if not (start ~= nil) then
				do return nil end
			end
			do
				local parens = false
				if self.acceptDeprecatedConstructs and self:acceptToken2(40) ~= nil then
					parens = true
				end
				do
					local value = self:acceptStringLiteral()
					if not (value ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do
						local xpr = _g.sling.model.PreprocessorIsDefinedExpressionNode:forVariable(value)
						if parens then
							do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated IFDEF syntax with parenthesis", start)) end
							do self:parseToken2(41) end
						end
						do self:acceptNewlineToken() end
						do
							local ifBlock = self:parseFlatBlockInContext(context, true)
							local elseBlock = nil
							local elseComment = nil
							do
								local ctc = self.currentTokenColumn
								local ctl = self.currentTokenLine
								local ctp = self.iterator:getCurrentPosition()
								local cqs = 0
								if self.commentQueue ~= nil then
									cqs = self.commentQueue:getSize()
								end
								do
									local cpt = self.previousToken
									elseComment = self:acceptCommentWithNewlines()
									do self:skipUnnecessaryEmptyLines() end
									if self:acceptToken1("ELSE") ~= nil then
										local ifdef = self:doAcceptIfdef(context, false)
										if ifdef ~= nil then
											elseBlock = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
											do elseBlock:addNode(ifdef) end
										else
											local ifndef = self:doAcceptIfdef(context, true)
											if ifndef ~= nil then
												elseBlock = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
												do elseBlock:addNode(ifndef) end
											else
												do self:acceptNewlineToken() end
												elseBlock = self:parseFlatBlockInContext(context, true)
											end
										end
									else
										self.currentTokenColumn = ctc
										self.currentTokenLine = ctl
										do self.iterator:setCurrentPosition(ctp) end
										while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
											do self.commentQueue:pop() end
										end
										self.previousToken = cpt
									end
								end
							end
							if isIfndef then
								xpr = _g.sling.model.LogicalNotExpressionNode:forExpression(xpr)
							end
							do
								local v = _g.sling.model.PreprocessorIfStatementNode:instance(xpr, ifBlock, elseBlock)
								do v:setSource(start) end
								do v:setElseBlockComment(elseComment, false) end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptIfdef(context)
	do return self:doAcceptIfdef(context, false) end
end

function sling.syntax.SlingParser:acceptIfndef(context)
	do return self:doAcceptIfdef(context, true) end
end

function sling.syntax.SlingParser:getExistingChildNamespace(root, name)
	if not (root ~= nil) then
		do return nil end
	end
	if not (name ~= nil) then
		do return nil end
	end
	do
		local idx = root:getNodeIndexForName(name)
		if not (idx ~= nil) then
			do return nil end
		end
		if idx ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(idx)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(idx[n + 1], '_isType.sling.model.NamespaceNode')
					if node ~= nil then
						do return node end
					end
					do n = n + 1 end
				end
			end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:getCreateNamespace(root, nss)
	local v = root
	if nss ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(nss)
		do
			n = 0
			while n < m do
				local ns = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(nss[n + 1])
				if ns ~= nil then
					local x = self:getExistingChildNamespace(v, ns)
					if x ~= nil then
						v = x
						goto _continue39
					end
					do
						local nsn = _g.sling.model.NamespaceNode:forName(ns)
						do v:addNode(nsn) end
						v = nsn
					end
				end
				::_continue39::
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.syntax.SlingParser:applyImportsToDeclaration(dec, addImports)
	if not (dec ~= nil and addImports ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(dec, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
		local ee = dec
		if addImports ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(addImports)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(addImports[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						local ndup = _g.sling.util.NodeUtil:dupAsNode(node)
						if (_vm:to_table_with_key(ndup, '_isType.sling.model.SymbolNode') ~= nil) then
							do ee:addToImportNamespaces(_vm:to_table_with_key(ndup, '_isType.sling.model.SymbolNode')) end
						elseif (_vm:to_table_with_key(ndup, '_isType.sling.model.ImportPackageStatementNode') ~= nil) then
							do ee:addToImportNamespaces(ndup:getPackage()) end
						elseif (_vm:to_table_with_key(ndup, '_isType.sling.model.ImportStaticMemberStatementNode') ~= nil) then
							do ee:addToImportStaticNamespaces(ndup) end
						elseif (_vm:to_table_with_key(ndup, '_isType.sling.model.ImportEntityStatementNode') ~= nil) then
							do ee:addToImportEntities(ndup) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return end
	end
	if (_vm:to_table_with_key(dec, '_isType.sling.model.PreprocessorIfStatementNode') ~= nil) then
		local ib = dec:getIfBlock()
		if ib ~= nil then
			local array = ib:getNodes()
			if array ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m2 do
						local ibn = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if ibn ~= nil then
							do self:applyImportsToDeclaration(ibn, addImports) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
		end
		do
			local eb = dec:getElseBlock()
			if eb ~= nil then
				local array2 = eb:getNodes()
				if array2 ~= nil then
					local n3 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n3 = 0
						while n3 < m3 do
							local ebn = _vm:to_table_with_key(array2[n3 + 1], '_isType.sling.common.NodeObject')
							if ebn ~= nil then
								do self:applyImportsToDeclaration(ebn, addImports) end
							end
							do n3 = n3 + 1 end
						end
					end
				end
			end
			do return end
		end
	end
end

function sling.syntax.SlingParser:parseFlatBlockInContext(context, requireBraces)
	local v = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
	if requireBraces then
		do self:parseToken2(123) end
		do
			local comment = self:acceptComment()
			if comment ~= nil then
				do v:addNode(comment) end
			end
			do self:parseNewlineToken() end
		end
	end
	do
		local myImports = nil
		while true do
			local comment = self:acceptCommentWithNewlines()
			if comment ~= nil then
				do self:addDeclarationToContainer(v, comment) end
				goto _continue40
			end
			if requireBraces then
				if self:acceptToken2(125) ~= nil then
					do self:parseNewlineToken() end
					do break end
				end
			elseif self:acceptEOF() ~= nil then
				do break end
			end
			if self:skipUnnecessaryEmptyLines() > 0 then
				goto _continue40
			end
			if self:acceptInclude(v, context) then
				goto _continue40
			end
			do
				local dest = v
				local dec = nil
				if context == _g.sling.syntax.SlingParser.NODECONTEXT_NAMESPACE then
					if self:acceptToken1("import") ~= nil then
						if not (myImports ~= nil) then
							myImports = {}
						end
						if self:acceptToken1("static") ~= nil then
							do _g.jk.lang.Vector:append(myImports, self:parseImportStaticDeclaration(self:getAcceptedToken())) end
							goto _continue40
						end
						do _g.jk.lang.Vector:append(myImports, self:parseImportDeclaration(self:getAcceptedToken())) end
						goto _continue40
					end
					if self:acceptToken1("use") ~= nil then
						if not (myImports ~= nil) then
							myImports = {}
						end
						do _g.jk.lang.Vector:append(myImports, self:parseUseDeclaration(self:getAcceptedToken())) end
						goto _continue40
					end
					do
						local nss = nil
						if self.allowCustomEntityNamespaces then
							nss = {}
						end
						dec = self:parseNamespaceDeclaration(nss)
						if _g.jk.lang.Vector:getSize(nss) > 0 then
							if not ((function()
								dest = self:getCreateNamespace(dest, nss)
								do return dest end
							end)() ~= nil) then
								do return nil end
							end
						end
					end
				elseif context == _g.sling.syntax.SlingParser.NODECONTEXT_ENTITY then
					dec = self:parseEntityDeclaration(true)
				elseif context == _g.sling.syntax.SlingParser.NODECONTEXT_STATEMENTBLOCK then
					dec = self:parseStatement()
				else
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown node context: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(context)) .. "'", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				if not (dec ~= nil) then
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				if myImports ~= nil then
					do self:applyImportsToDeclaration(dec, myImports) end
				end
				do self:addDeclarationToContainer(dest, dec) end
			end
			::_continue40::
		end
		do return v end
	end
end

function sling.syntax.SlingParser:isFixme(comment)
	if not (comment ~= nil) then
		do return false end
	end
	do
		local text = comment:getText()
		if not (text ~= nil) then
			do return false end
		end
		do
			local tt = _g.jk.lang.String:strip(text)
			if _g.jk.lang.String:startsWith(tt, "FIXME", 0) or _g.jk.lang.String:startsWith(tt, "TODO", 0) or _g.jk.lang.String:startsWith(tt, "FIX ME", 0) then
				do return true end
			end
			do return false end
		end
	end
end

function sling.syntax.SlingParser:acceptImmediateCommentToken()
	local ss = self:acceptImmediateSlashSlashCommentToken()
	if ss ~= nil then
		do return ss end
	end
	do
		local sa = self:acceptImmediateSlashAsteriskCommentToken()
		if sa ~= nil then
			do return sa end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:acceptComment()
	local comment = self:acceptCommentToken()
	if not (comment ~= nil) then
		do return nil end
	end
	do
		local str = comment:getValue()
		if str == nil then
			str = ""
		end
		do
			local text = _g.sling.syntax.SlingParserUtil:cleanComment(str)
			local nn = _g.sling.model.CommentNode:forText(text, false)
			if _g.jk.lang.String:getIndexOfCharacter(str, 10, 0) >= 0 then
				do nn:setSubstantial(true) end
			end
			do nn:setSource(comment) end
			if self:isFixme(nn) then
				if self.showFixmeWarnings then
					do self:onParseMessage(_g.sling.common.WarningMessage:forText("Code needs fixing", nn)) end
				end
			end
			do return nn end
		end
	end
end

function sling.syntax.SlingParser:preprocessIdentifier(t)
	if not (t ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:getChar(t, 0) == 64 then
		do return _g.jk.lang.String:getEndOfString(t, 1) end
	end
	do return t end
end

function sling.syntax.SlingParser:acceptBuiltinDataType()
	if self:acceptToken1("typeinfo") ~= nil then
		local src = self:getAcceptedToken()
		local v = _g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create())
		do v:setSource(src) end
		do return v end
	end
	if self:acceptToken1("array") ~= nil then
		local src = self:getAcceptedToken()
		local dt = nil
		local sz = nil
		local basetypes = nil
		if self:acceptToken2(60) ~= nil then
			dt = self:parseDataType(true)
			if self:acceptToken2(91) ~= nil then
				sz = self:parseExpression(true)
				do self:parseToken2(93) end
			end
			if self:acceptToken2(58) ~= nil then
				local base = nil
				if not (basetypes ~= nil) then
					basetypes = {}
				end
				while true do
					do _g.jk.lang.Vector:append(basetypes, self:parseDataType(true)) end
					if not (self:acceptToken2(44) ~= nil) then
						do break end
					end
				end
			end
			do self:parseToken2(62) end
		end
		if dt == nil then
			dt = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
		end
		if basetypes ~= nil and _g.jk.lang.Vector:getSize(basetypes) > 0 then
			local cd = _g.sling.model.ConstrainedDataTypeNode:forPrimaryType(dt)
			if basetypes ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(basetypes)
				do
					n2 = 0
					while n2 < m do
						local node = _vm:to_table_with_key(basetypes[n2 + 1], '_isType.sling.common.DataTypeNode')
						if node ~= nil then
							do cd:addToBaseTypes(node) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			dt = cd
		end
		do
			local v = _g.sling.model.StaticArrayDataTypeNode:forPrimaryType(dt, nil)
			do v:setSource(src) end
			do v:setSize(sz, false) end
			do return v end
		end
	end
	if self:acceptToken1("vector") ~= nil then
		local src = self:getAcceptedToken()
		local dt = nil
		if self:acceptToken2(60) ~= nil then
			if not ((function()
				dt = self:parseDataType(true)
				do return dt end
			end)() ~= nil) then
				do return nil end
			end
			do self:parseToken2(62) end
		end
		if dt == nil then
			dt = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
		end
		do
			local v = _g.sling.model.VectorDataTypeNode:forPrimaryType(dt)
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("ref") ~= nil then
		local src = self:getAcceptedToken()
		local dt = nil
		if self:acceptToken2(60) ~= nil then
			if not ((function()
				dt = self:parseDataType(true)
				do return dt end
			end)() ~= nil) then
				do return nil end
			end
			do self:parseToken2(62) end
		end
		if dt == nil then
			dt = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
		end
		do
			local v = _g.sling.model.VariableReferenceDataTypeNode:forPrimaryType(dt)
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("ptr") ~= nil then
		local src = self:getAcceptedToken()
		local dt = nil
		if self:acceptToken2(60) ~= nil then
			if not ((function()
				dt = self:parseDataType(true)
				do return dt end
			end)() ~= nil) then
				do return nil end
			end
			do self:parseToken2(62) end
		end
		if dt == nil then
			dt = _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT8)
		end
		do
			local v = _g.sling.model.PointerDataTypeNode:forPrimaryType(dt)
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("map") ~= nil then
		local src = self:getAcceptedToken()
		local keytype = nil
		local valtype = nil
		if self:acceptToken2(60) ~= nil then
			keytype = self:parseDataType(true)
			do self:parseToken2(44) end
			valtype = self:parseDataType(true)
			do self:parseToken2(62) end
		end
		if keytype == nil then
			keytype = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
		end
		if valtype == nil then
			valtype = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
		end
		do
			local v = _g.sling.model.MapDataTypeNode:forTypes(keytype, valtype)
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("set") ~= nil then
		local src = self:getAcceptedToken()
		local valtype = nil
		if self:acceptToken2(60) ~= nil then
			valtype = self:parseDataType(true)
			do self:parseToken2(62) end
		end
		if valtype == nil then
			valtype = _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())
		end
		do
			local v = _g.sling.model.SetDataTypeNode:forPrimaryType(valtype)
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("promise") ~= nil then
		local src = self:getAcceptedToken()
		local valtype = nil
		if self:acceptToken2(60) ~= nil then
			valtype = self:parseDataType(true)
			do self:parseToken2(62) end
		end
		if valtype == nil then
			valtype = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
		end
		do
			local v = _g.sling.model.PromiseDataTypeNode:forPrimaryType(valtype)
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("function") ~= nil then
		local src = self:getAcceptedToken()
		local vdecl = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		if self:acceptToken2(60) ~= nil then
			local rt = self:parseDataType(true)
			do vdecl:setReturnType(rt, false) end
			do
				local n = 1
				while true do
					if self:acceptToken2(44) == nil then
						do break end
					end
					do
						local dt = self:parseDataType(true)
						do vdecl:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, "p" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger((function() local v = n n = n + 1 return v end)())), nil)) end
					end
				end
				do self:parseToken2(62) end
			end
		else
			do vdecl:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
		end
		do
			local v = _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create())
			do v:setDeclaration(vdecl, false) end
			do v:setSource(src) end
			do return v end
		end
	end
	if self:acceptToken1("this") ~= nil then
		do return _g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()) end
	end
	if self:acceptToken1("parent") ~= nil then
		do return _g.sling.model.ParentDataTypeNode._construct0(_g.sling.model.ParentDataTypeNode._create()) end
	end
	if self:acceptToken1("object") ~= nil then
		do return _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()) end
	end
	if self:acceptToken1("buffer") ~= nil then
		do return _g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()) end
	end
	if self:acceptToken1("dynamic") ~= nil then
		do return _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()) end
	end
	if self:acceptToken1("auto") ~= nil then
		do return _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()) end
	end
	if self:acceptToken1("char") ~= nil then
		do return _g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()) end
	end
	if self:acceptToken1("int") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_INT) end
	end
	if self:acceptToken1("uint") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT) end
	end
	if self:acceptToken1("short") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_SHORT) end
	end
	if self:acceptToken1("ushort") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_USHORT) end
	end
	if self:acceptToken1("long") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_LONG) end
	end
	if self:acceptToken1("ulong") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_ULONG) end
	end
	if self:acceptToken1("int8") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_INT8) end
	end
	if self:acceptToken1("uint8") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT8) end
	end
	if self:acceptToken1("int16") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_INT16) end
	end
	if self:acceptToken1("uint16") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT16) end
	end
	if self:acceptToken1("int32") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_INT32) end
	end
	if self:acceptToken1("uint32") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT32) end
	end
	if self:acceptToken1("int64") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_INT64) end
	end
	if self:acceptToken1("uint64") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT64) end
	end
	if self:acceptToken1("double") ~= nil then
		do return _g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()) end
	end
	if self:acceptToken1("float") ~= nil then
		do return _g.sling.model.FloatDataTypeNode._construct0(_g.sling.model.FloatDataTypeNode._create()) end
	end
	if self:acceptToken1("void") ~= nil then
		do return _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()) end
	end
	if self:acceptToken1("bool") ~= nil or self:acceptToken1("boolean") ~= nil then
		do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
	end
	if self:acceptToken1("string") ~= nil then
		do return _g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()) end
	end
	if self:acceptToken1("tuple") ~= nil then
		do return _g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create()) end
	end
	if self:acceptToken1("unknown") ~= nil then
		do return _g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create()) end
	end
	if self:acceptToken1("datetime") ~= nil then
		do return _g.sling.model.DateTimeDataTypeNode._construct0(_g.sling.model.DateTimeDataTypeNode._create()) end
	end
	if self:acceptToken1("decimal") ~= nil then
		do return _g.sling.model.DecimalDataTypeNode._construct0(_g.sling.model.DecimalDataTypeNode._create()) end
	end
	if self:acceptToken1("exception") ~= nil then
		do return _g.sling.model.ExceptionDataTypeNode._construct0(_g.sling.model.ExceptionDataTypeNode._create()) end
	end
	if self:acceptToken1("stylesheet") ~= nil then
		local v = _g.sling.model.ext.NSlingStyleSheetDataType._construct0(_g.sling.model.ext.NSlingStyleSheetDataType._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("tree") ~= nil then
		local v = _g.sling.model.ext.NSlingTreeDataType._construct0(_g.sling.model.ext.NSlingTreeDataType._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	do return nil end
end

function sling.syntax.SlingParser:parseDataType(allowArray)
	local v = self:acceptDataType(allowArray)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("data type"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:parseReferenceDataType()
	local v = self:acceptReferenceDatatype()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("reference data type"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptReferenceDatatype()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local v = self:acceptDataType(false)
		if not (v ~= nil) then
			do return nil end
		end
		if (_vm:to_table_with_key(v, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) == false then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do return v end
	end
end

function sling.syntax.SlingParser:acceptDataType(allowArray)
	local v = self:acceptPrimaryDatatype()
	if not (v ~= nil) then
		do return nil end
	end
	do
		local src = v:getSource()
		if self:peekNextCharacter() == 63 then
			do self:getNextCharacter() end
			v = _g.sling.model.OptionalDataTypeNode:forPrimaryType(v)
			do v:setSource(src) end
		end
		if allowArray then
			while self:peekNextCharacter() == 91 do
				do self:getNextCharacter() end
				do
					local dims = 1
					while self:acceptToken2(44) ~= nil do
						do dims = dims + 1 end
					end
					do self:parseToken2(93) end
					if dims > 1 then
						v = _g.sling.model.MultiDimensionalArrayDataTypeNode:forDimensions(v, dims)
					else
						v = _g.sling.model.StaticArrayDataTypeNode:forPrimaryType(v, nil)
					end
					do v:setSource(src) end
				end
			end
		end
		do return v end
	end
end

function sling.syntax.SlingParser:acceptPrimaryDatatype()
	if self.acceptDeprecatedConstructs then
		if self:acceptToken1("TYPEOF") ~= nil then
			local src = self:getAcceptedToken()
			local parens = self:acceptToken2(40)
			local xpr = self:parseExpression(true)
			if parens ~= nil then
				do self:parseToken2(41) end
			end
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
			do
				local v = _g.sling.model.ExpressionDataTypeNode._construct0(_g.sling.model.ExpressionDataTypeNode._create())
				do v:setSource(src) end
				do v:setExpression(xpr, false) end
				do return v end
			end
		end
		if self:acceptToken1("xprtype") ~= nil then
			local src = self:getAcceptedToken()
			do self:parseToken2(40) end
			do
				local xpr = self:parseExpression(true)
				do self:parseToken2(41) end
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", src)) end
				do
					local v = _g.sling.model.ExpressionDataTypeNode._construct0(_g.sling.model.ExpressionDataTypeNode._create())
					do v:setSource(src) end
					do v:setExpression(xpr, false) end
					do return v end
				end
			end
		end
	end
	if self:acceptToken1("typeof") ~= nil then
		local src = self:getAcceptedToken()
		do self:parseToken2(40) end
		do
			local xpr = self:parseExpression(true)
			do self:parseToken2(41) end
			do
				local v = _g.sling.model.ExpressionDataTypeNode._construct0(_g.sling.model.ExpressionDataTypeNode._create())
				do v:setSource(src) end
				do v:setExpression(xpr, false) end
				do return v end
			end
		end
	end
	do
		local btt = self:acceptBuiltinDataType()
		if btt ~= nil then
			if btt:getSource() == nil then
				do btt:setSource(self:getAcceptedToken()) end
			end
			do return btt end
		end
		do
			local magical = false
			local symbol = nil
			if self:acceptToken1("magical") ~= nil then
				magical = true
				do self:parseToken2(60) end
				symbol = self:parseMagicalDataTypeSymbol()
				do symbol:setMagical(true) end
				do self:parseToken2(62) end
			elseif self:acceptToken2(33) ~= nil then
				magical = true
				symbol = self:parseMagicalDataTypeSymbol()
				do symbol:setMagical(true) end
			else
				symbol = self:acceptSymbolReference()
				if symbol ~= nil then
					local names = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
					if names ~= nil and self.isMacro == false and self.isGenericTypeParameter == false then
						local fname = _g.jk.lang.String:forObject(_g.jk.lang.Vector:get(names, 0))
						if fname ~= nil and fname == self.currentEntityName then
							do self:onParseMessage(_g.sling.common.WarningMessage:forText("Data type reference to the current class was encountered. Should use `this' instead.", symbol)) end
						end
					end
				end
			end
			if symbol ~= nil then
				local v = _g.sling.model.ReferenceDataTypeNode:forSymbol(symbol)
				do v:setSource(symbol:getSource()) end
				do v:setMagical(magical) end
				do return v end
			end
			do return nil end
		end
	end
end

function sling.syntax.SlingParser:parseMagicalDataTypeSymbol()
	local v = self:acceptMagicalDataTypeSymbol()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("magical symbol reference"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptMagicalDataTypeSymbol()
	local v = self:acceptSymbolReference()
	if v ~= nil then
		do return v end
	end
	do
		local dqt = self:acceptDoubleQuotedStringToken(92, false)
		if dqt ~= nil then
			local v = _g.sling.model.SymbolNode:forName(_g.sling.common.CodeStringUtil:unescapeStringLiteralCStyle(dqt.value, true))
			do v:setSource(dqt) end
			do return v end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:acceptModifierKeyword(keyword)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		do self:acceptNewlineToken() end
		if self:acceptToken1(keyword) ~= nil then
			do return true end
		end
		self.currentTokenColumn = ctc
		self.currentTokenLine = ctl
		do self.iterator:setCurrentPosition(ctp) end
		while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
			do self.commentQueue:pop() end
		end
		self.previousToken = cpt
		do return false end
	end
end

function sling.syntax.SlingParser:acceptCommonModifierIdForEntity()
	if self:acceptModifierKeyword("public") then
		do return _g.sling.model.Modifier.PUBLIC end
	end
	if self:acceptModifierKeyword("private") then
		do return _g.sling.model.Modifier.PRIVATE end
	end
	if self:acceptModifierKeyword("nsprivate") then
		do return _g.sling.model.Modifier.NAMESPACEPRIVATE end
	end
	if self:acceptModifierKeyword("protected") then
		do return _g.sling.model.Modifier.PROTECTED end
	end
	if self:acceptModifierKeyword("fundamental") then
		do return _g.sling.model.Modifier.FUNDAMENTAL end
	end
	if self:acceptModifierKeyword("static") then
		do return _g.sling.model.Modifier.STATIC end
	end
	if self:acceptModifierKeyword("extern") then
		do return _g.sling.model.Modifier.EXTERNAL end
	end
	if self:acceptModifierKeyword("final") then
		do return _g.sling.model.Modifier.FINAL end
	end
	if self:acceptModifierKeyword("deprecated") then
		do return _g.sling.model.Modifier.DEPRECATED end
	end
	if self:acceptModifierKeyword("partial") then
		do return _g.sling.model.Modifier.PARTIAL end
	end
	if self:acceptModifierKeyword("abstract") then
		do return _g.sling.model.Modifier.ABSTRACT end
	end
	if self:acceptModifierKeyword("header") then
		do return _g.sling.model.Modifier.HEADER end
	end
	if self:acceptModifierKeyword("implementation") then
		do return _g.sling.model.Modifier.IMPLEMENTATION end
	end
	do return nil end
end

function sling.syntax.SlingParser:parseEntityDetails(mods, basetypes, imports, uses, depends)
	local visibility = false
	while true do
		if self:acceptModifierKeyword("is") then
			local src = self:getAcceptedToken()
			if not (basetypes ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Base types are not supported in this context", src, _g.jk.lang.StackTrace:generate()))
			end
			while true do
				local sym = self:parseReferenceDataType()
				local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_AUTO)
				do btn:setSource(src) end
				do _g.jk.lang.Vector:append(basetypes, btn) end
				if not (self:acceptToken2(44) ~= nil) then
					do break end
				end
			end
		elseif self.acceptDeprecatedConstructs and self:acceptModifierKeyword("imports") then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", self:getAcceptedToken())) end
			if not (imports ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`imports' is not supported in this context", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
			end
			while true do
				do _g.jk.lang.Vector:append(imports, self:parseSymbolReference()) end
				if not (self:acceptToken2(44) ~= nil) then
					do break end
				end
			end
		elseif self.acceptDeprecatedConstructs and self:acceptModifierKeyword("uses") then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", self:getAcceptedToken())) end
			if not (uses ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`uses' is not supported in this context", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
			end
			while true do
				local sym = self:parseSymbolReference()
				do _g.jk.lang.Vector:append(uses, sym) end
				if not (self:acceptToken2(44) ~= nil) then
					do break end
				end
			end
		elseif self.acceptDeprecatedConstructs and self:acceptModifierKeyword("depends") then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", self:getAcceptedToken())) end
			if not (depends ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`depends' is not supported in this context", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
			end
			while true do
				local str = self:parseStringLiteralWithoutModifiers()
				do _g.jk.lang.Vector:append(depends, str) end
				if not (self:acceptToken2(44) ~= nil) then
					do break end
				end
			end
		elseif self:acceptModifierKeyword("extends") then
			local src = self:getAcceptedToken()
			if not (basetypes ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Base types are not supported in this context", src, _g.jk.lang.StackTrace:generate()))
			end
			do
				local sym = self:parseReferenceDataType()
				local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_EXTEND)
				do btn:setSource(src) end
				do _g.jk.lang.Vector:append(basetypes, btn) end
			end
		elseif self:acceptModifierKeyword("implements") then
			local src = self:getAcceptedToken()
			if not (basetypes ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Base types are not supported in this context", src, _g.jk.lang.StackTrace:generate()))
			end
			while true do
				local sym = self:parseReferenceDataType()
				local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT)
				do btn:setSource(src) end
				do _g.jk.lang.Vector:append(basetypes, btn) end
				if not (self:acceptToken2(44) ~= nil) then
					do break end
				end
			end
		elseif self:acceptModifierKeyword("isAlso") then
			local src = self:getAcceptedToken()
			if not (basetypes ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Base types are not supported in this context", src, _g.jk.lang.StackTrace:generate()))
			end
			while true do
				local sym = self:parseReferenceDataType()
				local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_INFORMATIVE)
				do btn:setSource(src) end
				do _g.jk.lang.Vector:append(basetypes, btn) end
				if not (self:acceptToken2(44) ~= nil) then
					do break end
				end
			end
		elseif self.acceptDeprecatedConstructs and (self:acceptModifierKeyword("basetype") or self:acceptModifierKeyword("bt")) then
			local src = self:getAcceptedToken()
			if not (basetypes ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Base types are not supported in this context", src, _g.jk.lang.StackTrace:generate()))
			end
			while true do
				local sym = self:parseReferenceDataType()
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Using deprecated syntax for base type declaration. Use `is' instead.", src)) end
				do
					local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_AUTO)
					do btn:setSource(src) end
					do _g.jk.lang.Vector:append(basetypes, btn) end
					if not (self:acceptToken2(44) ~= nil) then
						do break end
					end
				end
			end
		else
			local mod = self:acceptCommonModifierIdForEntity()
			if mod ~= nil then
				if not (mods ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Modifiers are not supported in this context", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
				end
				if _g.sling.model.Modifier:isVisibilityModifier(mod) then
					if visibility then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
					end
					visibility = true
				end
				do mods:addCommon(mod) end
			else
				do break end
			end
		end
	end
	while true do
		local cm = self:acceptCustomModifier()
		if cm ~= nil then
			if not (mods ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Modifiers not supported in this context", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
			end
			do mods:addCustom(cm) end
		else
			do break end
		end
	end
	do return true end
end

sling.syntax.SlingParser.DeclarationName = {}
sling.syntax.SlingParser.DeclarationName.__index = sling.syntax.SlingParser.DeclarationName
_vm:set_metatable(sling.syntax.SlingParser.DeclarationName, {})

function sling.syntax.SlingParser.DeclarationName._create()
	local v = _vm:set_metatable({}, sling.syntax.SlingParser.DeclarationName)
	return v
end

function sling.syntax.SlingParser.DeclarationName:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.syntax.SlingParser.DeclarationName'
	self['_isType.sling.syntax.SlingParser.DeclarationName'] = true
	self.ns = nil
	self.name = nil
end

function sling.syntax.SlingParser.DeclarationName:_construct0()
	sling.syntax.SlingParser.DeclarationName._init(self)
	return self
end

function sling.syntax.SlingParser:acceptDeclarationName()
	local r = _g.sling.syntax.SlingParser.DeclarationName._construct0(_g.sling.syntax.SlingParser.DeclarationName._create())
	r.name = nil
	r.ns = nil
	do
		local v = self:acceptIdentifier()
		if v == nil then
			do return r end
		end
		if self:acceptToken2(46) == nil then
			r.name = v
			do return r end
		end
		r.ns = {}
		do _g.jk.lang.Vector:append(r.ns, v) end
		while true do
			v = self:parseIdentifier()
			if self:acceptToken2(46) == nil then
				r.name = v
				do break end
			end
			do _g.jk.lang.Vector:append(r.ns, v) end
		end
		do return r end
	end
end

function sling.syntax.SlingParser:parseDeclarationName()
	local v = self:acceptDeclarationName()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("Declaration name"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptGenericTypes()
	local genericTypes = nil
	if self:acceptToken2(60) ~= nil then
		while true do
			local id = self:parseIdentifier()
			local cl = _g.sling.model.TemplateDeclarationNode:forName1(id)
			do cl:setSource(self:getAcceptedToken()) end
			if self:acceptToken1("class") ~= nil then
				do cl:setType(_g.sling.model.TemplateDeclarationNode.TYPE_CLASS) end
			end
			if self:acceptToken2(58) ~= nil then
				repeat
					local src = self:getAcceptedToken()
					self.isGenericTypeParameter = true
					do
						local tt = self:parseDataType(true)
						self.isGenericTypeParameter = false
						do
							local tx = _vm:to_table_with_key(tt, '_isType.sling.model.ReferenceDataTypeNode')
							if not (tx ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Must be a reference data type", tt, _g.jk.lang.StackTrace:generate()))
							end
							do
								local prv = _g.sling.model.BaseTypeNode:forType(tx, 0)
								do prv:setSource(src) end
								do cl:addToBaseTypes(prv) end
							end
						end
					end
				until not (self:acceptToken2(38) ~= nil)
			end
			if genericTypes == nil then
				genericTypes = {}
			end
			do _g.jk.lang.Vector:append(genericTypes, cl) end
			if self:acceptToken2(44) == nil then
				do break end
			end
		end
		do self:parseToken2(62) end
	end
	do return genericTypes end
end

function sling.syntax.SlingParser:parseDelegate(nss, src, allowFileMode)
	local name = self:parseDeclarationInit(nss, src, allowFileMode)
	local params = self:acceptFunctionDeclarationParameters()
	local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	while true do
		if self:acceptModifierKeyword("public") then
			do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
		elseif self:acceptModifierKeyword("private") then
			do mods:addCommon(_g.sling.model.Modifier.PRIVATE) end
		elseif self:acceptModifierKeyword("nsprivate") then
			do mods:addCommon(_g.sling.model.Modifier.NAMESPACEPRIVATE) end
		elseif self:acceptModifierKeyword("protected") then
			do mods:addCommon(_g.sling.model.Modifier.PROTECTED) end
		elseif self:acceptModifierKeyword("extern") then
			do mods:addCommon(_g.sling.model.Modifier.EXTERNAL) end
		elseif self:acceptModifierKeyword("deprecated") then
			do mods:addCommon(_g.sling.model.Modifier.DEPRECATED) end
		else
			do break end
		end
	end
	do
		local type = nil
		if self:acceptToken1("as") ~= nil then
			if not ((function()
				type = self:parseDataType(true)
				do return type end
			end)() ~= nil) then
				do return nil end
			end
		end
		if type == nil then
			type = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
		end
		while true do
			local cm = self:acceptCustomModifier()
			if cm ~= nil then
				do mods:addCustom(cm) end
			else
				do break end
			end
		end
		do self:parseEndOfStatementToken() end
		do
			local v = _g.sling.model.DelegateDeclarationNode._construct0(_g.sling.model.DelegateDeclarationNode._create())
			do v:setSource(src) end
			do v:setModifiers(mods) end
			do v:setReturnType(type) end
			do v:setName(name) end
			do v:setParameters(params) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:parseDeclarationInit(nss, src, allowFileMode)
	local name = nil
	if self:acceptToken1("name") ~= nil then
		if not ((function()
			name = self:parseDeclarationName()
			do return name end
		end)() ~= nil) then
			do return nil end
		end
	end
	if name == nil and allowFileMode then
		local v = self:getCurrentFileId()
		if v == nil then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to determine class name as current file id", src, _g.jk.lang.StackTrace:generate()))
		end
		do return v end
	end
	if name == nil then
		name = self:parseDeclarationInitName(nss, src)
	elseif name.ns ~= nil then
		if not (nss ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Declaration with namespace is not allowed in this context", src, _g.jk.lang.StackTrace:generate()))
		end
		do
			local array = name.ns
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local ns = (function(o)
							if (_vm:get_variable_type(o) == 'string') then
								do return o end
							end
							do return nil end
						end)(array[n + 1])
						if ns ~= nil then
							do _g.jk.lang.Vector:append(nss, ns) end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
	do return name.name end
end

function sling.syntax.SlingParser:parseDeclarationInitName(nss, src)
	local name = self:acceptDeclarationName()
	if not (name ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to parse or determine declaration name", src, _g.jk.lang.StackTrace:generate()))
	end
	if not (name.name ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No declaration name", src, _g.jk.lang.StackTrace:generate()))
	end
	if name.ns ~= nil then
		if not (nss ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Declaration with namespace is not allowed in this context", src, _g.jk.lang.StackTrace:generate()))
		end
		do
			local array = name.ns
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local ns = (function(o)
							if (_vm:get_variable_type(o) == 'string') then
								do return o end
							end
							do return nil end
						end)(array[n + 1])
						if ns ~= nil then
							do _g.jk.lang.Vector:append(nss, ns) end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
	do return name end
end

function sling.syntax.SlingParser:parseModel(nss, src, allowFileMode)
	local name = self:parseDeclarationInit(nss, src, allowFileMode)
	local genericTypes = self:acceptGenericTypes()
	local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	local visibility = nil
	while true do
		if self:acceptModifierKeyword("public") then
			visibility = _g.sling.model.Modifier.PUBLIC
		elseif self:acceptModifierKeyword("private") then
			visibility = _g.sling.model.Modifier.PRIVATE
		elseif self:acceptModifierKeyword("nsprivate") then
			visibility = _g.sling.model.Modifier.NAMESPACEPRIVATE
		elseif self:acceptModifierKeyword("protected") then
			visibility = _g.sling.model.Modifier.PROTECTED
		else
			do break end
		end
	end
	if _g.jk.lang.String:isEmpty(visibility) then
		visibility = _g.sling.model.Modifier.PUBLIC
	end
	do mods:addCommon(visibility) end
	do self:applyCustomModifiers(mods) end
	do
		local inFileMode = false
		if allowFileMode and self:acceptFileModeStartTerminator() then
			inFileMode = true
		else
			do self:parseNewlineToken() end
			do self:parseToken2(123) end
			do self:parseNewlineToken() end
		end
		do
			local v = _g.sling.model.ModelDeclarationNode:forName(name)
			do v:setSource(src) end
			do v:setModifiers(mods) end
			do v:setGenericTypes(genericTypes, false) end
			do
				local ee = self.currentEntityName
				self.currentEntityName = name
				while true do
					local comment = self:acceptCommentWithNewlines()
					if comment ~= nil then
						do self:addDeclarationToContainer(v, comment) end
						goto _continue41
					end
					if inFileMode then
						if self:acceptEOF() ~= nil then
							do break end
						end
					elseif self:acceptToken2(125) ~= nil then
						do self:parseNewlineToken() end
						do break end
					end
					if self:skipUnnecessaryEmptyLines() > 0 then
						goto _continue41
					end
					if self:acceptEntityMetaInformation(v) then
						goto _continue41
					end
					do
						local fsrc = self:parseIdentifierToken()
						local fname = fsrc.value
						local ename = self:acceptStringLiteral()
						do self:parseToken1("as") end
						do
							local fdt = self:parseDataType(true)
							local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
							while true do
								local mod = self:acceptCustomModifier()
								if not (mod ~= nil) then
									do break end
								end
								do mods:addCustom(mod) end
							end
							do self:parseNewlineToken() end
							do
								local vdec = _g.sling.model.VariableDeclarationNode:instance(fdt, fname, nil)
								do vdec:setModifiers(mods) end
								do vdec:setParamName(ename) end
								do vdec:setSource(fsrc) end
								do v:addNode(vdec) end
							end
						end
					end
					::_continue41::
				end
				self.currentEntityName = ee
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptEntityMetaInformation(ee)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if not (self:acceptToken1("meta") ~= nil) then
			do return false end
		end
		do self:acceptNewlineToken() end
		if not (self:acceptToken2(123) ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return false end
		end
		do self:parseNewlineToken() end
		while true do
			local comment = self:acceptCommentWithNewlines()
			if comment ~= nil then
				goto _continue42
			end
			if self:acceptToken1("description") ~= nil then
				local desc = self:parseStringLiteral()
				do self:parseNewlineToken() end
				do ee:setDescription(desc) end
				goto _continue42
			end
			if self:acceptToken1("data") ~= nil then
				local desc = self:parseStringLiteral()
				do self:parseNewlineToken() end
				do ee:setMetadata(desc) end
				goto _continue42
			end
			if self:acceptToken2(125) ~= nil then
				do self:parseNewlineToken() end
				do break end
			end
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("Meta declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			::_continue42::
		end
		do return true end
	end
end

function sling.syntax.SlingParser:acceptBlockMetaInformation(node)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if not (self:acceptToken1("meta") ~= nil) then
			do return false end
		end
		do self:acceptNewlineToken() end
		if not (self:acceptToken2(123) ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return false end
		end
		do self:parseNewlineToken() end
		do
			local fdb = _vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationBaseNode')
			while true do
				if fdb ~= nil then
					if self:acceptToken1("description") ~= nil then
						local desc = self:parseStringLiteral()
						do self:parseNewlineToken() end
						do fdb:setDescription(desc) end
						goto _continue43
					end
					if self:acceptToken1("param") ~= nil then
						local sym = self:parseSymbolReference()
						do self:parseNewlineToken() end
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("param declarations are not implemented.", sym)) end
						goto _continue43
					end
				end
				if self:acceptToken2(125) ~= nil then
					do self:parseNewlineToken() end
					do break end
				end
				do self:skipSpaces() end
				do self:updateStagingToken() end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("Meta declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				::_continue43::
			end
			do return true end
		end
	end
end

function sling.syntax.SlingParser:parseScript(nss, src, allowFileMode)
	local name = self:parseDeclarationInit(nss, src, allowFileMode)
	local imports = {}
	local uses = {}
	local depends = {}
	local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	do self:parseEntityDetails(mods, nil, imports, uses, depends) end
	do
		local v = _g.sling.model.ScriptDeclarationNode:forName(name)
		do v:setSourceLanguage("sling") end
		do v:setSource(src) end
		do v:setModifiers(mods) end
		do v:setDependencies(depends) end
		do v:setImportNamespaces(imports, false) end
		do v:setImportEntities(uses, false) end
		do
			local inFileMode = false
			if allowFileMode and self:acceptFileModeStartTerminator() then
				inFileMode = true
			else
				do self:parseNewlineToken() end
				do self:parseToken2(123) end
				do self:parseNewlineToken() end
			end
			do
				local ee = self.currentEntityName
				self.currentEntityName = name
				while true do
					local comment = self:acceptCommentWithNewlines()
					if comment ~= nil then
						do self:addDeclarationToContainer(v, comment) end
						goto _continue44
					end
					if inFileMode then
						if self:acceptEOF() ~= nil then
							do break end
						end
					elseif self:acceptToken2(125) ~= nil then
						do self:parseNewlineToken() end
						do break end
					end
					if self:skipUnnecessaryEmptyLines() > 0 then
						goto _continue44
					end
					if self:acceptEntityMetaInformation(v) then
						goto _continue44
					end
					if self:acceptInclude(v, _g.sling.syntax.SlingParser.NODECONTEXT_ENTITY) then
						goto _continue44
					end
					do self:pushEntity(v) end
					do
						local dec = self:parseScriptDeclaration()
						do self:popEntity() end
						do self:addDeclarationToContainer(v, dec) end
					end
					::_continue44::
				end
				self.currentEntityName = ee
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:parseScriptDeclaration()
	local ifdef = self:acceptIfdef(_g.sling.syntax.SlingParser.NODECONTEXT_ENTITY)
	if ifdef ~= nil then
		do return ifdef end
	end
	do
		local ifndef = self:acceptIfndef(_g.sling.syntax.SlingParser.NODECONTEXT_ENTITY)
		if ifndef ~= nil then
			do return ifndef end
		end
		do
			local alias = self:acceptTypeAliasDeclaration()
			if alias ~= nil then
				do return alias end
			end
			do
				local r = self:acceptEntity(nil, false, true)
				if r ~= nil then
					do return r end
				end
				do
					local edesc = self:acceptEntityDeclarationDescription()
					if edesc ~= nil then
						do self:parseNewlineToken() end
					end
					do
						local vardec = self:acceptEntityVariableDeclaration(true)
						if vardec ~= nil then
							if _g.jk.lang.String:isEmpty(vardec:getDescription()) then
								do vardec:setDescription(edesc) end
							end
							do return vardec end
						end
						do
							local mm = self:acceptMacroDeclaration()
							if mm ~= nil then
								if _g.jk.lang.String:isEmpty(mm:getDescription()) then
									do mm:setDescription(edesc) end
								end
								do return mm end
							end
							do
								local ff = self:acceptFunctionDeclarationStatement(nil)
								if ff ~= nil then
									if _g.jk.lang.String:isEmpty(ff:getDescription()) then
										do ff:setDescription(edesc) end
									end
									do return ff end
								end
								do
									local stmt = self:acceptStatement()
									if stmt ~= nil then
										do return stmt end
									end
									do self:skipSpaces() end
									do self:updateStagingToken() end
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("script declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
									do return nil end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseEnum(nss, src, allowFileMode)
	local name = self:parseDeclarationInit(nss, src, allowFileMode)
	local imports = {}
	local uses = {}
	local depends = {}
	local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	do self:parseEntityDetails(mods, nil, imports, uses, depends) end
	do
		local v = _g.sling.model.EnumDeclarationNode:forName(name)
		do v:setSourceLanguage("sling") end
		do v:setSource(src) end
		do v:setModifiers(mods) end
		do v:setDependencies(depends) end
		do v:setImportNamespaces(imports, false) end
		do v:setImportEntities(uses, false) end
		do
			local inFileMode = false
			if allowFileMode and self:acceptFileModeStartTerminator() then
				inFileMode = true
			else
				do self:parseNewlineToken() end
				do self:parseToken2(123) end
				do self:parseNewlineToken() end
			end
			do
				local ee = self.currentEntityName
				self.currentEntityName = name
				while true do
					local comment = self:acceptCommentWithNewlines()
					if comment ~= nil then
						do self:addDeclarationToContainer(v, comment) end
						goto _continue45
					end
					if inFileMode then
						if self:acceptEOF() ~= nil then
							do break end
						end
					elseif self:acceptToken2(125) ~= nil then
						do self:parseNewlineToken() end
						do break end
					end
					if self:skipUnnecessaryEmptyLines() > 0 then
						goto _continue45
					end
					if self:acceptEntityMetaInformation(v) then
						goto _continue45
					end
					do
						local id = self:acceptIdentifier()
						if not (id ~= nil) then
							do self:skipSpaces() end
							do self:updateStagingToken() end
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("identifier"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
						end
						do
							local e = _g.sling.model.EnumValueNode._construct0(_g.sling.model.EnumValueNode._create())
							do e:setSource(self:getAcceptedToken()) end
							do e:setName(id) end
							if self:acceptToken2(61) ~= nil then
								do e:setValue(self:parseExpression(false), false) end
							end
							do self:parseNewlineToken() end
							do v:addNode(e) end
						end
					end
					::_continue45::
				end
				self.currentEntityName = ee
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:parseClass(nss, src, allowFileMode)
	local name = self:parseDeclarationInit(nss, src, allowFileMode)
	local genericTypes = self:acceptGenericTypes()
	local basetypes = {}
	local imports = {}
	local uses = {}
	local depends = {}
	local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	do self:parseEntityDetails(mods, basetypes, imports, uses, depends) end
	do
		local inFileMode = false
		if allowFileMode and self:acceptFileModeStartTerminator() then
			inFileMode = true
		else
			do self:parseNewlineToken() end
			do self:parseToken2(123) end
			do self:parseNewlineToken() end
		end
		do
			local v = _g.sling.model.ClassDeclarationNode:forName(name)
			do v:setGenericTypes(genericTypes, false) end
			do v:setSourceLanguage("sling") end
			do v:setSource(src) end
			do v:setImportNamespaces(imports, false) end
			do v:setImportEntities(uses, false) end
			do v:setModifiers(mods) end
			do v:setBaseTypes(basetypes, false) end
			do v:setDependencies(depends) end
			do
				local ee = self.currentEntityName
				self.currentEntityName = name
				while true do
					local comment = self:acceptCommentWithNewlines()
					if comment ~= nil then
						do self:addDeclarationToContainer(v, comment) end
						goto _continue46
					end
					if inFileMode then
						if self:acceptEOF() ~= nil then
							do break end
						end
					elseif self:acceptToken2(125) ~= nil then
						do self:parseNewlineToken() end
						do break end
					end
					if self:skipUnnecessaryEmptyLines() > 0 then
						goto _continue46
					end
					if self:acceptEntityMetaInformation(v) then
						goto _continue46
					end
					if self:acceptInclude(v, _g.sling.syntax.SlingParser.NODECONTEXT_ENTITY) then
						goto _continue46
					end
					do self:pushEntity(v) end
					do
						local dec = self:parseEntityDeclaration(true)
						do self:popEntity() end
						do self:addDeclarationToContainer(v, dec) end
					end
					::_continue46::
				end
				self.currentEntityName = ee
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptFileModeStartTerminator()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if not (self:acceptToken2(58) ~= nil) then
			do return false end
		end
		if not (self:acceptNewlineToken() ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return false end
		end
		if not (self:acceptEOF() ~= nil) then
			do self:parseNewlineToken() end
		end
		do return true end
	end
end

function sling.syntax.SlingParser:parseInterface(nss, src, allowFileMode)
	local name = self:parseDeclarationInit(nss, src, allowFileMode)
	local genericTypes = self:acceptGenericTypes()
	local basetypes = {}
	local imports = {}
	local uses = {}
	local depends = {}
	local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
	do self:parseEntityDetails(mods, basetypes, imports, uses, depends) end
	do
		local v = _g.sling.model.InterfaceDeclarationNode:forName(name)
		do v:setGenericTypes(genericTypes, false) end
		do v:setSourceLanguage("sling") end
		do v:setSource(src) end
		do v:setModifiers(mods) end
		do v:setDependencies(depends) end
		do v:setBaseTypes(basetypes, false) end
		do v:setImportNamespaces(imports, false) end
		do v:setImportEntities(uses, false) end
		do
			local inFileMode = false
			if allowFileMode and self:acceptFileModeStartTerminator() then
				inFileMode = true
			else
				do self:parseNewlineToken() end
				do self:parseToken2(123) end
				do self:parseNewlineToken() end
			end
			do
				local ee = self.currentEntityName
				self.currentEntityName = name
				while true do
					local comment = self:acceptCommentWithNewlines()
					if comment ~= nil then
						do self:addDeclarationToContainer(v, comment) end
						goto _continue47
					end
					if inFileMode then
						if self:acceptEOF() ~= nil then
							do break end
						end
					elseif self:acceptToken2(125) ~= nil then
						do self:parseNewlineToken() end
						do break end
					end
					if self:skipUnnecessaryEmptyLines() > 0 then
						goto _continue47
					end
					if self:acceptEntityMetaInformation(v) then
						goto _continue47
					end
					if self:acceptInclude(v, _g.sling.syntax.SlingParser.NODECONTEXT_ENTITY) then
						goto _continue47
					end
					do self:pushEntity(v) end
					do
						local dec = self:parseEntityDeclaration(true)
						do self:popEntity() end
						do self:addDeclarationToContainer(v, dec) end
					end
					::_continue47::
				end
				self.currentEntityName = ee
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptForeachStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("foreach")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local parens = false
			if self.acceptDeprecatedConstructs and self:acceptToken2(40) ~= nil then
				parens = true
			end
			do
				local lefts = nil
				while true do
					local vdecl = _g.sling.model.VariableDeclarationNode:forName(self:parseDeclarationIdentifier())
					local vtype = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
					if self:acceptToken1("as") ~= nil then
						vtype = self:parseDataType(true)
					end
					do vdecl:setType(vtype, false) end
					if not (lefts ~= nil) then
						lefts = {}
					end
					do _g.jk.lang.Vector:append(lefts, vdecl) end
					if not (self:acceptToken2(44) ~= nil) then
						do break end
					end
				end
				if not (lefts ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:acceptToken1("in") ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do
					local right = self:parseExpression(true)
					local condition = nil
					if self:acceptToken1("where") ~= nil then
						condition = self:parseExpression(true)
					end
					if parens then
						do self:parseToken2(41) end
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated foreach syntax with parenthesis", start)) end
					end
					do
						local block = self:parseControlStructureBlock()
						local v = _g.sling.model.ForEachStatementNode._construct0(_g.sling.model.ForEachStatementNode._create())
						do v:setLefts(lefts, false) end
						do v:setRight(right, false) end
						do v:setBlock(block, false) end
						do v:setCondition(condition, false) end
						if self:acceptToken1("else") ~= nil then
							local elseBlock = self:parseControlStructureBlock()
							do v:setElseBlock(elseBlock, false) end
						end
						do v:setSource(start) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptSwitchStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("switch")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local val = nil
			if self.acceptDeprecatedConstructs and self:acceptToken2(40) ~= nil then
				if not ((function()
					val = self:acceptExpression(true)
					do return val end
				end)() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (self:acceptToken2(41) ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:acceptUnnecessaryNewlineToken() end
				if not (self:acceptToken2(123) ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated switch syntax with parenthesis", start)) end
			else
				if not ((function()
					val = self:acceptExpression(true)
					do return val end
				end)() ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:parseToken2(123) end
			end
			do self:parseNewlineToken() end
			do
				local stmts = {}
				while true do
					local cserr = nil
					local c = nil
					if self:acceptToken1("case") ~= nil then
						cserr = self:getAcceptedToken()
						if self:acceptToken1("!=") ~= nil then
							local x = self:parseExpression(true)
							c = _g.sling.model.CaseNotEqualsBlockNode:instance(x, nil)
						elseif self:acceptToken1("<=") ~= nil then
							local x = self:parseExpression(true)
							c = _g.sling.model.CaseLessOrEqualBlockNode:instance(x, nil)
						elseif self:acceptToken2(60) ~= nil then
							local x = self:parseExpression(true)
							c = _g.sling.model.CaseLessThanBlockNode:instance(x, nil)
						elseif self:acceptToken1(">=") ~= nil then
							local x = self:parseExpression(true)
							c = _g.sling.model.CaseGreaterOrEqualBlockNode:instance(x, nil)
						elseif self:acceptToken2(62) ~= nil then
							local x = self:parseExpression(true)
							c = _g.sling.model.CaseGreaterThanBlockNode:instance(x, nil)
						else
							local x = self:parseExpression(true)
							if (_vm:to_table_with_key(x, '_isType.sling.model.RangeExpressionNode') ~= nil) then
								local r = x
								c = _g.sling.model.CaseRangeBlockNode:instance(r:exportLowerBound(), r:exportUpperBound(), nil, r:getExclusionType())
								do r:destroy() end
							elseif (_vm:to_table_with_key(x, '_isType.sling.model.MultipleExpressionNode') ~= nil) then
								c = _g.sling.model.CaseMultipleEqualsBlockNode:forVectorOfObjects(x:exportExpressions(), nil)
							else
								c = _g.sling.model.CaseEqualsBlockNode:instance(x, nil)
							end
						end
					elseif self:acceptToken1("default") ~= nil then
						cserr = self:getAcceptedToken()
						c = _g.sling.model.CaseDefaultBlockNode._construct0(_g.sling.model.CaseDefaultBlockNode._create())
					else
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`case' or `default'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
					if self.acceptDeprecatedConstructs and self:acceptToken2(58) ~= nil then
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", self:getAcceptedToken())) end
					end
					do self:acceptUnnecessaryNewlineToken() end
					do
						local block = self:parseBlock(true, nil)
						do c:setBlock(block, false) end
						do c:setSource(cserr) end
						do _g.jk.lang.Vector:append(stmts, c) end
						if self:acceptToken2(125) ~= nil then
							do self:parseNewlineToken() end
							do break end
						end
					end
				end
				do
					local v = _g.sling.model.SwitchStatementNode:forExpression(val)
					do v:setBlocks(stmts, false) end
					do v:setSource(start) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptLangDeclaration(langOptional, isExpression)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("lang")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local type = self:acceptStringLiteral()
			local dt = self:acceptDataType(true)
			do self:acceptUnnecessaryNewlineToken() end
			do
				local blockToken = self:acceptTripleBraceBlockToken()
				if not (blockToken ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				if not (type ~= nil) and not langOptional then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("language type"), start, _g.jk.lang.StackTrace:generate()))
				end
				if isExpression and dt == nil then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("data type"), start, _g.jk.lang.StackTrace:generate()))
				end
				do
					local block = blockToken:getValue()
					if block == nil then
						block = ""
					end
					if isExpression == false then
						do self:parseNewlineToken() end
					end
					do
						local n1 = 3
						local n2 = 3
						local it1 = _g.jk.lang.String:iterate(block)
						do it1:getNextChar() end
						do it1:getNextChar() end
						do it1:getNextChar() end
						while it1:getNextChar() == 10 do
							do n1 = n1 + 1 end
						end
						it1 = _g.jk.lang.String:iterateReverse(block)
						do it1:getNextChar() end
						do it1:getNextChar() end
						do it1:getNextChar() end
						while it1:getNextChar() == 9 do
							do n2 = n2 + 1 end
						end
						block = _g.jk.lang.String:getSubString(block, n1, _g.jk.lang.String:getLength(block) - n1 - n2)
						do
							local v = _g.sling.model.EmbedBlockNode:instance(type, block)
							do v:setDefaultDataType(dt, false) end
							do v:setSource(start) end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptCustomModifierToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 35 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					do sb:appendCharacter(c0) end
					if self:peekNextCharacter() == 91 then
						local counter = 1
						do sb:appendCharacter(self:getNextCharacter()) end
						while true do
							local cn = self:getNextCharacter()
							if _g.jk.lang.Character:isEOF(cn) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							do sb:appendCharacter(cn) end
							if cn == 91 then
								do counter = counter + 1 end
							elseif cn == 93 then
								do counter = counter - 1 end
								if counter < 1 then
									do break end
								end
							end
						end
					else
						while true do
							local cn = self:peekNextCharacter()
							if _g.jk.lang.Character:isAlnum(cn) or cn == 95 then
								do self:getNextCharacter() end
								do sb:appendCharacter(cn) end
							else
								do break end
							end
						end
					end
					do
						local v = self.stagingToken
						self.stagingToken = nil
						do self:updateStagingToken() end
						v.line = ctl
						v.column = ctc
						v.position = ctp
						v.value = sb:toString()
						do self:onTokenAccepted(v) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptCustomModifier()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local cmt = self:acceptCustomModifierToken()
		if not (cmt ~= nil) then
			do return nil end
		end
		do
			local t = cmt:getValue()
			if not (t ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local cm = _g.jk.lang.String:getEndOfString(t, 1)
				if _g.jk.lang.String:startsWith(cm, "[", 0) and _g.jk.lang.String:endsWith(cm, "]") then
					cm = _g.jk.lang.String:getSubString(cm, 1, _g.jk.lang.String:getLength(cm) - 2)
				end
				if not _g.jk.lang.String:isNotEmpty(cm) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do return cm end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptNamespaceDeclaration(nss)
	local ifdef = self:acceptIfdef(_g.sling.syntax.SlingParser.NODECONTEXT_NAMESPACE)
	if ifdef ~= nil then
		do return ifdef end
	end
	do
		local ifndef = self:acceptIfndef(_g.sling.syntax.SlingParser.NODECONTEXT_NAMESPACE)
		if ifndef ~= nil then
			do return ifndef end
		end
		do
			local langDeclaration = self:acceptLangDeclaration(false, false)
			if langDeclaration ~= nil then
				do return langDeclaration end
			end
			do
				local r = self:acceptEntity(nss, true, false)
				if r ~= nil then
					do return r end
				end
				do
					local edesc = self:acceptEntityDeclarationDescription()
					if edesc ~= nil then
						do self:parseNewlineToken() end
					end
					do
						local mm = self:acceptMacroDeclaration()
						if mm ~= nil then
							if _g.jk.lang.String:isEmpty(mm:getDescription()) then
								do mm:setDescription(edesc) end
							end
							do return mm end
						end
						do
							local fd = self:acceptFunctionDeclarationStatement(nss)
							if fd ~= nil then
								do return fd end
							end
							do
								local vd = self:acceptVariableDeclarationStatement(nss)
								if vd ~= nil then
									do return vd end
								end
								do return nil end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseNamespaceDeclaration(nss)
	local v = self:acceptNamespaceDeclaration(nss)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("namespace declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptDocumentationToken()
	local t = self:acceptDocumentationCommentToken()
	if not (t ~= nil) then
		do return nil end
	end
	do
		local ts = t:getValue()
		if not (ts ~= nil) then
			do return nil end
		end
		if not _g.jk.lang.String:startsWith(ts, "**", 0) then
			do return "" end
		end
		do
			local v = _g.jk.lang.String:getEndOfString(ts, 2)
			if not (v ~= nil) then
				v = ""
			end
			if v ~= nil then
				v = _g.jk.lang.String:strip(v)
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptDocumentationSection()
	local dt = self:acceptDocumentationToken()
	if not (dt ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if _g.jk.lang.String:isEmpty(dt) == false then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Documentation sections should start with an empty header line `**' without content (this one has content: `" .. _g.jk.lang.String:safeString(dt) .. "').", self:getAcceptedToken())) end
			do sb:appendString(dt) end
		end
		do
			local v = {}
			while true do
				local dt = self:acceptDocumentationToken()
				if dt == nil then
					do break end
				end
				if _g.jk.lang.String:isEmpty(dt) then
					local ss = sb:toString()
					do sb:clear() end
					if _g.jk.lang.String:isEmpty(ss) then
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Empty paragraph in documentation section", self:getAcceptedToken())) end
					else
						do _g.jk.lang.Vector:append(v, ss) end
					end
				else
					if sb:count() > 0 then
						do sb:appendCharacter(32) end
					end
					do sb:appendString(dt) end
				end
			end
			if sb:count() > 0 then
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Documentation sections should end with a blank footer line `**' without content.", self:getAcceptedToken())) end
				do _g.jk.lang.Vector:append(v, sb:toString()) end
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptEntityDescription()
	local paragraphs = self:acceptDocumentationSection()
	if not (paragraphs ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if paragraphs ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(paragraphs)
			do
				n = 0
				while n < m do
					local paragraph = paragraphs[n + 1]
					if paragraph ~= nil then
						if sb:count() > 0 then
							do sb:appendCharacter(10) end
						end
						do sb:appendString(paragraph) end
					end
					do n = n + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function sling.syntax.SlingParser:acceptEntityDeclarationDescription()
	local paragraphs = self:acceptDocumentationSection()
	if not (paragraphs ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if paragraphs ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(paragraphs)
			do
				n = 0
				while n < m do
					local paragraph = paragraphs[n + 1]
					if paragraph ~= nil then
						if sb:count() > 0 then
							do sb:appendCharacter(10) end
						end
						do sb:appendString(paragraph) end
					end
					do n = n + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function sling.syntax.SlingParser:acceptEntity(nss, allowFileMode, isInnerDeclaration)
	local v = self:doAcceptEntity(nss, allowFileMode, isInnerDeclaration)
	if v ~= nil then
		local ve = _vm:to_table_with_key(v, '_isType.sling.model.EntityDeclarationNode')
		if ve ~= nil then
			if ve:hasCustomModifier("eq1compat") then
				do ve:removeCustomModifier("eq1compat") end
				do ve:setSourceLanguage("EQ1") end
			end
		end
	end
	do return v end
end

function sling.syntax.SlingParser:doAcceptEntity(nss, allowFileMode, isInnerDeclaration)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local edesc = self:acceptEntityDescription()
		if edesc ~= nil then
			do self:parseNewlineToken() end
		end
		if self:acceptToken1("class") ~= nil then
			local v = self:parseClass(nss, self:getAcceptedToken(), allowFileMode)
			if v ~= nil then
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(edesc) end
				end
			end
			do return v end
		end
		if self:acceptToken1("enum") ~= nil then
			local v = self:parseEnum(nss, self:getAcceptedToken(), allowFileMode)
			if v ~= nil then
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(edesc) end
				end
			end
			do return v end
		end
		if self:acceptToken1("model") ~= nil then
			local v = self:parseModel(nss, self:getAcceptedToken(), allowFileMode)
			if v ~= nil then
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(edesc) end
				end
			end
			do return v end
		end
		if self:acceptToken1("interface") ~= nil then
			local v = self:parseInterface(nss, self:getAcceptedToken(), allowFileMode)
			if v ~= nil then
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(edesc) end
				end
			end
			do return v end
		end
		if self:acceptToken1("delegate") ~= nil then
			local v = self:parseDelegate(nss, self:getAcceptedToken(), allowFileMode)
			if v ~= nil then
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(edesc) end
				end
			end
			do return v end
		end
		if self:acceptToken1("script") ~= nil then
			local v = self:parseScript(nss, self:getAcceptedToken(), allowFileMode)
			if v ~= nil then
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(edesc) end
				end
			end
			do return v end
		end
		self.currentTokenColumn = ctc
		self.currentTokenLine = ctl
		do self.iterator:setCurrentPosition(ctp) end
		while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
			do self.commentQueue:pop() end
		end
		self.previousToken = cpt
		do return nil end
	end
end

function sling.syntax.SlingParser:acceptMacroDeclaration()
	if self.isMacro then
		do return nil end
	end
	do
		local start = self:acceptToken1("macro")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local name = self:parseDeclarationIdentifier()
			local params = self:acceptFunctionDeclarationParameters()
			local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
			do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
			do mods:addCustom("macro") end
			while true do
				local cm = self:acceptCustomModifier()
				if cm ~= nil then
					do mods:addCustom(cm) end
					goto _continue48
				end
				do break end
				::_continue48::
			end
			self.isMacro = true
			do
				local body = self:parseFunctionBlock(nil)
				self.isMacro = false
				if not (body ~= nil) then
					do return nil end
				end
				do
					local v = _g.sling.model.FunctionDeclarationNode:forName(name, false)
					do v:setSource(start) end
					do v:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
					do v:setModifiers(mods) end
					do v:setParameters(params, false) end
					do v:setBody(body, false) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptInitializerBlockDeclaration()
	local start = self:acceptToken1("init")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local body = self:parseFunctionBlock(nil)
		do return _g.sling.model.InitializerBlockDeclarationNode:forBlock(body) end
	end
end

function sling.syntax.SlingParser:acceptFunctionDeclarationStatement(nss)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("func")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local dname = self:parseDeclarationInitName(nss, start)
			local name = dname.name
			if not (name ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local genericTypes = self:acceptGenericTypes()
				local params = self:acceptFunctionDeclarationParameters()
				local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
				local throwables = {}
				local visibility = false
				while true do
					if self:acceptModifierKeyword("public") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("Functions are by default public: Modifier is unnecessary", self:getAcceptedToken())) end
					elseif self:acceptModifierKeyword("private") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.PRIVATE) end
					elseif self:acceptModifierKeyword("nsprivate") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.NAMESPACEPRIVATE) end
					elseif self:acceptModifierKeyword("protected") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.PROTECTED) end
					elseif self:acceptModifierKeyword("abstract") then
						do mods:addCommon(_g.sling.model.Modifier.ABSTRACT) end
					elseif self:acceptModifierKeyword("static") then
						do mods:addCommon(_g.sling.model.Modifier.STATIC) end
					elseif self:acceptModifierKeyword("virtual") then
						do mods:addCommon(_g.sling.model.Modifier.VIRTUAL) end
					elseif self:acceptModifierKeyword("override") then
						do mods:addCommon(_g.sling.model.Modifier.OVERRIDE) end
					elseif self:acceptModifierKeyword("implement") then
						do mods:addCommon(_g.sling.model.Modifier.IMPLEMENT) end
					elseif self:acceptModifierKeyword("extern") then
						do mods:addCommon(_g.sling.model.Modifier.EXTERNAL) end
					elseif self:acceptModifierKeyword("final") then
						do mods:addCommon(_g.sling.model.Modifier.FINAL) end
					elseif self:acceptModifierKeyword("synchronized") then
						do mods:addCommon(_g.sling.model.Modifier.SYNCHRONIZED) end
					elseif self:acceptModifierKeyword("stub") then
						do mods:addCommon(_g.sling.model.Modifier.STUB) end
					elseif self:acceptModifierKeyword("deprecated") then
						do mods:addCommon(_g.sling.model.Modifier.DEPRECATED) end
					elseif self:acceptModifierKeyword("hide") then
						do mods:addCommon(_g.sling.model.Modifier.NEW) end
					elseif self:acceptModifierKeyword("async") then
						do mods:addCommon(_g.sling.model.Modifier.ASYNCHRONOUS) end
					elseif self:acceptModifierKeyword("throws") then
						local dt = self:parseDataType(true)
						do _g.jk.lang.Vector:append(throwables, dt) end
					else
						do break end
					end
				end
				do
					local dt = nil
					if self:acceptModifierKeyword("as") then
						dt = self:parseDataType(true)
					end
					while true do
						local cm = self:acceptCustomModifier()
						if cm ~= nil then
							do mods:addCustom(cm) end
						else
							do break end
						end
					end
					do
						local body = nil
						local v = _g.sling.model.FunctionDeclarationNode:forName(name, false)
						if self:acceptSemicolonToken() ~= nil then
							do self:acceptNewlineToken() end
						else
							body = self:parseFunctionBlock(v)
						end
						if visibility == false then
							do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
						end
						if dt == nil then
							dt = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
						end
						do v:setSource(start) end
						do v:setReturnType(dt, false) end
						do v:setModifiers(mods) end
						do v:setParameters(params, false) end
						do v:setThrowables(throwables, false) end
						do v:setGenericTypes(genericTypes, false) end
						do v:setBody(body, false) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptStaticBlockDeclaration()
	local start = self:acceptToken1("initStatic")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local body = self:parseFunctionBlock(nil)
		do return _g.sling.model.StaticBlockDeclarationNode:forBlock(body) end
	end
end

function sling.syntax.SlingParser:acceptFunctionDeclarationExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("func")
		if not (start ~= nil) then
			do return nil end
		end
		do
			local params = nil
			local emptyParameterListWarning = false
			if self:acceptToken2(40) ~= nil then
				params = {}
				if self:acceptToken2(41) ~= nil then
					emptyParameterListWarning = true
				else
					while true do
						local vr = self:acceptFunctionDeclarationParameter()
						if not (vr ~= nil) then
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
							do return nil end
						end
						do _g.jk.lang.Vector:append(params, vr) end
						if self:acceptToken2(44) ~= nil then
							do self:acceptMultipleNewlineTokens() end
							goto _continue49
						end
						if self:acceptToken2(41) ~= nil then
							do break end
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
						::_continue49::
					end
				end
			end
			do
				local throwables = {}
				while true do
					if self:acceptModifierKeyword("throws") then
						do _g.jk.lang.Vector:append(throwables, self:parseDataType(true)) end
					else
						do break end
					end
				end
				do
					local dt = nil
					if self:acceptModifierKeyword("as") then
						dt = self:parseDataType(true)
					end
					do
						local customs = nil
						while true do
							local cm = self:acceptCustomModifier()
							if cm ~= nil then
								if not (customs ~= nil) then
									customs = {}
								end
								do _g.jk.lang.Vector:append(customs, cm) end
							else
								do break end
							end
						end
						do
							local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
							local body = self:acceptBlock(false, v)
							if not (body ~= nil) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
								do return nil end
							end
							if emptyParameterListWarning then
								do self:onParseMessage(_g.sling.common.WarningMessage:forText("Empty parameter list in function declaration expression: Parenthesis should be omitted", start)) end
							end
							if dt == nil then
								dt = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
							end
							do v:setSource(start) end
							do v:setReturnType(dt, false) end
							do v:setParameters(params, false) end
							do v:setThrowables(throwables, false) end
							do v:setBody(body, false) end
							if customs ~= nil then
								local n = 0
								local m = _g.jk.lang.Vector:getSize(customs)
								do
									n = 0
									while n < m do
										local custom = customs[n + 1]
										if custom ~= nil then
											do v:addCustomModifier(custom) end
										end
										do n = n + 1 end
									end
								end
							end
							do
								local vv = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(v)
								do vv:setSource(start) end
								do return vv end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptTypeAliasDeclaration()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1("typedef")
		if not (src ~= nil) then
			do return nil end
		end
		do
			local idt = self:parseDeclarationIdentifier()
			local gen = self:acceptGenericTypes()
			if not (self:acceptToken1("=") ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local dtp = self:acceptDataType(true)
				if not (dtp ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do self:parseEndOfStatementToken() end
				do
					local v = _g.sling.model.TypeAliasDeclarationNode:instance(idt, dtp)
					do v:setSource(src) end
					do v:setGenericTypes(gen, false) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptConstructorDeclaration()
	if self:acceptToken1("constructor") == nil and self:acceptToken1("ctor") == nil then
		do return nil end
	end
	do
		local src = self:getAcceptedToken()
		local genericTypes = self:acceptGenericTypes()
		local throwables = {}
		local visibility = nil
		local nextcall = nil
		local stub = false
		local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
		local params = self:acceptFunctionDeclarationParameters()
		while true do
			if self:acceptModifierKeyword("public") then
				visibility = _g.sling.model.Modifier.PUBLIC
			elseif self:acceptModifierKeyword("deprecated") then
				do mods:addCommon(_g.sling.model.Modifier.DEPRECATED) end
			elseif self:acceptModifierKeyword("private") then
				visibility = _g.sling.model.Modifier.PRIVATE
			elseif self:acceptModifierKeyword("nsprivate") then
				visibility = _g.sling.model.Modifier.NAMESPACEPRIVATE
			elseif self:acceptModifierKeyword("protected") then
				visibility = _g.sling.model.Modifier.PROTECTED
			elseif self:acceptModifierKeyword("stub") then
				stub = true
			elseif self:acceptModifierKeyword("throws") then
				local dt = self:parseDataType(true)
				do _g.jk.lang.Vector:append(throwables, dt) end
			elseif self:acceptModifierKeyword("next") then
				local nc = self:parseExpression(true)
				nextcall = _vm:to_table_with_key(nc, '_isType.sling.model.FunctionCallExpressionNode')
				if not (nextcall ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("function call expression"), nc:getSource(), _g.jk.lang.StackTrace:generate()))
				end
			elseif self:acceptModifierKeyword("override") then
				do mods:addCommon(_g.sling.model.Modifier.OVERRIDE) end
			else
				do break end
			end
		end
		while true do
			local cm = self:acceptCustomModifier()
			if cm ~= nil then
				do mods:addCustom(cm) end
			else
				do break end
			end
		end
		if visibility == nil then
			visibility = _g.sling.model.Modifier.PUBLIC
		end
		do
			local block = nil
			if stub then
				if self:acceptSemicolonToken() == nil then
					do self:parseNewlineToken() end
				else
					do self:acceptNewlineToken() end
				end
			else
				block = self:parseFunctionBlock(nil)
			end
			do
				local v = _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create())
				do v:setSource(src) end
				do mods:addCommon(visibility) end
				if stub then
					do mods:addCommon(_g.sling.model.Modifier.STUB) end
				end
				do v:setModifiers(mods) end
				do v:setParameters(params, false) end
				do v:setThrowables(throwables, false) end
				do v:setBody(block, false) end
				do v:setGenericTypes(genericTypes, false) end
				do v:setNext(nextcall, false) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptDestructorDeclaration()
	if self:acceptToken1("destructor") == nil and self:acceptToken1("dtor") == nil then
		do return nil end
	end
	do
		local src = self:getAcceptedToken()
		local block = nil
		if self:acceptSemicolonToken() ~= nil then
			do self:acceptNewlineToken() end
		else
			block = self:parseFunctionBlock(nil)
		end
		do
			local v = _g.sling.model.DestructorDeclarationNode._construct0(_g.sling.model.DestructorDeclarationNode._create())
			do v:setSource(src) end
			do v:setBody(block, false) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:parseParameterVariableDeclaration(defaultAutomatic)
	local v = self:acceptParameterVariableDeclaration(defaultAutomatic)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("parameter variable declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:acceptNamedParameterDeclaration()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local name = self:acceptDeclarationIdentifier()
		if not (name ~= nil) then
			do return nil end
		end
		do
			local src = self:getAcceptedToken()
			if not (self:acceptToken2(58) ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local argument = self:acceptDeclarationIdentifier()
				if not (argument ~= nil) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do
					local argumentSrc = self:getAcceptedToken()
					local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
					while true do
						if self:acceptModifierKeyword("final") then
							do mods:addCommon(_g.sling.model.Modifier.FINAL) end
						else
							do break end
						end
					end
					if not (self:acceptToken1("as") ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do
						local dt = self:parseDataType(true)
						while true do
							local cm = self:acceptCustomModifier()
							if not (cm ~= nil) then
								do break end
							end
							do mods:addCustom(cm) end
						end
						do
							local v = _g.sling.model.VariableDeclarationNode:instance(dt, argument, nil)
							do v:setSource(argumentSrc) end
							do v:setModifiers(mods) end
							if self:acceptToken2(61) ~= nil then
								do v:setInitializer(self:parseExpression(false), false) end
							end
							do
								local npd = _g.sling.model.NamedParameterDeclarationNode._construct0(_g.sling.model.NamedParameterDeclarationNode._create())
								do npd:setSource(src) end
								do npd:setName(name) end
								do npd:setVariable(v, false) end
								do return npd end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptParameterVariableDeclaration(defaultAutomatic)
	local name = self:acceptDeclarationIdentifier()
	if not (name ~= nil) then
		do return nil end
	end
	do
		local src = self:getAcceptedToken()
		local paramName = nil
		local dt = nil
		local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
		while true do
			if self:acceptModifierKeyword("final") then
				do mods:addCommon(_g.sling.model.Modifier.FINAL) end
			else
				do break end
			end
		end
		while true do
			if self:acceptToken1("pname") ~= nil then
				if not ((function()
					paramName = self:parseIdentifier()
					do return paramName end
				end)() ~= nil) then
					do return nil end
				end
			else
				do break end
			end
		end
		if self:acceptToken1("as") ~= nil then
			if not ((function()
				dt = self:parseDataType(true)
				do return dt end
			end)() ~= nil) then
				do return nil end
			end
		end
		while true do
			local cm = self:acceptCustomModifier()
			if cm ~= nil then
				do mods:addCustom(cm) end
			else
				do break end
			end
		end
		do
			local expr = nil
			if self:acceptToken2(61) ~= nil then
				expr = self:parseExpression(false)
			end
			if dt == nil then
				if expr ~= nil and (_vm:to_table_with_key(expr, '_isType.sling.model.LiteralExpressionNode') ~= nil) then
					local dd = expr:getDefaultDataType()
					if not (dd ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Literal expression has no default data type!", expr, _g.jk.lang.StackTrace:generate()))
					end
					if not ((function()
						dt = _vm:to_table_with_key(dd:dup(), '_isType.sling.common.DataTypeNode')
						do return dt end
					end)() ~= nil) then
						do return nil end
					end
				elseif expr ~= nil or defaultAutomatic then
					dt = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
				else
					dt = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
				end
			end
			do
				local v = _g.sling.model.VariableDeclarationNode:instance(dt, name, nil)
				do v:setSource(src) end
				do v:setParamName(paramName) end
				do v:setModifiers(mods) end
				do v:setInitializer(expr, false) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptVariableDeclarationStatement(nss)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if not (self:acceptToken1("var") ~= nil) then
			do return nil end
		end
		do
			local src = self:getAcceptedToken()
			local dnm = self:parseDeclarationInitName(nss, src)
			local name = dnm.name
			if not (name ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local dt = nil
				local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
				while true do
					if self:acceptToken1("volatile") ~= nil then
						do mods:addCommon(_g.sling.model.Modifier.VOLATILE) end
					elseif self:acceptToken1("final") ~= nil then
						do mods:addCommon(_g.sling.model.Modifier.FINAL) end
					elseif self:acceptToken1("const") ~= nil then
						do mods:addCommon(_g.sling.model.Modifier.CONSTANT) end
					elseif self:acceptToken1("synchronized") ~= nil then
						do mods:addCommon(_g.sling.model.Modifier.SYNCHRONIZED) end
					elseif self:acceptToken1("weak") ~= nil then
						do mods:addCommon(_g.sling.model.Modifier.WEAK) end
					elseif self:acceptToken1("static") ~= nil then
						do mods:addCommon(_g.sling.model.Modifier.STATIC) end
					else
						do break end
					end
				end
				if self:acceptToken1("as") ~= nil then
					if not ((function()
						dt = self:parseDataType(true)
						do return dt end
					end)() ~= nil) then
						do return nil end
					end
				end
				while true do
					local cm = self:acceptCustomModifier()
					if cm ~= nil then
						do mods:addCustom(cm) end
					else
						do break end
					end
				end
				if self:acceptToken1(",") ~= nil then
					local mvd = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
					do mvd:setSource(src) end
					do mvd:setType(dt, false) end
					do
						local v = _g.sling.model.VariableDeclarationNode:instance(dt, name, nil)
						do v:setSource(src) end
						do v:setModifiers(mods) end
						do mvd:addToVariables(v) end
						while true do
							if not (self:acceptToken2(44) ~= nil) then
								do break end
							end
							do
								local nn = self:acceptDeclarationIdentifier()
								if self:acceptToken1("as") ~= nil then
									dt = self:parseDataType(true)
								end
								do
									local v = _g.sling.model.VariableDeclarationNode:instance(dt, nn, nil)
									do v:setSource(src) end
									do v:setModifiers(mods) end
									do mvd:addToVariables(v) end
								end
							end
						end
						if self:acceptToken2(61) ~= nil then
							do mvd:setInitializer(self:parseExpression(true), false) end
						end
						do return mvd end
					end
				end
				do
					local isAssert = nil
					local assertErrorBlock = nil
					local expr = nil
					if self:acceptToken2(61) ~= nil then
						isAssert = self:acceptToken1("assert")
						expr = self:parseExpression(true)
						if isAssert ~= nil then
							assertErrorBlock = self:parseControlStructureBlock()
						end
					end
					do
						local comment = nil
						if not (isAssert ~= nil) then
							comment = self:acceptComment()
							do self:parseEndOfStatementToken() end
						end
						if not (dt ~= nil) then
							if expr ~= nil then
								dt = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
							else
								dt = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
							end
						end
						do
							local v = _g.sling.model.VariableDeclarationNode:instance(dt, name, nil)
							do v:setSource(src) end
							do v:setModifiers(mods) end
							do v:setInitializer(expr, false) end
							if comment ~= nil then
								if _g.jk.lang.String:isEmpty(v:getDescription()) then
									do v:setDescription(comment:getText()) end
								end
							end
							if not (isAssert ~= nil) then
								do return v end
							end
							do
								local an = _g.sling.model.AssertStatementNode:forChild(v)
								do an:setSource(src) end
								do an:setErrorBlock(assertErrorBlock, false) end
								do return an end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:applyCustomModifiers(mods)
	while true do
		local cm = self:acceptCustomModifier()
		if cm ~= nil then
			if mods ~= nil then
				do mods:addCustom(cm) end
			end
		else
			do break end
		end
	end
end

function sling.syntax.SlingParser:acceptConstantVariableDeclaration()
	local src = self:acceptToken1("const")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local name = self:parseDeclarationIdentifier()
		local dt = nil
		if self:acceptModifierKeyword("as") then
			if not ((function()
				dt = self:parseDataType(true)
				do return dt end
			end)() ~= nil) then
				do return nil end
			end
		end
		do
			local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
			do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
			do mods:addCommon(_g.sling.model.Modifier.STATIC) end
			do mods:addCommon(_g.sling.model.Modifier.CONSTANT) end
			do self:applyCustomModifiers(mods) end
			do
				local expr = nil
				if self:acceptToken2(61) ~= nil then
					expr = self:parseExpression(true)
				end
				if not (dt ~= nil) then
					if expr ~= nil then
						dt = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
					else
						dt = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
					end
				end
				do
					local comment = self:acceptComment()
					do self:parseEndOfStatementToken() end
					do
						local v = _g.sling.model.VariableDeclarationNode:instance(dt, name, nil)
						do v:setSource(src) end
						do v:setModifiers(mods) end
						do v:setInitializer(expr, false) end
						if comment ~= nil then
							if _g.jk.lang.String:isEmpty(v:getDescription()) then
								do v:setDescription(comment:getText()) end
							end
						end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptPropertyDeclaration()
	local src = self:acceptToken1("property")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local name = self:parseDeclarationIdentifier()
		local backingVariableName = nil
		if self:acceptToken2(58) ~= nil then
			backingVariableName = self:parseDeclarationIdentifier()
		end
		do
			local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
			local visibility = false
			while true do
				if self:acceptModifierKeyword("public") then
					if visibility then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
					end
					visibility = true
					do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
				elseif self:acceptModifierKeyword("private") then
					if visibility then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
					end
					visibility = true
					do mods:addCommon(_g.sling.model.Modifier.PRIVATE) end
				elseif self:acceptModifierKeyword("nsprivate") then
					if visibility then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
					end
					visibility = true
					do mods:addCommon(_g.sling.model.Modifier.NAMESPACEPRIVATE) end
				elseif self:acceptModifierKeyword("protected") then
					if visibility then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
					end
					visibility = true
					do mods:addCommon(_g.sling.model.Modifier.PROTECTED) end
				elseif self:acceptModifierKeyword("static") then
					do mods:addCommon(_g.sling.model.Modifier.STATIC) end
				else
					do break end
				end
			end
			do self:parseToken1("as") end
			do
				local dt = self:parseDataType(true)
				local expr = nil
				if self:acceptToken2(61) ~= nil then
					expr = self:parseExpression(true)
				end
				do self:applyCustomModifiers(mods) end
				do
					local comment = self:acceptComment()
					do self:acceptNewlineToken() end
					do
						local v = _g.sling.model.ext.NSlingPropertyDeclaration._construct0(_g.sling.model.ext.NSlingPropertyDeclaration._create())
						do v:setSource(src) end
						do v:setModifiers(mods) end
						do v:setName(name) end
						do v:setBackingVariableName(backingVariableName) end
						do v:setType(dt, false) end
						do v:setInitializer(expr, false) end
						if comment ~= nil then
							if _g.jk.lang.String:isEmpty(v:getDescription()) then
								do v:setDescription(comment:getText()) end
							end
						end
						do self:parseToken2(123) end
						while true do
							do self:acceptMultipleNewlineTokens() end
							if self:acceptToken2(125) ~= nil then
								do break end
							end
							if self:acceptToken1("description") ~= nil then
								local desc = self:parseStringLiteralExpression(true)
								do v:setDescription(desc:getValue()) end
								goto _continue50
							end
							if self:acceptToken1("set") ~= nil then
								local mysrc = self:getAcceptedToken()
								local varName = nil
								if self:acceptToken1("(") ~= nil then
									varName = self:parseIdentifier()
									do self:parseToken2(41) end
								end
								do
									local block = self:parseBlockOrStatement(false, nil)
									if v:getSetter() ~= nil then
										do self:onParseMessage(_g.sling.common.WarningMessage:forText("Multiple setters encountered. Ignoring declaration.", mysrc)) end
									else
										do _g.sling.syntax.SlingNodeUtil:setPropertySetterAsBlock(v, mysrc, block, dt, varName) end
									end
									goto _continue50
								end
							end
							if self:acceptToken1("get") ~= nil then
								local mysrc = self:getAcceptedToken()
								local block = self:parseBlockOrStatement(false, nil)
								if v:getGetter() ~= nil then
									do self:onParseMessage(_g.sling.common.WarningMessage:forText("Multiple getters encountered. Ignoring declaration.", mysrc)) end
								else
									do _g.sling.syntax.SlingNodeUtil:setPropertyGetterAsBlock(v, mysrc, block, dt) end
								end
								goto _continue50
							end
							if self:acceptToken1("willset") ~= nil then
								local mysrc = self:getAcceptedToken()
								local varName = nil
								if self:acceptToken1("(") ~= nil then
									varName = self:parseIdentifier()
									do self:parseToken2(41) end
								end
								do
									local block = self:parseBlockOrStatement(false, nil)
									if v:getWillSetHandler() ~= nil then
										do self:onParseMessage(_g.sling.common.WarningMessage:forText("multiple willset handlers encountered. Ignoring declaration.", mysrc)) end
									else
										do _g.sling.syntax.SlingNodeUtil:setPropertyWillSetHandlerAsBlock(v, mysrc, block, dt, varName) end
									end
									goto _continue50
								end
							end
							if self:acceptToken1("didset") ~= nil then
								local mysrc = self:getAcceptedToken()
								local varName = nil
								if self:acceptToken1("(") ~= nil then
									varName = self:parseIdentifier()
									do self:parseToken2(41) end
								end
								do
									local block = self:parseBlockOrStatement(false, nil)
									if v:getDidSetHandler() ~= nil then
										do self:onParseMessage(_g.sling.common.WarningMessage:forText("multiple didset handlers encountered. Ignoring declaration.", mysrc)) end
									else
										do _g.sling.syntax.SlingNodeUtil:setPropertyDidSetHandlerAsBlock(v, mysrc, block, dt, varName) end
									end
									goto _continue50
								end
							end
							if self:acceptToken1("hasset") ~= nil then
								if not (v:getSetter() ~= nil) then
									do _g.sling.syntax.SlingNodeUtil:setPropertySetterAsBlock(v, self:getAcceptedToken(), nil, dt, nil) end
								end
								goto _continue50
							end
							if self:acceptToken1("hasget") ~= nil then
								if not (v:getGetter() ~= nil) then
									do _g.sling.syntax.SlingNodeUtil:setPropertyGetterAsBlock(v, self:getAcceptedToken(), nil, dt) end
								end
								goto _continue50
							end
							do self:skipSpaces() end
							do self:updateStagingToken() end
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`description', `set', `get', `willset', `didset', `hasset' or `hasget'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
							::_continue50::
						end
						do return v end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptEntityVariableDeclaration(addDefaultModifier)
	local cc = self:acceptConstantVariableDeclaration()
	if cc ~= nil then
		do return cc end
	end
	do
		local isPropertyKeyword = false
		if self:acceptToken1("prop") ~= nil then
			do self:onParseMessage(_g.sling.common.WarningMessage:forText("Property variables should be declared with keyword `pvar'", self:getAcceptedToken())) end
			isPropertyKeyword = true
		elseif self:acceptToken1("pvar") ~= nil then
			isPropertyKeyword = true
		elseif not (self:acceptToken1("var") ~= nil) then
			do return nil end
		end
		do
			local src = self:getAcceptedToken()
			local name = self:parseDeclarationIdentifier()
			local genericTypes = self:acceptGenericTypes()
			if genericTypes ~= nil then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported generic types encountered for a variable declaration (?)", src, _g.jk.lang.StackTrace:generate()))
			end
			do
				local dt = nil
				local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
				local visibility = false
				local isProperty = false
				while true do
					if self:acceptModifierKeyword("public") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
					elseif self:acceptModifierKeyword("private") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.PRIVATE) end
					elseif self:acceptModifierKeyword("nsprivate") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.NAMESPACEPRIVATE) end
					elseif self:acceptModifierKeyword("protected") then
						if visibility then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple visibility modifiers are not allowed.", self:getAcceptedToken(), _g.jk.lang.StackTrace:generate()))
						end
						visibility = true
						do mods:addCommon(_g.sling.model.Modifier.PROTECTED) end
					elseif self.acceptDeprecatedConstructs and self:acceptModifierKeyword("property") then
						do mods:addCommon(_g.sling.model.Modifier.PROPERTY) end
						isProperty = true
						do self:onParseMessage(_g.sling.common.WarningMessage:forText("The `property' modifier is deprecated. Use `pvar' declarations instead.", self:getAcceptedToken())) end
					elseif self:acceptModifierKeyword("const") then
						do mods:addCommon(_g.sling.model.Modifier.CONSTANT) end
					elseif self:acceptModifierKeyword("volatile") then
						do mods:addCommon(_g.sling.model.Modifier.VOLATILE) end
					elseif self:acceptModifierKeyword("transient") then
						do mods:addCommon(_g.sling.model.Modifier.TRANSIENT) end
					elseif self:acceptModifierKeyword("event") then
						do mods:addCommon(_g.sling.model.Modifier.EVENT) end
					elseif self:acceptModifierKeyword("static") then
						do mods:addCommon(_g.sling.model.Modifier.STATIC) end
					elseif self:acceptModifierKeyword("extern") then
						do mods:addCommon(_g.sling.model.Modifier.EXTERNAL) end
					elseif self:acceptModifierKeyword("final") then
						do mods:addCommon(_g.sling.model.Modifier.FINAL) end
					elseif self:acceptModifierKeyword("synchronized") then
						do mods:addCommon(_g.sling.model.Modifier.SYNCHRONIZED) end
					elseif self:acceptModifierKeyword("deprecated") then
						do mods:addCommon(_g.sling.model.Modifier.DEPRECATED) end
					elseif self:acceptModifierKeyword("weak") then
						do mods:addCommon(_g.sling.model.Modifier.WEAK) end
					else
						do break end
					end
				end
				if self:acceptModifierKeyword("as") then
					if not ((function()
						dt = self:parseDataType(true)
						do return dt end
					end)() ~= nil) then
						do return nil end
					end
				end
				do self:applyCustomModifiers(mods) end
				if not isPropertyKeyword then
					if visibility == false and addDefaultModifier == true then
						if isProperty then
							do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
						else
							do mods:addCommon(_g.sling.model.Modifier.PRIVATE) end
						end
						visibility = true
					end
				end
				do
					local expr = nil
					if self:acceptToken2(61) ~= nil then
						expr = self:parseExpression(true)
					end
					if dt == nil then
						if expr ~= nil then
							dt = _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create())
						else
							dt = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
						end
					end
					if isPropertyKeyword then
						do mods:addCommon(_g.sling.model.Modifier.PUBLIC) end
						do mods:addCommon(_g.sling.model.Modifier.PROPERTY) end
					end
					do
						local comment = self:acceptComment()
						do self:parseEndOfStatementToken() end
						do
							local v = _g.sling.model.VariableDeclarationNode:instance(dt, name, nil)
							do v:setSource(src) end
							do v:setModifiers(mods) end
							do v:setInitializer(expr, false) end
							if comment ~= nil then
								if _g.jk.lang.String:isEmpty(v:getDescription()) then
									do v:setDescription(comment:getText()) end
								end
							end
							do return v end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseModifierDeclaration(src)
	local cum = self:acceptCustomModifier()
	if cum ~= nil then
		local v = _g.sling.model.CustomModifierDeclarationNode._construct0(_g.sling.model.CustomModifierDeclarationNode._create())
		do v:setSource(src) end
		do v:setType(cum) end
		do return v end
	end
	do
		local com = self:acceptCommonModifierIdForEntity()
		if com ~= nil then
			local v = _g.sling.model.CommonModifierDeclarationNode._construct0(_g.sling.model.CommonModifierDeclarationNode._create())
			do v:setSource(src) end
			do v:setType(com) end
			do return v end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:parseImportStaticDeclaration(src)
	local allMembers = false
	local symbol = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	do symbol:addNameToComponents(self:parseIdentifier()) end
	do symbol:setSource(self:getAcceptedToken()) end
	while true do
		if not (self:acceptToken2(46) ~= nil) then
			do break end
		end
		if self:acceptToken2(42) ~= nil then
			allMembers = true
			do break end
		end
		do
			local id = self:acceptIdentifier()
			if id ~= nil then
				do symbol:addNameToComponents(id) end
				goto _continue51
			end
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("identifier or `*'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
		::_continue51::
	end
	do
		local container = nil
		if self:acceptToken1("from") ~= nil then
			container = self:parseSymbolReference()
		end
		do self:parseNewlineToken() end
		do
			local v = _g.sling.model.ImportStaticMemberStatementNode._construct0(_g.sling.model.ImportStaticMemberStatementNode._create())
			do v:setMember(symbol, false) end
			do v:setContainer(container, false) end
			do v:setAllMembers(allMembers) end
			do v:setSource(src) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:parseImportDeclaration(src)
	local symbol = self:parseSymbolReference()
	local name = nil
	if self:acceptToken1("as") ~= nil then
		name = self:parseIdentifier()
	end
	do self:parseNewlineToken() end
	do
		local imp = _g.sling.model.ImportPackageStatementNode._construct0(_g.sling.model.ImportPackageStatementNode._create())
		do imp:setSource(src) end
		do imp:setPackage(symbol, false) end
		do imp:setLocalName(name) end
		do return imp end
	end
end

function sling.syntax.SlingParser:parseUseDeclaration(src)
	local allMembers = false
	local symbol = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	do symbol:addNameToComponents(self:parseIdentifier()) end
	while true do
		if not (self:acceptToken2(46) ~= nil) then
			do break end
		end
		if self:acceptToken2(42) ~= nil then
			allMembers = true
			do break end
		end
		do
			local id = self:acceptIdentifier()
			if id ~= nil then
				do symbol:addNameToComponents(id) end
				goto _continue52
			end
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("identifier or `*'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
		::_continue52::
	end
	do
		local container = nil
		if self:acceptToken1("from") ~= nil then
			container = self:parseSymbolReference()
		end
		do
			local imp = _g.sling.model.ImportEntityStatementNode._construct0(_g.sling.model.ImportEntityStatementNode._create())
			do imp:setSource(src) end
			do imp:setContainer(container, false) end
			do imp:setEntity(symbol, false) end
			do imp:setAllMembers(allMembers) end
			do return imp end
		end
	end
end

function sling.syntax.SlingParser:parseDependsDeclaration(src)
	local str = self:parseStringLiteral()
	do self:parseNewlineToken() end
	do
		local v = _g.sling.model.DependencyDeclarationNode._construct0(_g.sling.model.DependencyDeclarationNode._create())
		do v:setSource(src) end
		do v:setValue(str) end
		do return v end
	end
end

function sling.syntax.SlingParser:parseBaseTypeDeclaration(src)
	local sym = self:parseReferenceDataType()
	local type = _g.sling.model.BaseTypeNode.INHERIT_AUTO
	if self:acceptToken1("type") ~= nil then
		if self:acceptToken1("auto") ~= nil then
			type = _g.sling.model.BaseTypeNode.INHERIT_AUTO
		elseif self:acceptToken1("extends") ~= nil then
			type = _g.sling.model.BaseTypeNode.INHERIT_EXTEND
		elseif self:acceptToken1("implements") ~= nil then
			type = _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT
		elseif self:acceptToken1("isAlso") ~= nil then
			type = _g.sling.model.BaseTypeNode.INHERIT_INFORMATIVE
		else
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`auto', `extends', `implements' or `isAlso'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
	end
	do self:parseNewlineToken() end
	do
		local btn = _g.sling.model.BaseTypeNode:forType(sym, type)
		do btn:setSource(src) end
		do return btn end
	end
end

function sling.syntax.SlingParser:addDeclarationToContainer(container, declaration)
	if container == nil or declaration == nil then
		do return end
	end
	if (_vm:to_table_with_key(declaration, '_isType.sling.model.FlatBlockNode') ~= nil) then
		local array = declaration:exportNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						do container:addNode(node) end
					end
					do n = n + 1 end
				end
			end
		end
	else
		do container:addNode(declaration) end
	end
end

function sling.syntax.SlingParser:acceptUiDeclaration()
	local src = self:acceptToken1("ui")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local dt = self:acceptReferenceDatatype()
		do self:parseNewlineToken() end
		do self:parseToken2(123) end
		do self:parseNewlineToken() end
		do
			local v = _g.sling.model.UIExpressionNode._construct0(_g.sling.model.UIExpressionNode._create())
			do v:setSource(src) end
			do v:setDefaultDataType(dt, false) end
			while true do
				local comment = self:acceptCommentWithNewlines()
				if comment ~= nil then
					do v:addToChildren(comment) end
					goto _continue53
				end
				if self:skipUnnecessaryEmptyLines() > 0 then
					goto _continue53
				end
				if self:acceptToken2(125) ~= nil then
					do self:parseNewlineToken() end
					do break end
				end
				do
					local ctc = self.currentTokenColumn
					local ctl = self.currentTokenLine
					local ctp = self.iterator:getCurrentPosition()
					local cqs = 0
					if self.commentQueue ~= nil then
						cqs = self.commentQueue:getSize()
					end
					do
						local cpt = self.previousToken
						local id = self:acceptIdentifier()
						if id ~= nil then
							local src2 = self:getAcceptedToken()
							local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
							while true do
								local cm = self:acceptCustomModifier()
								if cm ~= nil then
									do mods:addCustom(cm) end
								else
									do break end
								end
							end
							if not (self:acceptToken2(61) ~= nil) then
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
							else
								local value = self:parseExpression(true)
								do self:parseNewlineToken() end
								do
									local ae = _g.sling.model.PropertyValueDeclarationNode:forName(id, value)
									do ae:setModifiers(mods) end
									do ae:setSource(src2) end
									do v:addToChildren(ae) end
									goto _continue53
								end
							end
						end
						do
							local xpr = self:acceptUiExpression()
							if xpr ~= nil then
								do self:parseEndOfStatementToken() end
								do v:addToChildren(xpr) end
								goto _continue53
							end
							do self:skipSpaces() end
							do self:updateStagingToken() end
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("ui expression or assignment"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
						end
					end
				end
				::_continue53::
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptUiExpression()
	local v = nil
	local opos = self:rememberPosition()
	local dt = self:acceptReferenceDatatype()
	if dt ~= nil then
		local name = self:acceptIdentifier()
		local opos2 = self:rememberPosition()
		if self:acceptToken2(123) ~= nil or self:acceptToken2(58) ~= nil then
			v = _g.sling.model.UIExpressionNode._construct0(_g.sling.model.UIExpressionNode._create())
			do v:setDefaultDataType(dt, false) end
			do v:setName(name) end
			do v:setSource(dt:getSource()) end
			do self:restorePosition(opos2) end
		else
			do self:restorePosition(opos) end
		end
	end
	if not (v ~= nil) then
		local xpr = self:acceptExpression(true)
		if xpr ~= nil then
			local name = self:acceptIdentifier()
			v = _g.sling.model.UIExpressionNode._construct0(_g.sling.model.UIExpressionNode._create())
			do v:setExpression(xpr, false) end
			do v:setName(name) end
			do v:setSource(xpr:getSource()) end
		end
	end
	if not (v ~= nil) then
		do return nil end
	end
	if self:acceptToken2(58) ~= nil then
		while true do
			local xpr = self:parseExpression(false)
			do v:addToLayoutParams(xpr) end
			if not (self:acceptToken2(44) ~= nil) then
				do break end
			end
		end
	end
	if self:acceptToken2(123) ~= nil then
		do self:parseNewlineToken() end
		while true do
			local comment = self:acceptCommentWithNewlines()
			if comment ~= nil then
				do v:addToChildren(comment) end
				goto _continue54
			end
			if self:skipUnnecessaryEmptyLines() > 0 then
				goto _continue54
			end
			if self:acceptToken2(125) ~= nil then
				do break end
			end
			do
				local opos2 = self:rememberPosition()
				local id = self:acceptIdentifier()
				if id ~= nil then
					local src2 = self:getAcceptedToken()
					local mods = _g.sling.common.ModifierContainer._construct0(_g.sling.common.ModifierContainer._create())
					while true do
						local cm = self:acceptCustomModifier()
						if cm ~= nil then
							do mods:addCustom(cm) end
						else
							do break end
						end
					end
					if not (self:acceptToken2(61) ~= nil) then
						do self:restorePosition(opos2) end
					else
						local value = self:parseExpression(true)
						do self:parseNewlineToken() end
						do
							local ae = _g.sling.model.PropertyValueDeclarationNode:forName(id, value)
							do ae:setModifiers(mods) end
							do ae:setSource(src2) end
							do v:addToChildren(ae) end
							goto _continue54
						end
					end
				end
				do
					local xpr = self:acceptUiExpression()
					if xpr ~= nil then
						do self:parseEndOfStatementToken() end
						do v:addToChildren(xpr) end
						goto _continue54
					end
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("ui expression or assignment"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
			end
			::_continue54::
		end
	end
	do return v end
end

function sling.syntax.SlingParser:acceptHttpMethod()
	if self:acceptToken1("GET") ~= nil then
		do return "GET" end
	end
	if self:acceptToken1("PUT") ~= nil then
		do return "PUT" end
	end
	if self:acceptToken1("POST") ~= nil then
		do return "POST" end
	end
	if self:acceptToken1("PATCH") ~= nil then
		do return "PATCH" end
	end
	if self:acceptToken1("DELETE") ~= nil then
		do return "DELETE" end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptWebApiDeclaration(edesc)
	local initialize = self:acceptToken1("initialize")
	if initialize ~= nil then
		local block = self:parseFunctionBlock(nil)
		local v = _g.sling.model.InitializerFunctionDeclarationNode._construct0(_g.sling.model.InitializerFunctionDeclarationNode._create())
		if _g.jk.lang.String:isEmpty(v:getDescription()) then
			do v:setDescription(edesc) end
		end
		do v:setSource(initialize) end
		do v:setBody(block, false) end
		do return v end
	end
	if self:acceptToken1("handler") ~= nil then
		local src = self:getAcceptedToken()
		local path = self:parseStringLiteral()
		do self:parseToken2(61) end
		do
			local xpr = self:parseExpression(true)
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration._construct0(_g.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration._create())
				do v:setSource(src) end
				do v:setPath(path) end
				do v:setExpression(xpr, false) end
				do return v end
			end
		end
	end
	do
		local method = self:acceptHttpMethod()
		if not (method ~= nil) then
			do return nil end
		end
		do
			local src = self:getAcceptedToken()
			local methodt = self:getAcceptedToken()
			local path = self:parseStringLiteral()
			local v = _g.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration._construct0(_g.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration._create())
			do v:setSource(src) end
			if _g.jk.lang.String:isEmpty(v:getDescription()) then
				do v:setDescription(edesc) end
			end
			do v:setSource(methodt) end
			do v:setMethod(method) end
			do v:setPath(path) end
			while true do
				local cm = self:acceptCustomModifier()
				if not (cm ~= nil) then
					do break end
				end
				do v:addModifier(cm) end
			end
			do
				local block = self:parseFunctionBlock(nil)
				do v:setBody(block, false) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptWebApiStatement()
	if self:acceptToken1("sampleRequest") ~= nil then
		local src = self:getAcceptedToken()
		local title = self:parseStringLiteral()
		local content = self:parseStringLiteral()
		do self:parseEndOfStatementToken() end
		do
			local cparsed = _g.jk.json.JSONParser:parse(content)
			if cparsed ~= nil then
				content = _g.jk.json.JSONEncoder:encode(cparsed, true, false)
			end
			do
				local v = _g.sling.model.ext.NSlingWebApiSampleRequest._construct0(_g.sling.model.ext.NSlingWebApiSampleRequest._create())
				do v:setSource(src) end
				do v:setTitle(title) end
				do v:setContent(content) end
				do return v end
			end
		end
	end
	if self:acceptToken1("sampleResponse") ~= nil then
		local src = self:getAcceptedToken()
		local title = self:parseStringLiteral()
		local content = self:parseStringLiteral()
		do self:parseEndOfStatementToken() end
		do
			local cparsed = _g.jk.json.JSONParser:parse(content)
			if cparsed ~= nil then
				content = _g.jk.json.JSONEncoder:encode(cparsed, true, false)
			end
			do
				local v = _g.sling.model.ext.NSlingWebApiSampleResponse._construct0(_g.sling.model.ext.NSlingWebApiSampleResponse._create())
				do v:setSource(src) end
				do v:setTitle(title) end
				do v:setContent(content) end
				do return v end
			end
		end
	end
	if self:acceptToken1("receivePath") ~= nil then
		local src = self:getAcceptedToken()
		local name = self:parseIdentifier()
		local type = nil
		if self:acceptToken1("as") ~= nil then
			type = self:parseDataType(true)
		end
		do
			local desc = self:acceptStringLiteral()
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ext.NSlingWebApiInPathStatement._construct0(_g.sling.model.ext.NSlingWebApiInPathStatement._create())
				do v:setSource(src) end
				do v:setName(name) end
				do v:setType(type, false) end
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(desc) end
				end
				do return v end
			end
		end
	end
	if self:acceptToken1("receiveQueryParameter") ~= nil then
		local src = self:getAcceptedToken()
		local name = self:parseIdentifier()
		local type = nil
		local optional = false
		if self:acceptToken1("as") ~= nil then
			type = self:parseDataType(true)
		end
		if self:acceptToken1("optional") ~= nil then
			optional = true
		end
		do
			local desc = self:acceptStringLiteral()
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ext.NSlingWebApiInQueryParameterStatement._construct0(_g.sling.model.ext.NSlingWebApiInQueryParameterStatement._create())
				do v:setSource(src) end
				do v:setName(name) end
				do v:setType(type, false) end
				do v:setOptional(optional) end
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(desc) end
				end
				do return v end
			end
		end
	end
	if self:acceptToken1("receivePost") ~= nil then
		local src = self:getAcceptedToken()
		local name = self:parseIdentifier()
		if not (self:parseToken1("as") ~= nil) then
			do return nil end
		end
		do
			local type = self:parseDataType(true)
			local desc = self:acceptStringLiteral()
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ext.NSlingWebApiInPostStatement._construct0(_g.sling.model.ext.NSlingWebApiInPostStatement._create())
				do v:setSource(src) end
				do v:setName(name) end
				do v:setType(type, false) end
				if _g.jk.lang.String:isEmpty(v:getDescription()) then
					do v:setDescription(desc) end
				end
				do return v end
			end
		end
	end
	if self:acceptToken1("receiveSession") ~= nil then
		local src = self:getAcceptedToken()
		local name = self:parseIdentifier()
		do self:parseToken1("as") end
		do
			local type = self:parseDataType(true)
			do self:parseEndOfStatementToken() end
			do
				local v = _g.sling.model.ext.NSlingWebApiInSessionStatement._construct0(_g.sling.model.ext.NSlingWebApiInSessionStatement._create())
				do v:setSource(src) end
				do v:setName(name) end
				do v:setType(type, false) end
				do return v end
			end
		end
	end
	if self:acceptToken1("sendError") ~= nil then
		local src = self:getAcceptedToken()
		local code = self:acceptExpression(true)
		local data = self:acceptExpression(true)
		do self:parseEndOfStatementToken() end
		do
			local v = _g.sling.model.ext.NSlingWebApiOutErrorStatement._construct0(_g.sling.model.ext.NSlingWebApiOutErrorStatement._create())
			do v:setSource(src) end
			do v:setCode(code, false) end
			do v:setData(data, false) end
			do return v end
		end
	end
	if self:acceptToken1("sendOk") ~= nil then
		local src = self:getAcceptedToken()
		local data = self:acceptExpression(true)
		do self:parseEndOfStatementToken() end
		do
			local v = _g.sling.model.ext.NSlingWebApiOutOkStatement._construct0(_g.sling.model.ext.NSlingWebApiOutOkStatement._create())
			do v:setSource(src) end
			do v:setData(data, false) end
			do return v end
		end
	end
	if self:acceptToken1("sendObject") ~= nil then
		local src = self:getAcceptedToken()
		local data = self:parseExpression(true)
		do self:parseEndOfStatementToken() end
		do
			local v = _g.sling.model.ext.NSlingWebApiOutObjectStatement._construct0(_g.sling.model.ext.NSlingWebApiOutObjectStatement._create())
			do v:setSource(src) end
			do v:setData(data, false) end
			do return v end
		end
	end
	do return nil end
end

function sling.syntax.SlingParser:acceptDomComponentStatement()
	do return nil end
end

function sling.syntax.SlingParser:acceptMarkupTagParamValue()
	if self:acceptToken2(123) ~= nil then
		local v = self:parseExpression(true)
		do self:parseToken2(125) end
		do return v end
	end
	do
		local lit = self:acceptStringLiteralExpression(true)
		if lit ~= nil then
			do return lit end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:parseMarkupTagParamValue()
	local v = self:acceptMarkupTagParamValue()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("markup tag parameter value"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:isClosingTagComing()
	if not (self:peekNextCharacter() ~= 0) == 60 then
		do return false end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:getNextCharacter() end
			do
				local v = false
				if self:peekNextCharacter() == 47 then
					v = true
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptMarkupTextContentToken()
	do self:skipSpaces() end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			while true do
				local c = self:peekNextCharacter()
				if _g.jk.lang.Character:isEOF(c) then
					do break end
				end
				if c == 60 and self:isClosingTagComing() then
					do break end
				end
				do self:getNextCharacter() end
				do sb:appendCharacter(c) end
			end
			do
				local ids = sb:toString()
				if not _g.jk.lang.String:isNotEmpty(ids) then
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do return nil end
				end
				do
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = ids
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptTreeMarkup()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken2(60)
		if not (src ~= nil) then
			do return nil end
		end
		do
			local tag = self:acceptIdentifier()
			if not (tag ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do
				local v = _g.sling.model.ext.NSlingTreeNode._construct0(_g.sling.model.ext.NSlingTreeNode._create())
				do v:setSource(src) end
				do v:setName(tag) end
				while true do
					local param = self:acceptIdentifier()
					if not (param ~= nil) then
						do break end
					end
					do
						local attrsrc = self:getAcceptedToken()
						local value = nil
						if self:acceptToken2(61) ~= nil then
							value = self:parseMarkupTagParamValue()
						else
							value = _g.sling.model.BooleanLiteralExpressionNode:forValue(true)
						end
						do
							local attr = _g.sling.model.ext.NSlingTreeNodeAttribute._construct0(_g.sling.model.ext.NSlingTreeNodeAttribute._create())
							do attr:setSource(attrsrc) end
							do attr:setName(param) end
							do attr:setValue(value, false) end
							do v:addToAttributes(attr) end
						end
					end
				end
				if self:acceptToken1("/>") ~= nil then
					do return v end
				end
				do self:parseToken2(62) end
				do
					local closeToken = "</" .. _g.jk.lang.String:safeString(tag) .. ">"
					while true do
						if self:acceptToken1(closeToken) ~= nil then
							do break end
						end
						if self:acceptToken2(123) ~= nil then
							local xpr = self:parseExpression(true)
							do self:parseToken2(125) end
							do v:addToChildren(xpr) end
							goto _continue55
						end
						do
							local tag = self:acceptTreeMarkup()
							if tag ~= nil then
								do v:addToChildren(tag) end
								goto _continue55
							end
							do
								local text = self:acceptMarkupTextContentToken()
								if text ~= nil then
									local lit = _g.sling.model.StringLiteralExpressionNode:forValue(text.value)
									do lit:setSource(text) end
									do v:addToChildren(lit) end
									goto _continue55
								end
								do self:skipSpaces() end
								do self:updateStagingToken() end
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("<tag>, {expression} or text content"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
							end
						end
						::_continue55::
					end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseTreeMarkup()
	local v = self:acceptTreeMarkup()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("tag"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.SlingParser:isDomComponentStyleDeclarationSelectorCharacter(c)
	if _g.jk.lang.Character:isAlphaNumeric(c) or c == 46 or c == 35 or c == 64 or c == 45 or c == 95 then
		do return true end
	end
	if c == 40 or c == 41 or c == 91 or c == 93 or c == 123 or c == 125 then
		do return true end
	end
	do return false end
end

function sling.syntax.SlingParser:acceptDomComponentStyleDeclarationSelectorToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if not self:isDomComponentStyleDeclarationSelectorCharacter(c0) then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendCharacter(c0) end
				do self:getNextCharacter() end
				while true do
					local c = self:peekNextCharacter()
					if not self:isDomComponentStyleDeclarationSelectorCharacter(c) then
						do break end
					end
					do self:getNextCharacter() end
					do sb:appendCharacter(c) end
				end
				do
					local ids = sb:toString()
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = ids
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseDomComponentStyleDeclarationSelector()
	local token = self:acceptDomComponentStyleDeclarationSelectorToken()
	if not (token ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("selector"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return token.value end
end

function sling.syntax.SlingParser:isDomComponentStyleDeclarationPropertyNameCharacter(c)
	if _g.jk.lang.Character:isAlphaNumeric(c) or c == 45 or c == 95 or c == 46 then
		do return true end
	end
	do return false end
end

function sling.syntax.SlingParser:acceptDomComponentStyleDeclarationPropertyNameToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if not self:isDomComponentStyleDeclarationPropertyNameCharacter(c0) then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendCharacter(c0) end
				do self:getNextCharacter() end
				while true do
					local c = self:peekNextCharacter()
					if not self:isDomComponentStyleDeclarationPropertyNameCharacter(c) then
						do break end
					end
					do self:getNextCharacter() end
					do sb:appendCharacter(c) end
				end
				do
					local ids = sb:toString()
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = ids
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parseDomComponentStyleDeclarationPropertyName()
	local token = self:acceptDomComponentStyleDeclarationPropertyNameToken()
	if not (token ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("property name"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return token.value end
end

function sling.syntax.SlingParser:acceptDomComponentStyleDeclarationPropertyValueToken()
	do self:skipSpaces() end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			while true do
				local c = self:peekNextCharacter()
				if c == 13 then
					goto _continue56
				end
				if c == 59 or c == 10 then
					do break end
				end
				do self:getNextCharacter() end
				do sb:appendCharacter(c) end
				::_continue56::
			end
			do
				local ids = sb:toString()
				local v = self.stagingToken
				self.stagingToken = nil
				do self:updateStagingToken() end
				v.line = ctl
				v.column = ctc
				v.position = ctp
				v.value = ids
				do self:onTokenAccepted(v) end
				do return v end
			end
		end
	end
end

function sling.syntax.SlingParser:parseDomComponentStyleDeclarationPropertyValue()
	if self:acceptToken2(123) ~= nil then
		local v = self:parseExpression(true)
		do self:parseToken2(125) end
		do return v end
	end
	do
		local token = self:acceptDomComponentStyleDeclarationPropertyValueToken()
		if not (token ~= nil) then
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("property value"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		end
		do
			local v = _g.sling.model.StringLiteralExpressionNode:forValue(token.value)
			do v:setSource(token) end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptStyleLiteralExpression(keyword, isExpression)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1(keyword)
		if not (src ~= nil) then
			do return nil end
		end
		if isExpression then
			if not (self:acceptToken2(123) ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:parseNewlineToken() end
		else
			do self:parseNewlineToken() end
			do self:parseToken2(123) end
			do self:parseNewlineToken() end
		end
		do
			local v = _g.sling.model.ext.NSlingStyleSheetDeclarationExpression._construct0(_g.sling.model.ext.NSlingStyleSheetDeclarationExpression._create())
			do v:setSource(src) end
			while true do
				while self:acceptNewlineToken() ~= nil do
				end
				if self:acceptToken2(125) ~= nil then
					do break end
				end
				do
					local selector = self:parseDomComponentStyleDeclarationSelector()
					local dsd = _g.sling.model.ext.NSlingStyleDeclaration._construct0(_g.sling.model.ext.NSlingStyleDeclaration._create())
					do dsd:setSource(self:getAcceptedToken()) end
					do dsd:addToSelectors(selector) end
					while self:acceptToken2(44) ~= nil do
						do dsd:addToSelectors(self:parseDomComponentStyleDeclarationSelector()) end
					end
					do self:parseToken2(123) end
					do self:parseNewlineToken() end
					while true do
						while self:acceptNewlineToken() ~= nil do
						end
						if self:acceptToken2(125) ~= nil then
							do self:parseEndOfStatementToken() end
							do break end
						end
						do
							local propid = self:parseDomComponentStyleDeclarationPropertyName()
							local propsrc = self:getAcceptedToken()
							do self:parseToken2(58) end
							do
								local value = self:parseDomComponentStyleDeclarationPropertyValue()
								do self:acceptToken2(59) end
								do self:parseNewlineToken() end
								do
									local decl = _g.sling.model.ext.NSlingStyleDeclarationProperty._construct0(_g.sling.model.ext.NSlingStyleDeclarationProperty._create())
									do decl:setSource(propsrc) end
									do decl:setName(propid) end
									do decl:setValue(value, false) end
									do dsd:addToProperties(decl) end
								end
							end
						end
					end
					do v:addToStyles(dsd) end
				end
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:acceptMarkupLiteralExpression(keyword, isExpression)
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1(keyword)
		if not (src ~= nil) then
			do return nil end
		end
		if isExpression then
			if not (self:acceptToken2(123) ~= nil) then
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
			do self:parseEndOfStatementToken() end
		else
			do self:parseEndOfStatementToken() end
			do self:parseToken2(123) end
			do self:parseEndOfStatementToken() end
		end
		do
			local o = self.acceptNewlinesAsSpaces
			self.acceptNewlinesAsSpaces = true
			do
				local tag = self:parseTreeMarkup()
				do self:parseToken2(125) end
				self.acceptNewlinesAsSpaces = o
				do
					local v = _g.sling.model.ext.NSlingTreeDeclarationExpression._construct0(_g.sling.model.ext.NSlingTreeDeclarationExpression._create())
					do v:setSource(src) end
					do v:setRoot(tag, false) end
					do return v end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:acceptDomComponentDeclaration(edesc)
	local mlit = self:acceptMarkupLiteralExpression("markup", false)
	if mlit ~= nil then
		do self:parseEndOfStatementToken() end
		do return mlit end
	end
	do
		local slit = self:acceptStyleLiteralExpression("style", false)
		if slit ~= nil then
			do self:parseEndOfStatementToken() end
			do return slit end
		end
		do return nil end
	end
end

function sling.syntax.SlingParser:parseEntityDeclaration(addDefaultModifier)
	local currentEntity = self:peekEntity()
	if not (currentEntity ~= nil) then
		currentEntity = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
		do self:onParseMessage(_g.sling.common.WarningMessage:forText("parseEntityDeclaration called with a null currentEntity!", self:getStagingToken())) end
	end
	do
		local ifdef = self:acceptIfdef(_g.sling.syntax.SlingParser.NODECONTEXT_ENTITY)
		if ifdef ~= nil then
			do return ifdef end
		end
		do
			local ifndef = self:acceptIfndef(_g.sling.syntax.SlingParser.NODECONTEXT_ENTITY)
			if ifndef ~= nil then
				do return ifndef end
			end
			if self:acceptToken1("modifier") ~= nil then
				do return self:parseModifierDeclaration(self:getAcceptedToken()) end
			end
			if self:acceptToken1("depend") ~= nil then
				do return self:parseDependsDeclaration(self:getAcceptedToken()) end
			end
			if self:acceptToken1("import") ~= nil then
				if self:acceptToken1("static") ~= nil then
					do return self:parseImportStaticDeclaration(self:getAcceptedToken()) end
				end
				do return self:parseImportDeclaration(self:getAcceptedToken()) end
			end
			if self:acceptToken1("use") ~= nil then
				do return self:parseUseDeclaration(self:getAcceptedToken()) end
			end
			if self.acceptDeprecatedConstructs and self:acceptToken1("basetype") ~= nil then
				do self:onParseMessage(_g.sling.common.WarningMessage:forText("Deprecated construct", self:getAcceptedToken())) end
				do return self:parseBaseTypeDeclaration(self:getAcceptedToken()) end
			end
			if self:acceptToken1("is") ~= nil then
				local src = self:getAcceptedToken()
				local sym = self:parseReferenceDataType()
				do self:parseNewlineToken() end
				do
					local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_AUTO)
					do btn:setSource(src) end
					do return btn end
				end
			end
			if self:acceptToken1("extend") ~= nil then
				local src = self:getAcceptedToken()
				local sym = self:parseReferenceDataType()
				do self:parseNewlineToken() end
				do
					local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_EXTEND)
					do btn:setSource(src) end
					do return btn end
				end
			end
			if self:acceptToken1("implement") ~= nil then
				local src = self:getAcceptedToken()
				local sym = self:parseReferenceDataType()
				do self:parseNewlineToken() end
				do
					local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT)
					do btn:setSource(src) end
					do return btn end
				end
			end
			if self:acceptToken1("isAlso") ~= nil then
				local src = self:getAcceptedToken()
				local sym = self:parseReferenceDataType()
				do self:parseNewlineToken() end
				do
					local btn = _g.sling.model.BaseTypeNode:forType(sym, _g.sling.model.BaseTypeNode.INHERIT_INFORMATIVE)
					do btn:setSource(src) end
					do return btn end
				end
			end
			do
				local langDeclaration = self:acceptLangDeclaration(false, false)
				if langDeclaration ~= nil then
					do return langDeclaration end
				end
				do
					local uiDecl = self:acceptUiDeclaration()
					if uiDecl ~= nil then
						do return uiDecl end
					end
					do
						local alias = self:acceptTypeAliasDeclaration()
						if alias ~= nil then
							do return alias end
						end
						do
							local r = self:acceptEntity(nil, false, true)
							if r ~= nil then
								do return r end
							end
							do
								local edesc = self:acceptEntityDeclarationDescription()
								if edesc ~= nil then
									do self:parseNewlineToken() end
								end
								if self:acceptToken1("main") ~= nil then
									local src = self:getAcceptedToken()
									local argsVariableName = "args"
									if self:acceptToken2(40) ~= nil then
										argsVariableName = self:parseIdentifier()
										do self:parseToken2(41) end
									end
									do
										local block = self:parseFunctionBlock(nil)
										local v = _g.sling.model.MainFunctionDeclarationNode._construct0(_g.sling.model.MainFunctionDeclarationNode._create())
										if _g.jk.lang.String:isEmpty(v:getDescription()) then
											do v:setDescription(edesc) end
										end
										do v:setArgumentArrayName(argsVariableName) end
										do v:setSource(src) end
										do v:setBody(block, false) end
										do return v end
									end
								end
								if currentEntity:hasCustomModifier("domcomponent") then
									local decl = self:acceptDomComponentDeclaration(edesc)
									if decl ~= nil then
										do return decl end
									end
								end
								if currentEntity:hasCustomModifier("webapi") or currentEntity:hasCustomModifier("webapi2") then
									local decl = self:acceptWebApiDeclaration(edesc)
									if decl ~= nil then
										do return decl end
									end
								end
								do
									local ctor = self:acceptConstructorDeclaration()
									if ctor ~= nil then
										if _g.jk.lang.String:isEmpty(ctor:getDescription()) then
											do ctor:setDescription(edesc) end
										end
										do return ctor end
									end
									do
										local dtor = self:acceptDestructorDeclaration()
										if dtor ~= nil then
											if _g.jk.lang.String:isEmpty(dtor:getDescription()) then
												do dtor:setDescription(edesc) end
											end
											do return dtor end
										end
										do
											local mm = self:acceptMacroDeclaration()
											if mm ~= nil then
												if _g.jk.lang.String:isEmpty(mm:getDescription()) then
													do mm:setDescription(edesc) end
												end
												do return mm end
											end
											do
												local ff = self:acceptFunctionDeclarationStatement(nil)
												if ff ~= nil then
													if _g.jk.lang.String:isEmpty(ff:getDescription()) then
														do ff:setDescription(edesc) end
													end
													do return ff end
												end
												do
													local ibd = self:acceptInitializerBlockDeclaration()
													if ibd ~= nil then
														do return ibd end
													end
													do
														local propdec = self:acceptPropertyDeclaration()
														if propdec ~= nil then
															if _g.jk.lang.String:isEmpty(propdec:getDescription()) then
																do propdec:setDescription(edesc) end
															end
															do return propdec end
														end
														do
															local vardec = self:acceptEntityVariableDeclaration(addDefaultModifier)
															if vardec ~= nil then
																if _g.jk.lang.String:isEmpty(vardec:getDescription()) then
																	do vardec:setDescription(edesc) end
																end
																do return vardec end
															end
															do
																local sbd = self:acceptStaticBlockDeclaration()
																if sbd ~= nil then
																	do return sbd end
																end
																do
																	local bvd = self:acceptEntityBlockDeclaration()
																	if bvd ~= nil then
																		do return bvd end
																	end
																	do self:skipSpaces() end
																	do self:updateStagingToken() end
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("entity declaration"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
																	do return nil end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.syntax.SlingParser:parse()
	local v = _g.sling.common.CodeFileNode._construct0(_g.sling.common.CodeFileNode._create())
	do v:setFile(self:getCurrentFile()) end
	do
		local fb = self:parseAsNamespaceDeclarations()
		local array = fb:exportNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						do v:addNode(node) end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local fid = self:getCurrentFileIdComplete()
			if fid ~= nil then
				local us = _g.jk.lang.String:getIndexOfCharacter(fid, 64, 0)
				if us > 0 then
					do v:renameNode(_g.jk.lang.String:getSubString(fid, 0, us)) end
				else
					do v:renameNode(fid) end
				end
			end
			do return v end
		end
	end
end

function sling.syntax.SlingParser:parseAsStatements()
	do return self:parseFlatBlockInContext(_g.sling.syntax.SlingParser.NODECONTEXT_STATEMENTBLOCK, false) end
end

function sling.syntax.SlingParser:parseAsEntityDeclarations()
	do return self:parseFlatBlockInContext(_g.sling.syntax.SlingParser.NODECONTEXT_ENTITY, false) end
end

function sling.syntax.SlingParser:parseAsNamespaceDeclarations()
	do return self:parseFlatBlockInContext(_g.sling.syntax.SlingParser.NODECONTEXT_NAMESPACE, false) end
end

function sling.syntax.SlingParser:parseFileAsStatements(file)
	do self:initializeForFile(file) end
	do return self:parseAsStatements() end
end

function sling.syntax.SlingParser:parseStringAsStatements(data, dataName)
	do self:initializeForString(data, dataName) end
	do return self:parseAsStatements() end
end

function sling.syntax.SlingParser:parseFileAsEntityDeclarations(file)
	do self:initializeForFile(file) end
	do return self:parseAsEntityDeclarations() end
end

function sling.syntax.SlingParser:parseStringAsEntityDeclarations(data, dataName)
	do self:initializeForString(data, dataName) end
	do return self:parseAsEntityDeclarations() end
end

function sling.syntax.SlingParser:parseStringAsNamespaceDeclarations(data, dataName)
	do self:initializeForString(data, dataName) end
	do return self:parseAsNamespaceDeclarations() end
end

function sling.syntax.SlingParser:parseFileAsNamespaceDeclarations(file)
	do self:initializeForFile(file) end
	do return self:parseAsNamespaceDeclarations() end
end

function sling.syntax.SlingParser:getAllowCustomEntityNamespaces()
	do return self.allowCustomEntityNamespaces end
end

function sling.syntax.SlingParser:setAllowCustomEntityNamespaces(v)
	self.allowCustomEntityNamespaces = v
	do return self end
end

function sling.syntax.SlingParser:getCurrentEntityName()
	do return self.currentEntityName end
end

function sling.syntax.SlingParser:setCurrentEntityName(v)
	self.currentEntityName = v
	do return self end
end

function sling.syntax.SlingParser:getShowFixmeWarnings()
	do return self.showFixmeWarnings end
end

function sling.syntax.SlingParser:setShowFixmeWarnings(v)
	self.showFixmeWarnings = v
	do return self end
end

function sling.syntax.SlingParser:getAcceptDeprecatedConstructs()
	do return self.acceptDeprecatedConstructs end
end

function sling.syntax.SlingParser:setAcceptDeprecatedConstructs(v)
	self.acceptDeprecatedConstructs = v
	do return self end
end

sling.syntax.SlingNodeUtil = {}
sling.syntax.SlingNodeUtil.__index = sling.syntax.SlingNodeUtil
_vm:set_metatable(sling.syntax.SlingNodeUtil, {})

function sling.syntax.SlingNodeUtil._create()
	local v = _vm:set_metatable({}, sling.syntax.SlingNodeUtil)
	return v
end

function sling.syntax.SlingNodeUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.syntax.SlingNodeUtil'
	self['_isType.sling.syntax.SlingNodeUtil'] = true
end

function sling.syntax.SlingNodeUtil:_construct0()
	sling.syntax.SlingNodeUtil._init(self)
	return self
end

function sling.syntax.SlingNodeUtil:describeDataType(dt)
	if (_vm:to_table_with_key(dt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
		do return "null" end
	end
	do return _g.sling.syntax.SlingGenerator:dataTypeToString(dt) end
end

function sling.syntax.SlingNodeUtil:asPropertyValueParameterName(varName)
	if _g.jk.lang.String:isEmpty(varName) then
		do return "value" end
	end
	do return varName end
end

function sling.syntax.SlingNodeUtil:setPropertySetterAsBlock(node, src, block, type, varName)
	if not (node ~= nil) then
		do return end
	end
	do
		local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do v:setSource(src) end
		do v:setBody(block, false) end
		do v:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), _g.sling.syntax.SlingNodeUtil:asPropertyValueParameterName(varName), nil)) end
		do node:setSetter(v, false) end
	end
end

function sling.syntax.SlingNodeUtil:setPropertyWillSetHandlerAsBlock(node, src, block, type, varName)
	if not (node ~= nil) then
		do return end
	end
	do
		local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do v:setSource(src) end
		do v:setBody(block, false) end
		do v:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), _g.sling.syntax.SlingNodeUtil:asPropertyValueParameterName(varName), nil)) end
		do node:setWillSetHandler(v, false) end
	end
end

function sling.syntax.SlingNodeUtil:setPropertyDidSetHandlerAsBlock(node, src, block, type, varName)
	if not (node ~= nil) then
		do return end
	end
	do
		local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do v:setSource(src) end
		do v:setBody(block, false) end
		do v:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), _g.sling.syntax.SlingNodeUtil:asPropertyValueParameterName(varName), nil)) end
		do node:setDidSetHandler(v, false) end
	end
end

function sling.syntax.SlingNodeUtil:setPropertyGetterAsBlock(node, src, block, type)
	if not (node ~= nil) then
		do return end
	end
	do
		local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do v:setSource(src) end
		do v:setBody(block, false) end
		do v:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
		do node:setGetter(v, false) end
	end
end

sling.syntax.PlingParser = _g.sling.common.LiveTokenizingParser._create()
sling.syntax.PlingParser.__index = sling.syntax.PlingParser
_vm:set_metatable(sling.syntax.PlingParser, {
	__index = _g.sling.common.LiveTokenizingParser
})

function sling.syntax.PlingParser._create()
	local v = _vm:set_metatable({}, sling.syntax.PlingParser)
	return v
end

function sling.syntax.PlingParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.syntax.PlingParser'
	self['_isType.sling.syntax.PlingParser'] = true
	self.ctx = nil
end

function sling.syntax.PlingParser:_construct0()
	sling.syntax.PlingParser._init(self)
	do _g.sling.common.LiveTokenizingParser._construct0(self) end
	return self
end

function sling.syntax.PlingParser:_construct1(ctx)
	sling.syntax.PlingParser._init(self)
	do _g.sling.common.LiveTokenizingParser._construct0(self) end
	self.ctx = ctx
	return self
end

function sling.syntax.PlingParser:acceptImmediateCommentToken()
	do return self:acceptImmediateSlashAsteriskCommentToken() end
end

function sling.syntax.PlingParser:isValidIdentifierPrefix(c)
	do return c == 95 or _g.jk.lang.Character:isAlpha(c) end
end

function sling.syntax.PlingParser:isValidIdentifierCharacter(c)
	do return c == 95 or c == 46 or _g.jk.lang.Character:isAlnum(c) end
end

function sling.syntax.PlingParser:isSpaceCharacter(n)
	if n == 10 then
		do return false end
	end
	do return _g.sling.common.LiveTokenizingParser.isSpaceCharacter(self, n) end
end

function sling.syntax.PlingParser:acceptNewLine()
	do return self:acceptToken2(10) ~= nil end
end

function sling.syntax.PlingParser:acceptMultipleNewLine()
	while self:acceptNewLine() do
	end
end

function sling.syntax.PlingParser:acceptIndex()
	if not (self:acceptToken2(91) ~= nil) then
		do return nil end
	end
	do
		local v = self:parseStringLiteral()
		do self:parseToken2(93) end
		do return v end
	end
end

function sling.syntax.PlingParser:parseOperator()
	local app = self:acceptString("+=")
	if app ~= nil then
		do return app end
	end
	do
		local eql = self:acceptString("=")
		if eql ~= nil then
			do return eql end
		end
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("either `=' or `+='"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
		do return nil end
	end
end

function sling.syntax.PlingParser:acceptStringLiteral()
	local v = self:acceptDoubleQuotedStringToken(92, true)
	if not (v ~= nil) then
		do return nil end
	end
	do return _g.sling.common.CodeStringUtil:unescapeStringLiteralCStyle(v:getValue(), true) end
end

function sling.syntax.PlingParser:parseStringLiteral()
	local v = self:acceptStringLiteral()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("string literal"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.PlingParser:acceptList()
	if not (self:acceptToken2(91) ~= nil) then
		do return nil end
	end
	do self:acceptMultipleNewLine() end
	do
		local d = {}
		if self:acceptToken2(93) ~= nil then
			do return d end
		end
		while true do
			if self:acceptToken2(93) ~= nil then
				do break end
			end
			do self:acceptMultipleNewLine() end
			do
				local v = self:parseValue()
				do _g.jk.lang.Vector:append(d, v) end
				if self:acceptToken2(44) ~= nil then
					goto _continue57
				end
				do self:acceptMultipleNewLine() end
				if self:acceptToken2(93) ~= nil then
					do break end
				end
				do self:skipSpaces() end
				do self:updateStagingToken() end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `]'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			end
			::_continue57::
		end
		do return d end
	end
end

function sling.syntax.PlingParser:acceptMap()
	if not (self:acceptToken2(123) ~= nil) then
		do return nil end
	end
	do self:acceptMultipleNewLine() end
	do
		local d = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		if self:acceptToken2(125) ~= nil then
			do return d end
		end
		while true do
			if self:acceptToken2(125) ~= nil then
				do break end
			end
			do self:acceptMultipleNewLine() end
			do
				local k = self:parseStringLiteral()
				do self:parseToken2(58) end
				do
					local v = self:parseValue()
					do d:setObject(k, v) end
					if self:acceptToken2(44) ~= nil then
						goto _continue58
					end
					do self:acceptMultipleNewLine() end
					if self:acceptToken2(125) ~= nil then
						do break end
					end
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
			end
			::_continue58::
		end
		do return d end
	end
end

function sling.syntax.PlingParser:acceptValue()
	local str = self:acceptStringLiteral()
	if str ~= nil then
		do return str end
	end
	do
		local lst = self:acceptList()
		if lst ~= nil then
			do return lst end
		end
		do
			local map = self:acceptMap()
			if map ~= nil then
				do return map end
			end
			do return nil end
		end
	end
end

function sling.syntax.PlingParser:parseValue()
	local v = self:acceptValue()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Invalid value", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.syntax.PlingParser:parseConfiguration()
	local data = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	while true do
		do self:acceptMultipleNewLine() end
		do
			local comment = self:acceptCommentString()
			if comment ~= nil then
				goto _continue59
			end
			if self:acceptEOF() ~= nil then
				do break end
			end
			do
				local id = self:parseIdentifier()
				local ix = self:acceptIndex()
				local op = self:parseOperator()
				local vv = self:parseValue()
				do self:acceptMultipleNewLine() end
				if ix == nil then
					if op == "=" then
						do data:setObject(id, vv) end
					elseif op == "+=" then
						local cc = data:getVector(id)
						if cc == nil then
							cc = {}
							do data:setObject(id, cc) end
						end
						do _g.jk.lang.Vector:append(cc, vv) end
					end
				else
					local d = _vm:to_table_with_key(data:get(id), '_isType.jk.lang.DynamicMap')
					if d == nil then
						d = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
						do data:setObject(id, d) end
					end
					if op == "=" then
						do d:setObject(ix, vv) end
					elseif op == "+=" then
						local cc = d:getVector(ix)
						if cc == nil then
							cc = {}
							do d:setObject(ix, cc) end
						end
						do _g.jk.lang.Vector:append(cc, vv) end
					end
				end
			end
		end
		::_continue59::
	end
	do return data end
end

function sling.syntax.PlingParser:parseFileAsMap(file)
	if not (file ~= nil) then
		do return nil end
	end
	if file:hasExtension("slon") then
		local v = _vm:to_table_with_key(_g.jk.slon.SLONParser:parseFile(file), '_isType.jk.lang.DynamicMap')
		if not (v ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported file format: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(file)) .. "'", nil, nil))
		end
		do return v end
	end
	do self:initializeForFile(file) end
	do return self:parseConfiguration() end
end

function sling.syntax.PlingParser:parseFileAsUnitSettings(file, baseOptions, customOptions)
	local data = self:parseFileAsMap(file)
	local v = baseOptions
	if v ~= nil then
		do v:mergeFrom(data) end
	else
		v = data
	end
	do v:mergeFrom(customOptions) end
	do return self:createSettingsForMap(v) end
end

function sling.syntax.PlingParser:createSettings()
	local v = _g.sling.model.ext.NSlingUnitSettings._construct0(_g.sling.model.ext.NSlingUnitSettings._create())
	do v:setUseJkop(true) end
	do return v end
end

function sling.syntax.PlingParser:createSettingsForMap(data)
	local v = self:createSettings()
	if not (data ~= nil) then
		do return v end
	end
	if self.ctx ~= nil and self.ctx:isInDebugMode() then
		do _g.jk.log.Log:debug(self.ctx, "createSettingsForMap: `" .. _g.jk.lang.String:safeString(_g.jk.json.JSONEncoder:encode(data, false, false)) .. "'") end
	end
	do
		local iter = data:iterate()
		while iter ~= nil do
			local key = iter:next()
			if not (key ~= nil) then
				do break end
			end
			if key == "vendorId" then
				do v:setVendorId(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "projectVersion" or key == "version" then
				do v:setProjectVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "projectId" then
				do v:setProjectId(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "projectTitle" or key == "title" then
				do v:setProjectTitle(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "projectDescription" or key == "description" then
				do v:setProjectDescription(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "projectCopyright" or key == "copyright" then
				do v:setProjectCopyright(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "projectLicense" or key == "license" then
				do v:setProjectLicense(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "moduleId" then
				do v:setModuleId(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "moduleTitle" then
				do v:setModuleTitle(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "moduleDescription" then
				do v:setModuleDescription(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "useJkop" then
				do v:setUseJkop(data:getBoolean(key, false)) end
				goto _continue60
			end
			if key == "imports" then
				do v:setImports(data:getVector(key)) end
				goto _continue60
			end
			if key == "defines" then
				do v:setDefines(data:getDynamicMap(key)) end
				goto _continue60
			end
			if key == "ignoreModuleIdInNamespace" then
				do v:setIgnoreModuleIdInNamespace(data:getBoolean(key, false)) end
				goto _continue60
			end
			if key == "libraries" then
				do v:setLibraries(data:getVector(key)) end
				goto _continue60
			end
			if key == "libraryRepositories" then
				do _g.jk.log.Log:warning(self.ctx, "Ignoring obsolete directive `libraryRepositories'") end
				goto _continue60
			end
			if key == "preFilters" then
				do _g.jk.log.Log:warning(self.ctx, "Ignoring obsolete directive `preFilters'") end
				goto _continue60
			end
			if key == "resources" then
				local array = data:getVector(key)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local rstr = (function(o)
								if (_vm:get_variable_type(o) == 'string') then
									do return o end
								end
								do return nil end
							end)(array[n + 1])
							if rstr ~= nil then
								if _g.jk.lang.String:isEmpty(rstr) then
									goto _continue61
								end
								do
									local file = self:getRelativeFile(rstr)
									if not file:isFile() and not file:isDirectory() then
										goto _continue61
									end
									do
										local condition = nil
										local ii = _g.jk.lang.String:getLastIndexOfCharacter(rstr, 63, -1)
										if ii >= 0 then
											condition = _g.jk.lang.String:getEndOfString(rstr, ii + 1)
											rstr = _g.jk.lang.String:getSubString(rstr, 0, ii)
										end
										if file:isFile() then
											local sr = _g.sling.model.ResourceFileNode._construct0(_g.sling.model.ResourceFileNode._create())
											do sr:setSource(_g.sling.common.StaticSourceReference:forFile(file)) end
											do sr:setFile(file) end
											do sr:setCondition(condition) end
											do v:addToResources(sr) end
										elseif file:isDirectory() then
											local iter = file:entries()
											while iter ~= nil do
												local f = iter:next()
												if not (f ~= nil) then
													do break end
												end
												if f:isFile() then
													local sr = _g.sling.model.ResourceFileNode._construct0(_g.sling.model.ResourceFileNode._create())
													do sr:setSource(_g.sling.common.StaticSourceReference:forFile(f)) end
													do sr:setFile(f) end
													do sr:setCondition(condition) end
													do v:addToResources(sr) end
												end
											end
										else
											do self:onParseMessage(_g.sling.common.WarningMessage:forText("Invalid resource file `" .. _g.jk.lang.String:safeString(rstr) .. "' ", self:getStagingToken())) end
										end
									end
								end
							end
							::_continue61::
							do n = n + 1 end
						end
					end
				end
				goto _continue60
			end
			if key == "androidProjectId" then
				do v:setAndroidProjectId(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidVersion" then
				do v:setAndroidVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidPackageName" then
				do v:setAndroidPackageName(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidMinSdkVersion" then
				do v:setAndroidMinSdkVersion(data:getInteger(key, 0)) end
				goto _continue60
			end
			if key == "androidTargetSdkVersion" then
				do v:setAndroidTargetSdkVersion(data:getInteger(key, 0)) end
				goto _continue60
			end
			if key == "androidToolsVersion" then
				do v:setAndroidToolsVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidGradlePluginVersion" then
				do v:setAndroidGradlePluginVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidKotlinVersion" then
				do v:setAndroidKotlinVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidEnableAndroidJackForLibraries" then
				do v:setAndroidEnableAndroidJackForLibraries(data:getBoolean(key, false)) end
				goto _continue60
			end
			if key == "androidKeyStore" then
				do v:setAndroidKeyStore(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidKeyStorePassword" then
				do v:setAndroidKeyStorePassword(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidKeyAlias" then
				do v:setAndroidKeyAlias(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidKeyAliasPassword" then
				do v:setAndroidKeyAliasPassword(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidGoogleServicesVersion" then
				do v:setAndroidGoogleServicesVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "androidMetaData" then
				do v:setAndroidMetaData(data:getDynamicMap(key)) end
				goto _continue60
			end
			if key == "androidManifestCustomXmls" then
				do v:setAndroidManifestCustomXmls(data:getVector(key)) end
				goto _continue60
			end
			if key == "androidManifestApplicationCustomXml" then
				do v:setAndroidManifestApplicationCustomXmls(data:getVector(key)) end
				goto _continue60
			end
			if key == "androidPermissions" then
				do v:setAndroidPermissions(data:getVector(key)) end
				goto _continue60
			end
			if key == "androidFeatures" then
				do v:setAndroidFeatures(data:getVector(key)) end
				goto _continue60
			end
			if key == "androidGradleDepends" then
				do v:setAndroidGradleDepends(data:getVector(key)) end
				goto _continue60
			end
			if key == "androidGradleHeap" then
				do v:setAndroidGradleHeap(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosProjectName" then
				do v:setIosProjectName(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosVersion" then
				do v:setIosVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosDisplayName" then
				do v:setIosDisplayName(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosCflags" then
				do v:setIosCflags(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosLinkMethod" then
				do v:setIosLinkMethod(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosDeploymentTarget" then
				do v:setIosDeploymentTarget(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosResultType" then
				do v:setIosResultType(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "iosPods" then
				do v:setIosPods(data:getVector(key)) end
				goto _continue60
			end
			if key == "iosFrameworks" then
				do v:setIosFrameworks(data:getVector(key)) end
				goto _continue60
			end
			if key == "iosLinkLibs" then
				do v:setIosLinkLibs(data:getVector(key)) end
				goto _continue60
			end
			if key == "iosLdFlags" then
				do v:setIosLdFlags(data:getVector(key)) end
				goto _continue60
			end
			if key == "iosPlists" then
				do v:setIosPlists(data:getVector(key)) end
				goto _continue60
			end
			if key == "iosInfoPlistData" then
				do v:setIosInfoPlistData(data:getVector(key)) end
				goto _continue60
			end
			if key == "iosScreenOrientation" then
				do v:setIosScreenOrientation(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "mavenArtifactId" then
				do v:setMavenArtifactId(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "mavenGroupId" then
				do v:setMavenGroupId(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "mavenVersion" then
				do v:setMavenVersion(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "mavenName" then
				do v:setMavenName(data:getString(key, nil)) end
				goto _continue60
			end
			if key == "npmPackageJson" then
				do v:setNpmPackageJson(data:getDynamicMap(key)) end
				goto _continue60
			end
			if key == "npmAngularJson" then
				do v:setNpmAngularJson(data:getDynamicMap(key)) end
				goto _continue60
			end
			if key == "npmTsconfigJson" then
				do v:setNpmTsconfigJson(data:getDynamicMap(key)) end
				goto _continue60
			end
			if key == "npmTslintJson" then
				do v:setNpmTslintJson(data:getDynamicMap(key)) end
				goto _continue60
			end
			::_continue60::
		end
		do return v end
	end
end

sling.syntax.SlingParserUtil = {}
sling.syntax.SlingParserUtil.__index = sling.syntax.SlingParserUtil
_vm:set_metatable(sling.syntax.SlingParserUtil, {})

function sling.syntax.SlingParserUtil._create()
	local v = _vm:set_metatable({}, sling.syntax.SlingParserUtil)
	return v
end

function sling.syntax.SlingParserUtil:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.syntax.SlingParserUtil'
	self['_isType.sling.syntax.SlingParserUtil'] = true
end

function sling.syntax.SlingParserUtil:_construct0()
	sling.syntax.SlingParserUtil._init(self)
	return self
end

function sling.syntax.SlingParserUtil:cleanComment(comment)
	if not (comment ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:startsWith(comment, "//", 0) then
		do return _g.jk.lang.String:stripFromEnd(_g.jk.lang.String:getEndOfString(comment, 2)) end
	end
	if _g.jk.lang.String:startsWith(comment, "/*", 0) == false or _g.jk.lang.String:endsWith(comment, "*/") == false then
		do return comment end
	end
	do
		local m = _g.jk.lang.String:getLength(comment) - 4
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local it = _g.jk.lang.String:iterate(comment)
		local n = 2
		local newline = true
		local blank = false
		do it:getNextChar() end
		do it:getNextChar() end
		while n <= m do
			local c = it:getNextChar()
			do n = n + 1 end
			if c < 1 then
				do break end
			end
			if c == 13 then
				goto _continue62
			end
			if sb:count() < 1 and c == 10 then
				goto _continue62
			end
			if newline then
				if c == 32 or c == 9 or c == 42 then
					goto _continue62
				end
				newline = false
			end
			do sb:appendCharacter(c) end
			if c == 10 then
				newline = true
			end
			if c == 32 or c == 9 or c == 10 then
				blank = true
			else
				blank = false
			end
			::_continue62::
		end
		do
			local v = sb:toString()
			if blank then
				v = _g.jk.lang.String:strip(v)
			end
			do return v end
		end
	end
end
sling = sling or {}

sling.ss = sling.ss or {}

sling.ss.parser = sling.ss.parser or {}

sling.ss.parser.SlingScriptParser = _g.sling.common.CodeParser._create()
sling.ss.parser.SlingScriptParser.__index = sling.ss.parser.SlingScriptParser
_vm:set_metatable(sling.ss.parser.SlingScriptParser, {
	__index = _g.sling.common.CodeParser
})

function sling.ss.parser.SlingScriptParser._create()
	local v = _vm:set_metatable({}, sling.ss.parser.SlingScriptParser)
	return v
end

function sling.ss.parser.SlingScriptParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.ss.parser.SlingScriptParser'
	self['_isType.sling.ss.parser.SlingScriptParser'] = true
	self.hasHeader = true
end

function sling.ss.parser.SlingScriptParser:_construct0()
	sling.ss.parser.SlingScriptParser._init(self)
	do _g.sling.common.CodeParser._construct0(self) end
	do self:setImproperCommentPolicy(_g.sling.common.LiveTokenizingParser.IMPROPER_COMMENT_IGNORE) end
	return self
end

function sling.ss.parser.SlingScriptParser:isSpaceCharacter(n)
	if n == 32 or n == 9 or n == 13 then
		do return true end
	end
	do return false end
end

function sling.ss.parser.SlingScriptParser:acceptNewlineToken()
	local v = nil
	while true do
		if self:acceptToken2(10) ~= nil then
			if not (v ~= nil) then
				v = self:getAcceptedToken()
			end
		elseif self:acceptToken2(59) ~= nil then
			if not (v ~= nil) then
				v = self:getAcceptedToken()
			end
		else
			do break end
		end
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:parseNewlineToken()
	local v = self:acceptNewlineToken()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("newline"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:isValidIdentifierPrefix(c)
	do return c == 95 or _g.jk.lang.Character:isAlpha(c) end
end

function sling.ss.parser.SlingScriptParser:isValidIdentifierCharacter(c)
	do return c == 95 or _g.jk.lang.Character:isAlnum(c) end
end

function sling.ss.parser.SlingScriptParser:acceptComment()
	local comment = self:acceptCommentToken()
	if not (comment ~= nil) then
		do return nil end
	end
	do
		local str = comment:getValue()
		if str == nil then
			str = ""
		end
		do
			local text = _g.sling.syntax.SlingParserUtil:cleanComment(str)
			local nn = _g.sling.model.CommentNode:forText(text, false)
			if _g.jk.lang.String:getIndexOfCharacter(str, 10, 0) >= 0 then
				do nn:setSubstantial(true) end
			end
			do nn:setSource(comment) end
			do return nn end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptImmediateCommentToken()
	local hc = self:acceptImmediateHashCommentToken()
	if hc ~= nil then
		do return hc end
	end
	do
		local ssc = self:acceptImmediateSlashSlashCommentToken()
		if ssc ~= nil then
			do return ssc end
		end
		do
			local sac = self:acceptImmediateSlashAsteriskCommentToken()
			if sac ~= nil then
				do return sac end
			end
			do return nil end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptSymbolExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local isGlobal = false
		if self:acceptToken1("::") ~= nil then
			isGlobal = true
		end
		do
			local id = self:acceptIdentifierToken()
			if id ~= nil then
				local symbol = _g.sling.model.SymbolNode:forName(id.value)
				if isGlobal then
					do symbol:addModifier(_g.sling.model.Modifier.GLOBAL) end
				end
				do
					local v = _g.sling.model.SymbolExpressionNode:forSymbol(symbol)
					do v:setSource(id) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
	end
end

function sling.ss.parser.SlingScriptParser:parseSymbolExpression()
	local v = self:acceptSymbolExpression()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("symbol expression"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptSymbolReference()
	local src = nil
	local names = nil
	while true do
		local id = self:acceptIdentifierToken()
		if not (id ~= nil) then
			do break end
		end
		if not (src ~= nil) then
			src = id
		end
		if names == nil then
			names = {}
		end
		do _g.jk.lang.Vector:append(names, id.value) end
		if self:acceptToken2(46) ~= nil then
			goto _continue1
		end
		do break end
		::_continue1::
	end
	if not (src ~= nil) then
		do return nil end
	end
	if not (names ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.model.SymbolNode:forVectorOfNames(names)
		do v:setSource(src) end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:parseSymbolReference()
	local v = self:acceptSymbolReference()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("symbol reference", self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptDataType()
	if self:acceptToken1("typeinfo") ~= nil then
		local v = _g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("array") ~= nil then
		local v = _g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), nil)
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("vector") ~= nil then
		local v = _g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()))
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("map") ~= nil then
		local v = _g.sling.model.MapDataTypeNode:forTypes(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()))
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("set") ~= nil then
		local v = _g.sling.model.SetDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()))
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("function") ~= nil then
		local vdecl = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do vdecl:setReturnType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
		do
			local v = _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create())
			do v:setDeclaration(vdecl, false) end
			do v:setSource(self:getAcceptedToken()) end
			do return v end
		end
	end
	if self:acceptToken1("object") ~= nil then
		do return _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()) end
	end
	if self:acceptToken1("buffer") ~= nil then
		do return _g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()) end
	end
	if self:acceptToken1("dynamic") ~= nil then
		do return _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()) end
	end
	if self:acceptToken1("char") ~= nil then
		do return _g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()) end
	end
	if self:acceptToken1("int") ~= nil then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_INT) end
	end
	if self:acceptToken1("double") ~= nil then
		do return _g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()) end
	end
	if self:acceptToken1("float") ~= nil then
		do return _g.sling.model.FloatDataTypeNode._construct0(_g.sling.model.FloatDataTypeNode._create()) end
	end
	if self:acceptToken1("void") ~= nil then
		do return _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()) end
	end
	if self:acceptToken1("bool") ~= nil or self:acceptToken1("boolean") ~= nil then
		do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
	end
	if self:acceptToken1("string") ~= nil then
		do return _g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()) end
	end
	if self:acceptToken1("tuple") ~= nil then
		do return _g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create()) end
	end
	if self:acceptToken1("ptr") ~= nil then
		do return _g.sling.model.PointerDataTypeNode._construct0(_g.sling.model.PointerDataTypeNode._create()) end
	end
	if self:acceptToken1("unknown") ~= nil then
		do return _g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create()) end
	end
	if self:acceptToken1("datetime") ~= nil then
		do return _g.sling.model.DateTimeDataTypeNode._construct0(_g.sling.model.DateTimeDataTypeNode._create()) end
	end
	if self:acceptToken1("decimal") ~= nil then
		do return _g.sling.model.DecimalDataTypeNode._construct0(_g.sling.model.DecimalDataTypeNode._create()) end
	end
	if self:acceptToken1("exception") ~= nil then
		do return _g.sling.model.ExceptionDataTypeNode._construct0(_g.sling.model.ExceptionDataTypeNode._create()) end
	end
	if self:acceptToken1("stylesheet") ~= nil then
		local v = _g.sling.model.ext.NSlingStyleSheetDataType._construct0(_g.sling.model.ext.NSlingStyleSheetDataType._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("tree") ~= nil then
		local v = _g.sling.model.ext.NSlingTreeDataType._construct0(_g.sling.model.ext.NSlingTreeDataType._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	do
		local symbol = self:acceptSymbolReference()
		if symbol ~= nil then
			local v = _g.sling.model.ReferenceDataTypeNode:forSymbol(symbol)
			do v:setSource(symbol:getSource()) end
			do return v end
		end
		do return nil end
	end
end

function sling.ss.parser.SlingScriptParser:parseDataType()
	local v = self:acceptDataType()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("data type"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptMultilineStringToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if c0 ~= 91 then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				do self:getNextCharacter() end
				do
					local c1 = self:peekNextCharacter()
					if c1 ~= 91 then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
					do self:getNextCharacter() end
					while self:peekNextCharacter() == 13 do
						do self:getNextCharacter() end
					end
					do
						local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
						do sb:appendCharacter(c0) end
						do sb:appendCharacter(c1) end
						do
							local pc = 0
							local nl = false
							local emptycount = -1
							local cc = 0
							local necc = 0
							if self:peekNextCharacter() == 10 then
								do self:getNextCharacter() end
								nl = true
							end
							while true do
								local cn = self:getNextCharacter()
								if cn < 1 then
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
									do return nil end
								end
								if cn == 13 then
									goto _continue2
								end
								if nl and (cn == 32 or cn == 9) then
									if emptycount < 0 or cc < emptycount then
										do cc = cc + 1 end
										goto _continue2
									end
								end
								do sb:appendCharacter(cn) end
								do necc = necc + 1 end
								if cn == 10 then
									nl = true
									if emptycount < 0 and necc > 1 then
										emptycount = cc
									end
									necc = 0
									cc = 0
								else
									nl = false
								end
								if pc == 93 and cn == 93 then
									do break end
								end
								pc = cn
								::_continue2::
							end
							do
								local ids = sb:toString()
								local v = self.stagingToken
								self.stagingToken = nil
								do self:updateStagingToken() end
								v.line = ctl
								v.column = ctc
								v.position = ctp
								v.value = ids
								do self:onTokenAccepted(v) end
								do return v end
							end
						end
					end
				end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptCharacterLiteralExpression()
	local token = self:acceptSingleQuotedStringToken()
	if not (token ~= nil) then
		do return nil end
	end
	do
		local literal = token.value
		local c = 0
		if _g.jk.lang.String:getLength(literal) == 3 then
			c = _g.jk.lang.String:getChar(literal, 1)
		elseif literal == "'\\a'" then
			c = 7
		elseif literal == "'\\b'" then
			c = 8
		elseif literal == "'\\f'" then
			c = 12
		elseif literal == "'\\n'" then
			c = 10
		elseif literal == "'\\r'" then
			c = 13
		elseif literal == "'\\t'" then
			c = 9
		elseif literal == "'\\v'" then
			c = 11
		elseif literal == "'\\\\'" then
			c = 92
		elseif literal == "'\\''" then
			c = 39
		elseif literal == "'\\\"'" then
			c = 34
		elseif literal == "'\\?'" then
			c = 63
		elseif literal == "'\\0'" then
			c = 0
		else
			local ll = _g.jk.lang.String:getLength(literal)
			local c1 = _g.jk.lang.String:getChar(literal, 1)
			if ll == 6 and c1 == 92 and _g.jk.lang.String:getChar(literal, 2) == 120 then
				c = _g.jk.lang.String:toIntegerFromHex(_g.jk.lang.String:getSubString(literal, 3, 2))
			elseif ll == 8 and c1 == 92 and _g.jk.lang.String:getChar(literal, 2) == 117 then
				c = _g.jk.lang.String:toIntegerFromHex(_g.jk.lang.String:getSubString(literal, 3, 4))
			elseif ll == 6 and c1 == 92 then
				local n = 0
				n = n + _util:convert_to_integer(_g.jk.lang.String:getChar(literal, 4) - 48)
				n = n + (_g.jk.lang.String:getChar(literal, 3) - 48) * 8
				c = n
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported character literal", token, _g.jk.lang.StackTrace:generate()))
			end
		end
		do
			local v = _g.sling.model.CharacterLiteralExpressionNode:forValue(c)
			do v:setSource(token) end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptStringLiteralExpression()
	local dqt = self:acceptDoubleQuotedStringToken(92, false)
	if dqt ~= nil then
		local v = _g.sling.model.StringLiteralExpressionNode:forValue(_g.sling.common.CodeStringUtil:unescapeStringLiteralCStyle(dqt.value, true))
		do v:setSource(dqt) end
		do return v end
	end
	do
		local mlt = self:acceptMultilineStringToken()
		if mlt ~= nil then
			local n = 4
			local literal = mlt.value
			if _g.jk.lang.String:endsWith(literal, "\n]]") then
				do n = n + 1 end
			end
			do
				local v = _g.sling.model.StringLiteralExpressionNode:forValue(_g.jk.lang.String:getSubString(literal, 2, _g.jk.lang.String:getLength(literal) - n))
				do v:setSource(mlt) end
				do v:setIsLongString(true) end
				do return v end
			end
		end
		do return nil end
	end
end

function sling.ss.parser.SlingScriptParser:parseStringLiteralExpression()
	local v = self:acceptStringLiteralExpression()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("string literal"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptBooleanLiteralExpression()
	if self:acceptToken1("true") ~= nil then
		local v = _g.sling.model.BooleanLiteralExpressionNode:forValue(true)
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	if self:acceptToken1("false") ~= nil then
		local v = _g.sling.model.BooleanLiteralExpressionNode:forValue(false)
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	do return nil end
end

function sling.ss.parser.SlingScriptParser:acceptNullLiteralExpression()
	if self:acceptToken1("null") ~= nil then
		local v = _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	do return nil end
end

function sling.ss.parser.SlingScriptParser:acceptFailureLiteralExpression()
	if self:acceptToken1("fail") ~= nil then
		local v = _g.sling.model.FailureLiteralExpressionNode._construct0(_g.sling.model.FailureLiteralExpressionNode._create())
		do v:setSource(self:getAcceptedToken()) end
		do return v end
	end
	do return nil end
end

function sling.ss.parser.SlingScriptParser:acceptIntegerLiteralExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local num = _vm:to_table_with_key(self:acceptNumberLiteralExpression(), '_isType.sling.model.IntegerLiteralExpressionNode')
		if not (num ~= nil) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do return num end
	end
end

function sling.ss.parser.SlingScriptParser:acceptNumberLiteralExpression()
	local hex = self:acceptHexNumberLiteralToken(true)
	if hex ~= nil then
		local vv = _g.jk.lang.String:toIntegerFromHex(_g.jk.lang.String:getEndOfString(hex.value, 2))
		local v = _g.sling.model.IntegerLiteralExpressionNode:forValue(vv)
		do v:setFormat(_g.sling.model.IntegerLiteralExpressionNode.FORMAT_HEXADECIMAL) end
		do v:setSource(hex) end
		do return v end
	end
	do
		local ii = self:acceptDecimalNumberLiteralToken(true, true, true, false)
		if not (ii ~= nil) then
			do return nil end
		end
		if _g.jk.lang.String:getIndexOfCharacter(ii.value, 46, 0) < 0 then
			local v = _g.sling.model.IntegerLiteralExpressionNode:forValue(_g.jk.lang.String:toInteger(ii.value))
			do v:setFormat(_g.sling.model.IntegerLiteralExpressionNode.FORMAT_DECIMAL) end
			do v:setSource(ii) end
			do
				local unsigned = false
				local long = false
				if self:acceptToken2(117) ~= nil or self:acceptToken2(85) ~= nil then
					unsigned = true
				end
				if self:acceptToken2(108) ~= nil or self:acceptToken2(76) ~= nil then
					long = true
				end
				if unsigned then
					if long then
						do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_ULONG) end
					else
						do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT) end
					end
				elseif long then
					do v:setType(_g.sling.model.IntegerDataTypeNode.TYPE_LONG) end
				end
				do return v end
			end
		end
		if self:acceptToken2(109) ~= nil or self:acceptToken2(77) ~= nil then
			local v = _g.sling.model.DecimalLiteralExpressionNode._construct0(_g.sling.model.DecimalLiteralExpressionNode._create())
			do v:setSource(ii) end
			do v:setValue(ii.value) end
			do return v end
		end
		if self:acceptToken2(102) ~= nil or self:acceptToken2(70) ~= nil then
			local v = _g.sling.model.FloatLiteralExpressionNode:forValue(_g.jk.lang.String:toDouble(ii.value))
			do v:setSource(ii) end
			do return v end
		end
		do
			local v = _g.sling.model.DoubleLiteralExpressionNode:forValue(_g.jk.lang.String:toDouble(ii.value))
			do v:setSource(ii) end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptArrayLiteralExpression()
	local open = self:acceptToken2(91)
	if not (open ~= nil) then
		do return nil end
	end
	do self:acceptNewlineToken() end
	do
		local exprs = {}
		if self:acceptToken2(93) == nil then
			while true do
				do self:acceptNewlineToken() end
				do
					local xp = self:parseExpression()
					do self:acceptNewlineToken() end
					do _g.jk.lang.Vector:append(exprs, xp) end
					if self:acceptToken2(44) ~= nil then
						goto _continue3
					end
					if self:acceptToken2(93) ~= nil then
						do break end
					end
					do self:skipSpaces() end
					do self:updateStagingToken() end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `]'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
				end
				::_continue3::
			end
		end
		do
			local v = _g.sling.model.ArrayLiteralExpressionNode:forExpressions(exprs)
			do v:setSource(open) end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:parseArrayLiteralExpression()
	local v = self:acceptArrayLiteralExpression()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("array literal"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptMapLiteralExpression()
	local open = self:acceptToken2(123)
	if not (open ~= nil) then
		do return nil end
	end
	do self:acceptNewlineToken() end
	do
		local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
		do v:setSource(open) end
		do
			local ddt = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
			do ddt:setKeyType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
			do ddt:setValueType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
			do v:setDefaultDataType(ddt, false) end
			if self:acceptToken2(125) == nil then
				while true do
					do self:acceptNewlineToken() end
					if self:acceptToken2(125) ~= nil then
						do break end
					end
					do self:acceptNewlineToken() end
					do
						local key = self:parseExpression()
						do self:acceptNewlineToken() end
						do self:parseToken2(58) end
						do self:acceptNewlineToken() end
						do
							local val = self:parseExpression()
							do self:acceptNewlineToken() end
							do
								local vn = _g.sling.model.KeyValueNode:forValues(key, val)
								do vn:setSource(key:getSource()) end
								do v:addToValues(vn) end
								if self:acceptToken2(44) ~= nil then
									goto _continue4
								end
								if self:acceptToken2(125) ~= nil then
									do break end
								end
								do self:skipSpaces() end
								do self:updateStagingToken() end
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
							end
						end
					end
					::_continue4::
				end
			end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptFunctionCallParameters()
	local opos = self:acceptToken2(40)
	if not (opos ~= nil) then
		do return nil end
	end
	do self:acceptNewlineToken() end
	do
		local params = {}
		if self:acceptToken2(41) ~= nil then
			do return params end
		end
		while true do
			do self:acceptNewlineToken() end
			do
				local csym = self:parseExpression()
				do self:acceptNewlineToken() end
				do _g.jk.lang.Vector:append(params, csym) end
				if self:acceptToken2(44) ~= nil then
					goto _continue5
				end
				if self:acceptToken2(41) ~= nil then
					do break end
				end
				do self:skipSpaces() end
				do self:updateStagingToken() end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `)'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			end
			::_continue5::
		end
		do return params end
	end
end

function sling.ss.parser.SlingScriptParser:acceptCreateObjectExpression()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local src = self:acceptToken1("new")
		if not (src ~= nil) then
			do return nil end
		end
		if not (self:peekNextCharacter() ~= 40) then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		if self:acceptToken1("buffer") ~= nil then
			local src = self:getAcceptedToken()
			do self:acceptNewlineToken() end
			do self:parseToken2(123) end
			do
				local xprs = {}
				while true do
					do self:acceptNewlineToken() end
					do
						local lit = self:acceptIntegerLiteralExpression()
						do self:acceptNewlineToken() end
						if lit ~= nil then
							do _g.jk.lang.Vector:append(xprs, lit) end
							goto _continue6
						end
						if self:acceptToken2(44) ~= nil then
							goto _continue6
						end
						if self:acceptToken2(125) ~= nil then
							do break end
						end
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("literal, `,' or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
					::_continue6::
				end
				do
					local size = _g.jk.lang.Vector:getSize(xprs)
					if size < 1 then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Buffer literal with no data", src, _g.jk.lang.StackTrace:generate()))
					end
					do
						local buffer = _util:allocate_buffer(size)
						local n = 0
						if xprs ~= nil then
							local n2 = 0
							local m = _g.jk.lang.Vector:getSize(xprs)
							do
								n2 = 0
								while n2 < m do
									local lit = xprs[n2 + 1]
									if lit ~= nil then
										buffer[(function() local v = n n = n + 1 return v end)() + 1] = _vm:bitwise_and(lit:getValue(), 255)
									end
									do n2 = n2 + 1 end
								end
							end
						end
						do
							local v = _g.sling.model.BufferLiteralExpressionNode:forValue(buffer)
							do v:setSource(src) end
							do return v end
						end
					end
				end
			end
		end
		do
			local name = self:parseDataType()
			if self:acceptToken2(91) ~= nil then
				local v = _g.sling.model.ArrayCreationExpressionNode:forPrimaryType(name)
				do v:setSource(src) end
				while true do
					local xpr = self:acceptExpression()
					do self:parseToken2(93) end
					if not (xpr ~= nil) then
						xpr = _g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())
					end
					do v:addToDimensions(xpr) end
					if not (self:acceptToken2(91) ~= nil) then
						do break end
					end
				end
				if _g.jk.lang.Vector:isEmpty(v:getDimensions()) then
					do v:addToDimensions(_g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())) end
				end
				if self:acceptToken2(61) ~= nil then
					do v:setArrayLiteral(self:parseArrayLiteralExpression(), false) end
				end
				do return v end
			end
			do
				local v = _g.sling.model.CreateObjectExpressionNode:forType(name)
				do v:setSource(src) end
				do v:setParameters(self:acceptFunctionCallParameters(), false) end
				do return v end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptFunctionDeclarationParameters()
	local open = self:acceptToken2(40)
	if not (open ~= nil) then
		do return nil end
	end
	do
		local v = {}
		if self:acceptToken2(41) ~= nil then
			do return v end
		end
		while true do
			local vr = self:parseIdentifier()
			do _g.jk.lang.Vector:append(v, _g.sling.model.VariableDeclarationNode:forDynamic(vr)) end
			if self:acceptToken2(44) ~= nil then
				goto _continue7
			end
			if self:acceptToken2(41) ~= nil then
				do break end
			end
			do self:skipSpaces() end
			do self:updateStagingToken() end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("`,' or `)'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
			::_continue7::
		end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:hasBlockNext()
	do return self:peekToken2(58) or self:peekToken2(123) end
end

function sling.ss.parser.SlingScriptParser:acceptBlock()
	if self:acceptToken2(58) ~= nil then
		local src = self:getAcceptedToken()
		do self:acceptNewlineToken() end
		do
			local stmt = self:parseStatement()
			local v = _g.sling.model.BlockNode:forStatement(stmt)
			do v:setSource(src) end
			do return v end
		end
	end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			do self:acceptNewlineToken() end
			do
				local src = self:acceptToken2(123)
				if src ~= nil then
					local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
					while true do
						do self:acceptNewlineToken() end
						if self:acceptToken2(125) ~= nil then
							do break end
						end
						do
							local comment = self:acceptComment()
							if comment ~= nil then
								do v:addNode(comment) end
								goto _continue8
							end
							do
								local stmt = self:acceptStatement()
								if stmt ~= nil then
									do v:addNode(stmt) end
									goto _continue8
								end
								do self:skipSpaces() end
								do self:updateStagingToken() end
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("statement or `}'"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
							end
						end
						::_continue8::
					end
					do return v end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
				do return nil end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:parseBlock()
	local v = self:acceptBlock()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("block"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptFunctionDeclaration()
	local start = self:acceptToken1("func")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local name = self:acceptIdentifier()
		local params = self:acceptFunctionDeclarationParameters()
		local v = _g.sling.model.FunctionDeclarationNode:forName(name, false)
		do v:setSource(start) end
		do v:setReturnType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
		do v:setParameters(params, false) end
		do v:setBody(self:parseBlock(), false) end
		do
			local fdx = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(v)
			do fdx:setSource(start) end
			do return fdx end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions16()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local slit = self:acceptStringLiteralExpression()
		if slit ~= nil then
			do return slit end
		end
		do
			local clit = self:acceptCharacterLiteralExpression()
			if clit ~= nil then
				do return clit end
			end
			do
				local blit = self:acceptBooleanLiteralExpression()
				if blit ~= nil then
					do return blit end
				end
				do
					local nlit = self:acceptNullLiteralExpression()
					if nlit ~= nil then
						do return nlit end
					end
					do
						local flit = self:acceptFailureLiteralExpression()
						if flit ~= nil then
							do return flit end
						end
						do
							local number = self:acceptNumberLiteralExpression()
							if number ~= nil then
								do return number end
							end
							do
								local alit = self:acceptArrayLiteralExpression()
								if alit ~= nil then
									do return alit end
								end
								do
									local mlit = self:acceptMapLiteralExpression()
									if mlit ~= nil then
										do return mlit end
									end
									if self:acceptToken2(40) ~= nil then
										local xpr = self:parseExpression()
										do self:parseToken2(41) end
										do return xpr end
									end
									do
										local xob = self:acceptCreateObjectExpression()
										if xob ~= nil then
											do return xob end
										end
										if self:acceptToken1("try") ~= nil then
											local src = self:getAcceptedToken()
											local xpr = self:parseExpression()
											local r = _g.sling.model.TryCatchExpressionNode:forExpression(xpr)
											do r:setSource(src) end
											do return r end
										end
										if self:acceptToken1("typeof") ~= nil then
											if self:peekNextCharacter() ~= 40 then
												local src = self:getAcceptedToken()
												local xpr = self:acceptExpression()
												if xpr ~= nil then
													local v = _g.sling.model.GetExpressionTypeinfoExpressionNode:forExpression(xpr)
													do v:setSource(src) end
													do return v end
												end
											end
											self.currentTokenColumn = ctc
											self.currentTokenLine = ctl
											do self.iterator:setCurrentPosition(ctp) end
											while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
												do self.commentQueue:pop() end
											end
											self.previousToken = cpt
										end
										if self:acceptToken1("typeinfo") ~= nil then
											if self:peekNextCharacter() ~= 40 then
												local src = self:getAcceptedToken()
												local dt = self:acceptDataType()
												if dt ~= nil then
													local v = _g.sling.model.GetDatatypeTypeinfoExpressionNode:forDatatype(dt)
													do v:setSource(src) end
													do return v end
												end
											end
											self.currentTokenColumn = ctc
											self.currentTokenLine = ctl
											do self.iterator:setCurrentPosition(ctp) end
											while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
												do self.commentQueue:pop() end
											end
											self.previousToken = cpt
										end
										if self:acceptToken1("sizeof") ~= nil then
											if self:peekNextCharacter() ~= 40 then
												local src = self:getAcceptedToken()
												local expr = self:acceptExpressions16()
												if expr ~= nil then
													local v = _g.sling.model.GetSizeExpressionNode:forExpression(expr)
													do v:setSource(src) end
													do return v end
												end
											end
											self.currentTokenColumn = ctc
											self.currentTokenLine = ctl
											do self.iterator:setCurrentPosition(ctp) end
											while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
												do self.commentQueue:pop() end
											end
											self.previousToken = cpt
										end
										if self:acceptToken1("defaultvalue") ~= nil then
											if self:peekNextCharacter() ~= 40 then
												local src = self:getAcceptedToken()
												local dt = self:acceptDataType()
												if dt ~= nil then
													local v = _g.sling.model.DataTypeDefaultValueExpressionNode:forType(dt)
													do v:setSource(src) end
													do return v end
												end
											end
											self.currentTokenColumn = ctc
											self.currentTokenLine = ctl
											do self.iterator:setCurrentPosition(ctp) end
											while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
												do self.commentQueue:pop() end
											end
											self.previousToken = cpt
										end
										do
											local funcd = self:acceptFunctionDeclaration()
											if funcd ~= nil then
												do return funcd end
											end
											do
												local symx = self:acceptSymbolExpression()
												if symx ~= nil then
													do return symx end
												end
												do return nil end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions15()
	local pe = self:acceptExpressions16()
	if not (pe ~= nil) then
		do return nil end
	end
	do
		local pi = nil
		while true do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			local cqs = 0
			if self.commentQueue ~= nil then
				cqs = self.commentQueue:getSize()
			end
			do
				local cpt = self.previousToken
				local dot = self:acceptToken1(".")
				if dot ~= nil then
					local ne = self:acceptSymbolExpression()
					if not (ne ~= nil) then
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do break end
					end
					if pi == nil then
						pi = _g.sling.model.MemberAccessExpressionNode:forNodes(pe, ne)
						pe = pi
					else
						local nx = _g.sling.model.MemberAccessExpressionNode:forNodes(pi:exportChildExpression(), ne)
						do pi:setChildExpression(nx, false) end
						pi = nx
					end
					do pi:setSource(dot) end
					goto _continue9
				end
				do
					local params = self:acceptFunctionCallParameters()
					if params ~= nil then
						local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(pe)
						do fc:setParameters(params, false) end
						do fc:setSource(pe:getSource()) end
						pe = fc
						pi = nil
						goto _continue9
					end
					if self:acceptToken2(91) ~= nil then
						local subscript = nil
						if self:acceptToken2(93) == nil then
							subscript = self:parseExpression()
							do self:parseToken2(93) end
						end
						do
							local se = _g.sling.model.SubscriptExpressionNode:instance(pe, subscript)
							do se:setSource(pe:getSource()) end
							pe = se
							pi = nil
							goto _continue9
						end
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
					do break end
				end
			end
			::_continue9::
		end
		if self:acceptToken1("++") ~= nil then
			local r = _g.sling.model.PostIncrementExpressionNode:forExpression(pe)
			do r:setSource(pe:getSource()) end
			do return r end
		end
		if self:acceptToken1("--") ~= nil then
			local r = _g.sling.model.PostDecrementExpressionNode:forExpression(pe)
			do r:setSource(pe:getSource()) end
			do return r end
		end
		do return pe end
	end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions14()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if self:acceptToken1("++") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.PreIncrementExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("--") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.PreDecrementExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("+") ~= nil then
			local right = self:acceptExpressions14()
			if right ~= nil then
				do return right end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("-") ~= nil then
			local src = self:getAcceptedToken()
			local right = self:acceptExpressions14()
			if right ~= nil then
				local v = _g.sling.model.NegativeNumberExpressionNode:forExpression(right)
				do v:setSource(src) end
				do return v end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("!") ~= nil or self:acceptToken1("not") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.LogicalNotExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		if self:acceptToken1("~") ~= nil then
			local src = self:getAcceptedToken()
			local v = self:acceptExpressions14()
			if v ~= nil then
				local r = _g.sling.model.BitwiseNotExpressionNode:forExpression(v)
				do r:setSource(src) end
				do return r end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		do return self:acceptExpressions15() end
	end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions13()
	local left = self:acceptExpressions14()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("*")
			if o1 ~= nil then
				local right = self:acceptExpressions14()
				if right ~= nil then
					local v = _g.sling.model.MultiplicationExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue10
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptToken1("/")
				if o2 ~= nil then
					local right = self:acceptExpressions14()
					if right ~= nil then
						local v = _g.sling.model.DivisionExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue10
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptToken1("%")
					if o3 ~= nil then
						local right = self:acceptExpressions14()
						if right ~= nil then
							local v = _g.sling.model.ModuloExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue10
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do break end
				end
			end
		end
		::_continue10::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions12()
	local left = self:acceptExpressions13()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("..")
			if o1 ~= nil then
				local right = self:acceptExpressions13()
				if right ~= nil then
					local v = _g.sling.model.StringConcatenationExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue11
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptToken1("+")
				if o2 ~= nil then
					local right = self:acceptExpressions13()
					if right ~= nil then
						local v = _g.sling.model.AdditionExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue11
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptToken1("-")
					if o3 ~= nil then
						local right = self:acceptExpressions13()
						if right ~= nil then
							local v = _g.sling.model.SubtractionExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue11
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do break end
				end
			end
		end
		::_continue11::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions11()
	local left = self:acceptExpressions12()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("<<")
			if o1 ~= nil then
				local right = self:acceptExpressions12()
				if right ~= nil then
					local v = _g.sling.model.ShiftLeftExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue12
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptToken1(">>")
				if o2 ~= nil then
					local right = self:acceptExpressions12()
					if right ~= nil then
						local v = _g.sling.model.ShiftRightExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue12
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptToken1(">>>")
					if o3 ~= nil then
						local right = self:acceptExpressions12()
						if right ~= nil then
							local v = _g.sling.model.ShiftRightExpressionNode:instance(left, right)
							do v:setZeroLeftmostBit(true) end
							do v:setSource(o3) end
							left = v
							goto _continue12
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do break end
				end
			end
		end
		::_continue12::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions10()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		if self:acceptToken1("malloc") ~= nil then
			if self:peekNextCharacter() ~= 40 then
				local src = self:getAcceptedToken()
				local sz = self:acceptExpressions11()
				if sz ~= nil then
					local v = _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create())
					do v:setSource(src) end
					do v:setExpression(sz, false) end
					do return v end
				end
			end
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
		end
		do return self:acceptExpressions11() end
	end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions9()
	local left = self:acceptExpressions10()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("<")
			if o1 ~= nil then
				local right = self:acceptExpressions10()
				if right ~= nil then
					local v = _g.sling.model.LessThanExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue13
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptToken1(">")
				if o2 ~= nil then
					local right = self:acceptExpressions10()
					if right ~= nil then
						local v = _g.sling.model.GreaterThanExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue13
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptToken1("<=")
					if o3 ~= nil then
						local right = self:acceptExpressions10()
						if right ~= nil then
							local v = _g.sling.model.LessOrEqualExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue13
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do
						local o4 = self:acceptToken1(">=")
						if o4 ~= nil then
							local right = self:acceptExpressions10()
							if right ~= nil then
								local v = _g.sling.model.GreaterOrEqualExpressionNode:instance(left, right)
								do v:setSource(o4) end
								left = v
								goto _continue13
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do
							local o5 = self:acceptToken1("is")
							if o5 ~= nil then
								local right = self:acceptDataType()
								if right ~= nil then
									local v = _g.sling.model.TypeCheckExpressionNode:instance(right, left, false)
									do v:setSource(o5) end
									left = v
									goto _continue13
								end
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
							end
							do break end
						end
					end
				end
			end
		end
		::_continue13::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions8()
	local left = self:acceptExpressions9()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("==")
			if o1 ~= nil then
				local right = self:acceptExpressions9()
				if right ~= nil then
					local v = _g.sling.model.EqualsExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue14
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptToken1("!=")
				if o2 ~= nil then
					local right = self:acceptExpressions9()
					if right ~= nil then
						local v = _g.sling.model.NotEqualsExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue14
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do break end
			end
		end
		::_continue14::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions7()
	local left = self:acceptExpressions8()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("&")
			if o1 ~= nil then
				local right = self:acceptExpressions8()
				if right ~= nil then
					local v = _g.sling.model.BitwiseAndExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue15
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue15::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions6()
	local left = self:acceptExpressions7()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("^")
			if o1 ~= nil then
				local right = self:acceptExpressions7()
				if right ~= nil then
					local v = _g.sling.model.BitwiseXorExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue16
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue16::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions5()
	local left = self:acceptExpressions6()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("|")
			if o1 ~= nil then
				local right = self:acceptExpressions6()
				if right ~= nil then
					local v = _g.sling.model.BitwiseOrExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue17
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue17::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions4()
	local left = self:acceptExpressions5()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("&&")
			if o1 ~= nil then
				local right = self:acceptExpressions5()
				if right ~= nil then
					local v = _g.sling.model.LogicalAndExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue18
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue18::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions3()
	local left = self:acceptExpressions4()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("||")
			if o1 ~= nil then
				local right = self:acceptExpressions4()
				if right ~= nil then
					local v = _g.sling.model.LogicalOrExpressionNode:instance(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue19
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue19::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions2()
	local left = self:acceptExpressions3()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken2(63)
			if o1 ~= nil then
				local trueExpr = self:acceptExpression()
				if trueExpr ~= nil and self:acceptToken2(58) ~= nil then
					local falseExpr = self:acceptExpression()
					if falseExpr ~= nil then
						local v = _g.sling.model.ConditionalExpressionNode:instance(left, trueExpr, falseExpr)
						do v:setSource(o1) end
						left = v
						goto _continue20
					end
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do break end
		end
		::_continue20::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpressions1()
	local left = self:acceptExpressions2()
	if not (left ~= nil) then
		do return nil end
	end
	while true do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local o1 = self:acceptToken1("=")
			if o1 ~= nil then
				local right = self:acceptExpressions2()
				if right ~= nil then
					local v = _g.sling.model.AssignmentExpressionNode:forNodes(left, right)
					do v:setSource(o1) end
					left = v
					goto _continue21
				end
				self.currentTokenColumn = ctc
				self.currentTokenLine = ctl
				do self.iterator:setCurrentPosition(ctp) end
				while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
					do self.commentQueue:pop() end
				end
				self.previousToken = cpt
			end
			do
				local o2 = self:acceptToken1("*=")
				if o2 ~= nil then
					local right = self:acceptExpressions2()
					if right ~= nil then
						local v = _g.sling.model.MultiplicationAssignmentExpressionNode:instance(left, right)
						do v:setSource(o2) end
						left = v
						goto _continue21
					end
					self.currentTokenColumn = ctc
					self.currentTokenLine = ctl
					do self.iterator:setCurrentPosition(ctp) end
					while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
						do self.commentQueue:pop() end
					end
					self.previousToken = cpt
				end
				do
					local o3 = self:acceptToken1("/=")
					if o3 ~= nil then
						local right = self:acceptExpressions2()
						if right ~= nil then
							local v = _g.sling.model.DivisionAssignmentExpressionNode:instance(left, right)
							do v:setSource(o3) end
							left = v
							goto _continue21
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
					end
					do
						local o4 = self:acceptToken1("%=")
						if o4 ~= nil then
							local right = self:acceptExpressions2()
							if right ~= nil then
								local v = _g.sling.model.ModuloAssignmentExpressionNode:instance(left, right)
								do v:setSource(o4) end
								left = v
								goto _continue21
							end
							self.currentTokenColumn = ctc
							self.currentTokenLine = ctl
							do self.iterator:setCurrentPosition(ctp) end
							while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
								do self.commentQueue:pop() end
							end
							self.previousToken = cpt
						end
						do
							local o5 = self:acceptToken1("+=")
							if o5 ~= nil then
								local right = self:acceptExpressions2()
								if right ~= nil then
									local v = _g.sling.model.AdditionAssignmentExpressionNode:instance(left, right)
									do v:setSource(o5) end
									left = v
									goto _continue21
								end
								self.currentTokenColumn = ctc
								self.currentTokenLine = ctl
								do self.iterator:setCurrentPosition(ctp) end
								while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
									do self.commentQueue:pop() end
								end
								self.previousToken = cpt
							end
							do
								local o6 = self:acceptToken1("-=")
								if o6 ~= nil then
									local right = self:acceptExpressions2()
									if right ~= nil then
										local v = _g.sling.model.SubtractionAssignmentExpressionNode:instance(left, right)
										do v:setSource(o6) end
										left = v
										goto _continue21
									end
									self.currentTokenColumn = ctc
									self.currentTokenLine = ctl
									do self.iterator:setCurrentPosition(ctp) end
									while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
										do self.commentQueue:pop() end
									end
									self.previousToken = cpt
								end
								do
									local o7 = self:acceptToken1("<<=")
									if o7 ~= nil then
										local right = self:acceptExpressions2()
										if right ~= nil then
											local v = _g.sling.model.ShiftLeftAssignmentExpressionNode:instance(left, right)
											do v:setSource(o7) end
											left = v
											goto _continue21
										end
										self.currentTokenColumn = ctc
										self.currentTokenLine = ctl
										do self.iterator:setCurrentPosition(ctp) end
										while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
											do self.commentQueue:pop() end
										end
										self.previousToken = cpt
									end
									do
										local o8 = self:acceptToken1(">>=")
										if o8 ~= nil then
											local right = self:acceptExpressions2()
											if right ~= nil then
												local v = _g.sling.model.ShiftRightAssignmentExpressionNode:instance(left, right)
												do v:setSource(o8) end
												left = v
												goto _continue21
											end
											self.currentTokenColumn = ctc
											self.currentTokenLine = ctl
											do self.iterator:setCurrentPosition(ctp) end
											while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
												do self.commentQueue:pop() end
											end
											self.previousToken = cpt
										end
										do
											local o9 = self:acceptToken1(">>>=")
											if o9 ~= nil then
												local right = self:acceptExpressions2()
												if right ~= nil then
													local v = _g.sling.model.ShiftRightAssignmentExpressionNode:instance(left, right)
													do v:setSource(o9) end
													do v:setZeroLeftmostBit(true) end
													left = v
													goto _continue21
												end
												self.currentTokenColumn = ctc
												self.currentTokenLine = ctl
												do self.iterator:setCurrentPosition(ctp) end
												while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
													do self.commentQueue:pop() end
												end
												self.previousToken = cpt
											end
											do
												local o10 = self:acceptToken1("&=")
												if o10 ~= nil then
													local right = self:acceptExpressions2()
													if right ~= nil then
														local v = _g.sling.model.BitwiseAndAssignmentExpressionNode:instance(left, right)
														do v:setSource(o10) end
														left = v
														goto _continue21
													end
													self.currentTokenColumn = ctc
													self.currentTokenLine = ctl
													do self.iterator:setCurrentPosition(ctp) end
													while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
														do self.commentQueue:pop() end
													end
													self.previousToken = cpt
												end
												do
													local o11 = self:acceptToken1("^=")
													if o11 ~= nil then
														local right = self:acceptExpressions2()
														if right ~= nil then
															local v = _g.sling.model.BitwiseXorAssignmentExpressionNode:instance(left, right)
															do v:setSource(o11) end
															left = v
															goto _continue21
														end
														self.currentTokenColumn = ctc
														self.currentTokenLine = ctl
														do self.iterator:setCurrentPosition(ctp) end
														while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
															do self.commentQueue:pop() end
														end
														self.previousToken = cpt
													end
													do
														local o12 = self:acceptToken1("|=")
														if o12 ~= nil then
															local right = self:acceptExpressions2()
															if right ~= nil then
																local v = _g.sling.model.BitwiseOrAssignmentExpressionNode:instance(left, right)
																do v:setSource(o12) end
																left = v
																goto _continue21
															end
															self.currentTokenColumn = ctc
															self.currentTokenLine = ctl
															do self.iterator:setCurrentPosition(ctp) end
															while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
																do self.commentQueue:pop() end
															end
															self.previousToken = cpt
														end
														do break end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
		::_continue21::
	end
	do return left end
end

function sling.ss.parser.SlingScriptParser:acceptExpression()
	do return self:acceptExpressions1() end
end

function sling.ss.parser.SlingScriptParser:parseExpression()
	local v = self:acceptExpression()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("expression"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:acceptAssertStatement()
	local start = self:acceptToken1("assert")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local expression = self:parseExpression()
		local block = self:acceptBlock()
		local v = _g.sling.model.AssertStatementNode:forChild(expression)
		do v:setSource(start) end
		do v:setStyle(_g.sling.model.AssertStatementNode.STYLE_RETURN) end
		do v:setErrorBlock(block, false) end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:acceptTryStatement()
	local ctc = self.currentTokenColumn
	local ctl = self.currentTokenLine
	local ctp = self.iterator:getCurrentPosition()
	local cqs = 0
	if self.commentQueue ~= nil then
		cqs = self.commentQueue:getSize()
	end
	do
		local cpt = self.previousToken
		local start = self:acceptToken1("try")
		if not (start ~= nil) then
			do return nil end
		end
		if not self:hasBlockNext() then
			self.currentTokenColumn = ctc
			self.currentTokenLine = ctl
			do self.iterator:setCurrentPosition(ctp) end
			while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
				do self.commentQueue:pop() end
			end
			self.previousToken = cpt
			do return nil end
		end
		do
			local tryBlock = self:parseBlock()
			local v = _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create())
			do v:setSource(start) end
			do v:setTryBlock(tryBlock, false) end
			while true do
				do self:acceptNewlineToken() end
				if not (self:acceptToken1("catch") ~= nil) then
					do break end
				end
				do
					local variable = nil
					local varname = self:acceptIdentifier()
					if varname ~= nil then
						local vartype = nil
						if self:acceptToken1("as") ~= nil then
							vartype = self:parseDataType()
						end
						if not (vartype ~= nil) then
							vartype = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
						end
						variable = _g.sling.model.VariableDeclarationNode:instance(vartype, varname, nil)
					end
					do
						local catchBlock = self:parseBlock()
						do v:addToCatchBlocks(_g.sling.model.CatchBlockNode:instance(variable, catchBlock)) end
					end
				end
			end
			while true do
				do self:acceptNewlineToken() end
				if v:getFinallyBlock() == nil then
					local finally = self:acceptToken1("finally")
					if finally ~= nil then
						do v:setFinallyBlock(self:parseBlock(), false) end
						goto _continue22
					end
				end
				if v:getElseBlock() == nil then
					local elset = self:acceptToken1("else")
					if elset ~= nil then
						do v:setElseBlock(self:parseBlock(), false) end
						goto _continue22
					end
				end
				do break end
				::_continue22::
			end
			if _g.jk.lang.Vector:getSize(v:getCatchBlocks()) < 1 then
				local evar = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "e", nil)
				do v:addToCatchBlocks(_g.sling.model.CatchBlockNode:instance(evar, _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()))) end
			end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptThrowStatement()
	local start = self:acceptToken1("throw")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local expr = self:parseExpression()
		do self:parseNewlineToken() end
		do
			local v = _g.sling.model.ThrowStatementNode:forExpression(expr)
			do v:setSource(start) end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptVariableDeclarationStatement()
	local src = self:acceptToken1("var")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local name = self:parseIdentifier()
		local v = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), name, nil)
		do v:setSource(src) end
		if self:acceptToken2(61) ~= nil then
			do v:setInitializer(self:parseExpression(), false) end
		end
		do self:parseNewlineToken() end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:acceptIfStatement()
	local src = self:acceptToken1("if")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local condition = self:parseExpression()
		local elseBlock = nil
		local block = self:parseBlock()
		do self:acceptNewlineToken() end
		do
			local elseToken = self:acceptToken1("else")
			if elseToken ~= nil then
				local childIf = self:acceptIfStatement()
				if childIf ~= nil then
					elseBlock = _g.sling.model.BlockNode:forStatement(childIf)
					do elseBlock:setSource(elseToken) end
				else
					elseBlock = self:parseBlock()
					do self:acceptNewlineToken() end
				end
			end
			do
				local v = _g.sling.model.IfStatementNode:instance(condition, block, elseBlock)
				do v:setSource(src) end
				do return v end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptForeachStatement()
	local start = self:acceptToken1("foreach")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local left = self:parseIdentifier()
		do self:parseToken1("in") end
		do
			local right = self:parseExpression()
			local block = self:parseBlock()
			local leftvd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), left, nil)
			local v = _g.sling.model.ForEachStatementNode:instance(leftvd, right, block, nil)
			do v:setSource(start) end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptLoopStatement()
	local start = self:acceptToken1("loop")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local block = self:parseBlock()
		local v = _g.sling.model.WhileStatementNode:instance(_g.sling.model.BooleanLiteralExpressionNode:forValue(true), block, nil)
		do v:setSource(start) end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:acceptWhileStatement()
	local start = self:acceptToken1("while")
	if not (start ~= nil) then
		do return nil end
	end
	do
		local condition = self:parseExpression()
		local block = self:parseBlock()
		local v = _g.sling.model.WhileStatementNode:instance(condition, block, nil)
		do v:setSource(start) end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:acceptBreakStatement()
	local start = self:acceptToken1("break")
	if not (start ~= nil) then
		do return nil end
	end
	do self:parseNewlineToken() end
	do
		local v = _g.sling.model.BreakStatementNode._construct0(_g.sling.model.BreakStatementNode._create())
		do v:setSource(start) end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:acceptContinueStatement()
	local start = self:acceptToken1("continue")
	if not (start ~= nil) then
		do return nil end
	end
	do self:parseNewlineToken() end
	do
		local v = _g.sling.model.ContinueStatementNode._construct0(_g.sling.model.ContinueStatementNode._create())
		do v:setSource(start) end
		do return v end
	end
end

function sling.ss.parser.SlingScriptParser:isValidSimplifiedFunctionCallParameterCharacter(c)
	if c == 32 or c == 13 or c == 10 or c == 59 then
		do return false end
	end
	do return true end
end

function sling.ss.parser.SlingScriptParser:acceptSimplifiedFunctionCallParameterToken()
	do self:skipSpaces() end
	do
		local c0 = self:peekNextCharacter()
		if not self:isValidSimplifiedFunctionCallParameterCharacter(c0) then
			do return nil end
		end
		do
			local ctc = self.currentTokenColumn
			local ctl = self.currentTokenLine
			local ctp = self.iterator:getCurrentPosition()
			do self:getNextCharacter() end
			do
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendCharacter(c0) end
				while true do
					local cn = self:peekNextCharacter()
					if self:isValidSimplifiedFunctionCallParameterCharacter(cn) then
						do self:getNextCharacter() end
						do sb:appendCharacter(cn) end
					else
						do break end
					end
				end
				do
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = sb:toString()
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptFunctionCallStatement()
	local src = self:acceptToken1("call")
	if not (src ~= nil) then
		do return nil end
	end
	do
		local xpr = self:parseSymbolExpression()
		local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(xpr)
		local params = _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create())
		do params:setType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
		do fc:addToParameters(params) end
		while true do
			if self:acceptNewlineToken() ~= nil then
				do break end
			end
			do self:skipSpaces() end
			do
				local nc = self:peekNextCharacter()
				if nc == 40 or nc == 34 or nc == 39 then
					local pxpr = self:parseExpression()
					do params:addToExpressions(pxpr) end
					goto _continue23
				end
				do
					local ptok = self:acceptSimplifiedFunctionCallParameterToken()
					if ptok ~= nil then
						local lit = _g.sling.model.StringLiteralExpressionNode:forValue(ptok.value)
						do lit:setSource(ptok) end
						do params:addToExpressions(lit) end
						goto _continue23
					end
					do return nil end
				end
			end
			::_continue23::
		end
		do return fc end
	end
end

function sling.ss.parser.SlingScriptParser:acceptStatement()
	local ifStatement = self:acceptIfStatement()
	if ifStatement ~= nil then
		do return ifStatement end
	end
	do
		local feStatement = self:acceptForeachStatement()
		if feStatement ~= nil then
			do return feStatement end
		end
		do
			local lops = self:acceptLoopStatement()
			if lops ~= nil then
				do return lops end
			end
			do
				local whiles = self:acceptWhileStatement()
				if whiles ~= nil then
					do return whiles end
				end
				do
					local trys = self:acceptTryStatement()
					if trys ~= nil then
						do return trys end
					end
					do
						local asss = self:acceptAssertStatement()
						if asss ~= nil then
							do return asss end
						end
						do
							local throws = self:acceptThrowStatement()
							if throws ~= nil then
								do return throws end
							end
							do
								local breaks = self:acceptBreakStatement()
								if breaks ~= nil then
									do return breaks end
								end
								do
									local continues = self:acceptContinueStatement()
									if continues ~= nil then
										do return continues end
									end
									if self:peekToken2(123) then
										do return self:parseBlock() end
									end
									if self:acceptToken1("println") ~= nil then
										local src = self:getAcceptedToken()
										local xpr = self:acceptExpression()
										if not (xpr ~= nil) then
											xpr = _g.sling.model.StringLiteralExpressionNode:forValue("")
										end
										do self:parseNewlineToken() end
										do
											local v = _g.sling.model.PrintLineStatementNode:forExpression(xpr)
											do v:setSource(src) end
											do return v end
										end
									end
									if self:acceptToken1("print") ~= nil then
										local src = self:getAcceptedToken()
										local xpr = self:acceptExpression()
										if not (xpr ~= nil) then
											xpr = _g.sling.model.StringLiteralExpressionNode:forValue("")
										end
										do self:parseNewlineToken() end
										do
											local v = _g.sling.model.PrintStatementNode:forExpression(xpr)
											do v:setSource(src) end
											do return v end
										end
									end
									if self:acceptToken1("return") ~= nil then
										local src = self:getAcceptedToken()
										local xpr = self:acceptExpression()
										do self:parseNewlineToken() end
										do
											local v = _g.sling.model.ReturnStatementNode:forExpression(xpr)
											do v:setSource(src) end
											do return v end
										end
									end
									do
										local fd = self:acceptFunctionDeclaration()
										if fd ~= nil then
											do return fd end
										end
										do
											local vds = self:acceptVariableDeclarationStatement()
											if vds ~= nil then
												do return vds end
											end
											do
												local fcs = self:acceptFunctionCallStatement()
												if fcs ~= nil then
													do return fcs end
												end
												do
													local ctc = self.currentTokenColumn
													local ctl = self.currentTokenLine
													local ctp = self.iterator:getCurrentPosition()
													local cqs = 0
													if self.commentQueue ~= nil then
														cqs = self.commentQueue:getSize()
													end
													do
														local cpt = self.previousToken
														local xpr = self:acceptExpression()
														if xpr ~= nil then
															if self:acceptNewlineToken() ~= nil then
																if (_vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
																	xpr = _g.sling.model.FunctionCallExpressionNode:forExpression(xpr)
																end
																do return xpr end
															end
															self.currentTokenColumn = ctc
															self.currentTokenLine = ctl
															do self.iterator:setCurrentPosition(ctp) end
															while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
																do self.commentQueue:pop() end
															end
															self.previousToken = cpt
														end
														do return nil end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:parseStatement()
	local v = self:acceptStatement()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:isValidReferenceIdentifierCharacter(c, isLibraryName)
	if _g.jk.lang.Character:isAlnum(c) then
		do return true end
	end
	if c == 45 or c == 95 or c == 46 then
		do return true end
	end
	if isLibraryName and c == 58 then
		do return true end
	end
	do return false end
end

function sling.ss.parser.SlingScriptParser:acceptReferenceIdentifierToken(isLibraryName)
	do self:skipSpaces() end
	do
		local ctc = self.currentTokenColumn
		local ctl = self.currentTokenLine
		local ctp = self.iterator:getCurrentPosition()
		local cqs = 0
		if self.commentQueue ~= nil then
			cqs = self.commentQueue:getSize()
		end
		do
			local cpt = self.previousToken
			local c0 = self:peekNextCharacter()
			if not self:isValidReferenceIdentifierCharacter(c0, isLibraryName) then
				do return nil end
			end
			do self:getNextCharacter() end
			do
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendCharacter(c0) end
				while true do
					local cn = self:peekNextCharacter()
					if self:isValidReferenceIdentifierCharacter(cn, isLibraryName) then
						do self:getNextCharacter() end
						do sb:appendCharacter(cn) end
					else
						if cn == 32 or cn == 9 or cn == 13 or cn == 10 or cn == 59 then
							do break end
						end
						self.currentTokenColumn = ctc
						self.currentTokenLine = ctl
						do self.iterator:setCurrentPosition(ctp) end
						while self.commentQueue ~= nil and self.commentQueue:getSize() > cqs do
							do self.commentQueue:pop() end
						end
						self.previousToken = cpt
						do return nil end
					end
				end
				do
					local v = self.stagingToken
					self.stagingToken = nil
					do self:updateStagingToken() end
					v.line = ctl
					v.column = ctc
					v.position = ctp
					v.value = sb:toString()
					do self:onTokenAccepted(v) end
					do return v end
				end
			end
		end
	end
end

function sling.ss.parser.SlingScriptParser:acceptReferenceIdentifier(isLibraryName)
	local token = self:acceptReferenceIdentifierToken(isLibraryName)
	if not (token ~= nil) then
		do return nil end
	end
	do return token.value end
end

function sling.ss.parser.SlingScriptParser:acceptModuleName()
	do return self:acceptReferenceIdentifier(false) end
end

function sling.ss.parser.SlingScriptParser:parseModuleName()
	local v = self:acceptModuleName()
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("module name"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:parseLibraryNameString()
	local v = self:acceptReferenceIdentifier(true)
	if not (v ~= nil) then
		do self:skipSpaces() end
		do self:updateStagingToken() end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("library name"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
	end
	do return v end
end

function sling.ss.parser.SlingScriptParser:parse()
	local v = _g.sling.common.CodeFileNode._construct0(_g.sling.common.CodeFileNode._create())
	do v:setFile(self:getCurrentFile()) end
	do
		local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
		do v:addNode(block) end
		do
			local header = self:getHasHeader()
			while true do
				do self:acceptNewlineToken() end
				if self:acceptEOF() ~= nil then
					do break end
				end
				if header then
					if self:acceptToken1("lib") ~= nil then
						local src = self:getAcceptedToken()
						local libname = nil
						if self:acceptToken1("src") ~= nil then
							local lit = self:parseStringLiteralExpression()
							libname = "libsrc:" .. _g.jk.lang.String:safeString(lit:getValue())
						else
							libname = "libname:" .. _g.jk.lang.String:safeString(self:parseLibraryNameString())
						end
						do self:parseNewlineToken() end
						do
							local v = _g.sling.model.DependencyDeclarationNode._construct0(_g.sling.model.DependencyDeclarationNode._create())
							do v:setSource(src) end
							do v:setValue(libname) end
							do block:addNode(v) end
							goto _continue24
						end
					end
					if self:acceptToken1("import") ~= nil then
						local src = self:getAcceptedToken()
						local mod = self:parseSymbolReference()
						local name = nil
						if self:acceptToken1("as") ~= nil then
							name = self:parseIdentifier()
						end
						do self:parseNewlineToken() end
						do
							local v = _g.sling.model.ImportPackageStatementNode._construct0(_g.sling.model.ImportPackageStatementNode._create())
							do v:setPackage(mod, false) end
							do v:setLocalName(name) end
							do block:addNode(v) end
							goto _continue24
						end
					end
				end
				do
					local comment = self:acceptComment()
					if comment ~= nil then
						do block:addNode(comment) end
						goto _continue24
					end
					if self:acceptToken1("include") ~= nil then
						local src = self:getAcceptedToken()
						local filename = self:parseStringLiteralExpression()
						do self:parseNewlineToken() end
						do
							local cd = self:getCurrentDirectory()
							if not (cd ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No current directory. Cannot include.", src, _g.jk.lang.StackTrace:generate()))
							end
							do
								local file = cd:entry(filename:getValue())
								if not file:isFile() then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("File does not exist: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", src, _g.jk.lang.StackTrace:generate()))
								end
								do
									local ifile = _g.sling.ss.parser.SlingScriptParser._construct0(_g.sling.ss.parser.SlingScriptParser._create()):setHasHeader(false):parseFile(file)
									local array = ifile:exportNodes()
									if array ~= nil then
										local n = 0
										local m = _g.jk.lang.Vector:getSize(array)
										do
											n = 0
											while n < m do
												local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
												if node ~= nil then
													if (_vm:to_table_with_key(node, '_isType.sling.model.BlockNode') ~= nil) then
														local array2 = node:exportNodes()
														if array2 ~= nil then
															local n2 = 0
															local m2 = _g.jk.lang.Vector:getSize(array2)
															do
																n2 = 0
																while n2 < m2 do
																	local bnode = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
																	if bnode ~= nil then
																		do block:addNode(bnode) end
																	end
																	do n2 = n2 + 1 end
																end
															end
														end
													else
														do block:addNode(node) end
													end
												end
												do n = n + 1 end
											end
										end
									end
									goto _continue24
								end
							end
						end
					end
					do
						local stmt = self:acceptStatement()
						if stmt ~= nil then
							do block:addNode(stmt) end
							header = false
							goto _continue24
						end
						do self:skipSpaces() end
						do self:updateStagingToken() end
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expected: " .. self:getDisplayText("statement"), self:getStagingToken(), _g.jk.lang.StackTrace:generate()))
					end
				end
				::_continue24::
			end
			do return v end
		end
	end
end

function sling.ss.parser.SlingScriptParser:getHasHeader()
	do return self.hasHeader end
end

function sling.ss.parser.SlingScriptParser:setHasHeader(v)
	self.hasHeader = v
	do return self end
end
jk = jk or {}

jk.sha = jk.sha or {}

jk.sha.SHAEncoder = {}
jk.sha.SHAEncoder.__index = jk.sha.SHAEncoder
_vm:set_metatable(jk.sha.SHAEncoder, {})

jk.sha.SHAEncoder.ANY = 0
jk.sha.SHAEncoder.SHA1 = 1
jk.sha.SHAEncoder.SHA224 = 2
jk.sha.SHAEncoder.SHA256 = 3
jk.sha.SHAEncoder.SHA384 = 4
jk.sha.SHAEncoder.SHA512 = 5

function jk.sha.SHAEncoder._create()
	local v = _vm:set_metatable({}, jk.sha.SHAEncoder)
	return v
end

function jk.sha.SHAEncoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.sha.SHAEncoder'
	self['_isType.jk.sha.SHAEncoder'] = true
end

function jk.sha.SHAEncoder:_construct0()
	jk.sha.SHAEncoder._init(self)
	return self
end

function jk.sha.SHAEncoder:create()
	do return _g.jk.sha.SHAEncoderGeneric._construct0(_g.jk.sha.SHAEncoderGeneric._create()) end
end

function jk.sha.SHAEncoder:getSha1HashForString(data)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local enc = _g.jk.sha.SHAEncoder:create()
		if not (enc ~= nil) then
			do return nil end
		end
		do return enc:encodeAsString(_g.jk.lang.String:toUTF8Buffer(data), _g.jk.sha.SHAEncoder.SHA1) end
	end
end

function jk.sha.SHAEncoder:getSha1HashForBuffer(data)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local enc = _g.jk.sha.SHAEncoder:create()
		if not (enc ~= nil) then
			do return nil end
		end
		do return enc:encodeAsString(data, _g.jk.sha.SHAEncoder.SHA1) end
	end
end

function jk.sha.SHAEncoder:encodeAsBuffer(data, version)
end

function jk.sha.SHAEncoder:encodeAsString(data, version)
end

jk.sha.SHAEncoderGeneric = _g.jk.sha.SHAEncoder._create()
jk.sha.SHAEncoderGeneric.__index = jk.sha.SHAEncoderGeneric
_vm:set_metatable(jk.sha.SHAEncoderGeneric, {
	__index = _g.jk.sha.SHAEncoder
})

function jk.sha.SHAEncoderGeneric._create()
	local v = _vm:set_metatable({}, jk.sha.SHAEncoderGeneric)
	return v
end

function jk.sha.SHAEncoderGeneric:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.sha.SHAEncoderGeneric'
	self['_isType.jk.sha.SHAEncoderGeneric'] = true
end

function jk.sha.SHAEncoderGeneric:_construct0()
	jk.sha.SHAEncoderGeneric._init(self)
	do _g.jk.sha.SHAEncoder._construct0(self) end
	return self
end

function jk.sha.SHAEncoderGeneric:encodeAsBuffer(data, version)
	if not (data ~= nil) then
		do return nil end
	end
	do
		local algorithm = 0
		if _g.jk.sha.SHAEncoder.ANY == version or _g.jk.sha.SHAEncoder.SHA1 == version then
			algorithm = 128
		elseif _g.jk.sha.SHAEncoder.SHA256 == version then
			algorithm = 256
		elseif _g.jk.sha.SHAEncoder.SHA384 == version then
			algorithm = 384
		elseif _g.jk.sha.SHAEncoder.SHA512 == version then
			algorithm = 512
		end
		if not (algorithm ~= 0) then
			do return nil end
		end
		do
			local sha = _g.jk.sha.SHAEncoderGeneric.SHA._construct0(_g.jk.sha.SHAEncoderGeneric.SHA._create())
			do sha:encode(data, algorithm) end
			do return sha:digest() end
		end
	end
end

function jk.sha.SHAEncoderGeneric:encodeAsString(data, version)
	local digest = self:encodeAsBuffer(data, version)
	if not (digest ~= nil) then
		do return nil end
	end
	do
		local result = _g.jk.lang.String:forBufferHex(digest)
		do return result end
	end
end

jk.sha.SHAEncoderGeneric.SHA = {}
jk.sha.SHAEncoderGeneric.SHA.__index = jk.sha.SHAEncoderGeneric.SHA
_vm:set_metatable(jk.sha.SHAEncoderGeneric.SHA, {})

function jk.sha.SHAEncoderGeneric.SHA._create()
	local v = _vm:set_metatable({}, jk.sha.SHAEncoderGeneric.SHA)
	return v
end

function jk.sha.SHAEncoderGeneric.SHA:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.sha.SHAEncoderGeneric.SHA'
	self['_isType.jk.sha.SHAEncoderGeneric.SHA'] = true
	self.sha128 = 160
	self.sha256 = 256
	self.sha384 = 384
	self.sha512 = 512
	self.blockSize512 = 512
	self.blockSize1024 = 1024
	self.block64 = 448
	self.block128 = 896
	self.digestLength = 0
	self.blockBitSize = 0
	self.k = nil
	self.k2 = nil
	self.hash1 = nil
	self.hash2 = nil
	self.input = nil
	self.result = nil
end

function jk.sha.SHAEncoderGeneric.SHA:_construct0()
	jk.sha.SHAEncoderGeneric.SHA._init(self)
	return self
end

function jk.sha.SHAEncoderGeneric.SHA:encode(buf, version)
	if not (buf ~= nil) then
		do return end
	end
	self.input = buf
	if version == self.sha384 or version == self.sha512 then
		self.k2 = {
			4794697086780616704,
			8158064640168780800,
			-9223372036854775808,
			-9223372036854775808,
			4131703408338449408,
			6480981068601479168,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			1334009975649890304,
			2608012711638118912,
			6128411473006801920,
			8268148722764580864,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			1135362057144423808,
			2597628984639134720,
			3308224258029322752,
			5365058923640841216,
			6679025012923563008,
			8573033837759648768,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			489312712824947328,
			1452737877330783744,
			2861767655752347648,
			3322285676063803392,
			5560940570517710848,
			5996557281743188992,
			7280758554555802624,
			8532644243296464896,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			1182934255886127616,
			1847814050463011072,
			2177327727835720448,
			2830643537854262272,
			3796741975233480704,
			4115178125766777344,
			5681478168544905216,
			6601373596472566784,
			7507060721942968320,
			8399075790359080960,
			8693463985226723328,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			-9223372036854775808,
			500013540394364864,
			748580250866718848,
			1242879168328830464,
			1977374033974150912,
			2944078676154940416,
			3659926193048069120,
			4368137639120453120,
			4836135668995329024,
			5532061633213251584,
			6448918945643986944,
			6902733635092674560,
			7801388544844847104
		}
	end
	if version == 128 then
		self.digestLength = self.sha128
		self.blockBitSize = self.blockSize512
		self.hash1 = {
			1732584193,
			4023233417,
			2562383102,
			271733878,
			3285377520
		}
	elseif version == self.sha256 then
		self.digestLength = self.sha256
		self.blockBitSize = self.blockSize512
		self.hash1 = {
			1779033703,
			3144134277,
			1013904242,
			2773480762,
			1359893119,
			2600822924,
			528734635,
			1541459225
		}
		self.k = {
			1116352408,
			1899447441,
			3049323471,
			3921009573,
			961987163,
			1508970993,
			2453635748,
			2870763221,
			3624381080,
			310598401,
			607225278,
			1426881987,
			1925078388,
			2162078206,
			2614888103,
			3248222580,
			3835390401,
			4022224774,
			264347078,
			604807628,
			770255983,
			1249150122,
			1555081692,
			1996064986,
			2554220882,
			2821834349,
			2952996808,
			3210313671,
			3336571891,
			3584528711,
			113926993,
			338241895,
			666307205,
			773529912,
			1294757372,
			1396182291,
			1695183700,
			1986661051,
			2177026350,
			2456956037,
			2730485921,
			2820302411,
			3259730800,
			3345764771,
			3516065817,
			3600352804,
			4094571909,
			275423344,
			430227734,
			506948616,
			659060556,
			883997877,
			958139571,
			1322822218,
			1537002063,
			1747873779,
			1955562222,
			2024104815,
			2227730452,
			2361852424,
			2428436474,
			2756734187,
			3204031479,
			3329325298
		}
	elseif version == self.sha384 then
		self.digestLength = self.sha384
		self.blockBitSize = self.blockSize1024
		self.hash2 = {
			-9223372036854775808,
			7105036623409894400,
			-9223372036854775808,
			1526699215303891200,
			7436329637833083904,
			-9223372036854775808,
			-9223372036854775808,
			5167115440072839168
		}
	else
		self.digestLength = self.sha512
		self.blockBitSize = self.blockSize1024
		self.hash2 = {
			7640891576956012544,
			-9223372036854775808,
			4354685564936845312,
			-9223372036854775808,
			5840696475078000640,
			-9223372036854775808,
			2270897969802886400,
			6620516959819538432
		}
	end
end

function jk.sha.SHAEncoderGeneric.SHA:digest()
	if not (self.input ~= nil) then
		do return nil end
	end
	if self.result ~= nil then
		do return self.result end
	end
	do
		local ptr = self:bitPadding(self.input)
		local messageBlocks = self:blocks(ptr, _util:convert_to_integer(self.blockBitSize / 8))
		if messageBlocks ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(messageBlocks)
			do
				n = 0
				while n < m do
					local block = messageBlocks[n + 1]
					if block ~= nil then
						if self.blockBitSize == self.blockSize512 then
							do self:shaProcess32(block) end
						else
							do self:shaProcess64(block) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local ret = _util:allocate_buffer(_util:convert_to_integer(self.digestLength / 8))
			if self.blockBitSize == self.blockSize512 then
				local idx = 0
				if self.hash1 ~= nil then
					local n2 = 0
					local m2 = #self.hash1
					do
						n2 = 0
						while n2 < m2 do
							local element = self.hash1[n2 + 1]
							local pos = idx * 4
							ret[pos + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 24), 255)
							ret[pos + 1 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 16), 255)
							ret[pos + 2 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 8), 255)
							ret[pos + 3 + 1] = _vm:bitwise_and(element, 255)
							idx = idx + 1
							do n2 = n2 + 1 end
						end
					end
				end
			else
				local idx = 0
				if self.hash2 ~= nil then
					local n3 = 0
					local m3 = #self.hash2
					do
						n3 = 0
						while n3 < m3 do
							local element = self.hash2[n3 + 1]
							if self.digestLength == self.sha384 and idx == 6 then
								do break end
							end
							do
								local pos = idx * 8
								ret[pos + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 56), 255)
								ret[pos + 1 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 48), 255)
								ret[pos + 2 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 40), 255)
								ret[pos + 3 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 32), 255)
								ret[pos + 4 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 24), 255)
								ret[pos + 5 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 16), 255)
								ret[pos + 6 + 1] = _vm:bitwise_and(_vm:bitwise_right_shift(element, 8), 255)
								ret[pos + 7 + 1] = _vm:bitwise_and(element, 255)
								idx = idx + 1
							end
							do n3 = n3 + 1 end
						end
					end
				end
			end
			self.result = ret
			do return ret end
		end
	end
end

function jk.sha.SHAEncoderGeneric.SHA:shaProcess32(block)
	local kcount = 0
	if self.digestLength == self.sha128 then
		kcount = 80
	else
		kcount = #self.k
	end
	do
		local output = _vm:allocate_array(kcount)
		do
			local t = 0
			while t < #output do
				if t <= 15 then
					local index = t * 4
					output[t + 1] = _vm:bitwise_left_shift(block[index + 1], 24)
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 1 + 1], 16))
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 2 + 1], 8))
					output[t + 1] = _vm:bitwise_or(output[t + 1], block[index + 3 + 1])
				elseif self.digestLength == self.sha128 then
					output[t + 1] = _vm:bitwise_xor(_vm:bitwise_xor(_vm:bitwise_xor(self:rotateLeft(output[t - 3 + 1], 1), self:rotateLeft(output[t - 8 + 1], 1)), self:rotateLeft(output[t - 14 + 1], 1)), self:rotateLeft(output[t - 16 + 1], 1))
				else
					local s0 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight32(output[t - 15 + 1], 7), self:rotateRight32(output[t - 15 + 1], 18)), self:forUint32(_vm:bitwise_right_shift(output[t - 15 + 1], 3)))
					local s1 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight32(output[t - 2 + 1], 17), self:rotateRight32(output[t - 2 + 1], 19)), self:forUint32(_vm:bitwise_right_shift(output[t - 2 + 1], 10)))
					output[t + 1] = self:forUint32(s1 + output[t - 7 + 1] + s0 + output[t - 16 + 1])
				end
				do t = t + 1 end
			end
		end
		do
			local a = self.hash1[0 + 1]
			local b = self.hash1[1 + 1]
			local c = self.hash1[2 + 1]
			local d = self.hash1[3 + 1]
			local e = self.hash1[4 + 1]
			if self.digestLength == self.sha128 then
				do
					local j = 0
					while j <= 79 do
						local f = 0
						local k = 0
						if j <= 19 then
							f = self:forUint32(_vm:bitwise_or(_vm:bitwise_and(b, c), _vm:bitwise_and(_vm:bitwise_not(b), d)))
							k = 1518500249
						elseif j <= 39 then
							f = self:forUint32(_vm:bitwise_xor(_vm:bitwise_xor(b, c), d))
							k = 1859775393
						elseif j <= 59 then
							f = self:forUint32(_vm:bitwise_or(_vm:bitwise_or(_vm:bitwise_and(b, c), _vm:bitwise_and(b, d)), _vm:bitwise_and(c, d)))
							k = 2400959708
						elseif j <= 79 then
							f = self:forUint32(_vm:bitwise_xor(_vm:bitwise_xor(b, c), d))
							k = 3395469782
						end
						do
							local temp = self:forUint32(self:rotateLeft(a, 5) + f + e + output[j + 1] + k)
							e = d
							d = c
							c = self:rotateLeft(b, 30)
							b = a
							a = temp
						end
						do j = j + 1 end
					end
				end
				self.hash1[0 + 1] = a + self.hash1[0 + 1]
				self.hash1[1 + 1] = b + self.hash1[1 + 1]
				self.hash1[2 + 1] = c + self.hash1[2 + 1]
				self.hash1[3 + 1] = d + self.hash1[3 + 1]
				self.hash1[4 + 1] = e + self.hash1[4 + 1]
			else
				local f = self.hash1[5 + 1]
				local g = self.hash1[6 + 1]
				local h = self.hash1[7 + 1]
				do
					local t = 0
					while t < #self.k do
						local e1 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight32(e, 6), self:rotateRight32(e, 11)), self:rotateRight32(e, 25))
						local ch = _vm:bitwise_xor(_vm:bitwise_and(e, f), _vm:bitwise_and(_vm:bitwise_not(e), g))
						local t1 = self:forUint32(h + e1 + ch + self.k[t + 1] + output[t + 1])
						local e0 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight32(a, 2), self:rotateRight32(a, 13)), self:rotateRight32(a, 22))
						local maj = _vm:bitwise_xor(_vm:bitwise_xor(_vm:bitwise_and(a, b), _vm:bitwise_and(a, c)), _vm:bitwise_and(b, c))
						local t2 = self:forUint32(e0 + maj)
						h = g
						g = f
						f = e
						e = self:forUint32(d + t1)
						d = c
						c = b
						b = a
						a = self:forUint32(t1 + t2)
						do t = t + 1 end
					end
				end
				self.hash1[0 + 1] = a + self.hash1[0 + 1]
				self.hash1[1 + 1] = b + self.hash1[1 + 1]
				self.hash1[2 + 1] = c + self.hash1[2 + 1]
				self.hash1[3 + 1] = d + self.hash1[3 + 1]
				self.hash1[4 + 1] = e + self.hash1[4 + 1]
				self.hash1[5 + 1] = f + self.hash1[5 + 1]
				self.hash1[6 + 1] = g + self.hash1[6 + 1]
				self.hash1[7 + 1] = h + self.hash1[7 + 1]
			end
		end
	end
end

function jk.sha.SHAEncoderGeneric.SHA:forUint32(v)
	do return _vm:bitwise_and(v, 4294967295) end
end

function jk.sha.SHAEncoderGeneric.SHA:shaProcess64(block)
	if not (block ~= nil) then
		do return end
	end
	do
		local output = _vm:allocate_array(#self.k2)
		do
			local t = 0
			while t < #output do
				if t <= 15 then
					local index = t * 8
					output[t + 1] = _vm:bitwise_left_shift(block[index + 0 + 1], 56)
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 1 + 1], 48))
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 2 + 1], 40))
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 3 + 1], 32))
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 4 + 1], 24))
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 5 + 1], 16))
					output[t + 1] = _vm:bitwise_or(output[t + 1], _vm:bitwise_left_shift(block[index + 6 + 1], 8))
					output[t + 1] = _vm:bitwise_or(output[t + 1], block[index + 7 + 1])
				else
					local s0 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight64(output[t - 15 + 1], 1), self:rotateRight64(output[t - 15 + 1], 8)), _vm:bitwise_right_shift(output[t - 15 + 1], 7))
					local s1 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight64(output[t - 2 + 1], 19), self:rotateRight64(output[t - 2 + 1], 61)), _vm:bitwise_right_shift(output[t - 2 + 1], 6))
					output[t + 1] = s1 + output[t - 7 + 1] + s0 + output[t - 16 + 1]
				end
				do t = t + 1 end
			end
		end
		do
			local a = self.hash2[0 + 1]
			local b = self.hash2[1 + 1]
			local c = self.hash2[2 + 1]
			local d = self.hash2[3 + 1]
			local e = self.hash2[4 + 1]
			local f = self.hash2[5 + 1]
			local g = self.hash2[6 + 1]
			local h = self.hash2[7 + 1]
			do
				local t = 0
				while t < #self.k2 do
					local e0 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight64(a, 28), self:rotateRight64(a, 34)), self:rotateRight64(a, 39))
					local maj = _vm:bitwise_xor(_vm:bitwise_xor(_vm:bitwise_and(a, b), _vm:bitwise_and(a, c)), _vm:bitwise_and(b, c))
					local t2 = e0 + maj
					local e1 = _vm:bitwise_xor(_vm:bitwise_xor(self:rotateRight64(e, 14), self:rotateRight64(e, 18)), self:rotateRight64(e, 41))
					local ch = _vm:bitwise_xor(_vm:bitwise_and(e, f), _vm:bitwise_and(_vm:bitwise_not(e), g))
					local t1 = h + e1 + ch + self.k2[t + 1] + output[t + 1]
					h = g
					g = f
					f = e
					e = d + t1
					d = c
					c = b
					b = a
					a = t1 + t2
					do t = t + 1 end
				end
			end
			self.hash2[0 + 1] = a + self.hash2[0 + 1]
			self.hash2[1 + 1] = b + self.hash2[1 + 1]
			self.hash2[2 + 1] = c + self.hash2[2 + 1]
			self.hash2[3 + 1] = d + self.hash2[3 + 1]
			self.hash2[4 + 1] = e + self.hash2[4 + 1]
			self.hash2[5 + 1] = f + self.hash2[5 + 1]
			self.hash2[6 + 1] = g + self.hash2[6 + 1]
			self.hash2[7 + 1] = h + self.hash2[7 + 1]
		end
	end
end

function jk.sha.SHAEncoderGeneric.SHA:bitPadding(input)
	if not (input ~= nil) then
		do return nil end
	end
	do
		local inputBitLength = _g.jk.lang.Buffer:getSize(input) * 8
		local newBuf = _g.jk.lang.Buffer:resize(input, _g.jk.lang.Buffer:getSize(input) + 1)
		do _g.jk.lang.Buffer:setByte(newBuf, _g.jk.lang.Buffer:getSize(newBuf) - 1, 128) end
		do
			local mod = _util:convert_to_integer(inputBitLength % self.blockBitSize)
			local bitsToAppend = 0
			if self.blockBitSize == self.blockSize512 then
				if mod < self.block64 then
					bitsToAppend = self.block64 - 1 - mod
				else
					bitsToAppend = self.blockBitSize + self.block64 - mod - 1
				end
				do
					local osz = _g.jk.lang.Buffer:getSize(newBuf)
					local asz = _util:convert_to_integer((bitsToAppend - 7) / 8)
					newBuf = _g.jk.lang.Buffer:resize(newBuf, osz + asz)
					do
						local n = 0
						while n < asz do
							newBuf[osz + n + 1] = 0
							do n = n + 1 end
						end
					end
				end
			else
				if mod < self.block128 then
					bitsToAppend = self.block128 - 1 - mod
				else
					bitsToAppend = self.blockBitSize + self.block128 - mod - 1
				end
				do
					local osz = _g.jk.lang.Buffer:getSize(newBuf)
					local asz = _util:convert_to_integer((bitsToAppend - 7 + 64) / 8)
					newBuf = _g.jk.lang.Buffer:resize(newBuf, osz + asz)
					do
						local n = 0
						while n < asz do
							newBuf[osz + n + 1] = 0
							do n = n + 1 end
						end
					end
				end
			end
			newBuf = _g.jk.lang.Buffer:resize(newBuf, _g.jk.lang.Buffer:getSize(newBuf) + 8)
			do
				local sz = _g.jk.lang.Buffer:getSize(newBuf)
				newBuf[sz - 8 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, -9223372036854775808), 56)
				newBuf[sz - 7 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, 71776119061217280), 48)
				newBuf[sz - 6 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, 280375465082880), 40)
				newBuf[sz - 5 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, 1095216660480), 32)
				newBuf[sz - 4 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, 4278190080), 24)
				newBuf[sz - 3 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, 16711680), 16)
				newBuf[sz - 2 + 1] = _vm:bitwise_right_shift(_vm:bitwise_and(inputBitLength, 65280), 8)
				newBuf[sz - 1 + 1] = _vm:bitwise_and(inputBitLength, 255)
				do return newBuf end
			end
		end
	end
end

function jk.sha.SHAEncoderGeneric.SHA:blocks(buf, size)
	local msgBlocks = {}
	do
		local i = 0
		while i < _g.jk.lang.Buffer:getSize(buf) do
			local buff = _util:allocate_buffer(size)
			buff = _g.jk.lang.Buffer:getSubBuffer(buf, i, size, false)
			do _g.jk.lang.Vector:append(msgBlocks, buff) end
			i = i + size
		end
	end
	do return msgBlocks end
end

function jk.sha.SHAEncoderGeneric.SHA:rotateRight32(num, cnt)
	do return _vm:bitwise_or(self:forUint32(_vm:bitwise_right_shift(self:forUint32(num), cnt)), self:forUint32(_vm:bitwise_left_shift(self:forUint32(num), 32 - cnt))) end
end

function jk.sha.SHAEncoderGeneric.SHA:rotateRight64(num, cnt)
	do return _vm:bitwise_or(_vm:bitwise_right_shift(num, cnt), _vm:bitwise_left_shift(num, 64 - cnt)) end
end

function jk.sha.SHAEncoderGeneric.SHA:rotateLeft(num, cnt)
	do return _vm:bitwise_or(self:forUint32(_vm:bitwise_left_shift(self:forUint32(num), cnt)), self:forUint32(_vm:bitwise_right_shift(self:forUint32(num), 32 - cnt))) end
end
jk = jk or {}

jk.mime = jk.mime or {}

jk.mime.MimeTypeRegistry = {}
jk.mime.MimeTypeRegistry.__index = jk.mime.MimeTypeRegistry
_vm:set_metatable(jk.mime.MimeTypeRegistry, {})

jk.mime.MimeTypeRegistry.sharedInstance = nil

function jk.mime.MimeTypeRegistry._create()
	local v = _vm:set_metatable({}, jk.mime.MimeTypeRegistry)
	return v
end

function jk.mime.MimeTypeRegistry:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.mime.MimeTypeRegistry'
	self['_isType.jk.mime.MimeTypeRegistry'] = true
	self.htMime = nil
	self.htExt = nil
end

function jk.mime.MimeTypeRegistry:getSharedInstance()
	if not (_g.jk.mime.MimeTypeRegistry.sharedInstance ~= nil) then
		_g.jk.mime.MimeTypeRegistry.sharedInstance = _g.jk.mime.MimeTypeRegistry._construct0(_g.jk.mime.MimeTypeRegistry._create())
	end
	do return _g.jk.mime.MimeTypeRegistry.sharedInstance end
end

function jk.mime.MimeTypeRegistry:_construct0()
	jk.mime.MimeTypeRegistry._init(self)
	self.htMime = {}
	self.htExt = {}
	do self:addBuiltinTypes() end
	return self
end

function jk.mime.MimeTypeRegistry:addBuiltinTypes()
	do self:add("*.cpp", "text/x-c++src") end
	do self:add("*.ogm", "video/x-ogm+ogg") end
	do self:add("*.epsf", "image/x-eps") end
	do self:add("*.mpeg", "video/mpeg") end
	do self:add("*.rmj", "application/vnd.rn-realmedia") end
	do self:add("*.nes", "application/x-nes-rom") end
	do self:add("*.rmm", "application/vnd.rn-realmedia") end
	do self:add("*.gb", "application/x-gameboy-rom") end
	do self:add("*.qtvr", "video/quicktime") end
	do self:add("*.ogv", "video/ogg") end
	do self:add("*.amr", "audio/AMR") end
	do self:add("*.ogx", "application/ogg") end
	do self:add("*.rms", "application/vnd.rn-realmedia") end
	do self:add("*.gf", "application/x-tex-gf") end
	do self:add("*.gg", "application/x-sms-rom") end
	do self:add("*.xslt", "application/xml") end
	do self:add("*.Z", "application/x-compress") end
	do self:add("*.mdb", "application/vnd.ms-access") end
	do self:add("*.rmx", "application/vnd.rn-realmedia") end
	do self:add("*.anim[1-9j]", "video/x-anim") end
	do self:add("*.gp", "application/x-gnuplot") end
	do self:add("*.a", "application/x-archive") end
	do self:add("*.a", "application/x-shared-library-la") end
	do self:add("*.mdi", "image/vnd.ms-modi") end
	do self:add("*.c", "text/x-csrc") end
	do self:add("*.gv", "text/vnd.graphviz") end
	do self:add("*.m3u8", "audio/x-mpegurl") end
	do self:add("*.e", "text/x-eiffel") end
	do self:add("*.pict1", "image/x-pict") end
	do self:add("*.pict2", "image/x-pict") end
	do self:add("*.spd", "application/x-font-speedo") end
	do self:add("*.spc", "application/x-pkcs7-certificates") end
	do self:add("*.gz", "application/x-gzip") end
	do self:add("*.dtd", "application/xml-dtd") end
	do self:add("*.dvi.gz", "application/x-gzdvi") end
	do self:add("*.h", "text/x-chdr") end
	do self:add("*.o", "application/x-object") end
	do self:add("*.spl", "application/x-shockwave-flash") end
	do self:add("*.etheme", "application/x-e-theme") end
	do self:add("*.d", "text/x-dsrc") end
	do self:add("*.sr2", "image/x-sony-sr2") end
	do self:add("*.t", "text/troff") end
	do self:add("*.hh", "text/x-c++hdr") end
	do self:add("*.m", "text/x-objcsrc") end
	do self:add("*.m", "text/x-matlab") end
	do self:add("*.ps.bz2", "application/x-bzpostscript") end
	do self:add("*.anx", "application/annodex") end
	do self:add("*.crt", "application/x-x509-ca-cert") end
	do self:add("*.med", "audio/x-mod") end
	do self:add("*.crw", "image/x-canon-crw") end
	do self:add("*.spx", "audio/ogg") end
	do self:add("*.spx", "audio/x-speex") end
	do self:add("*.xliff", "application/x-xliff") end
	do self:add("*.ani", "application/x-navi-animation") end
	do self:add("*.hp", "text/x-c++hdr") end
	do self:add("*.vhdl", "text/x-vhdl") end
	do self:add("*.f", "text/x-fortran") end
	do self:add("*.hs", "text/x-haskell") end
	do self:add("*.epub", "application/epub+zip") end
	do self:add("*.kar", "audio/midi") end
	do self:add("*.mpga", "audio/mpeg") end
	do self:add("*.dtx", "text/x-tex") end
	do self:add("*.pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation") end
	do self:add("*.dsl", "text/x-dsl") end
	do self:add("*.csh", "application/x-csh") end
	do self:add("*.nfo", "text/x-nfo") end
	do self:add("*.pkr", "application/pgp-keys") end
	do self:add("*.epsi.bz2", "image/x-bzeps") end
	do self:add("*.spec", "text/x-rpm-spec") end
	do self:add("*.f90", "text/x-fortran") end
	do self:add("*.sql", "text/x-sql") end
	do self:add("*.css", "text/css") end
	do self:add("*.f95", "text/x-fortran") end
	do self:add("*.csv", "text/csv") end
	do self:add("*.epsi", "image/x-eps") end
	do self:add("*.tsv", "text/tab-separated-values") end
	do self:add("*.pla", "audio/x-iriver-pla") end
	do self:add("*.it", "audio/x-it") end
	do self:add("*.ape", "audio/x-ape") end
	do self:add("*.src", "application/x-wais-source") end
	do self:add("*.tta", "audio/x-tta") end
	do self:add("*.ttc", "application/x-font-ttf") end
	do self:add("*.srf", "image/x-sony-srf") end
	do self:add("*.pln", "application/x-planperfect") end
	do self:add("*.ttf", "application/x-font-ttf") end
	do self:add("*.exe", "application/x-ms-dos-executable") end
	do self:add("*.abw.gz", "application/x-abiword") end
	do self:add("*.chrt", "application/x-kchart") end
	do self:add("*.dvi", "application/x-dvi") end
	do self:add("*.rpm", "application/x-rpm") end
	do self:add("*.epsf.gz", "image/x-gzeps") end
	do self:add("*.pls", "audio/x-scpls") end
	do self:add("*.gcrd", "text/directory") end
	do self:add("*.t2t", "text/x-txt2tags") end
	do self:add("*.srt", "application/x-subrip") end
	do self:add("*.exr", "image/x-exr") end
	do self:add("*.pntg", "image/x-macpaint") end
	do self:add("*.ttx", "application/x-font-ttx") end
	do self:add("*.jad", "text/vnd.sun.j2me.app-descriptor") end
	do self:add("*.js", "application/javascript") end
	do self:add("*.latex", "text/x-tex") end
	do self:add("*.jar", "application/x-java-archive") end
	do self:add("*.ssa", "text/x-ssa") end
	do self:add("*.xspf", "application/xspf+xml") end
	do self:add("*.mgp", "application/x-magicpoint") end
	do self:add("*.movie", "video/x-sgi-movie") end
	do self:add("*.cue", "application/x-cue") end
	do self:add("*.html", "text/html") end
	do self:add("*.smaf", "application/x-smaf") end
	do self:add("*.zabw", "application/x-abiword") end
	do self:add("*.dwg", "image/vnd.dwg") end
	do self:add("authors", "text/x-authors") end
	do self:add("*.msod", "image/x-msod") end
	do self:add("*.xslfo", "text/x-xslfo") end
	do self:add("*.mrml", "text/x-mrml") end
	do self:add("*.kdc", "image/x-kodak-kdc") end
	do self:add("*.cur", "image/x-win-bitmap") end
	do self:add("*.gnucash", "application/x-gnucash") end
	do self:add("*.pkipath", "application/pkix-pkipath") end
	do self:add("*.p", "text/x-pascal") end
	do self:add("*.patch", "text/x-patch") end
	do self:add("*.old", "application/x-trash") end
	do self:add("*.m4", "application/x-m4") end
	do self:add("*.mbox", "application/mbox") end
	do self:add("*.png", "image/png") end
	do self:add("*.stc", "application/vnd.sun.xml.calc.template") end
	do self:add("*.std", "application/vnd.sun.xml.draw.template") end
	do self:add("*.arj", "application/x-arj") end
	do self:add("*.pnm", "image/x-portable-anymap") end
	do self:add("*.dxf", "image/vnd.dxf") end
	do self:add("*.sti", "application/vnd.sun.xml.impress.template") end
	do self:add("*.gplt", "application/x-gnuplot") end
	do self:add("*.la", "application/x-shared-library-la") end
	do self:add("*.stm", "audio/x-stm") end
	do self:add("*.pcf.gz", "application/x-font-pcf") end
	do self:add("*.kexic", "application/x-kexi-connectiondata") end
	do self:add("*.arw", "image/x-sony-arw") end
	do self:add("*.mid", "audio/midi") end
	do self:add("*.stw", "application/vnd.sun.xml.writer.template") end
	do self:add("*.mif", "application/x-mif") end
	do self:add("*.sty", "text/x-tex") end
	do self:add("*.hpgl", "application/vnd.hp-hpgl") end
	do self:add("*.asc", "application/pgp-encrypted") end
	do self:add("*.asc", "application/pgp-keys") end
	do self:add("*.asc", "text/plain") end
	do self:add("*.sub", "text/x-microdvd") end
	do self:add("*.sub", "text/x-mpsub") end
	do self:add("*.sub", "text/x-subviewer") end
	do self:add("*.ly", "text/x-lilypond") end
	do self:add("*.lz", "application/x-lzip") end
	do self:add("*.kexis", "application/x-kexiproject-shortcut") end
	do self:add("*.asf", "video/x-ms-asf") end
	do self:add("*.wmls", "text/vnd.wap.wmlscript") end
	do self:add("*.s3m", "audio/x-s3m") end
	do self:add("*.por", "application/x-spss-por") end
	do self:add("*.asp", "application/x-asp") end
	do self:add("*.aspx", "application/x-asp") end
	do self:add("*.ashx", "application/x-asp") end
	do self:add("*.pot", "application/vnd.ms-powerpoint") end
	do self:add("*.pot", "text/x-gettext-translation-template") end
	do self:add("*.sun", "image/x-sun-raster") end
	do self:add("*.ass", "text/x-ssa") end
	do self:add("*.rss", "application/rss+xml") end
	do self:add("*.lha", "application/x-lha") end
	do self:add("*.md", "application/x-genesis-rom") end
	do self:add("*.me", "text/x-troff-me") end
	do self:add("*.sami", "application/x-sami") end
	do self:add("*.asx", "audio/x-ms-asx") end
	do self:add("*.mm", "text/x-troff-mm") end
	do self:add("*.mo", "application/x-gettext-translation") end
	do self:add("CMakeLists.txt", "text/x-cmake") end
	do self:add("*.ml", "text/x-ocaml") end
	do self:add("*.ms", "text/x-troff-ms") end
	do self:add("*.kfo", "application/x-kformula") end
	do self:add("*.rtf", "application/rtf") end
	do self:add("*.lhs", "text/x-literate-haskell") end
	do self:add("*.svg", "image/svg+xml") end
	do self:add("*.ppm", "image/x-portable-pixmap") end
	do self:add("*.nb", "application/mathematica") end
	do self:add("*.lhz", "application/x-lhz") end
	do self:add("*.pps", "application/vnd.ms-powerpoint") end
	do self:add("*.ppt", "application/vnd.ms-powerpoint") end
	do self:add("*.nc", "application/x-netcdf") end
	do self:add("*.icb", "image/x-tga") end
	do self:add("*.ica", "application/x-ica") end
	do self:add("*.mka", "audio/x-matroska") end
	do self:add("*.ppz", "application/vnd.ms-powerpoint") end
	do self:add("*.txt", "text/plain") end
	do self:add("*.rtx", "text/richtext") end
	do self:add("*.gedcom", "application/x-gedcom") end
	do self:add("*.cxx", "text/x-c++src") end
	do self:add("*.ico", "image/vnd.microsoft.icon") end
	do self:add("*.metalink", "application/metalink+xml") end
	do self:add("*.txz", "application/x-xz-compressed-tar") end
	do self:add("*.ics", "text/calendar") end
	do self:add("*.p10", "application/pkcs10") end
	do self:add("gnumakefile", "text/x-makefile") end
	do self:add("*.p12", "application/x-pkcs12") end
	do self:add("*.swf", "application/x-shockwave-flash") end
	do self:add("*.mkv", "video/x-matroska") end
	do self:add("*.idl", "text/x-idl") end
	do self:add("*.prc", "application/x-palm-database") end
	do self:add("*.mli", "text/x-ocaml") end
	do self:add("*.tar.lzo", "application/x-tzo") end
	do self:add("*.sxc", "application/vnd.sun.xml.calc") end
	do self:add("*.sxd", "application/vnd.sun.xml.draw") end
	do self:add("*.cert", "application/x-x509-ca-cert") end
	do self:add("*.avi", "video/x-msvideo") end
	do self:add("*.sxg", "application/vnd.sun.xml.writer.global") end
	do self:add("*.qtl", "application/x-quicktime-media-link") end
	do self:add("*.sxi", "application/vnd.sun.xml.impress") end
	do self:add("*.xac", "application/x-gnucash") end
	do self:add("*.djvu", "image/vnd.djvu") end
	do self:add("*.sxm", "application/vnd.sun.xml.math") end
	do self:add("winmail.dat", "application/vnd.ms-tnef") end
	do self:add("*.bz2", "application/x-bzip") end
	do self:add("*.ief", "image/ief") end
	do self:add("*.tzo", "application/x-tzo") end
	do self:add("*.pk", "application/x-tex-pk") end
	do self:add("*.pl", "application/x-perl") end
	do self:add("*.rvx", "video/vnd.rn-realvideo") end
	do self:add("*.sxw", "application/vnd.sun.xml.writer") end
	do self:add("*.php4", "application/x-php") end
	do self:add("*.mmf", "application/x-smaf") end
	do self:add("*.BLEND", "application/x-blender") end
	do self:add("*.kil", "application/x-killustrator") end
	do self:add("*.pm", "application/x-perl") end
	do self:add("*.ps", "application/postscript") end
	do self:add("*.awb", "audio/AMR-WB") end
	do self:add("*.psf", "application/x-font-linux-psf") end
	do self:add("*.psf", "audio/x-psf") end
	do self:add("*.pw", "application/x-pw") end
	do self:add("*.aifc", "audio/x-aiff") end
	do self:add("*.mml", "text/mathml") end
	do self:add("*.psd", "image/vnd.adobe.photoshop") end
	do self:add("*.mo3", "audio/x-mo3") end
	do self:add("*.aiff", "audio/x-aiff") end
	do self:add("*.gba", "application/x-gba-rom") end
	do self:add("*.awk", "application/x-awk") end
	do self:add("*.not", "text/x-mup") end
	do self:add("changelog", "text/x-changelog") end
	do self:add("*.sv4cpio", "application/x-sv4cpio") end
	do self:add("*%", "application/x-trash") end
	do self:add("*.po", "text/x-gettext-translation") end
	do self:add("*.hdf", "application/x-hdf") end
	do self:add("*.psw", "application/x-pocket-word") end
	do self:add("*.tar.bz", "application/x-bzip-compressed-tar") end
	do self:add("*.php3", "application/x-php") end
	do self:add("*.desktop", "application/x-desktop") end
	do self:add("*.fb2", "application/x-fictionbook+xml") end
	do self:add("*.wb1", "application/x-quattropro") end
	do self:add("*.wb2", "application/x-quattropro") end
	do self:add("*.ora", "image/openraster") end
	do self:add("*.wb3", "application/x-quattropro") end
	do self:add("*.iff", "image/x-iff") end
	do self:add("*.mp+", "audio/x-musepack") end
	do self:add("*.axa", "audio/annodex") end
	do self:add("*.orf", "image/x-olympus-orf") end
	do self:add("*.xbm", "image/x-xbitmap") end
	do self:add("copying", "text/x-copying") end
	do self:add("*.mp2", "audio/mp2") end
	do self:add("*.mp2", "video/mpeg") end
	do self:add("*.mp3", "audio/mpeg") end
	do self:add("*.mp4", "video/mp4") end
	do self:add("*.py", "text/x-python") end
	do self:add("*.kino", "application/smil") end
	do self:add("*.ra", "audio/vnd.rn-realaudio") end
	do self:add("*.rb", "application/x-ruby") end
	do self:add("*.icns", "image/x-icns") end
	do self:add("*.qt", "video/quicktime") end
	do self:add("*.xcf", "image/x-xcf") end
	do self:add("*.mng", "video/x-mng") end
	do self:add("*.xbl", "application/xml") end
	do self:add("*.axv", "video/annodex") end
	do self:add("*.cpio", "application/x-cpio") end
	do self:add("*.rm", "application/vnd.rn-realmedia") end
	do self:add("*.mod", "audio/x-mod") end
	do self:add("*.sv4crc", "application/x-sv4crc") end
	do self:add("*.rp", "image/vnd.rn-realpix") end
	do self:add("*.mof", "text/x-mof") end
	do self:add("*.wav", "audio/x-wav") end
	do self:add("*.rt", "text/vnd.rn-realtext") end
	do self:add("*.wax", "audio/x-ms-asx") end
	do self:add("*.rv", "video/vnd.rn-realvideo") end
	do self:add("*.moc", "text/x-moc") end
	do self:add("*.siag", "application/x-siag") end
	do self:add("*.pack", "application/x-java-pack200") end
	do self:add("*.gnumeric", "application/x-gnumeric") end
	do self:add("*.tnef", "application/vnd.ms-tnef") end
	do self:add("*.tpic", "image/x-tga") end
	do self:add("*.mov", "video/quicktime") end
	do self:add("*.smil", "application/smil") end
	do self:add("*.sh", "application/x-shellscript") end
	do self:add("*.divx", "video/x-msvideo") end
	do self:add("*.sk", "image/x-skencil") end
	do self:add("*.moov", "video/quicktime") end
	do self:add("*.mpc", "audio/x-musepack") end
	do self:add("*.so", "application/x-sharedlib") end
	do self:add("*.mpe", "video/mpeg") end
	do self:add("*.otc", "application/vnd.oasis.opendocument.chart-template") end
	do self:add("*.midi", "audio/midi") end
	do self:add("*.otf", "application/vnd.oasis.opendocument.formula-template") end
	do self:add("*.otf", "application/x-font-otf") end
	do self:add("*.otg", "application/vnd.oasis.opendocument.graphics-template") end
	do self:add("*.oth", "application/vnd.oasis.opendocument.text-web") end
	do self:add("*.mpg", "video/mpeg") end
	do self:add("*.mpp", "audio/x-musepack") end
	do self:add("*.otp", "application/vnd.oasis.opendocument.presentation-template") end
	do self:add("*~", "application/x-trash") end
	do self:add("*.ged", "application/x-gedcom") end
	do self:add("*.ots", "application/vnd.oasis.opendocument.spreadsheet-template") end
	do self:add("*.ott", "application/vnd.oasis.opendocument.text-template") end
	do self:add("*.tar.lzma", "application/x-lzma-compressed-tar") end
	do self:add("*.docm", "application/vnd.openxmlformats-officedocument.wordprocessingml.document") end
	do self:add("makefile", "text/x-makefile") end
	do self:add("*.wcm", "application/vnd.ms-works") end
	do self:add("*.tk", "text/x-tcl") end
	do self:add("*.gen", "application/x-genesis-rom") end
	do self:add("*.docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document") end
	do self:add("*.log", "text/x-log") end
	do self:add("*.nsc", "application/x-netshow-channel") end
	do self:add("*.egon", "application/x-egon") end
	do self:add("*.tr", "text/troff") end
	do self:add("*.zip", "application/zip") end
	do self:add("*.kml", "application/vnd.google-earth.kml+xml") end
	do self:add("*.iptables", "text/x-iptables") end
	do self:add("*.m15", "audio/x-mod") end
	do self:add("*.wdb", "application/vnd.ms-works") end
	do self:add("*.kmz", "application/vnd.google-earth.kmz") end
	do self:add("*.shar", "application/x-shar") end
	do self:add("*.nsv", "video/x-nsv") end
	do self:add("*.texinfo", "text/x-texinfo") end
	do self:add("*.so.[0-9].*", "application/x-sharedlib") end
	do self:add("*.ui", "application/x-designer") end
	do self:add("*.ilbm", "image/x-ilbm") end
	do self:add("*.3ds", "image/x-3ds") end
	do self:add("*.vbs", "application/x-vbscript") end
	do self:add("*.mrl", "text/x-mrml") end
	do self:add("*.vcf", "text/directory") end
	do self:add("*.mrw", "image/x-minolta-mrw") end
	do self:add("*.jpeg", "image/jpeg") end
	do self:add("*.3g2", "video/3gpp") end
	do self:add("*.dar", "application/x-dar") end
	do self:add("*.tar.gz", "application/x-compressed-tar") end
	do self:add("*.p7b", "application/x-pkcs7-certificates") end
	do self:add("*.lzma", "application/x-lzma") end
	do self:add("*.vct", "text/directory") end
	do self:add("*.vcs", "text/calendar") end
	do self:add("*.msi", "application/x-msi") end
	do self:add("*.msi", "application/x-ms-win-installer") end
	do self:add("*.psid", "audio/prs.sid") end
	do self:add("*.kon", "application/x-kontour") end
	do self:add("*.blender", "application/x-blender") end
	do self:add("*.pyc", "application/x-python-bytecode") end
	do self:add("*.owl", "application/rdf+xml") end
	do self:add("*.vda", "image/x-tga") end
	do self:add("*.dbf", "application/x-dbf") end
	do self:add("*.p7s", "application/pkcs7-signature") end
	do self:add("*.pyo", "application/x-python-bytecode") end
	do self:add("*.msx", "application/x-msx-rom") end
	do self:add("*.epsf.bz2", "image/x-bzeps") end
	do self:add("*.cb7", "application/x-cb7") end
	do self:add("*.jng", "image/x-jng") end
	do self:add("*.texi", "text/x-texinfo") end
	do self:add("*.so.[0-9]", "application/x-sharedlib") end
	do self:add("*.wp", "application/vnd.wordperfect") end
	do self:add("*.kpm", "application/x-kpovmodeler") end
	do self:add("*.jp2", "image/jp2") end
	do self:add("*.wv", "audio/x-wavpack") end
	do self:add("*.cab", "application/vnd.ms-cab-compressed") end
	do self:add("*.kpr", "application/x-kpresenter") end
	do self:add("*.3ga", "video/3gpp") end
	do self:add("*.kpt", "application/x-kpresenter") end
	do self:add("*.n64", "application/x-n64-rom") end
	do self:add("*.mtm", "audio/x-mod") end
	do self:add("*.m2t", "video/mpeg") end
	do self:add("*.glade", "application/x-glade") end
	do self:add("*.oxt", "application/vnd.openofficeorg.extension") end
	do self:add("*.iso9660", "application/x-cd-image") end
	do self:add("*.gif", "image/gif") end
	do self:add("*.dcm", "application/dicom") end
	do self:add("*.ime", "text/x-iMelody") end
	do self:add("*.h++", "text/x-c++hdr") end
	do self:add("*.3gp", "video/3gpp") end
	do self:add("*.tar", "application/x-tar") end
	do self:add("*.dcr", "image/x-kodak-dcr") end
	do self:add("*.xi", "audio/x-xi") end
	do self:add("*.xm", "audio/x-xm") end
	do self:add("*.dcl", "text/x-dcl") end
	do self:add("*.3gpp", "video/3gpp") end
	do self:add("*.kdelnk", "application/x-desktop") end
	do self:add("*.vivo", "video/vivo") end
	do self:add("*.xz", "application/x-xz") end
	do self:add("*.imy", "text/x-iMelody") end
	do self:add("*.m3u", "audio/x-mpegurl") end
	do self:add("*.mup", "text/x-mup") end
	do self:add("*.kra", "application/x-krita") end
	do self:add("*.cbr", "application/x-cbr") end
	do self:add("*.m4b", "audio/x-m4b") end
	do self:add("*.cbt", "application/x-cbt") end
	do self:add("*.cpio.gz", "application/x-cpio-compressed") end
	do self:add("*.m4a", "audio/mp4") end
	do self:add("*.dds", "image/x-dds") end
	do self:add("*.jpe", "image/jpeg") end
	do self:add("*.jpg", "image/jpeg") end
	do self:add("*.cbz", "application/x-cbz") end
	do self:add("*.jpc", "image/jp2") end
	do self:add("*.tbz", "application/x-bzip-compressed-tar") end
	do self:add("*.eps.bz2", "image/x-bzeps") end
	do self:add("*.jpf", "image/jp2") end
	do self:add("*.k25", "image/x-kodak-k25") end
	do self:add("*.jpr", "application/x-jbuilder-project") end
	do self:add("*.7z", "application/x-7z-compressed") end
	do self:add("*.ins", "text/x-tex") end
	do self:add("*.deb", "application/x-deb") end
	do self:add("*.ini", "text/plain") end
	do self:add("*.psf.gz", "application/x-gz-font-linux-psf") end
	do self:add("*.jpx", "application/x-jbuilder-project") end
	do self:add("*.jpx", "image/jp2") end
	do self:add("*.m4v", "video/mp4") end
	do self:add("*.bak", "application/x-trash") end
	do self:add("*.rmvb", "application/vnd.rn-realmedia") end
	do self:add("gmon.out", "application/x-profile") end
	do self:add("*.perl", "application/x-perl") end
	do self:add("*.sam", "application/x-amipro") end
	do self:add("*.fig", "image/x-xfig") end
	do self:add("*.bcpio", "application/x-bcpio") end
	do self:add("*.gtar", "application/x-tar") end
	do self:add("*.ltx", "text/x-tex") end
	do self:add("*.lua", "text/x-lua") end
	do self:add("*.der", "application/x-x509-ca-cert") end
	do self:add("*.sav", "application/x-spss-sav") end
	do self:add("*.wk1", "application/vnd.lotus-1-2-3") end
	do self:add("*.tcl", "text/x-tcl") end
	do self:add("*.wk3", "application/vnd.lotus-1-2-3") end
	do self:add("*.wk4", "application/vnd.lotus-1-2-3") end
	do self:add("*.zoo", "application/x-zoo") end
	do self:add("*.xcf.gz", "image/x-compressed-xcf") end
	do self:add("*.qtif", "image/x-quicktime") end
	do self:add("*.oleo", "application/x-oleo") end
	do self:add("*.ksp", "application/x-kspread") end
	do self:add("*.ps.gz", "application/x-gzpostscript") end
	do self:add("*.opml", "text/x-opml+xml") end
	do self:add("*.cdf", "application/x-netcdf") end
	do self:add("*.vhd", "text/x-vhdl") end
	do self:add("*.xla", "application/vnd.ms-excel") end
	do self:add("*.inf", "text/plain") end
	do self:add("*.xlc", "application/vnd.ms-excel") end
	do self:add("*.xld", "application/vnd.ms-excel") end
	do self:add("*.xlf", "application/x-xliff") end
	do self:add("*.cdr", "application/vnd.corel-draw") end
	do self:add("*.xll", "application/vnd.ms-excel") end
	do self:add("*.xlm", "application/vnd.ms-excel") end
	do self:add("*.602", "application/x-t602") end
	do self:add("*.mxf", "application/mxf") end
	do self:add("*.xls", "application/vnd.ms-excel") end
	do self:add("*.xlt", "application/vnd.ms-excel") end
	do self:add("*.aac", "audio/mp4") end
	do self:add("*.xlsm", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") end
	do self:add("*.xlw", "application/vnd.ms-excel") end
	do self:add("*.docbook", "application/docbook+xml") end
	do self:add("*.raf", "image/x-fuji-raf") end
	do self:add("*.fits", "image/fits") end
	do self:add("*.epsi.gz", "image/x-gzeps") end
	do self:add("*.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") end
	do self:add("*.rdfs", "application/rdf+xml") end
	do self:add("*.ram", "application/ram") end
	do self:add("*.eif", "text/x-eiffel") end
	do self:add("*.scm", "text/x-scheme") end
	do self:add("*.ac3", "audio/ac3") end
	do self:add("*.rar", "application/x-rar") end
	do self:add("*.xmf", "audio/x-xmf") end
	do self:add("*.ras", "image/x-cmu-raster") end
	do self:add("*.cer", "application/x-x509-ca-cert") end
	do self:add("*.ldif", "text/x-ldif") end
	do self:add("*.kud", "application/x-kugar") end
	do self:add("*.rax", "audio/vnd.rn-realaudio") end
	do self:add("*.xml", "application/xml") end
	do self:add("*.gmo", "application/x-gettext-translation") end
	do self:add("*.xmi", "text/x-xmi") end
	do self:add("*.CSSL", "text/css") end
	do self:add("*.wks", "application/vnd.lotus-1-2-3") end
	do self:add("*.wks", "application/vnd.ms-works") end
	do self:add("*.tbz2", "application/x-bzip-compressed-tar") end
	do self:add("*.tex", "text/x-tex") end
	do self:add("*.raw", "image/x-panasonic-raw") end
	do self:add("*.sda", "application/vnd.stardivision.draw") end
	do self:add("*.sdc", "application/vnd.stardivision.calc") end
	do self:add("*.sdd", "application/vnd.stardivision.impress") end
	do self:add("*.bdf", "application/x-font-bdf") end
	do self:add("*.lwo", "image/x-lwo") end
	do self:add("*.lws", "image/x-lws") end
	do self:add("*.minipsf", "audio/x-minipsf") end
	do self:add("*.flc", "video/x-flic") end
	do self:add("*.gnc", "application/x-gnucash") end
	do self:add("*.gnd", "application/gnunet-directory") end
	do self:add("*.theme", "application/x-theme") end
	do self:add("*.sdp", "application/vnd.stardivision.impress") end
	do self:add("*.sdp", "application/sdp") end
	do self:add("*.fli", "video/x-flic") end
	do self:add("install", "text/x-install") end
	do self:add("*.sds", "application/vnd.stardivision.chart") end
	do self:add("*.abw", "application/x-abiword") end
	do self:add("*.j2k", "image/jp2") end
	do self:add("core", "application/x-core") end
	do self:add("*.sdw", "application/vnd.stardivision.writer") end
	do self:add("*.viv", "video/vivo") end
	do self:add("*.pdf.gz", "application/x-gzpdf") end
	do self:add("*.hpp", "text/x-c++hdr") end
	do self:add("*.flv", "video/x-flv") end
	do self:add("*.tiff", "image/tiff") end
	do self:add("*.flw", "application/x-kivio") end
	do self:add("*.ace", "application/x-ace") end
	do self:add("*.dvi.bz2", "application/x-bzdvi") end
	do self:add("*.dia", "application/x-dia-diagram") end
	do self:add("*.pcf.Z", "application/x-font-pcf") end
	do self:add("*.gnuplot", "application/x-gnuplot") end
	do self:add("*.wma", "audio/x-ms-wma") end
	do self:add("*.tga", "image/x-tga") end
	do self:add("*.cgm", "image/cgm") end
	do self:add("*.wmf", "image/x-wmf") end
	do self:add("*.torrent", "application/x-bittorrent") end
	do self:add("*.uil", "text/x-uil") end
	do self:add("*.vala", "text/x-vala") end
	do self:add("*.lwob", "image/x-lwo") end
	do self:add("*.kwd", "application/x-kword") end
	do self:add("*.wml", "text/vnd.wap.wml") end
	do self:add("*.iso", "application/x-cd-image") end
	do self:add("*.tgz", "application/x-compressed-tar") end
	do self:add("*.adb", "text/x-adasrc") end
	do self:add("*.wmv", "video/x-ms-wmv") end
	do self:add("*.wmx", "audio/x-ms-asx") end
	do self:add("*.rdf", "application/rdf+xml") end
	do self:add("*.kwt", "application/x-kword") end
	do self:add("*.vlc", "audio/x-mpegurl") end
	do self:add("*.lyx", "application/x-lyx") end
	do self:add("*.pdf.bz2", "application/x-bzpdf") end
	do self:add("*.chm", "application/x-chm") end
	do self:add("*.ufraw", "application/x-ufraw") end
	do self:add("*.gpg", "application/pgp-encrypted") end
	do self:add("*.ads", "text/x-adasrc") end
	do self:add("*.tar.Z", "application/x-tarz") end
	do self:add("*.xpm", "image/x-xpixmap") end
	do self:add("*.djv", "image/vnd.djvu") end
	do self:add("*.wp4", "application/vnd.wordperfect") end
	do self:add("*.wp5", "application/vnd.wordperfect") end
	do self:add("*.wp6", "application/vnd.wordperfect") end
	do self:add("*.xps", "application/vnd.ms-xpsdocument") end
	do self:add("*.lzh", "application/x-lha") end
	do self:add("*.lzo", "application/x-lzop") end
	do self:add("*.pak", "application/x-pak") end
	do self:add("*.sgf", "application/x-go-sgf") end
	do self:add("*.sylk", "text/spreadsheet") end
	do self:add("*.tif", "image/tiff") end
	do self:add("*.par2", "application/x-par2") end
	do self:add("*.sgi", "image/x-sgi") end
	do self:add("*.rej", "application/x-reject") end
	do self:add("*.sgl", "application/vnd.stardivision.writer") end
	do self:add("*.sgm", "text/sgml") end
	do self:add("*.xcf.bz2", "image/x-compressed-xcf") end
	do self:add("*.reg", "text/x-ms-regedit") end
	do self:add("*.pas", "text/x-pascal") end
	do self:add("*.emf", "image/x-emf") end
	do self:add("*.emp", "application/vnd.emusic-emusic_package") end
	do self:add("*.for", "text/x-fortran") end
	do self:add("*.pbm", "image/x-portable-bitmap") end
	do self:add("*.xbel", "application/x-xbel") end
	do self:add("*.gra", "application/x-graphite") end
	do self:add("*.afm", "application/x-font-afm") end
	do self:add("*.wpd", "application/vnd.wordperfect") end
	do self:add("*.shn", "application/x-shorten") end
	do self:add("*.wpg", "application/x-wpg") end
	do self:add("*.svgz", "image/svg+xml-compressed") end
	do self:add("*.cmake", "text/x-cmake") end
	do self:add("*.tar.bz2", "application/x-bzip-compressed-tar") end
	do self:add("*.wpl", "application/vnd.ms-wpl") end
	do self:add("*.dll", "application/x-sharedlib") end
	do self:add("*.ult", "audio/x-mod") end
	do self:add("*.wpp", "application/vnd.wordperfect") end
	do self:add("*.ent", "application/xml-external-parsed-entity") end
	do self:add("*.wps", "application/vnd.ms-works") end
	do self:add("*.669", "audio/x-mod") end
	do self:add("*.jnlp", "application/x-java-jnlp-file") end
	do self:add("*.pcf", "application/x-font-pcf") end
	do self:add("*.pcf", "application/x-cisco-vpn-settings") end
	do self:add("*.pcd", "image/x-photo-cd") end
	do self:add("*.bib", "text/x-bibtex") end
	do self:add("*.rgb", "image/x-rgb") end
	do self:add("*.sid", "audio/prs.sid") end
	do self:add("*.pcl", "application/vnd.hp-pcl") end
	do self:add("*.c++", "text/x-c++src") end
	do self:add("*.htm", "text/html") end
	do self:add("*.voc", "audio/x-voc") end
	do self:add("*.sik", "application/x-trash") end
	do self:add("*.vapi", "text/x-vala") end
	do self:add("*.bin", "application/octet-stream") end
	do self:add("*.vob", "video/mpeg") end
	do self:add("*.gsf", "application/x-font-type1") end
	do self:add("*.sk1", "image/x-skencil") end
	do self:add("*.ag", "image/x-applix-graphics") end
	do self:add("*.ai", "application/illustrator") end
	do self:add("*.sis", "application/vnd.symbian.install") end
	do self:add("*.sit", "application/x-stuffit") end
	do self:add("*.al", "application/x-perl") end
	do self:add("*.gsm", "audio/x-gsm") end
	do self:add("*.siv", "application/sieve") end
	do self:add("*.vor", "application/vnd.stardivision.writer") end
	do self:add("*.xsl", "application/xml") end
	do self:add("*.diff", "text/x-patch") end
	do self:add("*.pdb", "application/x-aportisdoc") end
	do self:add("*.pdb", "application/x-palm-database") end
	do self:add("*.pdc", "application/x-aportisdoc") end
	do self:add("*.as", "application/x-applix-spreadsheet") end
	do self:add("*.au", "audio/basic") end
	do self:add("*.pdf", "application/pdf") end
	do self:add("*.aw", "application/x-applix-word") end
	do self:add("*.obj", "application/x-tgif") end
	do self:add("*.sgml", "text/sgml") end
	do self:add("*.pcx", "image/x-pcx") end
	do self:add("*.dng", "image/x-adobe-dng") end
	do self:add("*.uni", "audio/x-mod") end
	do self:add("*.wbmp", "image/vnd.wap.wbmp") end
	do self:add("*.wri", "application/x-mswrite") end
	do self:add("*.java", "text/x-java") end
	do self:add("*.wrl", "model/vrml") end
	do self:add("*.flac", "audio/x-flac") end
	do self:add("*.cls", "text/x-tex") end
	do self:add("*.eps", "image/x-eps") end
	do self:add("*.kexi", "application/x-kexiproject-sqlite2") end
	do self:add("*.kexi", "application/x-kexiproject-sqlite3") end
	do self:add("*.tlz", "application/x-lzma-compressed-tar") end
	do self:add("*.pef", "image/x-pentax-pef") end
	do self:add("*.aif", "audio/x-aiff") end
	do self:add("*.ocl", "text/x-ocl") end
	do self:add("*.class", "application/x-java") end
	do self:add("*.doc", "application/msword") end
	do self:add("*.pem", "application/x-x509-ca-cert") end
	do self:add("*.bz", "application/x-bzip") end
	do self:add("makefile", "text/x-makefile") end
	do self:add("*.x3f", "image/x-sigma-x3f") end
	do self:add("*.cc", "text/x-c++src") end
	do self:add("*.skr", "application/pgp-keys") end
	do self:add("*.xul", "application/vnd.mozilla.xul+xml") end
	do self:add("*.xul", "application/vnd.mozilla.xul+xml") end
	do self:add("*.dot", "application/msword-template") end
	do self:add("*.dot", "text/vnd.graphviz") end
	do self:add("*.oda", "application/oda") end
	do self:add("*.odb", "application/vnd.oasis.opendocument.database") end
	do self:add("*.odc", "application/vnd.oasis.opendocument.chart") end
	do self:add("*.pict", "image/x-pict") end
	do self:add("*.pfb", "application/x-font-type1") end
	do self:add("*.odf", "application/vnd.oasis.opendocument.formula") end
	do self:add("*.odg", "application/vnd.oasis.opendocument.graphics") end
	do self:add("*.karbon", "application/x-karbon") end
	do self:add("*.odi", "application/vnd.oasis.opendocument.image") end
	do self:add("*.hwp", "application/x-hwp") end
	do self:add("*.xhtml", "application/xhtml+xml") end
	do self:add("*.odm", "application/vnd.oasis.opendocument.text-master") end
	do self:add("*.hwt", "application/x-hwt") end
	do self:add("credits", "text/x-credits") end
	do self:add("*.odp", "application/vnd.oasis.opendocument.presentation") end
	do self:add("*.tnf", "application/vnd.ms-tnef") end
	do self:add("*.pfa", "application/x-font-type1") end
	do self:add("*.ods", "application/vnd.oasis.opendocument.spreadsheet") end
	do self:add("*.odt", "application/vnd.oasis.opendocument.text") end
	do self:add("*.dc", "application/x-dc-rom") end
	do self:add("*.slk", "text/spreadsheet") end
	do self:add("*.erl", "text/x-erlang") end
	do self:add("*.pfx", "application/x-pkcs12") end
	do self:add("*.mab", "application/x-markaby") end
	do self:add("*.sisx", "x-epoc/x-sisx-app") end
	do self:add("*.ustar", "application/x-ustar") end
	do self:add("*.gvp", "text/x-google-video-pointer") end
	do self:add("*.dv", "video/dv") end
	do self:add("*.man", "application/x-troff-man") end
	do self:add("*.qif", "application/x-qw") end
	do self:add("*.qif", "image/x-quicktime") end
	do self:add("*.smd", "application/vnd.stardivision.mail") end
	do self:add("*.toc", "application/x-cdrdao-toc") end
	do self:add("*.smf", "application/vnd.stardivision.math") end
	do self:add("*.pgm", "image/x-portable-graymap") end
	do self:add("*.pgn", "application/x-chess-pgn") end
	do self:add("*.smi", "application/smil") end
	do self:add("*.smi", "application/x-sami") end
	do self:add("*.pgp", "application/pgp-encrypted") end
	do self:add("*.cs", "text/x-csharp") end
	do self:add("*.cs", "text/x-csharp") end
	do self:add("*.sml", "application/smil") end
	do self:add("*.smc", "application/x-snes-rom") end
	do self:add("*.xwd", "image/x-xwindowdump") end
	do self:add("*.bmp", "image/bmp") end
	do self:add("*.blend", "application/x-blender") end
	do self:add("*.com", "application/x-ms-dos-executable") end
	do self:add("*.atom", "application/atom+xml") end
	do self:add("*.sms", "application/x-sms-rom") end
	do self:add("*.el", "text/x-emacs-lisp") end
	do self:add("*.hxx", "text/x-c++hdr") end
	do self:add("*.g3", "image/fax-g3") end
	do self:add("*.vst", "image/x-tga") end
	do self:add("*.es", "application/ecmascript") end
	do self:add("*.PAR2", "application/x-par2") end
	do self:add("*.eps.gz", "image/x-gzeps") end
	do self:add("*.rle", "image/rle") end
	do self:add("*.snd", "audio/basic") end
	do self:add("*.ez", "application/andrew-inset") end
	do self:add("*.psflib", "audio/x-psflib") end
	do self:add("*.nds", "application/x-nintendo-ds-rom") end
	do self:add("*.php", "application/x-php") end
	do self:add("*.wvc", "audio/x-wavpack-correction") end
	do self:add("*.123", "application/vnd.lotus-1-2-3") end
	do self:add("*.uri", "text/x-uri") end
	do self:add("*.url", "text/x-uri") end
	do self:add("*.abw.CRASHED", "application/x-abiword") end
	do self:add("*.cr2", "image/x-canon-cr2") end
	do self:add("*.tar.xz", "application/x-xz-compressed-tar") end
	do self:add("*.roff", "text/troff") end
	do self:add("*.fl", "application/x-fluid") end
	do self:add("*.alz", "application/x-alz") end
	do self:add("*.oga", "audio/ogg") end
	do self:add("*.wvp", "audio/x-wavpack") end
	do self:add("*.nef", "image/x-nikon-nef") end
	do self:add("*,v", "text/plain") end
	do self:add("*.C", "text/x-c++src") end
	do self:add("*.themepack", "application/x-windows-themepack") end
	do self:add("*.ogg", "audio/ogg") end
	do self:add("*.ogg", "audio/x-vorbis+ogg") end
	do self:add("*.ogg", "audio/x-flac+ogg") end
	do self:add("*.ogg", "audio/x-speex+ogg") end
	do self:add("*.ogg", "video/x-theora+ogg") end
	do self:add("*.wvx", "audio/x-ms-asx") end
	do self:add("*.fo", "text/x-xslfo") end
	do self:add("*.etx", "text/x-setext") end
	do self:add("*.pptm", "application/vnd.openxmlformats-officedocument.presentationml.presentation") end
	do self:add("readme", "text/x-readme") end
	do self:add("todo", "text/x-todo") end
	do self:add("license", "text/x-license") end
	do self:add("*.version", "text/x-version") end
	do self:add("Makefile.*", "text/x-makefile") end
	do self:add("*.dmg", "application/x-apple-diskimage") end
	do self:add("*.swp", "application/x-igelle-software-package") end
	do self:add("*.squashfs", "application/x-igelle-diskimage-squashfs") end
	do self:add("*.img", "application/x-igelle-diskimage") end
	do self:add("*.eq", "text/x-eqela-src") end
	do self:add("*.equity", "text/x-eqela-equity-src") end
	do self:add("*.eqic", "text/x-eqela-eqic-config") end
	do self:add("*.config", "text/x-config") end
	do self:add("*.eqlib", "application/x-eqela-library") end
	do self:add("*.eqlibx", "application/x-eqela-library-encrypted") end
	do self:add("*.apk", "application/vnd.android.package-archive") end
	do self:add("*.eo", "application/x-eqela-object") end
	do self:add("*.eo1", "application/x-eqela-object-level-1") end
	do self:add("*.eo2", "application/x-eqela-object-level-2") end
	do self:add("*.eo3", "application/x-eqela-object-level-3") end
	do self:add("*.eo4", "application/x-eqela-object-level-4") end
	do self:add("*.eo5", "application/x-eqela-object-level-5") end
	do self:add("*.iga", "application/x-igelle-archive") end
	do self:add("*.ipa", "application/octet-stream") end
	do self:add("*.xap", "application/x-silverlight-app") end
	do self:add("*.webapp", "application/x-web-app-manifest+json") end
	do self:add("*.json", "application/json") end
	do self:add("*.properties", "application/properties") end
	do self:add(".classpath", "application/xml") end
	do self:add(".project", "application/xml") end
	do self:add("*.bat", "application/x-msdos-program") end
	do self:add("*.yml", "text/yaml") end
	do self:add("*.yaml", "text/yaml") end
	do self:add("*.scss", "text/x-scss") end
	do self:add("*.gradle", "application/x-gradle") end
	do self:add("manifest.mf", "application/x-manifest") end
	do self:add("*.vm", "application/x-velocity") end
	do self:add("*.jade", "application/x-jade") end
	do self:add("*.xsd", "application/xml") end
	do self:add("*.eot", "application/vnd.ms-fontobject") end
	do self:add("*.woff", "application/x-font-woff") end
	do self:add("*.woff2", "application/x-font-woff") end
	do self:add("*.svf", "application/x-font-svf") end
	do self:add("*.fnt", "application/x-font-fnt") end
	do self:add("*.wsdl", "application/wsdl+xml") end
	do self:add("*.jsx", "application/javascript") end
	do self:add("*.ts", "application/x-typescript") end
	do self:add("*.tsx", "application/x-typescript") end
	do self:add("*.jks", "application/x-jks") end
	do self:add("*.jsp", "application/x-jsp") end
	do self:add("*.pom", "application/x-maven-pom") end
	do self:add(".gitignore", "application/x-gitignore") end
	do self:add("org.eclipse.jdt.core.prefs", "application/x-eclipse-prefs") end
	do self:add("org.eclipse.buildship.core.prefs", "application/x-eclipse-prefs") end
	do self:add("*.vsd", "application/vnd.visio") end
	do self:add(".editorconfig", "application/x-editorconfig") end
	do self:add(".htaccess", "application/x-htaccess") end
	do self:add("*.mxml", "application/xml") end
	do self:add("*.tld", "application/xml") end
	do self:add("*.csproj", "application/csproj+xml") end
	do self:add("*.sln", "application/x-sln") end
	do self:add("*.elm", "application/x-elm") end
	do self:add("*.scala", "application/x-scala") end
	do self:add("dockerfile", "application/x-docker-dockerfile") end
	do self:add("gemfile", "application/x-gem-gemfile") end
	do self:add("*.sbt", "application/x-scala-sbt") end
end

function jk.mime.MimeTypeRegistry:getTypeForExtension(ext)
	if not (ext ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Map:get(self.htMime, _g.jk.lang.String:toLowerCase(ext)) end
end

function jk.mime.MimeTypeRegistry:getTypeForFile(f)
	if not (f ~= nil) then
		do return "application/unknown" end
	end
	do return self:getMimeType(f:getBasename()) end
end

function jk.mime.MimeTypeRegistry:getMimeType(str)
	local v = nil
	if str ~= nil then
		local mime = nil
		local ld = _g.jk.lang.String:getLastIndexOfCharacter(str, 46, -1)
		if ld >= 0 then
			mime = _g.jk.lang.String:getEndOfString(str, ld + 1)
		end
		v = _g.jk.lang.Map:get(self.htMime, _g.jk.lang.String:toLowerCase(mime))
		if _g.jk.lang.String:isEmpty(v) then
			v = _g.jk.lang.Map:get(self.htMime, _g.jk.lang.String:toLowerCase(str))
		end
	end
	if _g.jk.lang.String:isEmpty(v) then
		v = "application/unknown"
	end
	do return v end
end

function jk.mime.MimeTypeRegistry:getExtension(mimeType)
	do return _g.jk.lang.Map:get(self.htExt, mimeType) end
end

function jk.mime.MimeTypeRegistry:add(pattern, mimeType)
	local v = false
	if pattern == nil or mimeType == nil then
	elseif _g.jk.lang.String:startsWith(pattern, ".", 0) == true then
		local key = _g.jk.lang.String:getSubString(pattern, 1, _g.jk.lang.String:getLength(pattern) - 1)
		do _g.jk.lang.Map:set(self.htMime, key, mimeType) end
		do _g.jk.lang.Map:set(self.htExt, mimeType, key) end
		v = true
	elseif _g.jk.lang.String:startsWith(pattern, "*.", 0) == true then
		local key = _g.jk.lang.String:getSubString(pattern, 2, _g.jk.lang.String:getLength(pattern) - 2)
		do _g.jk.lang.Map:set(self.htMime, key, mimeType) end
		do _g.jk.lang.Map:set(self.htExt, mimeType, key) end
		v = true
	elseif _g.jk.lang.String:startsWith(pattern, "#", 0) == true then
	else
		do _g.jk.lang.Map:set(self.htMime, pattern, mimeType) end
		do _g.jk.lang.Map:set(self.htExt, mimeType, pattern) end
		v = true
	end
	do return v end
end

function jk.mime.MimeTypeRegistry:read(file)
	if not (file ~= nil) then
		do return false end
	end
	do
		local buf = _g.jk.io.PrintReader:forReader(file:read())
		if not (buf ~= nil) then
			do return false end
		end
		do
			local n = 0
			while true do
				local line = buf:readLine()
				if not (line ~= nil) then
					do break end
				end
				do
					local va = _g.jk.lang.String:split(line, 58, 0)
					local val = _g.jk.lang.Vector:iterate(va)
					if val ~= nil then
						local front = val:next()
						local back = val:next()
						if front ~= nil then
							front = _g.jk.lang.String:strip(front)
						end
						if back ~= nil then
							back = _g.jk.lang.String:strip(back)
						end
						if self:add(front, back) then
							do n = n + 1 end
						end
					end
				end
			end
			do return true end
		end
	end
end
jk = jk or {}

jk.url = jk.url or {}

jk.url.QueryString = {}
jk.url.QueryString.__index = jk.url.QueryString
_vm:set_metatable(jk.url.QueryString, {})

function jk.url.QueryString._create()
	local v = _vm:set_metatable({}, jk.url.QueryString)
	return v
end

function jk.url.QueryString:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.url.QueryString'
	self['_isType.jk.url.QueryString'] = true
end

function jk.url.QueryString:_construct0()
	jk.url.QueryString._init(self)
	return self
end

function jk.url.QueryString:parse(queryString)
	local v = {}
	if _g.jk.lang.String:isEmpty(queryString) then
		do return v end
	end
	do
		local array = _g.jk.lang.String:split(queryString, 38, 0)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local qs = array[n + 1]
					if qs ~= nil then
						if _g.jk.lang.String:isEmpty(qs) then
							goto _continue1
						end
						if _g.jk.lang.String:getIndexOfCharacter(qs, 61, 0) < 0 then
							do _g.jk.lang.Map:set(v, qs, nil) end
							goto _continue1
						end
						do
							local qsps = _g.jk.lang.String:split(qs, 61, 2)
							local key = qsps[0 + 1]
							local val = qsps[1 + 1]
							if val == nil then
								val = ""
							end
							if _g.jk.lang.String:isEmpty(key) == false then
								do _g.jk.lang.Map:set(v, _g.jk.url.URLDecoder:decode(key), _g.jk.url.URLDecoder:decode(val)) end
							end
						end
					end
					::_continue1::
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function jk.url.QueryString:encode(queryString)
	local str = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local first = true
	local keys = _g.jk.lang.Map:getKeys(queryString)
	if keys ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(keys)
		do
			n = 0
			while n < m do
				local key = keys[n + 1]
				if key ~= nil then
					if _g.jk.lang.String:isEmpty(key) then
						goto _continue2
					end
					do
						local val = _g.jk.lang.Map:getValue(queryString, key)
						if not first then
							do str:appendString("&") end
						end
						do str:appendString(_g.jk.url.URLEncoder:encode(key, false, true)) end
						do str:appendCharacter(61) end
						do str:appendString(_g.jk.url.URLEncoder:encode(val, false, true)) end
						first = false
					end
				end
				::_continue2::
				do n = n + 1 end
			end
		end
	end
	do return str:toString() end
end

jk.url.URL = {}
jk.url.URL.__index = jk.url.URL
_vm:set_metatable(jk.url.URL, {})

function jk.url.URL._create()
	local v = _vm:set_metatable({}, jk.url.URL)
	return v
end

function jk.url.URL:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.url.URL'
	self['_isType.jk.url.URL'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.scheme = nil
	self.username = nil
	self.password = nil
	self.host = nil
	self.port = nil
	self.path = nil
	self.fragment = nil
	self.rawQueryParameters = nil
	self.queryParameters = nil
	self.original = nil
	self.percentOnly = false
	self.encodeUnreservedChars = true
end

function jk.url.URL:_construct0()
	jk.url.URL._init(self)
	return self
end

function jk.url.URL:forString(str, normalizePath)
	local v = _g.jk.url.URL._construct0(_g.jk.url.URL._create())
	do v:parse(str, normalizePath) end
	do return v end
end

function jk.url.URL:dup()
	local v = _g.jk.url.URL._construct0(_g.jk.url.URL._create())
	do v:setScheme(self.scheme) end
	do v:setUsername(self.username) end
	do v:setPassword(self.password) end
	do v:setHost(self.host) end
	do v:setPort(self.port) end
	do v:setPath(self.path) end
	do v:setFragment(self.fragment) end
	if self.rawQueryParameters ~= nil then
		do v:setRawQueryParameters(self.rawQueryParameters:dup()) end
	end
	if self.queryParameters ~= nil then
		do v:setQueryParameters(_g.jk.lang.Map:dup(self.queryParameters)) end
	end
	do return v end
end

function jk.url.URL:toString()
	do return self:toStringDo(true) end
end

function jk.url.URL:toStringNohost()
	do return self:toStringDo(false) end
end

function jk.url.URL:toStringDo(userhost)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if userhost then
		if self.scheme ~= nil then
			do sb:appendString(self.scheme) end
			do sb:appendString("://") end
		end
		if self.username ~= nil then
			do sb:appendString(_g.jk.url.URLEncoder:encode(self.username, false, true)) end
			if self.password ~= nil then
				do sb:appendCharacter(58) end
				do sb:appendString(_g.jk.url.URLEncoder:encode(self.password, false, true)) end
			end
			do sb:appendCharacter(64) end
		end
		if self.host ~= nil then
			do sb:appendString(self.host) end
			if self.port ~= nil then
				do sb:appendCharacter(58) end
				do sb:appendString(self.port) end
			end
		end
	end
	if self.path ~= nil then
		do sb:appendString(_g.jk.lang.String:replaceCharacter(self.path, 32, 43)) end
	end
	if self.rawQueryParameters ~= nil and self.rawQueryParameters:count() > 0 then
		local first = true
		local it = _g.jk.lang.Map:iterateKeys(self.queryParameters)
		while it ~= nil do
			local key = (function(o)
				if (_vm:get_variable_type(o) == 'string') then
					do return o end
				end
				do return nil end
			end)(it:next())
			if key == nil then
				do break end
			end
			if first then
				do sb:appendCharacter(63) end
				first = false
			else
				do sb:appendCharacter(38) end
			end
			do sb:appendString(key) end
			do
				local val = _g.jk.lang.Map:get(self.queryParameters, key)
				if val ~= nil then
					do sb:appendCharacter(61) end
					do sb:appendString(_g.jk.url.URLEncoder:encode(val, self.percentOnly, self.encodeUnreservedChars)) end
				end
			end
		end
	end
	if self.fragment ~= nil then
		do sb:appendCharacter(35) end
		do sb:appendString(self.fragment) end
	end
	do return sb:toString() end
end

function jk.url.URL:clearQueryParameters()
	self.rawQueryParameters = nil
	self.queryParameters = nil
end

function jk.url.URL:normalizePath(path)
	if not (path ~= nil) then
		do return nil end
	end
	do
		local v = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local comps = _g.jk.lang.String:split(path, 47, 0)
		if comps ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(comps)
			do
				n = 0
				while n < m do
					local comp = comps[n + 1]
					if comp ~= nil then
						if _g.jk.lang.String:isEmpty(comp) then
						elseif comp == "." then
						elseif comp == ".." then
							local str = v:toString()
							do v:clear() end
							if str ~= nil then
								local slash = _g.jk.lang.String:getLastIndexOfCharacter(str, 47, -1)
								if slash > 0 then
									do v:appendString(_g.jk.lang.String:getSubString(str, 0, slash)) end
								end
							end
						else
							do v:appendCharacter(47) end
							do v:appendString(comp) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		if v:count() < 2 then
			do return "/" end
		end
		if _g.jk.lang.String:endsWith(path, "/") then
			do v:appendCharacter(47) end
		end
		do return v:toString() end
	end
end

function jk.url.URL:parse(astr, doNormalizePath)
	do self:setOriginal(astr) end
	if not (astr ~= nil) then
		do return end
	end
	do
		local fsp = _g.jk.lang.String:split(astr, 35, 2)
		local str = _g.jk.lang.Vector:get(fsp, 0)
		self.fragment = _g.jk.lang.Vector:get(fsp, 1)
		do
			local qsplit = _g.jk.lang.String:split(str, 63, 2)
			str = _g.jk.lang.Vector:get(qsplit, 0)
			do
				local queryString = _g.jk.lang.Vector:get(qsplit, 1)
				if _g.jk.lang.String:isEmpty(queryString) == false then
					local qss = _g.jk.lang.String:split(queryString, 38, 0)
					if qss ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(qss)
						do
							n = 0
							while n < m do
								local qs = qss[n + 1]
								if qs ~= nil then
									if not (self.rawQueryParameters ~= nil) then
										self.rawQueryParameters = _g.jk.lang.KeyValueList._construct0(_g.jk.lang.KeyValueList._create())
									end
									if not (self.queryParameters ~= nil) then
										self.queryParameters = {}
									end
									if _g.jk.lang.String:getIndexOfCharacter(qs, 61, 0) < 0 then
										do _g.jk.lang.Map:set(self.queryParameters, qs, nil) end
										do self.rawQueryParameters:add(qs, nil) end
										goto _continue3
									end
									do
										local qsps = _g.jk.lang.String:split(qs, 61, 2)
										local key = _g.jk.lang.Vector:get(qsps, 0)
										local val = _g.jk.lang.Vector:get(qsps, 1)
										if _g.jk.lang.String:isEmpty(key) == false then
											if not (val ~= nil) then
												val = ""
											end
											do
												local udv = _g.jk.url.URLDecoder:decode(val)
												do _g.jk.lang.Map:set(self.queryParameters, key, udv) end
												do self.rawQueryParameters:add(key, udv) end
											end
										end
									end
								end
								::_continue3::
								do n = n + 1 end
							end
						end
					end
				end
				do
					local css = _g.jk.lang.String:getIndexOfString(str, "://", 0)
					if css >= 0 then
						self.scheme = _g.jk.lang.String:getSubString(str, 0, css)
						if _g.jk.lang.String:getIndexOfCharacter(self.scheme, 58, 0) >= 0 or _g.jk.lang.String:getIndexOfCharacter(self.scheme, 47, 0) >= 0 then
							self.scheme = nil
						else
							str = _g.jk.lang.String:getEndOfString(str, css + 3)
						end
					end
					do
						local pp = nil
						if _g.jk.lang.String:getChar(str, 0) == 47 then
							pp = str
						else
							if _g.jk.lang.String:getIndexOfCharacter(str, 47, 0) >= 0 then
								local sssplit = _g.jk.lang.String:split(str, 47, 2)
								str = _g.jk.lang.Vector:get(sssplit, 0)
								pp = _g.jk.lang.Vector:get(sssplit, 1)
								if not (pp ~= nil) then
									pp = ""
								end
								if _g.jk.lang.String:getChar(pp, 0) ~= 47 then
									pp = _g.jk.lang.String:appendString("/", pp)
								end
							end
							if _g.jk.lang.String:getIndexOfCharacter(str, 64, 0) >= 0 then
								local asplit = _g.jk.lang.String:split(str, 64, 2)
								local auth = _g.jk.lang.Vector:get(asplit, 0)
								str = _g.jk.lang.Vector:get(asplit, 1)
								if _g.jk.lang.String:getIndexOfCharacter(auth, 58, 0) >= 0 then
									local acsplit = _g.jk.lang.String:split(auth, 58, 2)
									self.username = _g.jk.url.URLDecoder:decode(_g.jk.lang.Vector:get(acsplit, 0))
									self.password = _g.jk.url.URLDecoder:decode(_g.jk.lang.Vector:get(acsplit, 1))
								else
									self.username = auth
								end
							end
							if _g.jk.lang.String:getIndexOfCharacter(str, 58, 0) >= 0 then
								local hcsplit = _g.jk.lang.String:split(str, 58, 2)
								str = _g.jk.lang.Vector:get(hcsplit, 0)
								self.port = _g.jk.lang.Vector:get(hcsplit, 1)
							end
							self.host = str
						end
						if doNormalizePath then
							self.path = self:normalizePath(pp)
						else
							self.path = pp
						end
						if not (self.port ~= nil) and _g.jk.lang.String:equals("https", self.scheme) or _g.jk.lang.String:equals("wss", self.scheme) then
							self.port = "443"
						end
					end
				end
			end
		end
	end
end

function jk.url.URL:getPortInt()
	if not (self.port ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.String:toInteger(self.port) end
end

function jk.url.URL:getQueryParameter(key)
	if not (self.queryParameters ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Map:get(self.queryParameters, key) end
end

function jk.url.URL:addQueryParameter(key, value)
	if not (self.rawQueryParameters ~= nil) then
		self.rawQueryParameters = _g.jk.lang.KeyValueList._construct0(_g.jk.lang.KeyValueList._create())
	end
	if not (self.queryParameters ~= nil) then
		self.queryParameters = {}
	end
	do _g.jk.lang.Map:set(self.queryParameters, key, value) end
	do self.rawQueryParameters:add(key, value) end
end

function jk.url.URL:getScheme()
	do return self.scheme end
end

function jk.url.URL:setScheme(v)
	self.scheme = v
	do return self end
end

function jk.url.URL:getUsername()
	do return self.username end
end

function jk.url.URL:setUsername(v)
	self.username = v
	do return self end
end

function jk.url.URL:getPassword()
	do return self.password end
end

function jk.url.URL:setPassword(v)
	self.password = v
	do return self end
end

function jk.url.URL:getHost()
	do return self.host end
end

function jk.url.URL:setHost(v)
	self.host = v
	do return self end
end

function jk.url.URL:getPort()
	do return self.port end
end

function jk.url.URL:setPort(v)
	self.port = v
	do return self end
end

function jk.url.URL:getPath()
	do return self.path end
end

function jk.url.URL:setPath(v)
	self.path = v
	do return self end
end

function jk.url.URL:getFragment()
	do return self.fragment end
end

function jk.url.URL:setFragment(v)
	self.fragment = v
	do return self end
end

function jk.url.URL:getRawQueryParameters()
	do return self.rawQueryParameters end
end

function jk.url.URL:setRawQueryParameters(v)
	self.rawQueryParameters = v
	do return self end
end

function jk.url.URL:getQueryParameters()
	do return self.queryParameters end
end

function jk.url.URL:setQueryParameters(v)
	self.queryParameters = v
	do return self end
end

function jk.url.URL:getOriginal()
	do return self.original end
end

function jk.url.URL:setOriginal(v)
	self.original = v
	do return self end
end

function jk.url.URL:getPercentOnly()
	do return self.percentOnly end
end

function jk.url.URL:setPercentOnly(v)
	self.percentOnly = v
	do return self end
end

function jk.url.URL:getEncodeUnreservedChars()
	do return self.encodeUnreservedChars end
end

function jk.url.URL:setEncodeUnreservedChars(v)
	self.encodeUnreservedChars = v
	do return self end
end

jk.url.URLEncoder = {}
jk.url.URLEncoder.__index = jk.url.URLEncoder
_vm:set_metatable(jk.url.URLEncoder, {})

function jk.url.URLEncoder._create()
	local v = _vm:set_metatable({}, jk.url.URLEncoder)
	return v
end

function jk.url.URLEncoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.url.URLEncoder'
	self['_isType.jk.url.URLEncoder'] = true
end

function jk.url.URLEncoder:_construct0()
	jk.url.URLEncoder._init(self)
	return self
end

function jk.url.URLEncoder:encode(str, percentOnly, encodeUnreservedChars)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local buffer = _g.jk.lang.String:toUTF8Buffer(str)
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do
			local i = 0
			while i < #buffer do
				local c = _g.jk.lang.Buffer:getByte(buffer, i)
				if c < 1 then
					do break end
				end
				if c >= 97 and c <= 122 or (c >= 65 and c <= 90) or (c >= 48 and c <= 57) then
					do sb:appendCharacter(c) end
				elseif c == 45 or c == 46 or c == 95 or c == 126 and encodeUnreservedChars == false then
					do sb:appendCharacter(c) end
				elseif c == 32 and percentOnly == false then
					do sb:appendCharacter(43) end
				else
					do sb:appendCharacter(37) end
					do sb:appendString(_g.jk.lang.String:forIntegerHex(_vm:bitwise_and(_util:convert_to_integer(c), 255), 0)) end
				end
				do i = i + 1 end
			end
		end
		do return sb:toString() end
	end
end

jk.url.URLDecoder = {}
jk.url.URLDecoder.__index = jk.url.URLDecoder
_vm:set_metatable(jk.url.URLDecoder, {})

function jk.url.URLDecoder._create()
	local v = _vm:set_metatable({}, jk.url.URLDecoder)
	return v
end

function jk.url.URLDecoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.url.URLDecoder'
	self['_isType.jk.url.URLDecoder'] = true
end

function jk.url.URLDecoder:_construct0()
	jk.url.URLDecoder._init(self)
	return self
end

function jk.url.URLDecoder:xcharToInteger(c)
	if c >= 48 and c <= 57 then
		local ci = _util:convert_to_integer(c)
		do return ci - 48 end
	elseif c >= 97 and c <= 102 then
		do return 10 + c - 97 end
	elseif c >= 65 and c <= 70 then
		do return 10 + c - 65 end
	end
	do return 0 end
end

function jk.url.URLDecoder:decode(astr)
	if not (astr ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local str = _g.jk.lang.String:strip(astr)
		local it = _g.jk.lang.String:iterate(str)
		while it ~= nil do
			local x = it:getNextChar()
			if x < 1 then
				do break end
			end
			if x == 37 then
				local x1 = it:getNextChar()
				local x2 = it:getNextChar()
				if x1 > 0 and x2 > 0 then
					do sb:appendCharacter(_g.jk.url.URLDecoder:xcharToInteger(x1) * 16 + _g.jk.url.URLDecoder:xcharToInteger(x2)) end
				else
					do break end
				end
			elseif x == 43 then
				do sb:appendCharacter(32) end
			else
				do sb:appendCharacter(x) end
			end
		end
		do return sb:toString() end
	end
end
jk = jk or {}

jk.socket = jk.socket or {}

jk.socket.ConnectedSocket = {}

jk.socket.TCPSocket = {}
jk.socket.TCPSocket.__index = jk.socket.TCPSocket
_vm:set_metatable(jk.socket.TCPSocket, {})

function jk.socket.TCPSocket._create()
	local v = _vm:set_metatable({}, jk.socket.TCPSocket)
	return v
end

function jk.socket.TCPSocket:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.socket.TCPSocket'
	self['_isType.jk.socket.TCPSocket'] = true
	self['_isType.jk.socket.ConnectedSocket'] = true
	self.lastErrorDescription = nil
end

function jk.socket.TCPSocket:_construct0()
	jk.socket.TCPSocket._init(self)
	return self
end

function jk.socket.TCPSocket:create()
	do return _g.jk.socket.TCPSocketForSushi._construct0(_g.jk.socket.TCPSocketForSushi._create()) end
end

function jk.socket.TCPSocket:createAndConnect(address, port)
	local v = _g.jk.socket.TCPSocket:create()
	if not (v ~= nil) then
		do return nil end
	end
	if v:connect(address, port) == false then
		v = nil
	end
	do return v end
end

function jk.socket.TCPSocket:createAndListen(port)
	local v = _g.jk.socket.TCPSocket:create()
	if not (v ~= nil) then
		do return nil end
	end
	if v:listen(port) == false then
		v = nil
	end
	do return v end
end

function jk.socket.TCPSocket:getRemoteAddress()
end

function jk.socket.TCPSocket:getRemotePort()
end

function jk.socket.TCPSocket:getLocalAddress()
end

function jk.socket.TCPSocket:getLocalPort()
end

function jk.socket.TCPSocket:connect(address, port)
end

function jk.socket.TCPSocket:listen(port)
end

function jk.socket.TCPSocket:accept()
end

function jk.socket.TCPSocket:setBlocking(blocking)
end

function jk.socket.TCPSocket:getBlocking()
end

function jk.socket.TCPSocket:close()
end

function jk.socket.TCPSocket:read(buffer)
end

function jk.socket.TCPSocket:readWithTimeout(buffer, timeout)
	do return self:read(buffer) end
end

function jk.socket.TCPSocket:write(buffer, size)
end

function jk.socket.TCPSocket:getLastErrorDescription()
	do return self.lastErrorDescription end
end

function jk.socket.TCPSocket:setLastErrorDescription(v)
	self.lastErrorDescription = v
	do return self end
end

jk.socket.TCPSocketForSushi = _g.jk.socket.TCPSocket._create()
jk.socket.TCPSocketForSushi.__index = jk.socket.TCPSocketForSushi
_vm:set_metatable(jk.socket.TCPSocketForSushi, {
	__index = _g.jk.socket.TCPSocket
})

function jk.socket.TCPSocketForSushi._create()
	local v = _vm:set_metatable({}, jk.socket.TCPSocketForSushi)
	return v
end

function jk.socket.TCPSocketForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.socket.TCPSocketForSushi'
	self['_isType.jk.socket.TCPSocketForSushi'] = true
	self['_isType.jk.io.FileDescriptor'] = true
	self.fd = -1
	self.isBlocking = true
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function jk.socket.TCPSocketForSushi:_construct0()
	jk.socket.TCPSocketForSushi._init(self)
	do _g.jk.socket.TCPSocket._construct0(self) end
	return self
end

function jk.socket.TCPSocketForSushi:_destruct()
	do self:close() end
end

function jk.socket.TCPSocketForSushi:getFileDescriptor()
	do return self.fd end
end

function jk.socket.TCPSocketForSushi:createSocket()
	if self.fd >= 0 then
		do self:close() end
	end
	self.fd = _net:create_tcp_socket()
	if self.fd < 0 then
		do return false end
	end
	do return true end
end

function jk.socket.TCPSocketForSushi:close()
	local fd = self.fd
	if not (fd >= 0) then
		do return end
	end
	do _net:close_tcp_socket(fd) end
	self.fd = -1
end

function jk.socket.TCPSocketForSushi:getRemoteAddress()
	if not (self.fd >= 0) then
		do return nil end
	end
	do
		local fd = self.fd
		do return _net:get_tcp_socket_peer_address(fd) end
	end
end

function jk.socket.TCPSocketForSushi:getRemotePort()
	if not (self.fd >= 0) then
		do return 0 end
	end
	do
		local fd = self.fd
		do return _net:get_tcp_socket_peer_port(fd) end
	end
end

function jk.socket.TCPSocketForSushi:getLocalAddress()
	_io:write_to_stdout("[jk.socket.TCPSocketForSushi.getLocalAddress] (TCPSocketForSushi@target_sushi.sling:77:2): Not implemented" .. "\n")
	do return nil end
end

function jk.socket.TCPSocketForSushi:getLocalPort()
	_io:write_to_stdout("[jk.socket.TCPSocketForSushi.getLocalPort] (TCPSocketForSushi@target_sushi.sling:83:2): Not implemented" .. "\n")
	do return 0 end
end

function jk.socket.TCPSocketForSushi:connect(address, port)
	if not self:createSocket() then
		do return false end
	end
	do
		local fd = self.fd
		if _net:connect_tcp_socket(fd, address, port) ~= 0 then
			do self:close() end
			do return false end
		end
		do return true end
	end
end

function jk.socket.TCPSocketForSushi:listen(port)
	if not self:createSocket() then
		do return false end
	end
	do
		local fd = self.fd
		if _net:listen_tcp_socket(fd, port) ~= 0 then
			do self:close() end
			do return false end
		end
		do return true end
	end
end

function jk.socket.TCPSocketForSushi:accept()
	if not (self.fd >= 0) then
		do return nil end
	end
	do
		local r = 0
		local error = nil
		local fd = self.fd
		do r, error = _net:accept_tcp_socket(fd) end
		if error ~= nil then
			_vm:throw_error(_g.jk.lang.ExceptionWithError:forCode("failedToAcceptSocket", error))
		end
		if not (r >= 0) then
			do return nil end
		end
		do
			local v = _g.jk.socket.TCPSocketForSushi._construct0(_g.jk.socket.TCPSocketForSushi._create())
			do v:setFd(r) end
			do return v end
		end
	end
end

function jk.socket.TCPSocketForSushi:setBlocking(blocking)
	if not (self.fd >= 0) then
		do return false end
	end
	do
		local r = 0
		local fd = self.fd
		if blocking then
			do r = _net:set_socket_blocking(fd) end
		else
			do r = _net:set_socket_non_blocking(fd) end
		end
		if r ~= 0 then
			do return false end
		end
		self.isBlocking = blocking
		do return true end
	end
end

function jk.socket.TCPSocketForSushi:getBlocking()
	do return self.isBlocking end
end

function jk.socket.TCPSocketForSushi:read(buffer)
	do return self:readWithTimeout(buffer, -1) end
end

function jk.socket.TCPSocketForSushi:readWithTimeout(buffer, timeout)
	if self.fd < 0 then
		do return -1 end
	end
	if buffer == nil then
		do return -1 end
	end
	do
		local v = 0
		local fd = self.fd
		do v = _net:read_from_tcp_socket(fd, buffer, #buffer, timeout) end
		do return v end
	end
end

function jk.socket.TCPSocketForSushi:write(buffer, size)
	if self.fd < 0 then
		do return -1 end
	end
	if buffer == nil then
		do return -1 end
	end
	do
		local sz = size
		if sz < 0 then
			sz = #buffer
		end
		do
			local v = 0
			local fd = self.fd
			do v = _net:write_to_tcp_socket(fd, buffer, sz) end
			do return v end
		end
	end
end

function jk.socket.TCPSocketForSushi:getFd()
	do return self.fd end
end

function jk.socket.TCPSocketForSushi:setFd(v)
	self.fd = v
	do return self end
end

jk.socket.UDPSocket = {}
jk.socket.UDPSocket.__index = jk.socket.UDPSocket
_vm:set_metatable(jk.socket.UDPSocket, {})

function jk.socket.UDPSocket._create()
	local v = _vm:set_metatable({}, jk.socket.UDPSocket)
	return v
end

function jk.socket.UDPSocket:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.socket.UDPSocket'
	self['_isType.jk.socket.UDPSocket'] = true
end

function jk.socket.UDPSocket:_construct0()
	jk.socket.UDPSocket._init(self)
	return self
end

function jk.socket.UDPSocket:create()
	_io:write_to_stdout("[jk.socket.UDPSocket.create] (UDPSocket.sling:40:3): Not implemented." .. "\n")
	do return nil end
end

function jk.socket.UDPSocket:send(message, address, port)
end

function jk.socket.UDPSocket:sendBroadcast(message, address, port)
end

function jk.socket.UDPSocket:receive(message, timeout)
end

function jk.socket.UDPSocket:bind(port)
end

function jk.socket.UDPSocket:close()
end

function jk.socket.UDPSocket:getLocalAddress()
end

function jk.socket.UDPSocket:getLocalPort()
end
jk = jk or {}

jk.socket = jk.socket or {}

jk.socket.ssl = jk.socket.ssl or {}

jk.socket.ssl.SSLSocket = {}
jk.socket.ssl.SSLSocket.__index = jk.socket.ssl.SSLSocket
_vm:set_metatable(jk.socket.ssl.SSLSocket, {})

function jk.socket.ssl.SSLSocket._create()
	local v = _vm:set_metatable({}, jk.socket.ssl.SSLSocket)
	return v
end

function jk.socket.ssl.SSLSocket:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.socket.ssl.SSLSocket'
	self['_isType.jk.socket.ssl.SSLSocket'] = true
	self['_isType.jk.socket.ConnectedSocket'] = true
end

function jk.socket.ssl.SSLSocket:_construct0()
	jk.socket.ssl.SSLSocket._init(self)
	return self
end

function jk.socket.ssl.SSLSocket:createInstance(cSocket, serverAddress, ctx, certFile, keyFile, isServer, acceptInvalidCertificate, passphrase)
	if not (cSocket ~= nil) then
		do return nil end
	end
	do
		local v = nil
		local ss = _g.jk.socket.ssl.SSLSocketForSushi._construct0(_g.jk.socket.ssl.SSLSocketForSushi._create())
		do ss:setAcceptInvalidCertificate(acceptInvalidCertificate) end
		do ss:setCtx(ctx) end
		do ss:setServerAddress(serverAddress) end
		if ss:open(cSocket, certFile, keyFile, isServer, passphrase) then
			v = ss
		end
		do return v end
	end
end

function jk.socket.ssl.SSLSocket:forClient(cSocket, hostAddress, ctx, acceptInvalidCertificate, passphrase)
	do return _g.jk.socket.ssl.SSLSocket:createInstance(cSocket, hostAddress, ctx, nil, nil, false, acceptInvalidCertificate, passphrase) end
end

function jk.socket.ssl.SSLSocket:forServer(cSocket, certFile, keyFile, ctx, acceptInvalidCertificate, passphrase)
	do return _g.jk.socket.ssl.SSLSocket:createInstance(cSocket, nil, ctx, certFile, keyFile, true, acceptInvalidCertificate, passphrase) end
end

function jk.socket.ssl.SSLSocket:setAcceptInvalidCertificate(accept)
end

function jk.socket.ssl.SSLSocket:setRequireClientCertificate(require)
end

function jk.socket.ssl.SSLSocket:close()
end

function jk.socket.ssl.SSLSocket:read(buffer)
end

function jk.socket.ssl.SSLSocket:readWithTimeout(buffer, timeout)
end

function jk.socket.ssl.SSLSocket:write(buffer, size)
end

function jk.socket.ssl.SSLSocket:getSocket()
end

jk.socket.ssl.SSLSocketForSushi = _g.jk.socket.ssl.SSLSocket._create()
jk.socket.ssl.SSLSocketForSushi.__index = jk.socket.ssl.SSLSocketForSushi
_vm:set_metatable(jk.socket.ssl.SSLSocketForSushi, {
	__index = _g.jk.socket.ssl.SSLSocket
})

function jk.socket.ssl.SSLSocketForSushi._create()
	local v = _vm:set_metatable({}, jk.socket.ssl.SSLSocketForSushi)
	return v
end

function jk.socket.ssl.SSLSocketForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.socket.ssl.SSLSocketForSushi'
	self['_isType.jk.socket.ssl.SSLSocketForSushi'] = true
	self.ctx = nil
	self.socket = nil
	self.serverAddress = nil
	self.acceptInvalidCertificate = false
	self.requireClientCertificate = false
	self.ssl = nil
end

function jk.socket.ssl.SSLSocketForSushi:_construct0()
	jk.socket.ssl.SSLSocketForSushi._init(self)
	do _g.jk.socket.ssl.SSLSocket._construct0(self) end
	return self
end

function jk.socket.ssl.SSLSocketForSushi:setAcceptInvalidCertificate(v)
	self.acceptInvalidCertificate = v
end

function jk.socket.ssl.SSLSocketForSushi:setRequireClientCertificate(v)
	self.requireClientCertificate = v
end

function jk.socket.ssl.SSLSocketForSushi:open(cSocket, certFile, keyFile, isServer, passphrase)
	if not ((function()
		self.socket = _vm:to_table_with_key(cSocket, '_isType.jk.socket.TCPSocketForSushi')
		do return self.socket end
	end)() ~= nil) then
		do return false end
	end
	if isServer then
		do return false end
	end
	do
		local address = self.serverAddress
		if _g.jk.lang.String:isEmpty(address) then
			address = self.socket:getRemoteAddress()
		end
		if not _g.jk.lang.String:isNotEmpty(address) then
			do return false end
		end
		do
			local port = self.socket:getRemotePort()
			if port < 1 then
				port = 443
			end
			do
				local fd = self.socket:getFileDescriptor()
				local ssl = _crypto:ssl_connect(fd, address)
				if not (ssl ~= nil) then
					do return false end
				end
				self.ssl = ssl
				do return true end
			end
		end
	end
end

function jk.socket.ssl.SSLSocketForSushi:read(buffer)
	do return self:readWithTimeout(buffer, -1) end
end

function jk.socket.ssl.SSLSocketForSushi:close()
	if self.ssl ~= nil then
		local ssl = self.ssl
		self.ssl = nil
		do _crypto:ssl_close(ssl) end
	end
	if self.socket ~= nil then
		do self.socket:close() end
		self.socket = nil
	end
end

function jk.socket.ssl.SSLSocketForSushi:readWithTimeout(buffer, timeout)
	local ssl = self.ssl
	if not (ssl ~= nil) then
		do return 0 end
	end
	if not (buffer ~= nil) then
		do return -1 end
	end
	do
		local v = _crypto:ssl_read(ssl, buffer)
		if v < 1 then
			do self:close() end
			v = -1
		end
		do return v end
	end
end

function jk.socket.ssl.SSLSocketForSushi:write(buffer, size)
	local ssl = self.ssl
	if not (ssl ~= nil) then
		do return 0 end
	end
	if not (buffer ~= nil) then
		do return -1 end
	end
	do
		local v = _crypto:ssl_write(ssl, buffer, size)
		if v < 1 then
			do self:close() end
			v = -1
		end
		do return v end
	end
end

function jk.socket.ssl.SSLSocketForSushi:getSocket()
	do return self.socket end
end

function jk.socket.ssl.SSLSocketForSushi:getCtx()
	do return self.ctx end
end

function jk.socket.ssl.SSLSocketForSushi:setCtx(v)
	self.ctx = v
	do return self end
end

function jk.socket.ssl.SSLSocketForSushi:setSocket(v)
	self.socket = v
	do return self end
end

function jk.socket.ssl.SSLSocketForSushi:getServerAddress()
	do return self.serverAddress end
end

function jk.socket.ssl.SSLSocketForSushi:setServerAddress(v)
	self.serverAddress = v
	do return self end
end
jk = jk or {}

jk.archive = jk.archive or {}

jk.archive.ZipWriter = {}
jk.archive.ZipWriter.__index = jk.archive.ZipWriter
_vm:set_metatable(jk.archive.ZipWriter, {})

function jk.archive.ZipWriter._create()
	local v = _vm:set_metatable({}, jk.archive.ZipWriter)
	return v
end

function jk.archive.ZipWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipWriter'
	self['_isType.jk.archive.ZipWriter'] = true
end

function jk.archive.ZipWriter:_construct0()
	jk.archive.ZipWriter._init(self)
	return self
end

function jk.archive.ZipWriter:forOutputFile(file)
	do return _g.jk.archive.ZipWriterForSushi:forFile(file) end
end

function jk.archive.ZipWriter:writeToZipRecursive(ctx, dest, source, truncateDirectoryName)
	if not (dest ~= nil) then
		do _g.jk.log.Log:error(ctx, "No destination file specified for ZIP writer") end
		do return false end
	end
	if not (source ~= nil) then
		do _g.jk.log.Log:error(ctx, "No source file specified for ZIP writer") end
		do return false end
	end
	do
		local zip = _g.jk.archive.ZipWriter:forOutputFile(dest)
		if not (zip ~= nil) then
			do _g.jk.log.Log:error(ctx, "Failed to create ZIP writer for file: `" .. _g.jk.lang.String:safeString(dest:getPath()) .. "'") end
			do return false end
		end
		do
			local pd = source:getParent()
			if not (pd ~= nil) then
				do _g.jk.log.Log:error(ctx, "Directory has no parent: `" .. _g.jk.lang.String:safeString(source:getPath()) .. "'") end
				do return false end
			end
			do
				local parentPath = pd:getPath()
				if not _g.jk.lang.String:isNotEmpty(parentPath) then
					do _g.jk.log.Log:error(ctx, "Parent path is empty: `" .. _g.jk.lang.String:safeString(source:getPath()) .. "'") end
					do return false end
				end
				do
					local parentPathLength = _g.jk.lang.String:getLength(parentPath)
					if truncateDirectoryName then
						parentPathLength = _g.jk.lang.String:getLength(source:getPath())
					end
					if source:isFile() then
						if not zip:addFile(source, source:getBasename()) then
							do _g.jk.log.Log:error(ctx, "Failed to add to ZIP file: `" .. _g.jk.lang.String:safeString(source:getPath()) .. "'") end
							do zip:close() end
							do dest:remove() end
							do return false end
						end
						do zip:close() end
						do return true end
					end
					do
						local root = source
						if truncateDirectoryName then
							root = nil
						end
						do
							local ff = _g.jk.fs.FileFinder:forRoot(source)
							do ff:setIncludeDirectories(true) end
							while true do
								local file = nil
								if root ~= nil then
									file = root
									root = nil
								else
									file = ff:next()
								end
								if not (file ~= nil) then
									do break end
								end
								do
									local isFile = file:isFile()
									local isDirectory = file:isDirectory()
									if isFile == false and isDirectory == false then
										goto _continue4
									end
									do
										local fpath = file:getPath()
										if _g.jk.lang.String:isEmpty(fpath) then
											goto _continue4
										end
										do
											local partialPath = _g.jk.lang.String:getEndOfString(fpath, parentPathLength + 1)
											if _g.jk.lang.String:isEmpty(partialPath) then
												goto _continue4
											end
											partialPath = _g.jk.lang.String:replaceCharacter(partialPath, 92, 47)
											if isDirectory then
												partialPath = _g.jk.lang.String:safeString(partialPath) .. "/"
											end
											if not zip:addFile(file, partialPath) then
												do _g.jk.log.Log:error(ctx, "Failed to add to ZIP file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
												do zip:close() end
												do dest:remove() end
												do return false end
											end
										end
									end
								end
								::_continue4::
							end
							do zip:close() end
							do return true end
						end
					end
				end
			end
		end
	end
end

function jk.archive.ZipWriter:addFile(file, filename)
end

function jk.archive.ZipWriter:close()
end

jk.archive.ZipReader = {}
jk.archive.ZipReader.__index = jk.archive.ZipReader
_vm:set_metatable(jk.archive.ZipReader, {})

function jk.archive.ZipReader._create()
	local v = _vm:set_metatable({}, jk.archive.ZipReader)
	return v
end

function jk.archive.ZipReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipReader'
	self['_isType.jk.archive.ZipReader'] = true
end

function jk.archive.ZipReader:_construct0()
	jk.archive.ZipReader._init(self)
	return self
end

function jk.archive.ZipReader:forFile(file)
	do return _g.jk.archive.ZipReaderForSushi._construct0(_g.jk.archive.ZipReaderForSushi._create()):setFile(file):initialize() end
end

function jk.archive.ZipReader:extractZipBufferToDirectory(zipBuffer, destDir, listener)
	if not (zipBuffer ~= nil) then
		do return false end
	end
	do
		local dd = _g.jk.env.TemporaryDirectory:create()
		if not (dd ~= nil) then
			do return false end
		end
		do
			local ff = dd:entry("files.zip")
			if not ff:setContentsBuffer(zipBuffer) then
				do dd:removeRecursive() end
				do return false end
			end
			do
				local v = _g.jk.archive.ZipReader:extractZipFileToDirectory(ff, destDir, listener)
				do dd:removeRecursive() end
				do return v end
			end
		end
	end
end

function jk.archive.ZipReader:extractZipFileToDirectory(zipFile, destDir, listener)
	if not (zipFile ~= nil) then
		do return false end
	end
	if not (destDir ~= nil) then
		do return false end
	end
	do
		local zf = _g.jk.archive.ZipReader:forFile(zipFile)
		if not (zf ~= nil) then
			do return false end
		end
		if not destDir:isDirectory() then
			do destDir:createDirectoryRecursive() end
		end
		if not destDir:isDirectory() then
			do zf:close() end
			do return false end
		end
		do
			local array = zf:getEntries()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local entry = array[n + 1]
						if entry ~= nil then
							local ename = entry:getName()
							if _g.jk.lang.String:isEmpty(ename) then
								goto _continue1
							end
							do
								local dd = destDir
								ename = _g.jk.lang.String:replaceCharacter(ename, 92, 47)
								do
									local array2 = _g.jk.lang.String:split(ename, 47, 0)
									if array2 ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(array2)
										do
											n2 = 0
											while n2 < m2 do
												local comp = array2[n2 + 1]
												if comp ~= nil then
													if comp == "." or comp == ".." then
														goto _continue2
													end
													dd = dd:entry(comp)
												end
												::_continue2::
												do n2 = n2 + 1 end
											end
										end
									end
									if listener ~= nil then
										do listener(dd) end
									end
									if not entry:writeToFile(dd) then
										do zf:close() end
										do return false end
									end
								end
							end
						end
						::_continue1::
						do n = n + 1 end
					end
				end
			end
			do zf:close() end
			do return true end
		end
	end
end

function jk.archive.ZipReader:getEntries()
end

function jk.archive.ZipReader:close()
end

jk.archive.TarGZipWriter = {}
jk.archive.TarGZipWriter.__index = jk.archive.TarGZipWriter
_vm:set_metatable(jk.archive.TarGZipWriter, {})

function jk.archive.TarGZipWriter._create()
	local v = _vm:set_metatable({}, jk.archive.TarGZipWriter)
	return v
end

function jk.archive.TarGZipWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.TarGZipWriter'
	self['_isType.jk.archive.TarGZipWriter'] = true
end

function jk.archive.TarGZipWriter:_construct0()
	jk.archive.TarGZipWriter._init(self)
	return self
end

function jk.archive.TarGZipWriter:instance()
	do return _g.jk.archive.ExternalTarGZipWriter._construct0(_g.jk.archive.ExternalTarGZipWriter._create()) end
end

function jk.archive.TarGZipWriter:writeToTarballRecursive(ctx, dest, source, truncateDirectoryName)
	if not (dest ~= nil) then
		do _g.jk.log.Log:error(ctx, "No destination file specified for tar/gzip writer") end
		do return false end
	end
	if not (source ~= nil) then
		do _g.jk.log.Log:error(ctx, "No source file specified for tar/gzip writer") end
		do return false end
	end
	do
		local writer = _g.jk.archive.TarGZipWriter:instance()
		if not (writer ~= nil) then
			do _g.jk.log.Log:error(ctx, "Failed to create tar/gzip writer") end
			do return false end
		end
		do return writer:tarDir(ctx, source, dest, truncateDirectoryName) end
	end
end

function jk.archive.TarGZipWriter:tarDir(ctx, dir, output, truncateDir)
end

jk.archive.ZipReaderEntry = {}
jk.archive.ZipReaderEntry.__index = jk.archive.ZipReaderEntry
_vm:set_metatable(jk.archive.ZipReaderEntry, {})

function jk.archive.ZipReaderEntry._create()
	local v = _vm:set_metatable({}, jk.archive.ZipReaderEntry)
	return v
end

function jk.archive.ZipReaderEntry:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipReaderEntry'
	self['_isType.jk.archive.ZipReaderEntry'] = true
	self.name = nil
	self.compressedSize = 0
	self.uncompressedSize = 0
	self.isDirectory = false
	self.mode = 0
end

function jk.archive.ZipReaderEntry:_construct0()
	jk.archive.ZipReaderEntry._init(self)
	return self
end

function jk.archive.ZipReaderEntry:getName()
	do return self.name end
end

function jk.archive.ZipReaderEntry:setName(newName)
	self.name = _g.jk.lang.String:replaceCharacter(newName, 92, 47)
	if _g.jk.lang.String:endsWith(self.name, "/") then
		self.isDirectory = true
		self.name = _g.jk.lang.String:getSubString(self.name, 0, _g.jk.lang.String:getLength(self.name) - 1)
	end
	do return self end
end

function jk.archive.ZipReaderEntry:getContentReader()
	do return nil end
end

function jk.archive.ZipReaderEntry:getContentsBuffer()
	if self:getIsDirectory() then
		do return nil end
	end
	do
		local reader = self:getContentReader()
		if not (reader ~= nil) then
			do return nil end
		end
		do
			local v = nil
			local buf = _util:allocate_buffer(4096 * 4)
			while true do
				local n = reader:read(buf)
				if n == 0 then
					do break end
				end
				if n < 0 then
					v = nil
					do break end
				end
				v = _g.jk.lang.Buffer:append(v, buf, n)
			end
			if (_vm:to_table_with_key(reader, '_isType.jk.lang.Closable') ~= nil) then
				do reader:close() end
			end
			do return v end
		end
	end
end

function jk.archive.ZipReaderEntry:getContentsUTF8()
	local v = self:getContentsBuffer()
	if not (v ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.String:forUTF8Buffer(v) end
end

function jk.archive.ZipReaderEntry:writeToFile(file)
	if not (file ~= nil) then
		do return false end
	end
	do
		local v = false
		if self:getIsDirectory() then
			v = file:createDirectoryRecursive()
		else
			local reader = self:getContentReader()
			if not (reader ~= nil) then
				do return false end
			end
			do
				local fp = file:getParent()
				if fp ~= nil then
					do fp:createDirectoryRecursive() end
				end
				do
					local writer = file:write()
					if not (writer ~= nil) then
						if (_vm:to_table_with_key(reader, '_isType.jk.lang.Closable') ~= nil) then
							do reader:close() end
						end
						do return false end
					end
					do
						local buf = _util:allocate_buffer(4096 * 4)
						v = true
						do
							local n = 0
							while (function()
								n = reader:read(buf)
								do return n end
							end)() > 0 do
								local nr = writer:write(buf, n)
								if nr ~= n then
									v = false
									do break end
								end
							end
							if reader ~= nil and (_vm:to_table_with_key(reader, '_isType.jk.lang.Closable') ~= nil) then
								do reader:close() end
							end
							if writer ~= nil and (_vm:to_table_with_key(writer, '_isType.jk.lang.Closable') ~= nil) then
								do writer:close() end
							end
							if not v then
								do file:remove() end
							end
						end
					end
				end
			end
		end
		if v and self.mode > 0 and (_g.jk.os.OS:isLinux() or _g.jk.os.OS:isMacOS()) then
			do file:setMode(self.mode) end
		end
		do return v end
	end
end

function jk.archive.ZipReaderEntry:writeToDir(dir, fullPath, overwrite)
	if not (dir ~= nil) then
		do return nil end
	end
	if not (self.name ~= nil) then
		do return nil end
	end
	do
		local path = nil
		if fullPath == false then
			local nn = nil
			local r = _g.jk.lang.String:getLastIndexOfCharacter(self.name, 47, -1)
			if r < 1 then
				nn = self.name
			else
				nn = _g.jk.lang.String:getEndOfString(self.name, r + 1)
			end
			if nn == nil or _g.jk.lang.String:getLength(nn) < 1 then
				do return nil end
			end
			path = dir:entry(nn)
		else
			path = dir
			do
				local array = _g.jk.lang.String:split(self.name, 47, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local x = array[n + 1]
							if x ~= nil then
								if x ~= nil and _g.jk.lang.String:getLength(x) > 0 then
									path = path:entry(x)
								end
							end
							do n = n + 1 end
						end
					end
				end
				do
					local dd = path:getParent()
					if not dd:isDirectory() then
						do dd:createDirectoryRecursive() end
					end
					if not dd:isDirectory() then
						do return nil end
					end
				end
			end
		end
		if overwrite == false then
			if path:exists() then
				do return nil end
			end
		end
		if not self:writeToFile(path) then
			do return nil end
		end
		do return path end
	end
end

function jk.archive.ZipReaderEntry:getCompressedSize()
	do return self.compressedSize end
end

function jk.archive.ZipReaderEntry:setCompressedSize(v)
	self.compressedSize = v
	do return self end
end

function jk.archive.ZipReaderEntry:getUncompressedSize()
	do return self.uncompressedSize end
end

function jk.archive.ZipReaderEntry:setUncompressedSize(v)
	self.uncompressedSize = v
	do return self end
end

function jk.archive.ZipReaderEntry:getIsDirectory()
	do return self.isDirectory end
end

function jk.archive.ZipReaderEntry:setIsDirectory(v)
	self.isDirectory = v
	do return self end
end

function jk.archive.ZipReaderEntry:getMode()
	do return self.mode end
end

function jk.archive.ZipReaderEntry:setMode(v)
	self.mode = v
	do return self end
end

jk.archive.ZipWriterForSushi = _g.jk.archive.ZipWriter._create()
jk.archive.ZipWriterForSushi.__index = jk.archive.ZipWriterForSushi
_vm:set_metatable(jk.archive.ZipWriterForSushi, {
	__index = _g.jk.archive.ZipWriter
})

function jk.archive.ZipWriterForSushi._create()
	local v = _vm:set_metatable({}, jk.archive.ZipWriterForSushi)
	return v
end

function jk.archive.ZipWriterForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipWriterForSushi'
	self['_isType.jk.archive.ZipWriterForSushi'] = true
	self.zip = nil
end

function jk.archive.ZipWriterForSushi:_construct0()
	jk.archive.ZipWriterForSushi._init(self)
	do _g.jk.archive.ZipWriter._construct0(self) end
	return self
end

function jk.archive.ZipWriterForSushi:forFile(file)
	if not (file ~= nil) then
		do return nil end
	end
	do
		local path = file:getPath()
		if not _g.jk.lang.String:isNotEmpty(path) then
			do return nil end
		end
		do
			local zip = _zip:write_open(path)
			if not (zip ~= nil) then
				do return nil end
			end
			do
				local v = _g.jk.archive.ZipWriterForSushi._construct0(_g.jk.archive.ZipWriterForSushi._create())
				do v:setZip(zip) end
				do return v end
			end
		end
	end
end

function jk.archive.ZipWriterForSushi:addFile(file, filename)
	local zip = self.zip
	if not (zip ~= nil) then
		do return false end
	end
	if not (file ~= nil) then
		do return false end
	end
	if not _g.jk.lang.String:isNotEmpty(filename) then
		do return false end
	end
	do
		local v = false
		local ts = file:getLastModifiedTimeStamp()
		local attribs = 0
		local mode = 0
		local info = file:stat()
		if info ~= nil then
			mode = info:getMode()
		end
		do
			local large = 0
			if info:getSize() > 4294967295 then
				large = 1
			end
			if not _zip:write_start_file(zip, filename, ts, mode, large) then
				do return false end
			end
			if file:isDirectory() then
				v = true
			else
				local rd = file:read()
				if rd ~= nil then
					v = true
					do
						local bb = _util:allocate_buffer(32 * 1024)
						while true do
							local sz = rd:read(bb)
							if sz < 1 then
								do break end
							end
							if not _zip:write_to_file(zip, bb, sz) then
								v = false
								do break end
							end
						end
						do rd:close() end
					end
				end
			end
			do _zip:write_end_file(zip) end
			do return v end
		end
	end
end

function jk.archive.ZipWriterForSushi:close()
	local zz = self.zip
	if zz ~= nil then
		do _zip:write_close(zz) end
		self.zip = nil
	end
end

function jk.archive.ZipWriterForSushi:getZip()
	do return self.zip end
end

function jk.archive.ZipWriterForSushi:setZip(v)
	self.zip = v
	do return self end
end

jk.archive.ArchiveKit = {}
jk.archive.ArchiveKit.__index = jk.archive.ArchiveKit
_vm:set_metatable(jk.archive.ArchiveKit, {})

function jk.archive.ArchiveKit._create()
	local v = _vm:set_metatable({}, jk.archive.ArchiveKit)
	return v
end

function jk.archive.ArchiveKit:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ArchiveKit'
	self['_isType.jk.archive.ArchiveKit'] = true
	self.ctx = nil
end

function jk.archive.ArchiveKit:_construct0()
	jk.archive.ArchiveKit._init(self)
	return self
end

function jk.archive.ArchiveKit:_construct1(ctx)
	jk.archive.ArchiveKit._init(self)
	self.ctx = ctx
	return self
end

function jk.archive.ArchiveKit:compressZip(src, output)
	local srcfile = _g.jk.fs.File:asFile(src)
	if not (srcfile ~= nil) then
		do _g.jk.lang.Error:throw("invalidParameter", _g.jk.lang.String:asString(src)) end
	end
	do
		local outputfile = _g.jk.fs.File:asFile(output)
		if not (outputfile ~= nil) then
			outputfile = srcfile:getSibling(_g.jk.lang.String:safeString(srcfile:getBasename()) .. ".zip")
		end
		do _g.jk.log.Log:status(self.ctx, "Compressing files ..") end
		if not _g.jk.archive.ZipWriter:writeToZipRecursive(self.ctx, outputfile, srcfile, true) then
			do _g.jk.lang.Error:throw("failedToWrite", outputfile:getPath()) end
		end
		do _g.jk.log.Log:status(self.ctx, nil) end
		do return outputfile end
	end
end

function jk.archive.ArchiveKit:compressTarball(src, output)
	local srcfile = _g.jk.fs.File:asFile(src)
	if not (srcfile ~= nil) then
		do _g.jk.lang.Error:throw("invalidParameter", _g.jk.lang.String:asString(src)) end
	end
	do
		local outputfile = _g.jk.fs.File:asFile(output)
		if not (outputfile ~= nil) then
			outputfile = srcfile:getSibling(_g.jk.lang.String:safeString(srcfile:getBasename()) .. ".tar.gz")
		end
		do _g.jk.log.Log:status(self.ctx, "Compressing files ..") end
		if not _g.jk.archive.TarGZipWriter:writeToTarballRecursive(self.ctx, outputfile, srcfile, true) then
			do _g.jk.lang.Error:throw("failedToWrite", outputfile:getPath()) end
		end
		do _g.jk.log.Log:status(self.ctx, nil) end
		do return outputfile end
	end
end

jk.archive.TarReader = {}
jk.archive.TarReader.__index = jk.archive.TarReader
_vm:set_metatable(jk.archive.TarReader, {})

function jk.archive.TarReader._create()
	local v = _vm:set_metatable({}, jk.archive.TarReader)
	return v
end

function jk.archive.TarReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.TarReader'
	self['_isType.jk.archive.TarReader'] = true
end

function jk.archive.TarReader:_construct0()
	jk.archive.TarReader._init(self)
	return self
end

function jk.archive.TarReader:isTarFile(file)
	if not (file ~= nil) then
		do return false end
	end
	do
		local bn = _g.jk.lang.String:toLowerCase(file:getBasename())
		if not (bn ~= nil) then
			do return false end
		end
		if _g.jk.lang.String:endsWith(bn, ".tar") then
			do return true end
		end
		if _g.jk.lang.String:endsWith(bn, ".tar.gz") or _g.jk.lang.String:endsWith(bn, ".tar.bz2") or _g.jk.lang.String:endsWith(bn, ".tar.xz") then
			do return true end
		end
		if _g.jk.lang.String:endsWith(bn, ".tgz") or _g.jk.lang.String:endsWith(bn, ".tbz") or _g.jk.lang.String:endsWith(bn, ".tbz2") or _g.jk.lang.String:endsWith(bn, ".txz") then
			do return true end
		end
		do return false end
	end
end

function jk.archive.TarReader:extractTarFileToDirectory(tarFile, destDir)
	if not (tarFile ~= nil) then
		do return false end
	end
	if not (destDir ~= nil) then
		do return false end
	end
	do
		local pl = _g.jk.process.ProcessLauncher:forCommand("tar", nil)
		if not (pl ~= nil) then
			do return false end
		end
		if not destDir:isDirectory() then
			do destDir:createDirectoryRecursive() end
		end
		if not destDir:isDirectory() then
			do return false end
		end
		do pl:setCwd(destDir) end
		do pl:addToParams("xf") end
		do pl:addToParams(tarFile:getPath()) end
		if not (pl:execute() == 0) then
			do return false end
		end
		do return true end
	end
end

jk.archive.ExternalTarGZipWriter = _g.jk.archive.TarGZipWriter._create()
jk.archive.ExternalTarGZipWriter.__index = jk.archive.ExternalTarGZipWriter
_vm:set_metatable(jk.archive.ExternalTarGZipWriter, {
	__index = _g.jk.archive.TarGZipWriter
})

function jk.archive.ExternalTarGZipWriter._create()
	local v = _vm:set_metatable({}, jk.archive.ExternalTarGZipWriter)
	return v
end

function jk.archive.ExternalTarGZipWriter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ExternalTarGZipWriter'
	self['_isType.jk.archive.ExternalTarGZipWriter'] = true
end

function jk.archive.ExternalTarGZipWriter:_construct0()
	jk.archive.ExternalTarGZipWriter._init(self)
	do _g.jk.archive.TarGZipWriter._construct0(self) end
	return self
end

function jk.archive.ExternalTarGZipWriter:tarDir(ctx, dir, output, truncateDir)
	if not (dir ~= nil) then
		do _g.jk.log.Log:error(ctx, "No directory provided.") end
		do return false end
	end
	if not dir:isDirectory() then
		do _g.jk.log.Log:error(ctx, "Not a directory: `" .. _g.jk.lang.String:safeString(dir:getPath()) .. "'") end
		do return false end
	end
	do
		local bn = dir:baseName()
		if not (_g.jk.lang.String:isEmpty(bn) == false) then
			do _g.jk.log.Log:error(ctx, "Empty basename: `" .. _g.jk.lang.String:safeString(dir:getPath()) .. "'") end
			do return false end
		end
		do
			local pd = dir:getParent()
			if not (pd ~= nil) then
				do _g.jk.log.Log:error(ctx, "Directory has no parent: `" .. _g.jk.lang.String:safeString(dir:getPath()) .. "'") end
				do return false end
			end
			do
				local of = output
				if of == nil then
					of = pd:entry(_g.jk.lang.String:safeString(bn) .. ".tar.gz")
				end
				do
					local pl = _g.jk.process.ProcessLauncher:forCommand("tar", nil)
					if not (pl ~= nil) then
						do _g.jk.log.Log:error(ctx, "Failed to create a process launcher for command: `tar'") end
						do return false end
					end
					do pl:addToParams("zcf") end
					do pl:addToParams(of:getPath()) end
					if truncateDir then
						do pl:setCwd(dir) end
						do pl:addToParams(".") end
					else
						do pl:setCwd(pd) end
						do pl:addToParams(bn) end
					end
					do
						local r = pl:execute()
						if not (r == 0) then
							do _g.jk.log.Log:error(ctx, "Failure in execution of the tar command") end
							do return false end
						end
						do return true end
					end
				end
			end
		end
	end
end

jk.archive.ZipReaderForSushi = _g.jk.archive.ZipReader._create()
jk.archive.ZipReaderForSushi.__index = jk.archive.ZipReaderForSushi
_vm:set_metatable(jk.archive.ZipReaderForSushi, {
	__index = _g.jk.archive.ZipReader
})

function jk.archive.ZipReaderForSushi._create()
	local v = _vm:set_metatable({}, jk.archive.ZipReaderForSushi)
	return v
end

function jk.archive.ZipReaderForSushi:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipReaderForSushi'
	self['_isType.jk.archive.ZipReaderForSushi'] = true
	self.file = nil
	self.handle = nil
	self.readerOpen = false
	self.entryReader = nil
end

jk.archive.ZipReaderForSushi.MyZipFileEntryReader = {}
jk.archive.ZipReaderForSushi.MyZipFileEntryReader.__index = jk.archive.ZipReaderForSushi.MyZipFileEntryReader
_vm:set_metatable(jk.archive.ZipReaderForSushi.MyZipFileEntryReader, {})

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader._create()
	local v = _vm:set_metatable({}, jk.archive.ZipReaderForSushi.MyZipFileEntryReader)
	return v
end

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipReaderForSushi.MyZipFileEntryReader'
	self['_isType.jk.archive.ZipReaderForSushi.MyZipFileEntryReader'] = true
	self['_isType.jk.io.Reader'] = true
	self['_isType.jk.lang.Closable'] = true
	self.parent = nil
end

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader:_construct0()
	jk.archive.ZipReaderForSushi.MyZipFileEntryReader._init(self)
	return self
end

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader:read(buffer)
	if not (self.parent ~= nil) then
		do return -1 end
	end
	do
		local handle = self.parent:getHandle()
		if not (handle ~= nil) then
			do return -1 end
		end
		if not (buffer ~= nil) then
			do return 0 end
		end
		do return _zip:read_get_file_data(handle, buffer) end
	end
end

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader:close()
	if not (self.parent ~= nil) then
		do return end
	end
	do self.parent:closeEntryReader() end
end

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader:getParent()
	do return self.parent end
end

function jk.archive.ZipReaderForSushi.MyZipFileEntryReader:setParent(v)
	self.parent = v
	do return self end
end

jk.archive.ZipReaderForSushi.MyZipReaderEntry = _g.jk.archive.ZipReaderEntry._create()
jk.archive.ZipReaderForSushi.MyZipReaderEntry.__index = jk.archive.ZipReaderForSushi.MyZipReaderEntry
_vm:set_metatable(jk.archive.ZipReaderForSushi.MyZipReaderEntry, {
	__index = _g.jk.archive.ZipReaderEntry
})

function jk.archive.ZipReaderForSushi.MyZipReaderEntry._create()
	local v = _vm:set_metatable({}, jk.archive.ZipReaderForSushi.MyZipReaderEntry)
	return v
end

function jk.archive.ZipReaderForSushi.MyZipReaderEntry:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.archive.ZipReaderForSushi.MyZipReaderEntry'
	self['_isType.jk.archive.ZipReaderForSushi.MyZipReaderEntry'] = true
	self.parent = nil
end

function jk.archive.ZipReaderForSushi.MyZipReaderEntry:_construct0()
	jk.archive.ZipReaderForSushi.MyZipReaderEntry._init(self)
	do _g.jk.archive.ZipReaderEntry._construct0(self) end
	return self
end

function jk.archive.ZipReaderForSushi.MyZipReaderEntry:getContentReader()
	if not (self.parent ~= nil) then
		do return nil end
	end
	do return self.parent:getReaderForFile(self:getName()) end
end

function jk.archive.ZipReaderForSushi.MyZipReaderEntry:getParent()
	do return self.parent end
end

function jk.archive.ZipReaderForSushi.MyZipReaderEntry:setParent(v)
	self.parent = v
	do return self end
end

function jk.archive.ZipReaderForSushi:_construct0()
	jk.archive.ZipReaderForSushi._init(self)
	do _g.jk.archive.ZipReader._construct0(self) end
	self.entryReader = _g.jk.archive.ZipReaderForSushi.MyZipFileEntryReader._construct0(_g.jk.archive.ZipReaderForSushi.MyZipFileEntryReader._create())
	do self.entryReader:setParent(self) end
	return self
end

function jk.archive.ZipReaderForSushi:getHandle()
	do return self.handle end
end

function jk.archive.ZipReaderForSushi:initialize()
	if not (self.file ~= nil) then
		do return nil end
	end
	do
		local path = self.file:getPath()
		if not (path ~= nil) then
			do return nil end
		end
		if self.handle ~= nil then
			do self:close() end
		end
		self.handle = _zip:read_open(path)
		if not (self.handle ~= nil) then
			do return nil end
		end
		do return self end
	end
end

function jk.archive.ZipReaderForSushi:closeEntryReader()
	if self.readerOpen then
		do _zip:read_close_file(handle) end
		self.readerOpen = false
	end
end

function jk.archive.ZipReaderForSushi:getReaderForFile(filename)
	local handle = self.handle
	if not (handle ~= nil) then
		do return nil end
	end
	do
		local name = filename
		if not (name ~= nil) then
			do return nil end
		end
		do self:closeEntryReader() end
		if not (_zip:read_open_file(handle, name) == 1) then
			do return nil end
		end
		do return self.entryReader end
	end
end

function jk.archive.ZipReaderForSushi:getEntries()
	local handle = self.handle
	if not (handle ~= nil) then
		do return nil end
	end
	do
		local v = {}
		if _zip:read_first(handle) == 0 then
			do return nil end
		end
		while true do
			local name = nil
			local compressedSize = 0
			local uncompressedSize = 0
			local mode = 0
			do name, compressedSize, uncompressedSize, mode = _zip:read_entry_info(handle) end
			if not (name ~= nil) then
				do break end
			end
			do
				local entry = _g.jk.archive.ZipReaderForSushi.MyZipReaderEntry._construct0(_g.jk.archive.ZipReaderForSushi.MyZipReaderEntry._create())
				do entry:setParent(self) end
				do entry:setName(name) end
				do entry:setCompressedSize(compressedSize) end
				do entry:setUncompressedSize(uncompressedSize) end
				do entry:setMode(mode) end
				do _g.jk.lang.Vector:append(v, entry) end
				do
					local r = _zip:read_next(handle)
					if r == 0 then
						do return nil end
					end
					if r == 1 then
						goto _continue3
					end
					if r == 2 then
						do break end
					end
				end
			end
			::_continue3::
		end
		do return v end
	end
end

function jk.archive.ZipReaderForSushi:close()
	do self:closeEntryReader() end
	do
		local handle = self.handle
		if handle ~= nil then
			do _zip:read_close(handle) end
			handle = nil
		end
	end
end

function jk.archive.ZipReaderForSushi:getFile()
	do return self.file end
end

function jk.archive.ZipReaderForSushi:setFile(v)
	self.file = v
	do return self end
end
sling = sling or {}

sling.op = sling.op or {}

sling.op.RenamerForReservedWords = {}
sling.op.RenamerForReservedWords.__index = sling.op.RenamerForReservedWords
_vm:set_metatable(sling.op.RenamerForReservedWords, {})

function sling.op.RenamerForReservedWords._create()
	local v = _vm:set_metatable({}, sling.op.RenamerForReservedWords)
	return v
end

function sling.op.RenamerForReservedWords:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.op.RenamerForReservedWords'
	self['_isType.sling.op.RenamerForReservedWords'] = true
end

function sling.op.RenamerForReservedWords:_construct0()
	sling.op.RenamerForReservedWords._init(self)
	return self
end

function sling.op.RenamerForReservedWords:execute(ctx, root, words, issueWarnings)
	local set = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
	if words ~= nil then
		local n = 0
		local m = #words
		do
			n = 0
			while n < m do
				local word = words[n + 1]
				if word ~= nil then
					do set:add(word) end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.common.NamedNode", false, true, false)
		if array ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array)
			do
				n2 = 0
				while n2 < m2 do
					local nn = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NamedNode')
					if nn ~= nil then
						local name = nn:getNodeName()
						if _g.jk.lang.String:isEmpty(name) then
							goto _continue1
						end
						if set:contains(name) then
							if issueWarnings then
								do _g.sling.common.RefLog:warning(ctx, "Renaming node with reserved word: `" .. _g.jk.lang.String:safeString(name) .. "'", nn) end
							end
							do nn:renameNode("_" .. _g.jk.lang.String:safeString(name)) end
						end
					end
					::_continue1::
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

sling.op.OverloadedMethodRenamer = {}
sling.op.OverloadedMethodRenamer.__index = sling.op.OverloadedMethodRenamer
_vm:set_metatable(sling.op.OverloadedMethodRenamer, {})

function sling.op.OverloadedMethodRenamer._create()
	local v = _vm:set_metatable({}, sling.op.OverloadedMethodRenamer)
	return v
end

function sling.op.OverloadedMethodRenamer:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.op.OverloadedMethodRenamer'
	self['_isType.sling.op.OverloadedMethodRenamer'] = true
	self.resolver = nil
	self.ignoreStatic = false
end

function sling.op.OverloadedMethodRenamer:_construct0()
	sling.op.OverloadedMethodRenamer._init(self)
	return self
end

function sling.op.OverloadedMethodRenamer:addToMap(ee, ignore, ht, skipStatic)
	if not (ee ~= nil) then
		do return end
	end
	do
		local array = ee:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local fd = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
					if fd ~= nil then
						if self.ignoreStatic then
							if skipStatic and fd:hasModifier(_g.sling.model.Modifier.STATIC) then
								goto _continue2
							end
						end
						do
							local name = fd:getNodeName()
							if _g.jk.lang.String:isEmpty(name) then
								goto _continue2
							end
							do
								local fdqn = _g.sling.util.NodeUtil:getQualifiedNameString(fd, 46)
								if fdqn ~= nil and ignore:contains(fdqn) then
									goto _continue2
								end
								do
									local cc = _g.jk.lang.Map:get(ht, name)
									if not (cc ~= nil) then
										cc = {}
										ht[name] = cc
									end
									do _g.jk.lang.Vector:append(cc, fd) end
								end
							end
						end
					end
					::_continue2::
					do n = n + 1 end
				end
			end
		end
		do
			local bc = self.resolver:getBaseClass(ee)
			if bc ~= nil then
				do self:addToMap(bc, ignore, ht, true) end
			end
		end
	end
end

function sling.op.OverloadedMethodRenamer:handleEntity(ctx, ee, handled)
	if (_vm:to_table_with_key(ee, '_isType.sling.model.ClassDeclarationNode') ~= nil) == false and (_vm:to_table_with_key(ee, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) == false then
		do return end
	end
	do
		local eename = _g.sling.util.NodeUtil:getQualifiedNameString(ee, 46)
		if not (eename ~= nil) then
			do return end
		end
		if handled:contains(eename) then
			do return end
		end
		do handled:add(eename) end
		do
			local bc = self.resolver:getBaseClass(ee)
			if bc ~= nil then
				do self:handleEntity(ctx, bc, handled) end
			end
			do
				local isHeader = ee:hasModifier(_g.sling.model.Modifier.HEADER)
				local ht = {}
				local ignore = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
				local array = ee:getNodes()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local fd = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
							if fd ~= nil then
								if self.ignoreStatic and fd:hasModifier(_g.sling.model.Modifier.STATIC) then
									goto _continue3
								end
								do
									local bd = fd:getBaseClassDeclaration()
									if bd ~= nil then
										local bdname = _g.sling.util.NodeUtil:getQualifiedNameString(bd, 46)
										if bdname ~= nil then
											do ignore:add(bdname) end
										end
									end
								end
							end
							::_continue3::
							do n = n + 1 end
						end
					end
				end
				do self:addToMap(ee, ignore, ht, false) end
				do
					local keys = _g.jk.lang.Map:getKeys(ht)
					if keys ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(keys)
						do
							n2 = 0
							while n2 < m2 do
								local key = keys[n2 + 1]
								if key ~= nil then
									local cc = _g.jk.lang.Map:get(ht, key)
									if cc == nil then
										goto _continue4
									end
									do
										local counter = 1
										local hasDuplicates = _g.jk.lang.Vector:getSize(cc) > 1
										if cc ~= nil then
											local n3 = 0
											local m3 = _g.jk.lang.Vector:getSize(cc)
											do
												n3 = 0
												while n3 < m3 do
													local fd = cc[n3 + 1]
													if fd ~= nil then
														if fd:getParent() ~= ee then
															goto _continue5
														end
														if self.ignoreStatic == false or not fd:hasModifier(_g.sling.model.Modifier.STATIC) then
															local bdecl = fd:getBaseClassDeclaration()
															if bdecl ~= nil then
																do fd:renameNode(bdecl:getNodeName()) end
																goto _continue5
															end
														end
														if hasDuplicates then
															local impf = self.resolver:findImplementedInterfaceMethod(fd)
															if impf ~= nil then
																goto _continue5
															end
															if not isHeader then
																do _g.sling.common.RefLog:warning(ctx, "Renaming overloaded method. This works, but does not produce a good API in the target language.", fd) end
															end
															while true do
																local nname = _g.jk.lang.String:safeString(fd:getNodeName()) .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger((function() local v = counter counter = counter + 1 return v end)()))
																if _g.jk.lang.Vector:getSize(_g.jk.lang.Map:get(ht, nname)) > 0 then
																	goto _continue6
																end
																do fd:renameNode(nname) end
																do break end
																::_continue6::
															end
														end
													end
													::_continue5::
													do n3 = n3 + 1 end
												end
											end
										end
									end
								end
								::_continue4::
								do n2 = n2 + 1 end
							end
						end
					end
				end
			end
		end
	end
end

function sling.op.OverloadedMethodRenamer:execute(ctx, node)
	local handled = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ee = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if ee ~= nil then
					do self:handleEntity(ctx, ee, handled) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.OverloadedMethodRenamer:getResolver()
	do return self.resolver end
end

function sling.op.OverloadedMethodRenamer:setResolver(v)
	self.resolver = v
	do return self end
end

function sling.op.OverloadedMethodRenamer:getIgnoreStatic()
	do return self.ignoreStatic end
end

function sling.op.OverloadedMethodRenamer:setIgnoreStatic(v)
	self.ignoreStatic = v
	do return self end
end

sling.op.CommonOps = {}
sling.op.CommonOps.__index = sling.op.CommonOps
_vm:set_metatable(sling.op.CommonOps, {})

function sling.op.CommonOps._create()
	local v = _vm:set_metatable({}, sling.op.CommonOps)
	return v
end

function sling.op.CommonOps:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.op.CommonOps'
	self['_isType.sling.op.CommonOps'] = true
end

function sling.op.CommonOps:_construct0()
	sling.op.CommonOps._init(self)
	return self
end

function sling.op.CommonOps:flattenOptionalDataTypes(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.OptionalDataTypeNode", true, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local op = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.OptionalDataTypeNode')
				if op ~= nil then
					do _g.sling.common.RefLog:warning(ctx, "Flattening optional data type", op) end
					do _g.sling.util.NodeUtil:replaceNode(op, op:exportPrimaryType()) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:flattenUnwrappingExpressions(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfTypes(node, {
		"class:sling.model.ForceUnwrapOptionalExpressionNode",
		"class:sling.model.SafeUnwrapOptionalExpressionNode"
	}, true, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local uw = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.UnaryExpressionNode')
				if uw ~= nil then
					do _g.sling.common.RefLog:warning(ctx, "Flattening unwrapping expression", uw) end
					do _g.sling.util.NodeUtil:replaceNode(uw, uw:exportExpression()) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:flattenPromiseExpressions(node)
	local array = _g.sling.util.FindUtil:findNodesOfType(node, "class:sling.model.PromiseExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local px = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.PromiseExpressionNode')
				if px ~= nil then
					do _g.sling.util.NodeUtil:replaceNode(px, px:exportExpression()) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:removeComments(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.CommentNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.CommentNode')
				if nn ~= nil then
					do _g.sling.util.NodeUtil:removeNode(nn) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:removeDestructors(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.DestructorDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.DestructorDeclarationNode')
				if nn ~= nil then
					do _g.sling.common.RefLog:warning(ctx, "Removing destructor", nn) end
					do _g.sling.util.NodeUtil:removeNode(nn) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:renameAmbiguousClassVariables(node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local entt = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if entt ~= nil then
					local array2 = entt:getNodes()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local chld = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
								if chld ~= nil then
									local name = chld:getNodeName()
									local decs = entt:getNodeIndexForName(name)
									if _g.jk.lang.Vector:getSize(decs) > 1 then
										local flag = _g.sling.op.CommonOps:nameClashedWithFunction(decs)
										if decs ~= nil then
											local n3 = 0
											local m3 = _g.jk.lang.Vector:getSize(decs)
											do
												n3 = 0
												while n3 < m3 do
													local vdec = _vm:to_table_with_key(decs[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
													if vdec ~= nil then
														local vnnm = name
														if flag then
															vnnm = "_" .. _g.jk.lang.String:safeString(vnnm)
														end
														vnnm = _g.sling.op.CommonOps:getUniqueName(vnnm, entt)
														do vdec:renameNode(vnnm) end
													end
													do n3 = n3 + 1 end
												end
											end
										end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:nameClashedWithFunction(decs)
	if decs ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(decs)
		do
			n = 0
			while n < m do
				local fdec = _vm:to_table_with_key(decs[n + 1], '_isType.sling.model.FunctionDeclarationNode')
				if fdec ~= nil then
					do return true end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function sling.op.CommonOps:getUniqueName(name, entt)
	local cc = 1
	while true do
		local nn = _g.jk.lang.String:safeString(name) .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(cc))
		if _g.jk.lang.Vector:isEmpty(entt:getNodeIndexForName(nn)) then
			do return nn end
		end
		do cc = cc + 1 end
	end
	do return name end
end

function sling.op.CommonOps:expandConditionalExpressions(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ConditionalExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ConditionalExpressionNode')
				if nn ~= nil then
					local condition = nn:exportCondition()
					local trueExpr = nn:exportTrueExpr()
					local falseExpr = nn:exportFalseExpr()
					local mfcd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
					do mfcd:setReturnType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
					do mfcd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "a", nil)) end
					do mfcd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "b", nil)) end
					do mfcd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "c", nil)) end
					do
						local trs = _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.FunctionCallExpressionNode:forName("b"))
						local cond = _g.sling.model.IfStatementNode:instance(_g.sling.model.SymbolExpressionNode:forName("a"), _g.sling.model.BlockNode:forStatement(trs), nil)
						do _g.sling.util.FunctionUtil:addStatement(mfcd, cond) end
						do _g.sling.util.FunctionUtil:addStatement(mfcd, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.FunctionCallExpressionNode:forName("c"))) end
						do
							local mfc = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(mfcd)
							local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(mfc)
							do fc:addToParameters(condition) end
							do
								local af = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
								do af:setReturnType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
								do _g.sling.util.FunctionUtil:addStatement(af, _g.sling.model.ReturnStatementNode:forExpression(trueExpr)) end
								do fc:addToParameters(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(af)) end
								do
									local bf = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
									do bf:setReturnType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
									do _g.sling.util.FunctionUtil:addStatement(bf, _g.sling.model.ReturnStatementNode:forExpression(falseExpr)) end
									do fc:addToParameters(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(bf)) end
									do _g.sling.util.NodeUtil:replaceNode(nn, fc) end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandAssignmentExpressions(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.AssignmentExpressionBaseNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.AssignmentExpressionBaseNode')
				if nn ~= nil then
					if (_vm:to_table_with_key(nn, '_isType.sling.model.AssignmentExpressionNode') ~= nil) then
						goto _continue7
					end
					do
						local x = nil
						if (_vm:to_table_with_key(nn, '_isType.sling.model.AdditionAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.AdditionExpressionNode._construct0(_g.sling.model.AdditionExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.BitwiseAndAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.BitwiseAndExpressionNode._construct0(_g.sling.model.BitwiseAndExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.BitwiseOrAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.BitwiseOrExpressionNode._construct0(_g.sling.model.BitwiseOrExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.BitwiseXorAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.BitwiseXorExpressionNode._construct0(_g.sling.model.BitwiseXorExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.DivisionAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.DivisionExpressionNode._construct0(_g.sling.model.DivisionExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.ExponentAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.ExponentExpressionNode._construct0(_g.sling.model.ExponentExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.FloorDivisionAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.FloorDivisionExpressionNode._construct0(_g.sling.model.FloorDivisionExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.ModuloAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.ModuloExpressionNode._construct0(_g.sling.model.ModuloExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.MultiplicationAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.MultiplicationExpressionNode._construct0(_g.sling.model.MultiplicationExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.ShiftLeftAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.ShiftLeftExpressionNode._construct0(_g.sling.model.ShiftLeftExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.ShiftRightAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.ShiftRightExpressionNode._construct0(_g.sling.model.ShiftRightExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.StringConcatenationAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.StringConcatenationExpressionNode._construct0(_g.sling.model.StringConcatenationExpressionNode._create())
						elseif (_vm:to_table_with_key(nn, '_isType.sling.model.SubtractionAssignmentExpressionNode') ~= nil) then
							x = _g.sling.model.SubtractionExpressionNode._construct0(_g.sling.model.SubtractionExpressionNode._create())
						else
							do _g.sling.common.RefLog:warning(ctx, "Unsupported assignment expression node: `" .. _g.jk.lang.String:safeString(nn:getNodeTypeName()) .. "'", nn) end
						end
						if x ~= nil then
							do x:setLeft(_g.sling.util.ExpressionUtil:dupAsExpression(nn:getLeft()), false) end
							do x:setRight(nn:exportRight(), false) end
							do
								local nx = _g.sling.model.AssignmentExpressionNode:forNodes(nn:exportLeft(), x)
								if not nn:replaceWith(nx, false) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to replace node", nn, nil))
								end
							end
						end
					end
				end
				::_continue7::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandAssertStatements(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.AssertStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local an = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.AssertStatementNode')
				if an ~= nil then
					local style = an:getStyle()
					if style == _g.sling.model.AssertStatementNode.STYLE_RETURN then
						local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
						local errorBlock = an:getErrorBlock()
						if errorBlock ~= nil then
							local array2 = errorBlock:exportNodes()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local enode = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
										if enode ~= nil then
											do block:addNode(enode) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
						end
						do block:addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.FailureLiteralExpressionNode._construct0(_g.sling.model.FailureLiteralExpressionNode._create()))) end
						do
							local xpr = nil
							local child = an:exportChild()
							if (_vm:to_table_with_key(child, '_isType.sling.common.ExpressionNode') ~= nil) then
								xpr = child
							elseif (_vm:to_table_with_key(child, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
								local vd = child
								local pp = _vm:to_table_with_key(an:getParent(), '_isType.sling.common.ContainerNode')
								if not (pp ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Assert statement is not inside a container", an, nil))
								end
								do pp:insertAboveNode(child, an) end
								xpr = _g.sling.model.SymbolExpressionNode:forName(vd:getName())
							else
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported child type in assert statement", child, nil))
							end
							do
								local ifs = _g.sling.model.IfStatementNode:instance(_g.sling.model.LogicalNotExpressionNode:forExpression(xpr), block, nil)
								do ifs:setSource(an:getSource()) end
								do _g.sling.util.NodeUtil:replaceNode(an, ifs) end
							end
						end
					else
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandFailureLiterals(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.FailureLiteralExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FailureLiteralExpressionNode')
				if nn ~= nil then
					local pp = nn:getParent()
					if (_vm:to_table_with_key(pp, '_isType.sling.model.ReturnStatementNode') ~= nil) and pp:getExpression() == nn then
						local ff = _g.sling.util.FindUtil:findNearestFunction(nn)
						if not (ff ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing function", nn, nil))
						end
						do
							local dt = ff:getReturnType()
							if dt == nil or (_vm:to_table_with_key(dt, '_isType.sling.model.VoidDataTypeNode') ~= nil) then
								do nn:remove() end
							else
								local lit = nil
								if (_vm:to_table_with_key(dt, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
									lit = _g.sling.model.BooleanLiteralExpressionNode:forValue(false)
								elseif (_vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
									lit = _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())
								elseif (_vm:to_table_with_key(dt, '_isType.sling.model.VectorDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.MapDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.SetDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.ObjectDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.StringDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) or (_vm:to_table_with_key(dt, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
									lit = _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())
								elseif (_vm:to_table_with_key(dt, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
									lit = _g.sling.model.CharacterLiteralExpressionNode:forValue(0)
								elseif (_vm:to_table_with_key(dt, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
									lit = _g.sling.model.FloatLiteralExpressionNode:forValue(0.0)
								elseif (_vm:to_table_with_key(dt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
									lit = _g.sling.model.DoubleLiteralExpressionNode:forValue(0.0)
								else
									lit = _g.sling.model.IntegerLiteralExpressionNode:forValue(0)
								end
								do nn:replaceWith(lit, false) end
							end
							goto _continue8
						end
					end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported context for failure literal", nn, nil))
				end
				::_continue8::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandErrorStatements(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ErrorStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local error = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ErrorStatementNode')
				if error ~= nil then
					if error:getParent() == nil then
						goto _continue9
					end
					do
						local ff = _g.sling.util.FindUtil:findNearestFunctionBase(error)
						if not (ff ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find enclosing function", error, nil))
						end
						do
							local ffqn = nil
							if (_vm:to_table_with_key(ff, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
								local ffp = ff:getParent()
								if not (ffp ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Node has no parent", ff, nil))
								end
								ffqn = _g.sling.util.NodeUtil:getQualifiedNameString(ffp, 46)
							else
								ffqn = _g.sling.util.NodeUtil:getQualifiedNameString(ff, 46)
							end
							if _g.jk.lang.String:isEmpty(ffqn) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find qualified name of method / function", ff, nil))
							end
							do
								local tokmsg = nil
								local tok = _vm:to_table_with_key(error:getSource(), '_isType.sling.common.Token')
								if tok ~= nil then
									local toksrc = tok.source
									if toksrc ~= nil then
										local ff = toksrc:getFile()
										if ff ~= nil then
											tokmsg = " (" .. _g.jk.lang.String:safeString(ff:baseName()) .. ":" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(tok.line + 1)) .. ":" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(tok.column + 1)) .. ")"
										end
									end
								end
								do
									local msg = error:getMessage()
									if _g.jk.lang.String:isEmpty(msg) then
										msg = "ERROR"
									end
									if tokmsg == nil then
										tokmsg = ""
									end
									do
										local line = "[" .. _g.jk.lang.String:safeString(ffqn) .. "]" .. _g.jk.lang.String:safeString(tokmsg) .. ": " .. _g.jk.lang.String:safeString(msg)
										local pl = _g.sling.model.PrintLineStatementNode:forExpression(_g.sling.model.StringLiteralExpressionNode:forValue(line))
										if not error:replaceWith(pl, false) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to replace node", error, nil))
										end
									end
								end
							end
						end
					end
				end
				::_continue9::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandThisReferences(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ThisDataTypeNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ThisDataTypeNode')
				if nn ~= nil then
					local ee = _g.sling.util.FindUtil:findNearestEntity(nn)
					if not (ee ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing entity", nn, nil))
					end
					do
						local name = ee:getName()
						if _g.jk.lang.String:isEmpty(name) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Entity has no name", ee, nil))
						end
						do
							local ref = _g.sling.model.ReferenceDataTypeNode:forName(name)
							do ref:setSource(nn:getSource()) end
							do nn:replaceWith(ref, false) end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandForStatements(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ForStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ForStatementNode')
				if nn ~= nil then
					local inits = nn:exportInitializer()
					local condition = nn:exportCondition()
					local finalizer = nn:exportFinalizer()
					local block = nn:exportBlock()
					if not (block ~= nil) then
						block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
					end
					do
						local v = _g.sling.model.WhileStatementNode._construct0(_g.sling.model.WhileStatementNode._create())
						do v:setSource(nn:getSource()) end
						do v:setCondition(condition, false) end
						do v:setBlock(block, false) end
						do
							local mblock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
							do mblock:setSource(nn:getSource()) end
							if inits ~= nil then
								local array2 = inits:getNodes()
								if array2 ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(array2)
									do
										n2 = 0
										while n2 < m2 do
											local init = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
											if init ~= nil then
												do mblock:addNode(init) end
											end
											do n2 = n2 + 1 end
										end
									end
								end
							end
							do mblock:addNode(v) end
							do
								local olast = block:getLastNode()
								if olast ~= nil and ((_vm:to_table_with_key(olast, '_isType.sling.model.ReturnStatementNode') ~= nil) or (_vm:to_table_with_key(olast, '_isType.sling.model.ContinueStatementNode') ~= nil) or (_vm:to_table_with_key(olast, '_isType.sling.model.BreakStatementNode') ~= nil)) then
								else
									local bdup = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(finalizer), '_isType.sling.model.FlatBlockNode')
									if not (bdup ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate node", finalizer, nil))
									end
									do
										local array3 = bdup:exportNodes()
										if array3 ~= nil then
											local n3 = 0
											local m3 = _g.jk.lang.Vector:getSize(array3)
											do
												n3 = 0
												while n3 < m3 do
													local stmt = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.NodeObject')
													if stmt ~= nil then
														do block:addNode(stmt) end
													end
													do n3 = n3 + 1 end
												end
											end
										end
									end
								end
								do
									local array4 = _g.sling.common.NodeFinder:findNodesOfType(block, "class:sling.model.ContinueStatementNode", false, true, false)
									if array4 ~= nil then
										local n4 = 0
										local m4 = _g.jk.lang.Vector:getSize(array4)
										do
											n4 = 0
											while n4 < m4 do
												local cn = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.ContinueStatementNode')
												if cn ~= nil then
													local nb = _g.sling.util.FindUtil:findNearestLoop(cn)
													if nb ~= v then
														goto _continue10
													end
													do
														local cnp = _vm:to_table_with_key(cn:getParent(), '_isType.sling.common.ContainerNode')
														if not (cnp ~= nil) then
															do _g.sling.common.RefLog:warning(ctx, "Continue statement is not inside a container", cn) end
															goto _continue10
														end
														do
															local bdup = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(finalizer), '_isType.sling.model.FlatBlockNode')
															if not (bdup ~= nil) then
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate node", finalizer, nil))
															end
															do
																local array5 = bdup:exportNodes()
																if array5 ~= nil then
																	local n5 = 0
																	local m5 = _g.jk.lang.Vector:getSize(array5)
																	do
																		n5 = 0
																		while n5 < m5 do
																			local stmt = _vm:to_table_with_key(array5[n5 + 1], '_isType.sling.common.NodeObject')
																			if stmt ~= nil then
																				if not cnp:insertAboveNode(stmt, cn) then
																					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insertAboveNode", cn, nil))
																				end
																			end
																			do n5 = n5 + 1 end
																		end
																	end
																end
															end
														end
													end
												end
												::_continue10::
												do n4 = n4 + 1 end
											end
										end
									end
									do nn:replaceWith(mblock, false) end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandDynamicCastExpressions(ctx, node, excludeReferenceTypes)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.DynamicCastExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.DynamicCastExpressionNode')
				if nn ~= nil then
					local type = nn:getType()
					if excludeReferenceTypes and (_vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
						goto _continue11
					end
					do
						local xpr = nn:exportExpression()
						local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
						do fd:setSource(nn:getSource()) end
						do fd:setReturnType(_vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(type), '_isType.sling.common.DataTypeNode'), false) end
						do
							local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), "o", nil)
							do fd:addToParameters(vd) end
							do
								local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
								local condition = _g.sling.model.TypeCheckExpressionNode:instance(_vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(type), '_isType.sling.common.DataTypeNode'), _g.sling.model.SymbolExpressionNode:forBoundName("o", vd, nil), false)
								local value = _g.sling.model.StaticCastExpressionNode:instance(_vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(type), '_isType.sling.common.DataTypeNode'), _g.sling.model.SymbolExpressionNode:forBoundName("o", vd, nil))
								do block:addNode(_g.sling.model.IfStatementNode:forStatement(condition, _g.sling.model.ReturnStatementNode:forExpression(value))) end
								do block:addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()))) end
								do fd:setBody(block, false) end
								do
									local fdx = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)
									do fdx:setSource(nn:getSource()) end
									do
										local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(fdx)
										do fc:setSource(nn:getSource()) end
										do fc:addToParameters(xpr) end
										do fc:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
										do nn:replaceWith(fc, false) end
									end
								end
							end
						end
					end
				end
				::_continue11::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:changeContinueToGoto(ctx, node)
	local counter = 1
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ContinueStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ContinueStatementNode')
				if nn ~= nil then
					local lp = _g.sling.util.FindUtil:findNearestLoop(nn)
					if not (lp ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing loop", nn, nil))
					end
					do
						local block = lp:getBlock()
						if not (block ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No block", _vm:to_table_with_key(lp, '_isType.sling.common.NodeObject'), nil))
						end
						do
							local last = block:getLastNode()
							local labelname = nil
							if last ~= nil and (_vm:to_table_with_key(last, '_isType.sling.model.LabeledStatementNode') ~= nil) then
								labelname = last:getName()
							end
							if _g.jk.lang.String:isEmpty(labelname) then
								labelname = "_continue" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger((function() local v = counter counter = counter + 1 return v end)()))
								do block:addNode(_g.sling.model.LabeledStatementNode:forLabel(labelname)) end
							end
							do
								local _goto = _g.sling.model.GoToLabelStatementNode._construct0(_g.sling.model.GoToLabelStatementNode._create())
								do _goto:setTarget(_g.sling.model.SymbolExpressionNode:forName(labelname), false) end
								do nn:replaceWith(_goto, false) end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:wrapAssignmentsInExpressions(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.AssignmentExpressionNode", true, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.AssignmentExpressionNode')
				if nn ~= nil then
					local pp = nn:getParent()
					if pp ~= nil and (_vm:to_table_with_key(pp, '_isType.sling.model.BlockNode') ~= nil) then
						goto _continue12
					end
					do
						local fc = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
						do _g.sling.util.NodeUtil:replaceAndExport(nn, fc) end
						do
							local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
							do _g.sling.util.FunctionUtil:addStatement(fd, nn) end
							do
								local left = _g.sling.util.ExpressionUtil:dupAsExpression(nn:getLeft())
								local type = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(left, nil)
								do _g.sling.util.FunctionUtil:addStatement(fd, _g.sling.model.ReturnStatementNode:forExpression(left)) end
								if type ~= nil then
									do fd:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
									do fc:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
								end
								do fc:setExpression(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd), false) end
								do fc:setSource(nn:getSource()) end
							end
						end
					end
				end
				::_continue12::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:switchContainsUnsupportedCase(statement, supportedCaseBlocks)
	local cases = statement:getBlocks()
	if _g.jk.lang.Vector:isEmpty(cases) then
		do return false end
	end
	if _g.jk.lang.Array:isEmpty(supportedCaseBlocks) then
		do return true end
	end
	if cases ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(cases)
		do
			n = 0
			while n < m do
				local block = _vm:to_table_with_key(cases[n + 1], '_isType.sling.model.CaseBlockNode')
				if block ~= nil then
					local tinfo = _vm:get_datatype_info(block)
					local isnot = true
					if supportedCaseBlocks ~= nil then
						local n2 = 0
						local m2 = #supportedCaseBlocks
						do
							n2 = 0
							while n2 < m2 do
								local info = supportedCaseBlocks[n2 + 1]
								if info ~= nil then
									if tinfo == info then
										isnot = false
										do break end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					if isnot then
						do return true end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function sling.op.CommonOps:convertSwitchToIf(ctx, node, blocks)
	local supportedCaseBlocks = blocks
	if not (supportedCaseBlocks ~= nil) then
		supportedCaseBlocks = {
			"class:sling.model.CaseEqualsBlockNode",
			"class:sling.model.CaseDefaultBlockNode"
		}
	end
	do
		local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.SwitchStatementNode", false, true, false)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local ss = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SwitchStatementNode')
					if ss ~= nil then
						if not _g.sling.op.CommonOps:switchContainsUnsupportedCase(ss, supportedCaseBlocks) then
							goto _continue13
						end
						do
							local xpr = ss:exportExpression()
							if not (xpr ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No expression in switch statement", ss, nil))
							end
							do
								local varname = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(ss, "v")
								local body = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
								local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), varname, xpr)
								do body:addNode(vd) end
								do
									local prev = nil
									local defaultBlock = nil
									local array2 = ss:getBlocks()
									if array2 ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(array2)
										do
											n2 = 0
											while n2 < m2 do
												local block = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.CaseBlockNode')
												if block ~= nil then
													local ifs = nil
													if (_vm:to_table_with_key(block, '_isType.sling.model.CaseDefaultBlockNode') ~= nil) then
														if defaultBlock ~= nil then
															_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Duplicate default block in switch statement", block, nil))
														end
														defaultBlock = block:exportBlock()
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseEqualsBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local eqx = _g.sling.model.EqualsExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), block:exportExpression())
															do ifs:setCondition(eqx, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseLessThanBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local lsx = _g.sling.model.LessThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), block:exportExpression())
															do ifs:setCondition(lsx, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseLessOrEqualBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local loe = _g.sling.model.LessOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), block:exportExpression())
															do ifs:setCondition(loe, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseNotEqualsBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local lnt = _g.sling.model.NotEqualsExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), block:exportExpression())
															do ifs:setCondition(lnt, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseGreaterThanBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local gtx = _g.sling.model.GreaterThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), block:exportExpression())
															do ifs:setCondition(gtx, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseGreaterOrEqualBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local goe = _g.sling.model.GreaterOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), block:exportExpression())
															do ifs:setCondition(goe, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseRangeBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local range = block
															local cond1 = nil
															local cond2 = nil
															local xtype = range:getExclusionType()
															if xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS then
																cond1 = _g.sling.model.GreaterThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																cond2 = _g.sling.model.LessThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
															elseif xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND then
																cond1 = _g.sling.model.GreaterOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																cond2 = _g.sling.model.LessThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
															elseif xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND then
																cond1 = _g.sling.model.GreaterThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																cond2 = _g.sling.model.LessOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
															else
																cond1 = _g.sling.model.GreaterOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																cond2 = _g.sling.model.LessOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
															end
															do ifs:setCondition(_g.sling.model.LogicalAndExpressionNode:instance(cond1, cond2), false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseMultipleEqualsBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local con = nil
															local array3 = block:exportExpressions()
															if array3 ~= nil then
																local n3 = 0
																local m3 = _g.jk.lang.Vector:getSize(array3)
																do
																	n3 = 0
																	while n3 < m3 do
																		local exp = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.ExpressionNode')
																		if exp ~= nil then
																			local com = nil
																			if (_vm:to_table_with_key(exp, '_isType.sling.model.RangeExpressionNode') ~= nil) then
																				local range = exp
																				local cond1 = nil
																				local cond2 = nil
																				local xtype = range:getExclusionType()
																				if xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS then
																					cond1 = _g.sling.model.GreaterThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																					cond2 = _g.sling.model.LessThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
																				elseif xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND then
																					cond1 = _g.sling.model.GreaterOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																					cond2 = _g.sling.model.LessThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
																				elseif xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND then
																					cond1 = _g.sling.model.GreaterThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																					cond2 = _g.sling.model.LessOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
																				else
																					cond1 = _g.sling.model.GreaterOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportLowerBound())
																					cond2 = _g.sling.model.LessOrEqualExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), range:exportUpperBound())
																				end
																				com = _g.sling.model.LogicalAndExpressionNode:instance(cond1, cond2)
																			else
																				com = _g.sling.model.EqualsExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(varname), exp)
																			end
																			if con ~= nil then
																				con = _g.sling.model.LogicalOrExpressionNode:instance(con, com)
																			else
																				con = com
																			end
																		end
																		do n3 = n3 + 1 end
																	end
																end
															end
															do ifs:setCondition(con, false) end
															do ifs:setIfBlock(block:exportBlock(), false) end
														end
													elseif (_vm:to_table_with_key(block, '_isType.sling.model.CaseTypePatternBlockNode') ~= nil) then
														ifs = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
														do
															local ctp = block
															local type = ctp:exportType()
															local tc = _g.sling.model.TypeCheckExpressionNode:instance(type, _g.sling.model.SymbolExpressionNode:forName(varname), false)
															do ifs:setCondition(tc, false) end
															do
																local cast = _g.sling.model.DynamicCastExpressionNode:instance(type, _g.sling.model.SymbolExpressionNode:forName(varname))
																local eb = block:exportBlock()
																do eb:prependNode(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), ctp:getName(), cast)) end
																do ifs:setIfBlock(eb, false) end
															end
														end
													else
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported case block node", block, nil))
													end
													if prev ~= nil then
														do prev:setElseBlock(_g.sling.model.BlockNode:forStatement(ifs), false) end
													else
														do body:addNode(ifs) end
													end
													if ifs ~= nil then
														prev = ifs
													end
												end
												do n2 = n2 + 1 end
											end
										end
									end
									if defaultBlock ~= nil then
										if prev ~= nil then
											do prev:setElseBlock(defaultBlock, false) end
										else
											do body:addNode(defaultBlock) end
										end
									end
									do _g.sling.util.NodeUtil:replaceNode(ss, body) end
								end
							end
						end
					end
					::_continue13::
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.op.CommonOps:addReturnToMainFunction(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.MainFunctionDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local mainf = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.MainFunctionDeclarationNode')
				if mainf ~= nil then
					local body = mainf:getBody()
					if body ~= nil then
						local found = false
						local array2 = body:getNodes()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local rr = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.ReturnStatementNode')
									if rr ~= nil then
										found = true
										do break end
									end
									do n2 = n2 + 1 end
								end
							end
						end
						if not found then
							do body:addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.IntegerLiteralExpressionNode:forValue(0))) end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:expandStubFunctions(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.FunctionDeclarationBaseNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationBaseNode')
				if node ~= nil then
					if not node:hasModifier(_g.sling.model.Modifier.STUB) then
						goto _continue14
					end
					if _vm:to_table_with_key(node:getParent(), '_isType.sling.model.InterfaceDeclarationNode') ~= nil and node:hasModifier(_g.sling.model.Modifier.STATIC) == false then
						goto _continue14
					end
					if node:hasModifier(_g.sling.model.Modifier.ABSTRACT) then
						goto _continue14
					end
					if node:getBody() ~= nil then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Stub function already has a body. Either remove the modifier or the body.", node, nil))
					end
					do
						local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
						local eename = nil
						local ffname = nil
						local ee = _g.sling.util.FindUtil:findNearestEntity(node)
						if ee ~= nil then
							eename = _g.sling.util.NodeUtil:getQualifiedNameString(ee, 46)
							if _g.jk.lang.String:isEmpty(eename) then
								eename = "UNNAMED_ENTITY"
							end
						else
							eename = "NO_ENTITY"
						end
						if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
							ffname = node:getName()
						elseif (_vm:to_table_with_key(node, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
							ffname = "(constructor)"
						elseif (_vm:to_table_with_key(node, '_isType.sling.model.DestructorDeclarationNode') ~= nil) then
							ffname = "(destructor)"
						end
						if _g.jk.lang.String:isEmpty(ffname) then
							ffname = "UNKNOWN_FUNCTION"
						end
						do
							local lit = _g.sling.model.StringLiteralExpressionNode:forValue("--- stub --- " .. _g.jk.lang.String:safeString(eename) .. " :: " .. _g.jk.lang.String:safeString(ffname))
							do block:addNode(_g.sling.model.PrintLineStatementNode:forExpression(lit)) end
							do
								local rf = nil
								if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
									rf = _g.sling.util.DataTypeUtil:createDefaultValue(node:getReturnType())
								end
								if rf ~= nil then
									do block:addNode(_g.sling.model.ReturnStatementNode:forExpression(rf)) end
								end
								do node:setBody(block, false) end
								do node:removeModifier(_g.sling.model.Modifier.STUB) end
							end
						end
					end
				end
				::_continue14::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:fixInheritanceTypes(ctx, tr, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.BaseTypeNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
				if node ~= nil then
					if node:getInheritType() == _g.sling.model.BaseTypeNode.INHERIT_AUTO then
						do node:setInheritType(tr:getRealInheritType(node)) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:setDefaultValuesInVariableDeclarations(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.VariableDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
				if node ~= nil then
					if node:getInitializer() ~= nil then
						goto _continue15
					end
					do
						local pp = node:getParent()
						if (_vm:to_table_with_key(pp, '_isType.sling.model.EntityDeclarationNode') ~= nil) == false and (_vm:to_table_with_key(pp, '_isType.sling.model.BlockNode') ~= nil) == false then
							goto _continue15
						end
						do node:setInitializer(_g.sling.util.DataTypeUtil:createDefaultValue(node:getType()), false) end
					end
				end
				::_continue15::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:createDefaultConstructors(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.ClassDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
				if node ~= nil then
					if (_vm:to_table_with_key(node, '_isType.sling.model.TemplateDeclarationNode') ~= nil) then
						goto _continue16
					end
					do
						local found = false
						local array2 = node:getNodes()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local nd = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
									if nd ~= nil then
										if (_vm:to_table_with_key(nd, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) == false then
											goto _continue17
										end
										do
											local params = nd:getParameters()
											if _g.jk.lang.Vector:isEmpty(params) then
												found = true
												do break end
											end
										end
									end
									::_continue17::
									do n2 = n2 + 1 end
								end
							end
						end
						if found == false then
							local nc = _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create())
							do nc:addModifier(_g.sling.model.Modifier.PUBLIC) end
							do nc:setBody(_g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()), false) end
							do node:prependNode(nc) end
						end
					end
				end
				::_continue16::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:handleMainFunctionsForAllScripts(ctx, root, generateMainCall, argSymbolName)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.common.CodeFileNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local script = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.CodeFileNode')
				if script ~= nil then
					local lastMainFunction = nil
					local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(script, "class:sling.model.MainFunctionDeclarationNode", false, true, false)
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local mainf = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.MainFunctionDeclarationNode')
								if mainf ~= nil then
									if lastMainFunction ~= nil then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Duplicate main function declaration inside a script", mainf, nil))
									end
									do
										local name = mainf:getArgumentArrayName()
										if _g.jk.lang.String:isEmpty(name) then
											name = "args"
										end
										do
											local fd = _g.sling.model.FunctionDeclarationNode:forName("_main", false)
											do fd:addModifier(_g.sling.model.Modifier.PUBLIC) end
											do fd:addModifier(_g.sling.model.Modifier.STATIC) end
											do
												local adt = _g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), nil)
												do fd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(adt, name, nil)) end
												do fd:setReturnType(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), false) end
												do fd:setBody(mainf:exportBody(), false) end
												do _g.sling.util.NodeUtil:replaceNode(mainf, fd) end
												lastMainFunction = fd
											end
										end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					if lastMainFunction ~= nil then
						local qs = _g.sling.util.NodeUtil:getQualifiedNameString(lastMainFunction, 46)
						if not (qs == "_main") then
							local fd = _g.sling.model.FunctionDeclarationNode:forName("_main", false)
							do fd:addModifier(_g.sling.model.Modifier.PUBLIC) end
							do fd:addModifier(_g.sling.model.Modifier.STATIC) end
							do
								local adt = _g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), nil)
								do fd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(adt, "args", nil)) end
								do fd:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(lastMainFunction:getReturnType()), false) end
								do
									local xpr = _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forBinding(lastMainFunction, nil))
									do xpr:addToParameters(_g.sling.model.SymbolExpressionNode:forName("args")) end
									do _g.sling.util.FunctionUtil:addStatement(fd, _g.sling.model.ReturnStatementNode:forExpression(xpr)) end
									do script:addNode(fd) end
									lastMainFunction = fd
								end
							end
						end
					end
					if generateMainCall and lastMainFunction ~= nil then
						local ms = _g.sling.model.SymbolExpressionNode:forBinding(lastMainFunction, nil)
						local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(ms)
						if argSymbolName ~= nil then
							do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName(argSymbolName)) end
						end
						do script:addNode(fc) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:determineAccessType(node)
	local left = node:getParentExpression()
	if not (left ~= nil) then
		do return _g.sling.model.MemberAccessExpressionNode.TYPE_AUTO end
	end
	do
		local v = _g.sling.model.MemberAccessExpressionNode.TYPE_INSTANCE
		if (_vm:to_table_with_key(left, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
			local bound = _g.sling.util.SymbolUtil:tryGetSymbolBindingForExpression(left)
			if bound ~= nil and ((_vm:to_table_with_key(bound, '_isType.sling.model.EntityDeclarationNode') ~= nil) or (_vm:to_table_with_key(bound, '_isType.sling.model.NamespaceNode') ~= nil)) then
				v = _g.sling.model.MemberAccessExpressionNode.TYPE_STATIC
			end
		end
		do
			local right = _vm:to_table_with_key(node:getChildExpression(), '_isType.sling.model.SymbolExpressionNode')
			if right ~= nil then
				local bound = _g.sling.util.SymbolUtil:tryGetSymbolBindingForExpression(right)
				if bound ~= nil then
					if (_vm:to_table_with_key(bound, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
						if v == _g.sling.model.MemberAccessExpressionNode.TYPE_STATIC then
							do return _g.sling.model.MemberAccessExpressionNode.TYPE_STATIC_VARIABLE end
						else
							do return _g.sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_VARIABLE end
						end
					elseif (_vm:to_table_with_key(bound, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
						if v == _g.sling.model.MemberAccessExpressionNode.TYPE_STATIC then
							do return _g.sling.model.MemberAccessExpressionNode.TYPE_STATIC_FUNCTION end
						else
							do return _g.sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_FUNCTION end
						end
					end
				end
			end
			do return v end
		end
	end
end

function sling.op.CommonOps:determineAndSetAccessType(node)
	do node:setAccessType(_g.sling.op.CommonOps:determineAccessType(node)) end
end

function sling.op.CommonOps:setMemberAccessExpressionTypes(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.MemberAccessExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local max = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.MemberAccessExpressionNode')
				if max ~= nil then
					if max:getAccessType() == _g.sling.model.MemberAccessExpressionNode.TYPE_AUTO then
						do _g.sling.op.CommonOps:determineAndSetAccessType(max) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:forceUnresolveSymbols(root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.SymbolNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local symbol = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolNode')
				if symbol ~= nil then
					if _g.jk.lang.Vector:isNotEmpty(symbol:getComponents()) then
						do symbol:setBinding(nil, nil) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.FunctionDeclarationNode", false, true, false)
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local ff = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.FunctionDeclarationNode')
					if ff ~= nil then
						do ff:setBaseClassDeclaration(nil, nil) end
						do ff:setOverridingDeclarations(nil) end
						do ff:setImplementedDeclarations(nil) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do
			local array3 = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.common.ExpressionNode", false, true, false)
			if array3 ~= nil then
				local n3 = 0
				local m3 = _g.jk.lang.Vector:getSize(array3)
				do
					n3 = 0
					while n3 < m3 do
						local xpr = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.ExpressionNode')
						if xpr ~= nil then
							do xpr:setResolvedDataType(nil, false) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
		end
	end
end

function sling.op.CommonOps:isLastSymbolInMemberAccessExpressionWithOnlySymbols(xpr)
	if not (xpr ~= nil) then
		do return false end
	end
	do
		local pp = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return false end
		end
		do
			local last = pp:getLastNode()
			if not (last ~= nil) then
				do return false end
			end
			if not (last == xpr) then
				do return false end
			end
			do
				local cc = last
				while cc ~= nil do
					if (_vm:to_table_with_key(not (cc ~= nil), '_isType.sling.model.SymbolExpressionNode') ~= nil) then
						do return false end
					end
					cc = _g.sling.model.MemberAccessExpressionNode:getPreviousNode(cc)
				end
				do return true end
			end
		end
	end
end

function sling.op.CommonOps:unresolveSymbols(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.SymbolNode", true, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local symbol = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolNode')
				if symbol ~= nil then
					if not (symbol:getParent() ~= nil) then
						goto _continue18
					end
					do
						local binding = symbol:getBinding()
						if not (binding ~= nil) then
							goto _continue18
						end
						if (_vm:to_table_with_key(binding, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) then
							goto _continue18
						end
						do
							local sxpr = _vm:to_table_with_key(symbol:getParent(), '_isType.sling.model.SymbolExpressionNode')
							if sxpr ~= nil and ((_vm:to_table_with_key(binding, '_isType.sling.model.EntityDeclarationNode') ~= nil) or binding:hasModifier(_g.sling.model.Modifier.STATIC)) and _g.sling.op.CommonOps:isLastSymbolInMemberAccessExpressionWithOnlySymbols(sxpr) then
								local comps = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
								if _g.jk.lang.Vector:isEmpty(comps) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty symbol components when unresolving (4)", symbol, nil))
								end
								do symbol:setBinding(nil, nil) end
								do symbol:clearComponents() end
								if comps ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(comps)
									do
										n2 = 0
										while n2 < m2 do
											local comp = _vm:to_table_with_key(comps[n2 + 1], '_isType.sling.model.SymbolNameComponentNode')
											if comp ~= nil then
												do symbol:addToComponents(comp) end
											end
											do n2 = n2 + 1 end
										end
									end
								end
								do symbol:addModifier(_g.sling.model.Modifier.GLOBAL) end
								do
									local root = _g.sling.model.MemberAccessExpressionNode:findFromChild(sxpr)
									if not (root ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find root member access expression", sxpr, nil))
									end
									do _g.sling.util.NodeUtil:exportNode(sxpr) end
									do _g.sling.util.NodeUtil:replaceNode(root, sxpr) end
								end
							elseif sxpr ~= nil and _g.sling.model.MemberAccessExpressionNode:isChild(sxpr) then
								local name = _g.sling.util.SymbolUtil:getSymbolName(symbol)
								if _g.jk.lang.String:isEmpty(name) then
									local re = _g.sling.common.ReferenceError:forMessage("Empty name when unresolving (1)", symbol, nil)
									local binding = symbol:getBinding()
									if binding ~= nil then
										do re:addRelatedMessage("Symbol is bound to this", binding) end
									end
									_vm:throw_error(re)
								end
								do symbol:setBinding(nil, nil) end
								do symbol:clearComponents() end
								do symbol:addToComponents(_g.sling.model.SymbolNameComponentNode:forName(name)) end
							elseif (_vm:to_table_with_key(binding, '_isType.sling.model.EntityDeclarationNode') ~= nil) == false and binding:hasModifier(_g.sling.model.Modifier.STATIC) == false then
								local name = _g.sling.util.SymbolUtil:getSymbolName(symbol)
								if _g.jk.lang.String:isEmpty(name) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty name when unresolving (3)", symbol, nil))
								end
								do symbol:setBinding(nil, nil) end
								do symbol:clearComponents() end
								do symbol:addToComponents(_g.sling.model.SymbolNameComponentNode:forName(name)) end
							else
								local comps = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
								if _g.jk.lang.Vector:isEmpty(comps) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty symbol components when unresolving (4)", symbol, nil))
								end
								do symbol:setBinding(nil, nil) end
								do symbol:clearComponents() end
								if comps ~= nil then
									local n3 = 0
									local m3 = _g.jk.lang.Vector:getSize(comps)
									do
										n3 = 0
										while n3 < m3 do
											local comp = _vm:to_table_with_key(comps[n3 + 1], '_isType.sling.model.SymbolNameComponentNode')
											if comp ~= nil then
												do symbol:addToComponents(comp) end
											end
											do n3 = n3 + 1 end
										end
									end
								end
								do symbol:addModifier(_g.sling.model.Modifier.GLOBAL) end
							end
						end
					end
				end
				::_continue18::
				do n = n + 1 end
			end
		end
	end
	do
		local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.FunctionDeclarationNode", false, true, false)
		if array2 ~= nil then
			local n4 = 0
			local m4 = _g.jk.lang.Vector:getSize(array2)
			do
				n4 = 0
				while n4 < m4 do
					local ff = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.model.FunctionDeclarationNode')
					if ff ~= nil then
						do ff:setBaseClassDeclaration(nil, nil) end
						do ff:setOverridingDeclarations(nil) end
						do ff:setImplementedDeclarations(nil) end
					end
					do n4 = n4 + 1 end
				end
			end
		end
		do
			local array3 = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.common.ExpressionNode", false, true, false)
			if array3 ~= nil then
				local n5 = 0
				local m5 = _g.jk.lang.Vector:getSize(array3)
				do
					n5 = 0
					while n5 < m5 do
						local xpr = _vm:to_table_with_key(array3[n5 + 1], '_isType.sling.common.ExpressionNode')
						if xpr ~= nil then
							do xpr:setResolvedDataType(nil, false) end
						end
						do n5 = n5 + 1 end
					end
				end
			end
		end
	end
end

function sling.op.CommonOps:isSelfEntity(symentity, binentity, tr)
	if symentity == binentity then
		do return true end
	end
	if tr:isBaseTypeOf(symentity, binentity) then
		do return true end
	end
	do return false end
end

function sling.op.CommonOps:addExplicitCurrentObjectExpressions(ctx, tr, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.SymbolExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local sex = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolExpressionNode')
				if sex ~= nil then
					local pax = _vm:to_table_with_key(sex:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
					if pax ~= nil then
						if pax:getParentExpression() == sex and (_vm:to_table_with_key(pax:getParent(), '_isType.sling.model.MemberAccessExpressionNode') ~= nil) == false then
						else
							goto _continue19
						end
					end
					do
						local symbol = sex:getSymbol()
						if not (symbol ~= nil) then
							goto _continue19
						end
						do
							local binding = symbol:getBinding()
							if not (binding ~= nil) then
								goto _continue19
							end
							if binding:hasModifier(_g.sling.model.Modifier.STATIC) then
								goto _continue19
							end
							do
								local symentity = _g.sling.util.FindUtil:findNearestEntity(symbol)
								if not (symentity ~= nil) then
									goto _continue19
								end
								do
									local binentity = binding:getParent()
									if not _g.sling.op.CommonOps:isSelfEntity(symentity, binentity, tr) then
										goto _continue19
									end
									do
										local max = _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create())
										do _g.sling.util.NodeUtil:replaceAndExport(sex, max) end
										do max:setParentExpression(_g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create()), false) end
										do max:setChildExpression(sex, false) end
										do max:setSource(sex:getSource()) end
										do
											local xx = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(sex, nil)
											if xx ~= nil then
												do max:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(xx), false) end
											else
												do tr:execute(max) end
											end
										end
									end
								end
							end
						end
					end
				end
				::_continue19::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:addBaseCallsToConstructors(ctx, resolver, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.ConstructorDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ct = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ConstructorDeclarationNode')
				if ct ~= nil then
					do _g.sling.util.FunctionUtil:addBaseClassCallParameters(resolver, ct, false, false) end
				end
				do n = n + 1 end
			end
		end
	end
end

sling.op.CommonOps.ProcessedTracker = {}
sling.op.CommonOps.ProcessedTracker.__index = sling.op.CommonOps.ProcessedTracker
_vm:set_metatable(sling.op.CommonOps.ProcessedTracker, {})

function sling.op.CommonOps.ProcessedTracker._create()
	local v = _vm:set_metatable({}, sling.op.CommonOps.ProcessedTracker)
	return v
end

function sling.op.CommonOps.ProcessedTracker:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.op.CommonOps.ProcessedTracker'
	self['_isType.sling.op.CommonOps.ProcessedTracker'] = true
	self.data = nil
end

function sling.op.CommonOps.ProcessedTracker:_construct0()
	sling.op.CommonOps.ProcessedTracker._init(self)
	return self
end

function sling.op.CommonOps.ProcessedTracker:add(name)
	if not (self.data ~= nil) then
		self.data = {}
	end
	do _g.jk.lang.Map:setValue(self.data, name, {}) end
end

function sling.op.CommonOps.ProcessedTracker:addFunctionCalls(name, call)
	if not (self.data ~= nil) then
		self.data = {}
	end
	do
		local fcxs = _g.jk.lang.Map:getValue(self.data, name)
		if not (fcxs ~= nil) then
			fcxs = {}
			do _g.jk.lang.Map:setValue(self.data, name, fcxs) end
		end
		do _g.jk.lang.Vector:append(fcxs, call) end
	end
end

function sling.op.CommonOps.ProcessedTracker:contains(name)
	do return _g.jk.lang.Map:containsKey(self.data, name) end
end

function sling.op.CommonOps.ProcessedTracker:getFunctionCalls(name)
	do return _g.jk.lang.Map:getValue(self.data, name) end
end

function sling.op.CommonOps:addAwaitAndAsyncModifiers(node)
	local processed = _g.sling.op.CommonOps.ProcessedTracker._construct0(_g.sling.op.CommonOps.ProcessedTracker._create())
	local array = _g.sling.util.FindUtil:findNodesOfType(node, "class:sling.model.FunctionDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local fdec = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
				if fdec ~= nil then
					do _g.sling.op.CommonOps:doAddAwaitAndAsyncModifiers(fdec, processed, nil) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:doAddAwaitAndAsyncModifiers(fdec, processed, fcex)
	local name = _g.sling.util.NodeUtil:getQualifiedNameString(fdec, 46)
	if processed:contains(name) then
		if fcex ~= nil then
			do processed:addFunctionCalls(name, fcex) end
		end
		do return fdec:hasModifier(_g.sling.model.Modifier.ASYNCHRONOUS) end
	end
	do processed:add(name) end
	do
		local array = _g.sling.util.FindUtil:findNodesOfType(fdec:getBody(), "class:sling.model.FunctionCallExpressionNode", false, true, false)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local call = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionCallExpressionNode')
					if call ~= nil then
						local ndec = _g.sling.util.FindUtil:findNearestFunction(call)
						if not (ndec ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No containing function declaration found", call, nil))
						end
						if (_vm:to_table_with_key(call:getParent(), '_isType.sling.model.PromiseExpressionNode') ~= nil) then
							goto _continue20
						end
						if (_vm:to_table_with_key(call:getParent(), '_isType.sling.model.AwaitExpressionNode') ~= nil) then
							if not ndec:hasModifier(_g.sling.model.Modifier.ASYNCHRONOUS) then
								do ndec:addModifier(_g.sling.model.Modifier.ASYNCHRONOUS) end
							end
							goto _continue20
						end
						do
							local odec = _g.sling.util.FunctionUtil:getResolvedDeclaration(call)
							if not (odec ~= nil) then
								goto _continue20
							end
							if _g.sling.op.CommonOps:doAddAwaitAndAsyncModifiers(odec, processed, call) then
								if not ndec:hasModifier(_g.sling.model.Modifier.ASYNCHRONOUS) then
									do ndec:addModifier(_g.sling.model.Modifier.ASYNCHRONOUS) end
								end
								do _g.sling.op.CommonOps:replaceCallWithAwait(call) end
							end
						end
					end
					::_continue20::
					do n = n + 1 end
				end
			end
		end
		do
			local v = fdec:hasModifier(_g.sling.model.Modifier.ASYNCHRONOUS)
			if v then
				local array2 = processed:getFunctionCalls(name)
				if array2 ~= nil then
					local n2 = 0
					local m2 = _g.jk.lang.Vector:getSize(array2)
					do
						n2 = 0
						while n2 < m2 do
							local call = array2[n2 + 1]
							if call ~= nil then
								if (_vm:to_table_with_key(call:getParent(), '_isType.sling.model.AwaitExpressionNode') ~= nil) then
									goto _continue21
								end
								do _g.sling.op.CommonOps:replaceCallWithAwait(call) end
							end
							::_continue21::
							do n2 = n2 + 1 end
						end
					end
				end
			end
			do return v end
		end
	end
end

function sling.op.CommonOps:replaceCallWithAwait(call)
	local awen = _g.sling.model.AwaitExpressionNode._construct0(_g.sling.model.AwaitExpressionNode._create())
	do _g.sling.util.NodeUtil:replaceAndExport(call, awen) end
	do awen:setExpression(call, false) end
	do call:setResolvedDataType(nil, false) end
end

function sling.op.CommonOps:isEmptyNamespace(node)
	local nsn = _vm:to_table_with_key(node, '_isType.sling.model.NamespaceNode')
	if not (nsn ~= nil) then
		do return false end
	end
	do
		local array = nsn:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if child ~= nil then
						if not _g.sling.op.CommonOps:isEmptyNamespace(child) then
							do return false end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return true end
	end
end

function sling.op.CommonOps:removeEmptyNamespaces(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.NamespaceNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ns = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.NamespaceNode')
				if ns ~= nil then
					if _g.sling.op.CommonOps:isEmptyNamespace(ns) then
						do _g.sling.util.NodeUtil:removeNode(ns) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:convertToOneBasedIndexing(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.SubscriptExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SubscriptExpressionNode')
				if node ~= nil then
					local xpr = node:getChild()
					if not (xpr ~= nil) then
						goto _continue22
					end
					do
						local xprdt = _g.sling.util.ExpressionUtil:getExpressionDataType(xpr, nil)
						if (_vm:to_table_with_key(xprdt, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) or (_vm:to_table_with_key(xprdt, '_isType.sling.model.VectorDataTypeNode') ~= nil) or (_vm:to_table_with_key(xprdt, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
							local array2 = node:exportSubscripts()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local ss = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.ExpressionNode')
										if ss ~= nil then
											do node:addToSubscripts(_g.sling.model.AdditionExpressionNode:instance(ss, _g.sling.model.IntegerLiteralExpressionNode:forValue(1))) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
						end
					end
				end
				::_continue22::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:cleanReturnStatementsInFunctions(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.FunctionDeclarationBaseNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local _function = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationBaseNode')
				if _function ~= nil then
					local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(_function, "class:sling.model.BlockNode", false, true, false)
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local block = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.BlockNode')
								if block ~= nil then
									local toremove = nil
									local array3 = block:getNodes()
									if array3 ~= nil then
										local n3 = 0
										local m3 = _g.jk.lang.Vector:getSize(array3)
										do
											n3 = 0
											while n3 < m3 do
												local node = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.NodeObject')
												if node ~= nil then
													if toremove == nil and (_vm:to_table_with_key(node, '_isType.sling.model.ReturnStatementNode') ~= nil) then
														toremove = {}
														goto _continue23
													end
													if (_vm:to_table_with_key(node, '_isType.sling.model.LabeledStatementNode') ~= nil) then
														goto _continue23
													end
													if toremove ~= nil then
														do _g.jk.lang.Vector:append(toremove, node) end
													end
												end
												::_continue23::
												do n3 = n3 + 1 end
											end
										end
									end
									if toremove ~= nil then
										local n4 = 0
										local m4 = _g.jk.lang.Vector:getSize(toremove)
										do
											n4 = 0
											while n4 < m4 do
												local rem = toremove[n4 + 1]
												if rem ~= nil then
													do _g.sling.util.NodeUtil:removeNode(rem) end
												end
												do n4 = n4 + 1 end
											end
										end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:sortEntitiesByDependencies(ctx, resolver, root)
	do _g.sling.op.EntitySorter._construct0(_g.sling.op.EntitySorter._create()):setResolver(resolver):execute(ctx, root) end
end

function sling.op.CommonOps:renameOverloadedMethods(ctx, resolver, root, ignoreStatic)
	do _g.sling.op.OverloadedMethodRenamer._construct0(_g.sling.op.OverloadedMethodRenamer._create()):setResolver(resolver):setIgnoreStatic(ignoreStatic):execute(ctx, root) end
end

function sling.op.CommonOps:addDefaultParameterValuesToFunctionCalls(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.FunctionCallExpressionNode", false, true, false)
	if array ~= nil then
		local n2 = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n2 = 0
			while n2 < m do
				local fc = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.FunctionCallExpressionNode')
				if fc ~= nil then
					local decl = _g.sling.util.FunctionUtil:getResolvedDeclaration(fc)
					if not (decl ~= nil) then
						goto _continue24
					end
					do
						local dparams = decl:getParameters()
						local cparams = fc:getParameters()
						local dpsz = _g.jk.lang.Vector:getSize(dparams)
						local cpsz = _g.jk.lang.Vector:getSize(cparams)
						if cpsz >= dpsz then
							goto _continue24
						end
						do
							local n = cpsz
							while n < dpsz do
								local pdecl = _vm:to_table_with_key(_g.jk.lang.Vector:get(dparams, n), '_isType.sling.model.VariableDeclarationNode')
								if not (pdecl ~= nil) then
									do break end
								end
								do
									local init = pdecl:getInitializer()
									if not (init ~= nil) then
										do break end
									end
									do
										local addxpr = _g.sling.util.ExpressionUtil:dupAsExpression(init)
										do fc:addToParameters(addxpr) end
									end
								end
								do n = n + 1 end
							end
						end
					end
				end
				::_continue24::
				do n2 = n2 + 1 end
			end
		end
	end
end

function sling.op.CommonOps:wrapFunctionReferencesToFunctionDeclarationExpressions(ctx, root, tr)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.SymbolExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local sxpr = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SymbolExpressionNode')
				if sxpr ~= nil then
					if tr ~= nil then
						do tr:resolveExpression(sxpr) end
					end
					do
						local binding = _vm:to_table_with_key(_g.sling.util.SymbolUtil:tryGetSymbolBindingForExpression(sxpr), '_isType.sling.model.FunctionDeclarationNode')
						if not (binding ~= nil) then
							goto _continue25
						end
						do
							local xpr = _vm:to_table_with_key(sxpr, '_isType.sling.common.ExpressionNode')
							while (_vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.MemberAccessExpressionNode') ~= nil) do
								xpr = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.common.ExpressionNode')
							end
							do
								local pfcx = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.FunctionCallExpressionNode')
								if pfcx ~= nil and pfcx:getExpression() == xpr then
									goto _continue25
								end
								do
									local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
									do fd:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(binding:getReturnType()), false) end
									do
										local pc = 0
										local array2 = binding:getParameters()
										if array2 ~= nil then
											local n2 = 0
											local m2 = _g.jk.lang.Vector:getSize(array2)
											do
												n2 = 0
												while n2 < m2 do
													local param = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
													if param ~= nil then
														local pvd = _vm:to_table_with_key(param, '_isType.sling.model.VariableDeclarationNode')
														if not (pvd ~= nil) then
															_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Referenced function parameter is not a variable. Don't know what to do with it.", param, nil))
														end
														do
															local nvd = _g.sling.util.NodeUtil:dupAsVariableDeclaration(pvd)
															do nvd:setName("_p" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(pc))) end
															do pc = pc + 1 end
															do fd:addToParameters(nvd) end
														end
													end
													do n2 = n2 + 1 end
												end
											end
										end
										do
											local body = fd:getCreateBody()
											local xpr2 = _g.sling.util.ExpressionUtil:dupAsExpression(xpr)
											local fcx = _g.sling.model.FunctionCallExpressionNode:forExpression(xpr2)
											local array3 = fd:getParameters()
											if array3 ~= nil then
												local n3 = 0
												local m3 = _g.jk.lang.Vector:getSize(array3)
												do
													n3 = 0
													while n3 < m3 do
														local param = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
														if param ~= nil then
															do fcx:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(param, nil)) end
														end
														do n3 = n3 + 1 end
													end
												end
											end
											do body:addNode(fcx) end
											do
												local fdx = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)
												do _g.sling.util.NodeUtil:replaceNode(xpr, fdx) end
											end
										end
									end
								end
							end
						end
					end
				end
				::_continue25::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:convertMultipleExpressionsToFunctionExpression(root)
	local array = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.MultipleExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.MultipleExpressionNode')
				if node ~= nil then
					local fdec = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
					do fdec:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:tryGetExpressionDataType(node, nil)), false) end
					do
						local xprs = node:exportExpressions()
						local size = _g.jk.lang.Vector:getSize(xprs)
						do
							local i = 0
							while i < size do
								local expr = _vm:to_table_with_key(_g.jk.lang.Vector:get(xprs, i), '_isType.sling.common.ExpressionNode')
								if i == size - 1 then
									do _g.sling.util.FunctionUtil:addStatement(fdec, _g.sling.model.ReturnStatementNode:forExpression(expr)) end
								else
									local name = _g.sling.util.FunctionUtil:findUniqueVariableNameInFunction(fdec, "_mx")
									do _g.sling.util.FunctionUtil:addStatement(fdec, _g.sling.model.VariableDeclarationNode:forAutomatic(name, expr)) end
								end
								do i = i + 1 end
							end
						end
						do _g.sling.util.NodeUtil:replaceNode(node, _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fdec))) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:removeExpressionDataTypeNodes(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ExpressionDataTypeNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local an = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ExpressionDataTypeNode')
				if an ~= nil then
					local xpr = an:getExpression()
					local dt = nil
					if xpr ~= nil then
						dt = _g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(xpr, nil))
					end
					if not (dt ~= nil) then
						dt = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
					end
					do _g.sling.util.NodeUtil:replaceNode(an, dt) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:handleBlock(block)
	local start = true
	local array = block:getNodes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
				if node ~= nil then
					if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) and start then
						goto _continue26
					end
					start = false
					if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
						local nodes = block:exportNodes()
						local ns1 = {}
						local ns2 = {}
						local p = 0
						if nodes ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(nodes)
							do
								n2 = 0
								while n2 < m2 do
									local nn = nodes[n2 + 1]
									if nn ~= nil then
										if p == 0 then
											if nn == node then
												do p = p + 1 end
												do _g.jk.lang.Vector:append(ns2, nn) end
											else
												do _g.jk.lang.Vector:append(ns1, nn) end
											end
										else
											do _g.jk.lang.Vector:append(ns2, nn) end
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
						do
							local b2 = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
							do b2:setNodes(ns2) end
							do _g.jk.lang.Vector:append(ns1, b2) end
							do block:setNodes(ns1) end
							do _g.sling.op.CommonOps:handleBlock(b2) end
							do break end
						end
					end
				end
				::_continue26::
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:surroundLocalVariablesInBlocks(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.BlockNode", true, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local block = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BlockNode')
				if block ~= nil then
					do _g.sling.op.CommonOps:handleBlock(block) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:removeIntegerToIntegerCasts(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.StaticCastExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local cast = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.StaticCastExpressionNode')
				if cast ~= nil then
					local type = cast:getType()
					if not (type ~= nil) then
						goto _continue27
					end
					do
						local xpr = cast:getExpression()
						if not (xpr ~= nil) then
							goto _continue27
						end
						do
							local xprdt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(xpr, nil)
							if not (xprdt ~= nil) then
								goto _continue27
							end
							if (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (_vm:to_table_with_key(xprdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
								local nxpr = cast:exportExpression()
								do _g.sling.util.NodeUtil:replaceNode(cast, nxpr) end
							end
						end
					end
				end
				::_continue27::
				do n = n + 1 end
			end
		end
	end
end

sling.op.CommonOps.HeaderFinder = _g.sling.common.NodeVisitor._create()
sling.op.CommonOps.HeaderFinder.__index = sling.op.CommonOps.HeaderFinder
_vm:set_metatable(sling.op.CommonOps.HeaderFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.op.CommonOps.HeaderFinder._create()
	local v = _vm:set_metatable({}, sling.op.CommonOps.HeaderFinder)
	return v
end

function sling.op.CommonOps.HeaderFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.op.CommonOps.HeaderFinder'
	self['_isType.sling.op.CommonOps.HeaderFinder'] = true
	self.results = {}
end

function sling.op.CommonOps.HeaderFinder:_construct0()
	sling.op.CommonOps.HeaderFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.op.CommonOps.HeaderFinder:visit(node)
	if node ~= nil and node:hasModifier(_g.sling.model.Modifier.HEADER) then
		do _g.jk.lang.Vector:append(self.results, node) end
		do self:setSkipChildren(true) end
		do return true end
	end
	do return true end
end

function sling.op.CommonOps.HeaderFinder:getResults()
	do return self.results end
end

function sling.op.CommonOps.HeaderFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.op.CommonOps:removeHeaderDeclarations(ctx, node)
	local hf = _g.sling.op.CommonOps.HeaderFinder._construct0(_g.sling.op.CommonOps.HeaderFinder._create())
	do node:accept(hf) end
	do
		local array = hf:getResults()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = array[n + 1]
					if node ~= nil then
						do _g.sling.util.NodeUtil:removeNode(node) end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.op.CommonOps:convertScriptsToClassDeclarations(node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.ScriptDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local sdec = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ScriptDeclarationNode')
				if sdec ~= nil then
					local cdec = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
					local array2 = sdec:exportNodes()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local nobj = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
								if nobj ~= nil then
									do nobj:addModifier(_g.sling.model.Modifier.STATIC) end
									do cdec:addNode(nobj) end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					do cdec:setName(sdec:getNodeName()) end
					do cdec:setModifiers(sdec:exportModifiers()) end
					do _g.sling.util.NodeUtil:replaceAndExport(sdec, cdec) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.CommonOps:convertEnumsToClassDeclarations(node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.EnumDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local edec = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EnumDeclarationNode')
				if edec ~= nil then
					local cdec = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
					local array2 = edec:getNodes()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local enum = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.EnumValueNode')
								if enum ~= nil then
									local name = enum:getName()
									local type = enum:exportType()
									local eval = enum:exportValue()
									if not (eval ~= nil) then
										eval = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forNode(cdec, nil))
									end
									if not (type ~= nil) then
										type = _g.sling.model.ReferenceDataTypeNode:forNode(cdec, nil)
									end
									do
										local vdec = _g.sling.model.VariableDeclarationNode:instance(type, name, eval)
										do vdec:addModifier(_g.sling.model.Modifier.PUBLIC) end
										do vdec:addModifier(_g.sling.model.Modifier.STATIC) end
										do vdec:addModifier(_g.sling.model.Modifier.FINAL) end
										do cdec:addNode(vdec) end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					do cdec:setName(edec:getNodeName()) end
					do _g.sling.util.NodeUtil:replaceAndExport(edec, cdec) end
				end
				do n = n + 1 end
			end
		end
	end
end

sling.op.EntitySorter = {}
sling.op.EntitySorter.__index = sling.op.EntitySorter
_vm:set_metatable(sling.op.EntitySorter, {})

function sling.op.EntitySorter._create()
	local v = _vm:set_metatable({}, sling.op.EntitySorter)
	return v
end

function sling.op.EntitySorter:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.op.EntitySorter'
	self['_isType.sling.op.EntitySorter'] = true
	self.resolver = nil
end

function sling.op.EntitySorter:_construct0()
	sling.op.EntitySorter._init(self)
	return self
end

function sling.op.EntitySorter:findNodeIndex(nodes, node)
	if node == nil then
		do return -1 end
	end
	do
		local c = _g.jk.lang.Vector:getSize(nodes)
		local n = 0
		while n < c do
			if _g.jk.lang.Vector:get(nodes, n) == node then
				do return n end
			end
			do n = n + 1 end
		end
		do return -1 end
	end
end

function sling.op.EntitySorter:orderContainerByDependency(depEntity, entity)
	local dep = _vm:to_table_with_key(depEntity:getParent(), '_isType.sling.common.ContainerNode')
	if not (dep ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Entity has no container parent (1)", depEntity, nil))
	end
	do
		local ee = _vm:to_table_with_key(entity:getParent(), '_isType.sling.common.ContainerNode')
		if not (ee ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Entity has no container parent (2)", entity, nil))
		end
		do
			local dpp = dep
			local epp = nil
			local dpns = depEntity
			local epns = entity
			local commonAncestor = nil
			while true do
				if dpp == nil then
					do break end
				end
				epns = entity
				epp = ee
				while true do
					if epp == nil then
						do break end
					end
					if dpp == epp then
						commonAncestor = dpp
						do break end
					end
					if (_vm:to_table_with_key(epp, '_isType.sling.common.ContainerNode') ~= nil) == false then
						do break end
					end
					epns = epp
					epp = _vm:to_table_with_key(epp:getParent(), '_isType.sling.common.ContainerNode')
				end
				if commonAncestor ~= nil then
					do break end
				end
				if (_vm:to_table_with_key(dpp, '_isType.sling.common.ContainerNode') ~= nil) == false then
					do break end
				end
				dpns = dpp
				dpp = _vm:to_table_with_key(dpp:getParent(), '_isType.sling.common.ContainerNode')
			end
			if not (commonAncestor ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get commonAncestor", dep, nil))
			end
			do
				local nodes = commonAncestor:getNodes()
				local dpIdx = self:findNodeIndex(nodes, dpns)
				if dpIdx < 0 then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Corrupted location of dpns", dpns, nil))
				end
				do
					local epIdx = self:findNodeIndex(nodes, epns)
					if epIdx < 0 then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Corrupted location of epns", epns, nil))
					end
					if epIdx < dpIdx then
						do _g.jk.lang.Vector:set(nodes, dpIdx, epns) end
						do _g.jk.lang.Vector:set(nodes, epIdx, dpns) end
					end
				end
			end
		end
	end
end

function sling.op.EntitySorter:orderBaseTypeOfInnerClass(oentity, entity, nodes)
	local enodes = entity:getNodes()
	local nidx = self:findNodeIndex(nodes, oentity)
	if nidx < 0 then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Corrupted location of oentity", oentity, nil))
	end
	do
		local swaps = 0
		local swapped = false
		if _g.jk.lang.Vector:isEmpty(enodes) == false then
			if enodes ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(enodes)
				do
					n = 0
					while n < m do
						local nn = _vm:to_table_with_key(enodes[n + 1], '_isType.sling.model.EntityDeclarationNode')
						if nn ~= nil then
							if self:orderBaseTypeOfInnerClass(oentity, nn, nodes) then
								do return true end
							end
							do
								local array = nn:getBaseTypes()
								if array ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(array)
									do
										n2 = 0
										while n2 < m2 do
											local bt = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.BaseTypeNode')
											if bt ~= nil then
												local decl = _g.sling.util.TypeResolver:getAndRequireBoundEntity(bt:getReferenceType())
												local idx = self:findNodeIndex(nodes, decl)
												if idx <= nidx then
													goto _continue28
												end
												do _g.jk.lang.Vector:set(nodes, idx, oentity) end
												do _g.jk.lang.Vector:set(nodes, nidx, decl) end
												do swaps = swaps + 1 end
												swapped = true
												if swaps > 10000 then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("More than 10000 swaps encountered when sorting inner child entities. Possibly recursive dependency. Don't know how to continue.", nn, nil))
												end
												do break end
											end
											::_continue28::
											do n2 = n2 + 1 end
										end
									end
								end
								if swapped then
									do return true end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do return false end
	end
end

function sling.op.EntitySorter:sortContainer(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local nodes = node:getNodes()
		if not _g.jk.lang.Vector:isNotEmpty(nodes) then
			do return end
		end
		do
			local n = 0
			local c = _g.jk.lang.Vector:getSize(nodes)
			local swaps = 0
			if nodes ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(nodes)
				do
					n2 = 0
					while n2 < m do
						local ee = _vm:to_table_with_key(nodes[n2 + 1], '_isType.sling.model.EntityDeclarationNode')
						if ee ~= nil then
							do self:sortContainer(ee) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			while n < c do
				local ee = _vm:to_table_with_key(_g.jk.lang.Vector:get(nodes, n), '_isType.sling.model.EntityDeclarationNode')
				if ee == nil then
					do n = n + 1 end
					goto _continue29
				end
				if self:orderBaseTypeOfInnerClass(ee, ee, nodes) then
					goto _continue29
				end
				do
					local swapped = false
					local array = ee:getBaseTypes()
					if array ~= nil then
						local n3 = 0
						local m2 = _g.jk.lang.Vector:getSize(array)
						do
							n3 = 0
							while n3 < m2 do
								local btn = _vm:to_table_with_key(array[n3 + 1], '_isType.sling.model.BaseTypeNode')
								if btn ~= nil then
									local decl = _g.sling.util.TypeResolver:getAndRequireBoundEntity(btn:getReferenceType())
									if (_vm:to_table_with_key(decl, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) or (_vm:to_table_with_key(decl, '_isType.sling.model.TemplateDeclarationNode') ~= nil) then
										goto _continue30
									end
									do
										local idx = self:findNodeIndex(nodes, decl)
										if idx < 0 then
											do self:orderContainerByDependency(decl, ee) end
										end
										if idx <= n then
											goto _continue30
										end
										do _g.jk.lang.Vector:set(nodes, idx, ee) end
										do _g.jk.lang.Vector:set(nodes, n, decl) end
										swapped = true
										do swaps = swaps + 1 end
										if swaps > 10000 then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("More than 10000 swaps encountered when sorting child entities. Possibly recursive dependency. Don't know how to continue.", ee, nil))
										end
										do break end
									end
								end
								::_continue30::
								do n3 = n3 + 1 end
							end
						end
					end
					if swapped == false then
						do n = n + 1 end
					end
				end
				::_continue29::
			end
		end
	end
end

function sling.op.EntitySorter:execute(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.NamespaceNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ns = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.NamespaceNode')
				if ns ~= nil then
					do self:sortContainer(ns) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.op.EntitySorter:getResolver()
	do return self.resolver end
end

function sling.op.EntitySorter:setResolver(v)
	self.resolver = v
	do return self end
end
jk = jk or {}

jk.web = jk.web or {}

jk.web.WebClient = {}
jk.web.WebClient.__index = jk.web.WebClient
_vm:set_metatable(jk.web.WebClient, {})

function jk.web.WebClient._create()
	local v = _vm:set_metatable({}, jk.web.WebClient)
	return v
end

function jk.web.WebClient:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.web.WebClient'
	self['_isType.jk.web.WebClient'] = true
	self.followRedirects = true
	self.credentialsEnabled = false
end

function jk.web.WebClient:_construct0()
	jk.web.WebClient._init(self)
	return self
end

function jk.web.WebClient:query(method, url, headers, body, callback)
end

function jk.web.WebClient:getFollowRedirects()
	do return self.followRedirects end
end

function jk.web.WebClient:setFollowRedirects(v)
	self.followRedirects = v
	do return self end
end

function jk.web.WebClient:getCredentialsEnabled()
	do return self.credentialsEnabled end
end

function jk.web.WebClient:setCredentialsEnabled(v)
	self.credentialsEnabled = v
	do return self end
end

jk.web.NativeWebClient = {}
jk.web.NativeWebClient.__index = jk.web.NativeWebClient
_vm:set_metatable(jk.web.NativeWebClient, {})

function jk.web.NativeWebClient._create()
	local v = _vm:set_metatable({}, jk.web.NativeWebClient)
	return v
end

function jk.web.NativeWebClient:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.web.NativeWebClient'
	self['_isType.jk.web.NativeWebClient'] = true
end

function jk.web.NativeWebClient:_construct0()
	jk.web.NativeWebClient._init(self)
	return self
end

function jk.web.NativeWebClient:instance()
	_io:write_to_stdout("[jk.web.NativeWebClient.instance] (NativeWebClient.sling:51:3): Not implemented." .. "\n")
	do return nil end
end
jk = jk or {}

jk.http = jk.http or {}

jk.http.client = jk.http.client or {}

jk.http.client.HTTPClientRequest = {}
jk.http.client.HTTPClientRequest.__index = jk.http.client.HTTPClientRequest
_vm:set_metatable(jk.http.client.HTTPClientRequest, {})

function jk.http.client.HTTPClientRequest._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClientRequest)
	return v
end

function jk.http.client.HTTPClientRequest:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClientRequest'
	self['_isType.jk.http.client.HTTPClientRequest'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.method = nil
	self.protocol = nil
	self.username = nil
	self.password = nil
	self.serverAddress = nil
	self.serverPort = 0
	self.requestPath = nil
	self.body = nil
	self.queryParams = nil
	self.rawHeaders = nil
	self.headers = nil
end

function jk.http.client.HTTPClientRequest:forGET(url)
	local v = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do v:setMethod("GET") end
	do v:setUrl(url) end
	do return v end
end

function jk.http.client.HTTPClientRequest:forPOST1(url, mimeType, data)
	local v = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do v:setMethod("POST") end
	do v:setUrl(url) end
	if _g.jk.lang.String:isEmpty(mimeType) == false then
		do v:addHeader("Content-Type", mimeType) end
	end
	if data ~= nil then
		do v:setBody(data) end
	end
	do return v end
end

function jk.http.client.HTTPClientRequest:forPOST2(url, file)
	if not (url ~= nil) then
		do return nil end
	end
	if not (file ~= nil) then
		do return nil end
	end
	do
		local reader = file:read()
		if not (reader ~= nil) then
			do return nil end
		end
		do return _g.jk.http.client.HTTPClientRequest:forPOST1(url, _g.jk.mime.MimeTypeRegistry:getSharedInstance():getTypeForFile(file), reader) end
	end
end

function jk.http.client.HTTPClientRequest:forPOST3(url, mimeType, data)
	local v = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do v:setMethod("POST") end
	do v:setUrl(url) end
	if _g.jk.lang.String:isEmpty(mimeType) == false then
		do v:addHeader("Content-Type", mimeType) end
	end
	if data ~= nil then
		do v:setBody(_g.jk.io.BufferReader:forBuffer(data)) end
	end
	do return v end
end

function jk.http.client.HTTPClientRequest:forPUT1(url, mimeType, data)
	local v = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do v:setMethod("PUT") end
	do v:setUrl(url) end
	if _g.jk.lang.String:isEmpty(mimeType) == false then
		do v:addHeader("Content-Type", mimeType) end
	end
	if data ~= nil then
		do v:setBody(data) end
	end
	do return v end
end

function jk.http.client.HTTPClientRequest:forPUT2(url, file)
	if not (url ~= nil) then
		do return nil end
	end
	if not (file ~= nil) then
		do return nil end
	end
	do
		local reader = file:read()
		if not (reader ~= nil) then
			do return nil end
		end
		do return _g.jk.http.client.HTTPClientRequest:forPUT1(url, _g.jk.mime.MimeTypeRegistry:getSharedInstance():getTypeForFile(file), reader) end
	end
end

function jk.http.client.HTTPClientRequest:forPUT3(url, mimeType, data)
	local v = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do v:setMethod("PUT") end
	do v:setUrl(url) end
	if _g.jk.lang.String:isEmpty(mimeType) == false then
		do v:addHeader("Content-Type", mimeType) end
	end
	if data ~= nil then
		do v:setBody(_g.jk.io.BufferReader:forBuffer(data)) end
	end
	do return v end
end

function jk.http.client.HTTPClientRequest:forDELETE(url)
	local v = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do v:setMethod("DELETE") end
	do v:setUrl(url) end
	do return v end
end

function jk.http.client.HTTPClientRequest:_construct0()
	jk.http.client.HTTPClientRequest._init(self)
	self.protocol = "http"
	self.serverPort = 80
	self.requestPath = "/"
	self.method = "GET"
	return self
end

function jk.http.client.HTTPClientRequest:setUrl(url)
	local uu = _g.jk.url.URL:forString(url, false)
	do self:setProtocol(uu:getScheme()) end
	do self:setUsername(uu:getUsername()) end
	do self:setPassword(uu:getPassword()) end
	do self:setServerAddress(uu:getHost()) end
	do
		local pp = _g.jk.lang.String:toInteger(uu:getPort())
		if pp < 1 then
			if self.protocol == "https" then
				pp = 443
			elseif self.protocol == "http" then
				pp = 80
			end
		end
		do self:setServerPort(pp) end
		do self:setRequestPath(uu:getPath()) end
		self.queryParams = uu:getRawQueryParameters()
	end
end

function jk.http.client.HTTPClientRequest:addHeader(key, value)
	if self.rawHeaders == nil then
		self.rawHeaders = _g.jk.lang.KeyValueListForStrings._construct0(_g.jk.lang.KeyValueListForStrings._create())
	end
	if self.headers == nil then
		self.headers = {}
	end
	do self.rawHeaders:add(key, value) end
	self.headers[_g.jk.lang.String:toLowerCase(key)] = value
end

function jk.http.client.HTTPClientRequest:addQueryParameter(key, value)
	if self.queryParams == nil then
		self.queryParams = _g.jk.lang.KeyValueList._construct0(_g.jk.lang.KeyValueList._create())
	end
	do self.queryParams:add(key, value) end
end

function jk.http.client.HTTPClientRequest:getHeader(key)
	if not (self.headers ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Map:get(self.headers, key) end
end

function jk.http.client.HTTPClientRequest:setUserAgent(agent)
	do self:addHeader("User-Agent", agent) end
end

function jk.http.client.HTTPClientRequest:getUrl()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(self.protocol) end
	do sb:appendString("://") end
	do sb:appendString(self.serverAddress) end
	if self.serverPort == 80 and self.protocol == "http" then
	elseif self.serverPort == 443 and self.protocol == "https" then
	else
		do sb:appendCharacter(58) end
		do sb:appendString(_g.jk.lang.String:forInteger(self.serverPort)) end
	end
	do
		local path = self:getRequestPath()
		if _g.jk.lang.String:isEmpty(path) then
			path = "/"
		end
		do sb:appendString(path) end
		do return sb:toString() end
	end
end

function jk.http.client.HTTPClientRequest:toString1(defaultUserAgent)
	local rq = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local body = self:getBody()
	local path = self:getRequestPath()
	if _g.jk.lang.String:isEmpty(path) then
		path = "/"
	end
	do rq:appendString(self:getMethod()) end
	do rq:appendCharacter(32) end
	do rq:appendString(path) end
	do
		local first = true
		if self.queryParams ~= nil then
			local it = self.queryParams:iterate()
			while it ~= nil do
				local kv = it:next()
				if kv == nil then
					do break end
				end
				if first then
					do rq:appendCharacter(63) end
					first = false
				else
					do rq:appendCharacter(38) end
				end
				do rq:appendString(kv.key) end
				do
					local val = kv.value
					if val ~= nil then
						do rq:appendCharacter(61) end
						do rq:appendString(_g.jk.url.URLEncoder:encode(val, false, false)) end
					end
				end
			end
		end
		do rq:appendCharacter(32) end
		do rq:appendString("HTTP/1.1\r\n") end
		do
			local hasUserAgent = false
			local hasHost = false
			local hasContentLength = false
			if self.rawHeaders ~= nil then
				local it = self.rawHeaders:iterate()
				while true do
					local kvp = it:next()
					if kvp == nil then
						do break end
					end
					do
						local key = kvp.key
						if _g.jk.lang.String:equalsIgnoreCase(key, "user-agent") then
							hasUserAgent = true
						elseif _g.jk.lang.String:equalsIgnoreCase(key, "host") then
							hasHost = true
						elseif _g.jk.lang.String:equalsIgnoreCase(key, "content-length") then
							hasContentLength = true
						end
						do rq:appendString(key) end
						do rq:appendString(": ") end
						do rq:appendString(kvp.value) end
						do rq:appendString("\r\n") end
					end
				end
			end
			if hasUserAgent == false and defaultUserAgent ~= nil then
				do rq:appendString("User-Agent: ") end
				do rq:appendString(defaultUserAgent) end
				do rq:appendString("\r\n") end
			end
			if hasHost == false then
				do rq:appendString("Host: " .. _g.jk.lang.String:safeString(self:getServerAddress()) .. "\r\n") end
			end
			if body ~= nil and hasContentLength == false then
				local bs = body:getSize()
				local bss = _g.jk.lang.String:forInteger(bs)
				do rq:appendString("Content-Length: " .. _g.jk.lang.String:safeString(bss) .. "\r\n") end
			end
			do rq:appendString("\r\n") end
			do return rq:toString() end
		end
	end
end

function jk.http.client.HTTPClientRequest:toString()
	do return self:toString1(nil) end
end

function jk.http.client.HTTPClientRequest:getMethod()
	do return self.method end
end

function jk.http.client.HTTPClientRequest:setMethod(v)
	self.method = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getProtocol()
	do return self.protocol end
end

function jk.http.client.HTTPClientRequest:setProtocol(v)
	self.protocol = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getUsername()
	do return self.username end
end

function jk.http.client.HTTPClientRequest:setUsername(v)
	self.username = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getPassword()
	do return self.password end
end

function jk.http.client.HTTPClientRequest:setPassword(v)
	self.password = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getServerAddress()
	do return self.serverAddress end
end

function jk.http.client.HTTPClientRequest:setServerAddress(v)
	self.serverAddress = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getServerPort()
	do return self.serverPort end
end

function jk.http.client.HTTPClientRequest:setServerPort(v)
	self.serverPort = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getRequestPath()
	do return self.requestPath end
end

function jk.http.client.HTTPClientRequest:setRequestPath(v)
	self.requestPath = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getBody()
	do return self.body end
end

function jk.http.client.HTTPClientRequest:setBody(v)
	self.body = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getRawHeaders()
	do return self.rawHeaders end
end

function jk.http.client.HTTPClientRequest:setRawHeaders(v)
	self.rawHeaders = v
	do return self end
end

function jk.http.client.HTTPClientRequest:getHeaders()
	do return self.headers end
end

function jk.http.client.HTTPClientRequest:setHeaders(v)
	self.headers = v
	do return self end
end

jk.http.client.HTTPClientListener = {}
jk.http.client.HTTPClientListener.__index = jk.http.client.HTTPClientListener
_vm:set_metatable(jk.http.client.HTTPClientListener, {})

function jk.http.client.HTTPClientListener._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClientListener)
	return v
end

function jk.http.client.HTTPClientListener:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClientListener'
	self['_isType.jk.http.client.HTTPClientListener'] = true
	self.completed = false
end

function jk.http.client.HTTPClientListener:_construct0()
	jk.http.client.HTTPClientListener._init(self)
	return self
end

function jk.http.client.HTTPClientListener:onError(message)
end

function jk.http.client.HTTPClientListener:onStatus(message)
end

function jk.http.client.HTTPClientListener:onStartRequest(request)
	do return true end
end

function jk.http.client.HTTPClientListener:onEndRequest()
	do return true end
end

function jk.http.client.HTTPClientListener:onResponseReceived(response)
	do return true end
end

function jk.http.client.HTTPClientListener:onDataReceived(buffer)
	do return true end
end

function jk.http.client.HTTPClientListener:onAborted()
end

function jk.http.client.HTTPClientListener:onResponseCompleted()
	self.completed = true
end

function jk.http.client.HTTPClientListener:getCompleted()
	do return self.completed end
end

function jk.http.client.HTTPClientListener:setCompleted(v)
	self.completed = v
	do return self end
end

jk.http.client.HTTPClientResponse = {}
jk.http.client.HTTPClientResponse.__index = jk.http.client.HTTPClientResponse
_vm:set_metatable(jk.http.client.HTTPClientResponse, {})

function jk.http.client.HTTPClientResponse._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClientResponse)
	return v
end

function jk.http.client.HTTPClientResponse:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClientResponse'
	self['_isType.jk.http.client.HTTPClientResponse'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.httpVersion = nil
	self.httpStatus = nil
	self.httpStatusDescription = nil
	self.rawHeaders = nil
	self.headers = nil
end

function jk.http.client.HTTPClientResponse:_construct0()
	jk.http.client.HTTPClientResponse._init(self)
	return self
end

function jk.http.client.HTTPClientResponse:addHeader(key, value)
	if self.rawHeaders == nil then
		self.rawHeaders = _g.jk.lang.KeyValueListForStrings._construct0(_g.jk.lang.KeyValueListForStrings._create())
	end
	if self.headers == nil then
		self.headers = {}
	end
	do self.rawHeaders:add(key, value) end
	self.headers[_g.jk.lang.String:toLowerCase(key)] = value
end

function jk.http.client.HTTPClientResponse:getHeader(key)
	if not (self.headers ~= nil) then
		do return nil end
	end
	do return _g.jk.lang.Map:get(self.headers, key) end
end

function jk.http.client.HTTPClientResponse:toString()
	do return _g.jk.lang.String:asString(self.rawHeaders) end
end

function jk.http.client.HTTPClientResponse:getHttpVersion()
	do return self.httpVersion end
end

function jk.http.client.HTTPClientResponse:setHttpVersion(v)
	self.httpVersion = v
	do return self end
end

function jk.http.client.HTTPClientResponse:getHttpStatus()
	do return self.httpStatus end
end

function jk.http.client.HTTPClientResponse:setHttpStatus(v)
	self.httpStatus = v
	do return self end
end

function jk.http.client.HTTPClientResponse:getHttpStatusDescription()
	do return self.httpStatusDescription end
end

function jk.http.client.HTTPClientResponse:setHttpStatusDescription(v)
	self.httpStatusDescription = v
	do return self end
end

function jk.http.client.HTTPClientResponse:getRawHeaders()
	do return self.rawHeaders end
end

function jk.http.client.HTTPClientResponse:setRawHeaders(v)
	self.rawHeaders = v
	do return self end
end

function jk.http.client.HTTPClientResponse:getHeaders()
	do return self.headers end
end

function jk.http.client.HTTPClientResponse:setHeaders(v)
	self.headers = v
	do return self end
end

jk.http.client.HTTPClient = {}
jk.http.client.HTTPClient.__index = jk.http.client.HTTPClient
_vm:set_metatable(jk.http.client.HTTPClient, {})

function jk.http.client.HTTPClient._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClient)
	return v
end

function jk.http.client.HTTPClient:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClient'
	self['_isType.jk.http.client.HTTPClient'] = true
end

function jk.http.client.HTTPClient:_construct0()
	jk.http.client.HTTPClient._init(self)
	return self
end

function jk.http.client.HTTPClient:createDefault()
	do return _g.jk.http.client.HTTPClientOperation._construct0(_g.jk.http.client.HTTPClientOperation._create()) end
end

function jk.http.client.HTTPClient:execute1(client, request, listener)
	if not (client ~= nil) then
		do return end
	end
	do client:executeRequest(request, listener) end
end

jk.http.client.HTTPClient.MyListener = _g.jk.http.client.HTTPClientListener._create()
jk.http.client.HTTPClient.MyListener.__index = jk.http.client.HTTPClient.MyListener
_vm:set_metatable(jk.http.client.HTTPClient.MyListener, {
	__index = _g.jk.http.client.HTTPClientListener
})

function jk.http.client.HTTPClient.MyListener._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClient.MyListener)
	return v
end

function jk.http.client.HTTPClient.MyListener:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClient.MyListener'
	self['_isType.jk.http.client.HTTPClient.MyListener'] = true
	self.response = nil
	self.buffer = nil
	self.errorHandler = nil
	self.ctx = nil
end

function jk.http.client.HTTPClient.MyListener:_construct0()
	jk.http.client.HTTPClient.MyListener._init(self)
	do _g.jk.http.client.HTTPClientListener._construct0(self) end
	return self
end

function jk.http.client.HTTPClient.MyListener:onResponseReceived(response)
	self.response = response
	do return true end
end

function jk.http.client.HTTPClient.MyListener:onDataReceived(buffer)
	self.buffer = _g.jk.lang.Buffer:append(self.buffer, buffer, -1)
	do return true end
end

function jk.http.client.HTTPClient.MyListener:onAborted()
end

function jk.http.client.HTTPClient.MyListener:onStatus(message)
	if message ~= nil then
		do _g.jk.log.Log:debug(self.ctx, message) end
	end
end

function jk.http.client.HTTPClient.MyListener:onError(message)
	do _g.jk.log.Log:error(self.ctx, message) end
	if self.errorHandler ~= nil then
		do self.errorHandler(message) end
	end
end

function jk.http.client.HTTPClient.MyListener:onResponseCompleted()
end

function jk.http.client.HTTPClient.MyListener:getResponse()
	do return self.response end
end

function jk.http.client.HTTPClient.MyListener:setResponse(v)
	self.response = v
	do return self end
end

function jk.http.client.HTTPClient.MyListener:getBuffer()
	do return self.buffer end
end

function jk.http.client.HTTPClient.MyListener:setBuffer(v)
	self.buffer = v
	do return self end
end

function jk.http.client.HTTPClient.MyListener:getErrorHandler()
	do return self.errorHandler end
end

function jk.http.client.HTTPClient.MyListener:setErrorHandler(v)
	self.errorHandler = v
	do return self end
end

function jk.http.client.HTTPClient.MyListener:getCtx()
	do return self.ctx end
end

function jk.http.client.HTTPClient.MyListener:setCtx(v)
	self.ctx = v
	do return self end
end

function jk.http.client.HTTPClient:execute2(ctx, client, request, listener, errorHandler)
	local ll = _g.jk.http.client.HTTPClient.MyListener._construct0(_g.jk.http.client.HTTPClient.MyListener._create())
	do ll:setCtx(ctx) end
	do ll:setErrorHandler(errorHandler) end
	do _g.jk.http.client.HTTPClient:execute1(client, request, ll) end
	if listener ~= nil then
		do listener(ll:getResponse()) end
	end
end

function jk.http.client.HTTPClient:executeForBuffer(ctx, client, request, listener, errorHandler)
	local ll = _g.jk.http.client.HTTPClient.MyListener._construct0(_g.jk.http.client.HTTPClient.MyListener._create())
	do ll:setCtx(ctx) end
	do ll:setErrorHandler(errorHandler) end
	do _g.jk.http.client.HTTPClient:execute1(client, request, ll) end
	if listener ~= nil then
		do listener(ll:getResponse(), ll:getBuffer()) end
	end
end

function jk.http.client.HTTPClient:executeForString(ctx, client, request, listener, errorHandler)
	local ll = _g.jk.http.client.HTTPClient.MyListener._construct0(_g.jk.http.client.HTTPClient.MyListener._create())
	do ll:setCtx(ctx) end
	do ll:setErrorHandler(errorHandler) end
	do _g.jk.http.client.HTTPClient:execute1(client, request, ll) end
	if listener ~= nil then
		do listener(ll:getResponse(), _g.jk.lang.String:forUTF8Buffer(ll:getBuffer())) end
	end
end

function jk.http.client.HTTPClient:executeRequest(request, listener)
end

jk.http.client.HTTPRPCClient = {}
jk.http.client.HTTPRPCClient.__index = jk.http.client.HTTPRPCClient
_vm:set_metatable(jk.http.client.HTTPRPCClient, {})

function jk.http.client.HTTPRPCClient._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPRPCClient)
	return v
end

function jk.http.client.HTTPRPCClient:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPRPCClient'
	self['_isType.jk.http.client.HTTPRPCClient'] = true
	self.baseUrl = nil
end

function jk.http.client.HTTPRPCClient:_construct0()
	jk.http.client.HTTPRPCClient._init(self)
	return self
end

function jk.http.client.HTTPRPCClient:forBaseUrl(url)
	local v = _g.jk.http.client.HTTPRPCClient._construct0(_g.jk.http.client.HTTPRPCClient._create())
	do v:setBaseUrl(url) end
	do return v end
end

function jk.http.client.HTTPRPCClient:callRemoteFunction(name, data)
	local dd = data
	if not (dd ~= nil) then
		dd = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	end
	do
		local sdata = _g.jk.json.JSONEncoder:encode(dd, true, false)
		local bdata = _g.jk.lang.String:toUTF8Buffer(sdata)
		local url = _g.jk.lang.String:safeString(self.baseUrl) .. "/func/" .. _g.jk.lang.String:safeString(name)
		local rdata = nil
		local headers = _g.jk.lang.KeyValueList._construct0(_g.jk.lang.KeyValueList._create())
		do headers:add("content-type", "application/json") end
		do
			local wc = _g.jk.http.client.CustomWebClient._construct0(_g.jk.http.client.CustomWebClient._create())
			do wc:query("POST", url, headers, bdata, function(status, headers, body)
				if status == nil then
					local detail = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
					do detail:setString("url", url) end
					do detail:setString("error", _g.jk.lang.String:forUTF8Buffer(body)) end
					do _g.jk.lang.Error:throw("failedToCallRemoteFunction", _g.jk.json.JSONEncoder:toString(detail)) end
				end
				do
					local str = _g.jk.lang.String:forUTF8Buffer(body)
					rdata = _vm:to_table_with_key(_g.jk.json.JSONParser:parseString(str), '_isType.jk.lang.DynamicMap')
					if not (rdata ~= nil) then
						local detail = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
						do detail:setString("url", url) end
						do detail:setString("responseBody", str) end
						do _g.jk.lang.Error:throw("failedToCallRemoteFunction", _g.jk.json.JSONEncoder:toString(detail)) end
					end
				end
			end) end
			if not (rdata ~= nil) then
				do _g.jk.lang.Error:throw("failedToCallRemoteFunction", url) end
			end
			do
				local status = rdata:getString("status", nil)
				if _g.jk.lang.String:equals(status, "ok") then
					do return rdata:get("data") end
				elseif _g.jk.lang.String:equals(status, "error") then
					local error = rdata:getString("errorCode", nil)
					local detail = rdata:getString("errorDetail", nil)
					if _g.jk.lang.String:isEmpty(error) then
						error = "errorStatusFromRemoteFunction"
					end
					if _g.jk.lang.String:isEmpty(detail) then
						detail = name
					end
					do _g.jk.lang.Error:throw(error, detail) end
				else
					do _g.jk.lang.Error:throw("unsupportedRpcStatus", status) end
				end
				do return nil end
			end
		end
	end
end

function jk.http.client.HTTPRPCClient:getBaseUrl()
	do return self.baseUrl end
end

function jk.http.client.HTTPRPCClient:setBaseUrl(v)
	self.baseUrl = v
	do return self end
end

jk.http.client.WebRequest = {}
jk.http.client.WebRequest.__index = jk.http.client.WebRequest
_vm:set_metatable(jk.http.client.WebRequest, {})

function jk.http.client.WebRequest._create()
	local v = _vm:set_metatable({}, jk.http.client.WebRequest)
	return v
end

function jk.http.client.WebRequest:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.WebRequest'
	self['_isType.jk.http.client.WebRequest'] = true
end

function jk.http.client.WebRequest:_construct0()
	jk.http.client.WebRequest._init(self)
	return self
end

jk.http.client.WebRequest.Response = {}
jk.http.client.WebRequest.Response.__index = jk.http.client.WebRequest.Response
_vm:set_metatable(jk.http.client.WebRequest.Response, {})

function jk.http.client.WebRequest.Response._create()
	local v = _vm:set_metatable({}, jk.http.client.WebRequest.Response)
	return v
end

function jk.http.client.WebRequest.Response:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.WebRequest.Response'
	self['_isType.jk.http.client.WebRequest.Response'] = true
	self.httpStatus = nil
	self.httpStatusDescription = nil
	self.headers = nil
	self.body = nil
	self.bodyAsString = nil
	self.bodyAsDynamicMap = nil
end

function jk.http.client.WebRequest.Response:_construct0()
	jk.http.client.WebRequest.Response._init(self)
	return self
end

function jk.http.client.WebRequest.Response:getHeaderValue(key)
	if not (self.headers ~= nil) then
		do return nil end
	end
	if not (key ~= nil) then
		do return nil end
	end
	do
		local it = self.headers:iterate()
		while it ~= nil do
			local ee = it:next()
			if not (ee ~= nil) then
				do break end
			end
			if _g.jk.lang.String:equalsIgnoreCase(ee.key, key) then
				do return ee.value end
			end
		end
		do return nil end
	end
end

function jk.http.client.WebRequest.Response:getBodyAsBuffer()
	if not (self.body ~= nil) then
		do _g.jk.lang.Error:throw("httpRequestError", "noBody") end
	end
	do return self.body end
end

function jk.http.client.WebRequest.Response:getBodyAsString()
	if self.bodyAsString ~= nil then
		do return self.bodyAsString end
	end
	do
		local v = _g.jk.lang.String:forUTF8Buffer(self:getBodyAsBuffer())
		if not (v ~= nil) then
			do _g.jk.lang.Error:throw("httpRequestError", "notString") end
		end
		self.bodyAsString = v
		do return v end
	end
end

function jk.http.client.WebRequest.Response:getBodyAsDynamicMap()
	if self.bodyAsDynamicMap ~= nil then
		do return self.bodyAsDynamicMap end
	end
	do
		local v = _vm:to_table_with_key(_g.jk.json.JSONParser:parseBuffer(self:getBodyAsBuffer()), '_isType.jk.lang.DynamicMap')
		if not (v ~= nil) then
			do _g.jk.lang.Error:throw("httpRequestError", "notJsonMap") end
		end
		self.bodyAsDynamicMap = v
		do return v end
	end
end

function jk.http.client.WebRequest.Response:getHttpStatus()
	do return self.httpStatus end
end

function jk.http.client.WebRequest.Response:setHttpStatus(v)
	self.httpStatus = v
	do return self end
end

function jk.http.client.WebRequest.Response:getHttpStatusDescription()
	do return self.httpStatusDescription end
end

function jk.http.client.WebRequest.Response:setHttpStatusDescription(v)
	self.httpStatusDescription = v
	do return self end
end

function jk.http.client.WebRequest.Response:getHeaders()
	do return self.headers end
end

function jk.http.client.WebRequest.Response:setHeaders(v)
	self.headers = v
	do return self end
end

function jk.http.client.WebRequest.Response:getBody()
	do return self.body end
end

function jk.http.client.WebRequest.Response:setBody(v)
	self.body = v
	do return self end
end

jk.http.client.WebRequest.MyHTTPClientListener = _g.jk.http.client.HTTPClientListener._create()
jk.http.client.WebRequest.MyHTTPClientListener.__index = jk.http.client.WebRequest.MyHTTPClientListener
_vm:set_metatable(jk.http.client.WebRequest.MyHTTPClientListener, {
	__index = _g.jk.http.client.HTTPClientListener
})

function jk.http.client.WebRequest.MyHTTPClientListener._create()
	local v = _vm:set_metatable({}, jk.http.client.WebRequest.MyHTTPClientListener)
	return v
end

function jk.http.client.WebRequest.MyHTTPClientListener:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.WebRequest.MyHTTPClientListener'
	self['_isType.jk.http.client.WebRequest.MyHTTPClientListener'] = true
	self.response = nil
	self.body = nil
end

function jk.http.client.WebRequest.MyHTTPClientListener:_construct0()
	jk.http.client.WebRequest.MyHTTPClientListener._init(self)
	do _g.jk.http.client.HTTPClientListener._construct0(self) end
	return self
end

function jk.http.client.WebRequest.MyHTTPClientListener:onError(message)
	do _g.jk.lang.Error:throw("httpRequestError", message) end
end

function jk.http.client.WebRequest.MyHTTPClientListener:onAborted()
	do _g.jk.lang.Error:throw("httpRequestError", "aborted") end
end

function jk.http.client.WebRequest.MyHTTPClientListener:onDataReceived(buffer)
	self.body = _g.jk.lang.Buffer:append(self.body, buffer, -1)
	do return true end
end

function jk.http.client.WebRequest.MyHTTPClientListener:onResponseReceived(response)
	if not (response ~= nil) then
		do return false end
	end
	self.response = response
	do return true end
end

function jk.http.client.WebRequest.MyHTTPClientListener:getResponse()
	do return self.response end
end

function jk.http.client.WebRequest.MyHTTPClientListener:setResponse(v)
	self.response = v
	do return self end
end

function jk.http.client.WebRequest.MyHTTPClientListener:getBody()
	do return self.body end
end

function jk.http.client.WebRequest.MyHTTPClientListener:setBody(v)
	self.body = v
	do return self end
end

function jk.http.client.WebRequest:execute(method, url, headers, body)
	local req = _g.jk.http.client.HTTPClientRequest._construct0(_g.jk.http.client.HTTPClientRequest._create())
	do req:setMethod(method) end
	do req:setUrl(url) end
	if headers ~= nil then
		local it = headers:iterate()
		while it ~= nil do
			local pair = it:next()
			if not (pair ~= nil) then
				do break end
			end
			do req:addHeader(pair.key, pair.value) end
		end
	end
	do req:setBody(_g.jk.io.BufferReader:forBuffer(body)) end
	do
		local op = _g.jk.http.client.HTTPClientOperation._construct0(_g.jk.http.client.HTTPClientOperation._create())
		local listener = _g.jk.http.client.WebRequest.MyHTTPClientListener._construct0(_g.jk.http.client.WebRequest.MyHTTPClientListener._create())
		do op:executeRequest(req, listener) end
		do op:closeConnection(nil) end
		do
			local hresp = listener:getResponse()
			if not (hresp ~= nil) then
				do _g.jk.lang.Error:throw("httpRequestError", "noResponse") end
			end
			do
				local body = listener:getBody()
				local v = _g.jk.http.client.WebRequest.Response._construct0(_g.jk.http.client.WebRequest.Response._create())
				do v:setHttpStatus(hresp:getHttpStatus()) end
				do v:setHttpStatusDescription(hresp:getHttpStatusDescription()) end
				do v:setHeaders(hresp:getRawHeaders()) end
				do v:setBody(body) end
				do return v end
			end
		end
	end
end

jk.http.client.HTTPClientOperation = _g.jk.http.client.HTTPClient._create()
jk.http.client.HTTPClientOperation.__index = jk.http.client.HTTPClientOperation
_vm:set_metatable(jk.http.client.HTTPClientOperation, {
	__index = _g.jk.http.client.HTTPClient
})

function jk.http.client.HTTPClientOperation._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClientOperation)
	return v
end

function jk.http.client.HTTPClientOperation:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClientOperation'
	self['_isType.jk.http.client.HTTPClientOperation'] = true
	self.openSocket = nil
	self.openSocketProtocol = nil
	self.openSocketAddress = nil
	self.openSocketPort = 0
	self.defaultUserAgent = nil
	self.parser = nil
	self.receiveBuffer = nil
	self.acceptInvalidCertificate = false
end

jk.http.client.HTTPClientOperation.MyResponseParser = {}
jk.http.client.HTTPClientOperation.MyResponseParser.__index = jk.http.client.HTTPClientOperation.MyResponseParser
_vm:set_metatable(jk.http.client.HTTPClientOperation.MyResponseParser, {})

function jk.http.client.HTTPClientOperation.MyResponseParser._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClientOperation.MyResponseParser)
	return v
end

function jk.http.client.HTTPClientOperation.MyResponseParser:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClientOperation.MyResponseParser'
	self['_isType.jk.http.client.HTTPClientOperation.MyResponseParser'] = true
	self.receivedData = nil
	self.headers = nil
	self.isChunked = false
	self.isStream = false
	self.contentLength = 0
	self.dataCounter = 0
	self.listener = nil
	self.endOfResponse = false
	self.aborted = false
end

function jk.http.client.HTTPClientOperation.MyResponseParser:_construct0()
	jk.http.client.HTTPClientOperation.MyResponseParser._init(self)
	return self
end

jk.http.client.HTTPClientOperation.MyResponseParser.Chunk = {}
jk.http.client.HTTPClientOperation.MyResponseParser.Chunk.__index = jk.http.client.HTTPClientOperation.MyResponseParser.Chunk
_vm:set_metatable(jk.http.client.HTTPClientOperation.MyResponseParser.Chunk, {})

function jk.http.client.HTTPClientOperation.MyResponseParser.Chunk._create()
	local v = _vm:set_metatable({}, jk.http.client.HTTPClientOperation.MyResponseParser.Chunk)
	return v
end

function jk.http.client.HTTPClientOperation.MyResponseParser.Chunk:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.HTTPClientOperation.MyResponseParser.Chunk'
	self['_isType.jk.http.client.HTTPClientOperation.MyResponseParser.Chunk'] = true
	self.data = nil
	self.completed = true
end

function jk.http.client.HTTPClientOperation.MyResponseParser.Chunk:_construct0()
	jk.http.client.HTTPClientOperation.MyResponseParser.Chunk._init(self)
	return self
end

function jk.http.client.HTTPClientOperation.MyResponseParser:reset()
	self.isChunked = false
	self.isStream = false
	self.headers = nil
	self.contentLength = 0
	self.dataCounter = 0
	self.endOfResponse = false
	self.aborted = false
end

function jk.http.client.HTTPClientOperation.MyResponseParser:hasEndOfHeaders(buf, size)
	local n = 0
	local v = false
	while n <= size - 4 do
		if _g.jk.lang.Buffer:getByte(buf, n) == 13 and _g.jk.lang.Buffer:getByte(buf, n + 1) == 10 and _g.jk.lang.Buffer:getByte(buf, n + 2) == 13 and _g.jk.lang.Buffer:getByte(buf, n + 3) == 10 then
			v = true
			do break end
		end
		do n = n + 1 end
	end
	do return v end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:parseResponse(buf)
	local i = 0
	local p = _util:convert_to_integer(48)
	local v = nil
	local first = true
	local isChunked = false
	while true do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		while (function()
			p = _g.jk.lang.Buffer:getByte(buf, i)
			do return p end
		end)() ~= 0 do
			if p == 13 then
			elseif p == 10 then
				do i = i + 1 end
				do break end
			else
				do sb:appendCharacter(p) end
			end
			do i = i + 1 end
		end
		do
			local t = sb:toString()
			if _g.jk.lang.String:isEmpty(t) then
				do break end
			end
			if first then
				local comps = _g.jk.lang.String:split(t, 32, 3)
				v = _g.jk.http.client.HTTPClientResponse._construct0(_g.jk.http.client.HTTPClientResponse._create())
				do v:setHttpVersion(_g.jk.lang.Vector:get(comps, 0)) end
				do v:setHttpStatus(_g.jk.lang.Vector:get(comps, 1)) end
				do v:setHttpStatusDescription(_g.jk.lang.Vector:get(comps, 2)) end
			else
				local comps = _g.jk.lang.String:split(t, 58, 2)
				local key = _g.jk.lang.Vector:get(comps, 0)
				if _g.jk.lang.String:isEmpty(key) == false then
					local val = _g.jk.lang.String:strip(_g.jk.lang.Vector:get(comps, 1))
					do v:addHeader(key, val) end
					if isChunked == false and _g.jk.lang.String:equalsIgnoreCase(key, "transfer-encoding") then
						if val == "chunked" then
							isChunked = true
						end
					elseif self.contentLength < 1 and _g.jk.lang.String:equalsIgnoreCase(key, "content-length") then
						self.contentLength = _g.jk.lang.String:toInteger(val)
					end
				end
			end
			first = false
		end
	end
	do
		local l = _g.jk.lang.Buffer:getSize(buf) - i
		if l > 0 then
			self.receivedData = _g.jk.lang.Buffer:getSubBuffer(buf, i, l, false)
		else
			self.receivedData = nil
		end
		self.isChunked = isChunked
		if self.contentLength < 1 and (_g.jk.lang.String:equalsIgnoreCase(v:getHeader("connection"), "close") or _g.jk.lang.String:equalsIgnoreCase(v:getHttpVersion(), "HTTP/1.0")) then
			self.isStream = true
		end
		do return v end
	end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:getChunk()
	local i = 0
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	while true do
		if self.receivedData == nil or #self.receivedData <= i then
			local chunk = _g.jk.http.client.HTTPClientOperation.MyResponseParser.Chunk._construct0(_g.jk.http.client.HTTPClientOperation.MyResponseParser.Chunk._create())
			chunk.completed = false
			do return chunk end
		end
		do
			local p = _g.jk.lang.Buffer:getByte(self.receivedData, i)
			if p == 13 then
			elseif p == 10 then
				do i = i + 1 end
				do break end
			else
				do sb:appendCharacter(p) end
			end
			do i = i + 1 end
			if sb:count() >= 16 then
				do return nil end
			end
		end
	end
	do
		local cl = -1
		local t = _g.jk.lang.String:strip(sb:toString())
		if _g.jk.lang.String:isEmpty(t) == false then
			cl = _g.jk.lang.String:toIntegerFromHex(t)
		end
		do
			local chunk = _g.jk.http.client.HTTPClientOperation.MyResponseParser.Chunk._construct0(_g.jk.http.client.HTTPClientOperation.MyResponseParser.Chunk._create())
			if cl > 0 then
				if _g.jk.lang.Buffer:getSize(self.receivedData) - i < cl + 2 then
					chunk.completed = false
					do return chunk end
				end
				chunk.data = _util:allocate_buffer(cl)
				do _g.jk.lang.Buffer:copyFrom(chunk.data, self.receivedData, i, 0, cl) end
				i = i + cl
			end
			while i < _g.jk.lang.Buffer:getSize(self.receivedData) and (_g.jk.lang.Buffer:getByte(self.receivedData, i) == 13 or _g.jk.lang.Buffer:getByte(self.receivedData, i) == 10) do
				do i = i + 1 end
			end
			do
				local rem = _g.jk.lang.Buffer:getSize(self.receivedData) - i
				if rem > 0 then
					local tmp = self.receivedData
					self.receivedData = _util:allocate_buffer(rem)
					do _g.jk.lang.Buffer:copyFrom(self.receivedData, tmp, i, 0, rem) end
				else
					self.receivedData = nil
				end
				do return chunk end
			end
		end
	end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:onDataReceived(buf, size)
	if size > 0 then
		self.receivedData = _g.jk.lang.Buffer:append(self.receivedData, buf, size)
	end
	if not (self.headers ~= nil) then
		if self:hasEndOfHeaders(self.receivedData, _g.jk.lang.Buffer:getSize(self.receivedData)) then
			self.headers = self:parseResponse(self.receivedData)
			if self.headers ~= nil then
				do self:onHeadersReceived(self.headers) end
			end
		else
			do return end
		end
	end
	if self.isChunked then
		while true do
			local r = self:getChunk()
			if r ~= nil then
				if not r.completed then
					do break end
				end
				if not (r.data ~= nil) then
					do self:reset() end
					do self:onEndOfResponse() end
					do break end
				end
				do
					local sz = _g.jk.lang.Buffer:getSize(r.data)
					self.dataCounter = self.dataCounter + sz
					do self:onBodyDataReceived(r.data, sz) end
				end
			else
				do self:reset() end
				do self:onEndOfResponse() end
				do break end
			end
			if self.receivedData == nil then
				do break end
			end
		end
	elseif self.isStream then
		local sz = _g.jk.lang.Buffer:getSize(self.receivedData)
		if sz > 0 then
			local v = self.receivedData
			self.receivedData = nil
			self.dataCounter = self.dataCounter + sz
			do self:onBodyDataReceived(v, sz) end
		end
	elseif self.contentLength > 0 then
		local rsz = _g.jk.lang.Buffer:getSize(self.receivedData)
		if rsz > 0 then
			if self.contentLength <= 0 or self.dataCounter + rsz <= self.contentLength then
				local v = self.receivedData
				self.receivedData = nil
				self.dataCounter = self.dataCounter + rsz
				do self:onBodyDataReceived(v, rsz) end
			else
				local vsz = self.contentLength - self.dataCounter
				local v = _g.jk.lang.Buffer:getSubBuffer(self.receivedData, 0, vsz, false)
				self.receivedData = _g.jk.lang.Buffer:getSubBuffer(self.receivedData, vsz, rsz - vsz, false)
				self.dataCounter = self.dataCounter + vsz
				do self:onBodyDataReceived(v, vsz) end
			end
		end
		if self.dataCounter >= self.contentLength then
			do self:reset() end
			do self:onEndOfResponse() end
		end
	else
		do self:reset() end
		do self:onEndOfResponse() end
	end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:onHeadersReceived(headers)
	if self.listener ~= nil and self.listener:onResponseReceived(headers) == false then
		if self.listener ~= nil then
			do self.listener:onAborted() end
		end
		self.aborted = true
	end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:onBodyDataReceived(buffer, size)
	if self.listener ~= nil and self.listener:onDataReceived(buffer) == false then
		if self.listener ~= nil then
			do self.listener:onAborted() end
		end
		self.aborted = true
	end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:onEndOfResponse()
	if self.listener ~= nil then
		do self.listener:onResponseCompleted() end
	end
	self.endOfResponse = true
end

function jk.http.client.HTTPClientOperation.MyResponseParser:getListener()
	do return self.listener end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:setListener(v)
	self.listener = v
	do return self end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:getEndOfResponse()
	do return self.endOfResponse end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:setEndOfResponse(v)
	self.endOfResponse = v
	do return self end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:getAborted()
	do return self.aborted end
end

function jk.http.client.HTTPClientOperation.MyResponseParser:setAborted(v)
	self.aborted = v
	do return self end
end

function jk.http.client.HTTPClientOperation:_construct0()
	jk.http.client.HTTPClientOperation._init(self)
	do _g.jk.http.client.HTTPClient._construct0(self) end
	self.receiveBuffer = _util:allocate_buffer(64 * 1024)
	return self
end

function jk.http.client.HTTPClientOperation:openConnection1(protocol, address, aport, listener)
	do self:closeConnection(listener) end
	if _g.jk.lang.String:isEmpty(address) then
		if listener ~= nil then
			do listener:onError("No server address") end
		end
		do return false end
	end
	if not (protocol == "http") and not (protocol == "https") then
		if listener ~= nil then
			do listener:onError("Protocol is invalid: `" .. _g.jk.lang.String:safeString(protocol) .. "'. Must be http or https") end
		end
		do return false end
	end
	do
		local port = aport
		if port < 1 then
			if protocol == "https" then
				port = 443
			else
				port = 80
			end
		end
		if listener ~= nil then
			do listener:onStatus("Connecting to server `" .. _g.jk.lang.String:safeString(address) .. ":" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(port)) .. "' ..") end
		end
		self.openSocket = _g.jk.socket.TCPSocket:createAndConnect(address, port)
		if listener ~= nil then
			do listener:onStatus(nil) end
		end
		if self.openSocket == nil then
			if listener ~= nil then
				do listener:onError("Connection failed: `" .. _g.jk.lang.String:safeString(address) .. ":" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(port)) .. "'") end
			end
			do return false end
		end
		if protocol == "https" then
			self.openSocket = _g.jk.socket.ssl.SSLSocket:forClient(self.openSocket, address, nil, self.acceptInvalidCertificate, nil)
			if self.openSocket == nil and listener ~= nil then
				do listener:onError("FAILED to create SSL socket for HTTPS") end
				do self:closeConnection(listener) end
				do return false end
			end
		end
		self.openSocketProtocol = protocol
		self.openSocketAddress = address
		self.openSocketPort = port
		self.parser = _g.jk.http.client.HTTPClientOperation.MyResponseParser._construct0(_g.jk.http.client.HTTPClientOperation.MyResponseParser._create())
		do return true end
	end
end

function jk.http.client.HTTPClientOperation:openConnection2(request, listener)
	if request == nil then
		if listener ~= nil then
			do listener:onError("No request") end
		end
		do return false end
	end
	do return self:openConnection1(request:getProtocol(), request:getServerAddress(), request:getServerPort(), listener) end
end

function jk.http.client.HTTPClientOperation:closeConnection(listener)
	if not (self.openSocket ~= nil) then
		do return end
	end
	if listener ~= nil then
		do listener:onStatus("Closing connection") end
	end
	do self.openSocket:close() end
	self.openSocket = nil
	self.openSocketProtocol = nil
	self.openSocketAddress = nil
	self.openSocketPort = 0
	self.parser = nil
	if listener ~= nil then
		do listener:onStatus(nil) end
	end
end

function jk.http.client.HTTPClientOperation:sendRequest(request, listener)
	if request == nil then
		if listener ~= nil then
			do listener:onError("No request") end
		end
		do return false end
	end
	if listener ~= nil and listener:onStartRequest(request) == false then
		do return false end
	end
	if self.openSocket ~= nil then
		if not (request:getServerAddress() == self.openSocketAddress) or not (request:getProtocol() == self.openSocketProtocol) or request:getServerPort() ~= self.openSocketPort then
			do self:closeConnection(listener) end
		end
	end
	if self.openSocket == nil then
		do self:openConnection2(request, listener) end
		if not (self.openSocket ~= nil) then
			do return false end
		end
	end
	if listener ~= nil then
		do listener:onStatus("Sending request headers ..") end
	end
	do
		local rqs = request:toString1(self.defaultUserAgent)
		local pww = _g.jk.io.PrintWriterWrapper:forWriter(self.openSocket)
		local whr = pww:print(rqs)
		if listener ~= nil then
			do listener:onStatus(nil) end
		end
		if whr == false then
			if listener ~= nil then
				do listener:onError("Failed to send HTTP request headers") end
			end
			do self:closeConnection(listener) end
			do return false end
		end
		do
			local body = request:getBody()
			if body ~= nil then
				if listener ~= nil then
					do listener:onStatus("Sending request body ..") end
				end
				do
					local rv = true
					local bf = _util:allocate_buffer(4096 * 4)
					while true do
						local r = body:read(bf)
						if r < 1 then
							do break end
						end
						do
							local bw = self.openSocket:write(bf, r)
							if bw < r then
								if listener ~= nil then
									do listener:onError("Failed to send request body (wrote " .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(bw)) .. " bytes out of a " .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(r)) .. " byte packet)") end
								end
								do self:closeConnection(listener) end
								rv = false
								do break end
							end
						end
					end
					if (_vm:to_table_with_key(body, '_isType.jk.lang.Closable') ~= nil) then
						do body:close() end
					end
					if listener ~= nil then
						do listener:onStatus(nil) end
					end
					if rv == false then
						do return false end
					end
				end
			end
			do return true end
		end
	end
end

function jk.http.client.HTTPClientOperation:readResponse(listener, timeout)
	if self.openSocket == nil then
		if listener ~= nil then
			do listener:onError("No open socket") end
		end
		do return false end
	end
	if listener ~= nil then
		do listener:onStatus("Receiving response ..") end
	end
	do
		local rv = true
		do self.parser:setListener(listener) end
		while true do
			local r = 0
			if (_vm:to_table_with_key(self.openSocket, '_isType.jk.socket.ssl.SSLSocket') ~= nil) then
				r = self.openSocket:readWithTimeout(self.receiveBuffer, timeout)
			else
				r = self.openSocket:readWithTimeout(self.receiveBuffer, timeout)
			end
			if r == 0 then
				rv = false
				do break end
			end
			if r < 1 then
				if self.parser.isStream then
					do self.parser:reset() end
					do self.parser:onEndOfResponse() end
					do break end
				end
				do self:closeConnection(listener) end
				if listener ~= nil then
					do listener:onAborted() end
				end
				rv = false
				do break end
			end
			do self.parser:onDataReceived(self.receiveBuffer, r) end
			if self.parser:getAborted() then
				do self:closeConnection(listener) end
				rv = false
				do break end
			end
			if self.parser:getEndOfResponse() then
				do self.parser:reset() end
				rv = true
				do break end
			end
		end
		if self.parser ~= nil then
			do self.parser:setListener(nil) end
		end
		if listener ~= nil then
			do listener:onStatus(nil) end
			if listener:onEndRequest() == false then
				rv = false
			end
		end
		do return rv end
	end
end

function jk.http.client.HTTPClientOperation:executeRequest(request, listener)
	if not self:sendRequest(request, listener) then
		do return end
	end
	if not self:readResponse(listener, 30000) then
		do return end
	end
	if _g.jk.lang.String:equalsIgnoreCase(request:getHeader("connection"), "close") then
		do self:closeConnection(listener) end
	end
end

function jk.http.client.HTTPClientOperation:getDefaultUserAgent()
	do return self.defaultUserAgent end
end

function jk.http.client.HTTPClientOperation:setDefaultUserAgent(v)
	self.defaultUserAgent = v
	do return self end
end

function jk.http.client.HTTPClientOperation:getAcceptInvalidCertificate()
	do return self.acceptInvalidCertificate end
end

function jk.http.client.HTTPClientOperation:setAcceptInvalidCertificate(v)
	self.acceptInvalidCertificate = v
	do return self end
end

jk.http.client.CustomWebClient = _g.jk.web.WebClient._create()
jk.http.client.CustomWebClient.__index = jk.http.client.CustomWebClient
_vm:set_metatable(jk.http.client.CustomWebClient, {
	__index = _g.jk.web.WebClient
})

function jk.http.client.CustomWebClient._create()
	local v = _vm:set_metatable({}, jk.http.client.CustomWebClient)
	return v
end

function jk.http.client.CustomWebClient:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.CustomWebClient'
	self['_isType.jk.http.client.CustomWebClient'] = true
end

function jk.http.client.CustomWebClient:_construct0()
	jk.http.client.CustomWebClient._init(self)
	do _g.jk.web.WebClient._construct0(self) end
	return self
end

jk.http.client.CustomWebClient.MyHTTPClientListener = _g.jk.http.client.HTTPClientListener._create()
jk.http.client.CustomWebClient.MyHTTPClientListener.__index = jk.http.client.CustomWebClient.MyHTTPClientListener
_vm:set_metatable(jk.http.client.CustomWebClient.MyHTTPClientListener, {
	__index = _g.jk.http.client.HTTPClientListener
})

function jk.http.client.CustomWebClient.MyHTTPClientListener._create()
	local v = _vm:set_metatable({}, jk.http.client.CustomWebClient.MyHTTPClientListener)
	return v
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.http.client.CustomWebClient.MyHTTPClientListener'
	self['_isType.jk.http.client.CustomWebClient.MyHTTPClientListener'] = true
	self.listener = nil
	self.response = nil
	self.body = nil
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:_construct0()
	jk.http.client.CustomWebClient.MyHTTPClientListener._init(self)
	do _g.jk.http.client.HTTPClientListener._construct0(self) end
	return self
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:onError(message)
	if self.listener ~= nil then
		do self.listener(nil, nil, _g.jk.lang.String:toUTF8Buffer(message)) end
	end
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:onAborted()
	if self.listener ~= nil then
		do self.listener(nil, nil, _g.jk.lang.String:toUTF8Buffer("aborted")) end
	end
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:onDataReceived(buffer)
	self.body = _g.jk.lang.Buffer:append(self.body, buffer, -1)
	do return true end
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:onResponseReceived(response)
	if not (response ~= nil) then
		do return false end
	end
	self.response = response
	do return true end
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:onResponseCompleted()
	do _g.jk.http.client.HTTPClientListener.onResponseCompleted(self) end
	if self.listener ~= nil then
		do self.listener(self.response:getHttpStatus(), self.response:getRawHeaders(), self.body) end
	end
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:getListener()
	do return self.listener end
end

function jk.http.client.CustomWebClient.MyHTTPClientListener:setListener(v)
	self.listener = v
	do return self end
end

function jk.http.client.CustomWebClient:query(method, url, headers, body, callback)
	local contentType = nil
	if headers ~= nil then
		local array = headers:asVector()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local kvp = array[n + 1]
					if kvp ~= nil then
						if _g.jk.lang.String:equalsIgnoreCase(kvp.key, "Content-Type") then
							contentType = kvp.value
							do break end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do
		local req = nil
		if _g.jk.lang.String:equalsIgnoreCase(method, "GET") then
			req = _g.jk.http.client.HTTPClientRequest:forGET(url)
		elseif _g.jk.lang.String:equalsIgnoreCase(method, "POST") then
			req = _g.jk.http.client.HTTPClientRequest:forPOST3(url, contentType, body)
		elseif _g.jk.lang.String:equalsIgnoreCase(method, "PUT") then
			req = _g.jk.http.client.HTTPClientRequest:forPUT3(url, contentType, body)
		elseif _g.jk.lang.String:equalsIgnoreCase(method, "DELETE") then
			req = _g.jk.http.client.HTTPClientRequest:forDELETE(url)
		else
			do callback(nil, nil, nil) end
			do return end
		end
		if headers ~= nil then
			local array2 = headers:asVector()
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local kvp = array2[n2 + 1]
						if kvp ~= nil then
							if _g.jk.lang.String:equals(kvp.key, "Content-Type") and _g.jk.lang.String:isNotEmpty(req:getHeader("content-type")) then
								goto _continue1
							end
							do req:addHeader(kvp.key, kvp.value) end
						end
						::_continue1::
						do n2 = n2 + 1 end
					end
				end
			end
		end
		do
			local op = _g.jk.http.client.HTTPClientOperation._construct0(_g.jk.http.client.HTTPClientOperation._create())
			do op:setAcceptInvalidCertificate(true) end
			do op:executeRequest(req, _g.jk.http.client.CustomWebClient.MyHTTPClientListener._construct0(_g.jk.http.client.CustomWebClient.MyHTTPClientListener._create()):setListener(callback)) end
			do op:closeConnection(nil) end
		end
	end
end
jk = jk or {}

jk.md5 = jk.md5 or {}

jk.md5.MD5Encoder = {}
jk.md5.MD5Encoder.__index = jk.md5.MD5Encoder
_vm:set_metatable(jk.md5.MD5Encoder, {})

function jk.md5.MD5Encoder._create()
	local v = _vm:set_metatable({}, jk.md5.MD5Encoder)
	return v
end

function jk.md5.MD5Encoder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.md5.MD5Encoder'
	self['_isType.jk.md5.MD5Encoder'] = true
end

function jk.md5.MD5Encoder:_construct0()
	jk.md5.MD5Encoder._init(self)
	return self
end

function jk.md5.MD5Encoder:encodeBuffer(buffer)
	if buffer == nil or _g.jk.lang.Buffer:getSize(buffer) < 1 then
		do return nil end
	end
	do
		local md5 = _g.jk.md5.MD5EncoderGeneric._construct0(_g.jk.md5.MD5EncoderGeneric._create())
		do return md5:encode(buffer) end
	end
end

function jk.md5.MD5Encoder:encodeString(string)
	do return _g.jk.md5.MD5Encoder:encodeBuffer(_g.jk.lang.String:toUTF8Buffer(string)) end
end

function jk.md5.MD5Encoder:encodeObject(obj)
	local bb = _g.jk.lang.Buffer:asBuffer(obj)
	if bb ~= nil then
		do return _g.jk.md5.MD5Encoder:encodeBuffer(bb) end
	end
	do
		local ss = _g.jk.lang.String:asString(obj)
		if ss ~= nil then
			do return _g.jk.md5.MD5Encoder:encodeString(ss) end
		end
		do return nil end
	end
end

jk.md5.MD5EncoderGeneric = {}
jk.md5.MD5EncoderGeneric.__index = jk.md5.MD5EncoderGeneric
_vm:set_metatable(jk.md5.MD5EncoderGeneric, {})

function jk.md5.MD5EncoderGeneric._create()
	local v = _vm:set_metatable({}, jk.md5.MD5EncoderGeneric)
	return v
end

function jk.md5.MD5EncoderGeneric:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.md5.MD5EncoderGeneric'
	self['_isType.jk.md5.MD5EncoderGeneric'] = true
end

function jk.md5.MD5EncoderGeneric:_construct0()
	jk.md5.MD5EncoderGeneric._init(self)
	return self
end

function jk.md5.MD5EncoderGeneric:encode(buf)
	do return self:stringToHex(self:toMD5(buf)) end
end

function jk.md5.MD5EncoderGeneric:toMD5(input)
	do return self:binl2rstr(self:md5(self:rstr2binl(input), _g.jk.lang.Buffer:getSize(input) * 8)) end
end

function jk.md5.MD5EncoderGeneric:stringToHex(input)
	local hexTab = {
		48,
		49,
		50,
		51,
		52,
		53,
		54,
		55,
		56,
		57,
		65,
		66,
		67,
		68,
		69,
		70
	}
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do
		local i = 0
		while i < _g.jk.lang.Buffer:getSize(input) do
			local x = input[i + 1]
			local value1 = hexTab[_vm:bitwise_and(_vm:bitwise_right_shift(x, 4), 15) + 1]
			local value2 = hexTab[_vm:bitwise_and(x, 15) + 1]
			do sb:appendCharacter(value1) end
			do sb:appendCharacter(value2) end
			do i = i + 1 end
		end
	end
	do return _g.jk.lang.String:toLowerCase(sb:toString()) end
end

function jk.md5.MD5EncoderGeneric:md5(input, len)
	if not (input ~= nil) then
		do return nil end
	end
	do
		local x = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		do
			local i = 0
			while i < #input do
				do x:setInteger(_g.jk.lang.String:forInteger(i), input[i + 1]) end
				do i = i + 1 end
			end
		end
		do
			local lenValue = _util:convert_to_integer(len % 32)
			local n = 0
			local value = n + _vm:bitwise_left_shift(128, lenValue)
			local v = _vm:bitwise_or(self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(_vm:bitwise_right_shift(len, 5)), 0), 0), value)
			do x:setInteger(_g.jk.lang.String:forInteger(_vm:bitwise_right_shift(len, 5)), v) end
			do
				local slen = _vm:bitwise_right_shift(len + 64, 9)
				local index = _vm:bitwise_left_shift(slen, 4) + 14
				do x:setInteger(_g.jk.lang.String:forInteger(index), self:unwrap(_vm:bitwise_or(x:getInteger(_g.jk.lang.String:forInteger(index), 0), len), 0)) end
				do
					local a = 1732584193
					local b = -271733879
					local c = -1732584194
					local d = 271733878
					local aa = 0
					local bb = 0
					local cc = 0
					local dd = 0
					do
						local i = 0
						while i < self:getMaxLength(x) do
							aa = a
							bb = b
							cc = c
							dd = d
							a = self:ff(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 0), 0), 0), 7, -680876936)
							d = self:ff(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 1), 0), 0), 12, -389564586)
							c = self:ff(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 2), 0), 0), 17, 606105819)
							b = self:ff(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 3), 0), 0), 22, -1044525330)
							a = self:ff(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 4), 0), 0), 7, -176418897)
							d = self:ff(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 5), 0), 0), 12, 1200080426)
							c = self:ff(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 6), 0), 0), 17, -1473231341)
							b = self:ff(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 7), 0), 0), 22, -45705983)
							a = self:ff(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 8), 0), 0), 7, 1770035416)
							d = self:ff(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 9), 0), 0), 12, -1958414417)
							c = self:ff(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 10), 0), 0), 17, -42063)
							b = self:ff(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 11), 0), 0), 22, -1990404162)
							a = self:ff(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 12), 0), 0), 7, 1804603682)
							d = self:ff(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 13), 0), 0), 12, -40341101)
							c = self:ff(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 14), 0), 0), 17, -1502002290)
							b = self:ff(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 15), 0), 0), 22, 1236535329)
							a = self:gg(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 1), 0), 0), 5, -165796510)
							d = self:gg(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 6), 0), 0), 9, -1069501632)
							c = self:gg(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 11), 0), 0), 14, 643717713)
							b = self:gg(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 0), 0), 0), 20, -373897302)
							a = self:gg(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 5), 0), 0), 5, -701558691)
							d = self:gg(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 10), 0), 0), 9, 38016083)
							c = self:gg(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 15), 0), 0), 14, -660478335)
							b = self:gg(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 4), 0), 0), 20, -405537848)
							a = self:gg(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 9), 0), 0), 5, 568446438)
							d = self:gg(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 14), 0), 0), 9, -1019803690)
							c = self:gg(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 3), 0), 0), 14, -187363961)
							b = self:gg(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 8), 0), 0), 20, 1163531501)
							a = self:gg(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 13), 0), 0), 5, -1444681467)
							d = self:gg(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 2), 0), 0), 9, -51403784)
							c = self:gg(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 7), 0), 0), 14, 1735328473)
							b = self:gg(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 12), 0), 0), 20, -1926607734)
							a = self:hh(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 5), 0), 0), 4, -378558)
							d = self:hh(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 8), 0), 0), 11, -2022574463)
							c = self:hh(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 11), 0), 0), 16, 1839030562)
							b = self:hh(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 14), 0), 0), 23, -35309556)
							a = self:hh(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 1), 0), 0), 4, -1530992060)
							d = self:hh(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 4), 0), 0), 11, 1272893353)
							c = self:hh(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 7), 0), 0), 16, -155497632)
							b = self:hh(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 10), 0), 0), 23, -1094730640)
							a = self:hh(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 13), 0), 0), 4, 681279174)
							d = self:hh(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 0), 0), 0), 11, -358537222)
							c = self:hh(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 3), 0), 0), 16, -722521979)
							b = self:hh(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 6), 0), 0), 23, 76029189)
							a = self:hh(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 9), 0), 0), 4, -640364487)
							d = self:hh(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 12), 0), 0), 11, -421815835)
							c = self:hh(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 15), 0), 0), 16, 530742520)
							b = self:hh(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 2), 0), 0), 23, -995338651)
							a = self:ii(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 0), 0), 0), 6, -198630844)
							d = self:ii(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 7), 0), 0), 10, 1126891415)
							c = self:ii(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 14), 0), 0), 15, -1416354905)
							b = self:ii(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 5), 0), 0), 21, -57434055)
							a = self:ii(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 12), 0), 0), 6, 1700485571)
							d = self:ii(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 3), 0), 0), 10, -1894986606)
							c = self:ii(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 10), 0), 0), 15, -1051523)
							b = self:ii(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 1), 0), 0), 21, -2054922799)
							a = self:ii(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 8), 0), 0), 6, 1873313359)
							d = self:ii(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 15), 0), 0), 10, -30611744)
							c = self:ii(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 6), 0), 0), 15, -1560198380)
							b = self:ii(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 13), 0), 0), 21, 1309151649)
							a = self:ii(a, b, c, d, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 4), 0), 0), 6, -145523070)
							d = self:ii(d, a, b, c, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 11), 0), 0), 10, -1120210379)
							c = self:ii(c, d, a, b, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 2), 0), 0), 15, 718787259)
							b = self:ii(b, c, d, a, self:unwrap(x:getInteger(_g.jk.lang.String:forInteger(i + 9), 0), 0), 21, -343485551)
							a = self:addUnsigned(a, aa)
							b = self:addUnsigned(b, bb)
							c = self:addUnsigned(c, cc)
							d = self:addUnsigned(d, dd)
							i = i + 16
						end
					end
					do
						local ret = _vm:allocate_array(4)
						ret[0 + 1] = a
						ret[1 + 1] = b
						ret[2 + 1] = c
						ret[3 + 1] = d
						do return ret end
					end
				end
			end
		end
	end
end

function jk.md5.MD5EncoderGeneric:getMaxLength(dm)
	local i = 0
	local keys = dm:getKeys()
	if keys ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(keys)
		do
			n = 0
			while n < m do
				local v = keys[n + 1]
				if v ~= nil then
					local key = _g.jk.lang.String:toInteger(v)
					if key > i then
						i = key
					end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local v = i + 1
		do return v end
	end
end

function jk.md5.MD5EncoderGeneric:rstr2binl(input)
	if not (input ~= nil) then
		do return nil end
	end
	do
		local output = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		do
			local i = 0
			while i < _g.jk.lang.Buffer:getSize(input) * 8 do
				local value = _vm:bitwise_left_shift(_vm:bitwise_and(input[_util:convert_to_integer(i / 8) + 1], 255), _util:convert_to_integer(i % 32))
				local x = _vm:bitwise_right_shift(i, 5)
				local y = 0
				if output:containsKey(_g.jk.lang.String:forInteger(x)) then
					y = output:getInteger(_g.jk.lang.String:forInteger(x), 0)
				end
				do output:setInteger(_g.jk.lang.String:forInteger(x), _vm:bitwise_or(self:unwrap(y, 0), value)) end
				i = i + 8
			end
		end
		do return self:dictionary2array(output) end
	end
end

function jk.md5.MD5EncoderGeneric:binl2rstr(input)
	local output = _vm:allocate_array(16)
	do
		local i = 0
		while i < #input * 32 do
			local value = self:zeroFillRightShift(input[_vm:bitwise_right_shift(i, 5) + 1], _vm:bitwise_and(_util:convert_to_integer(i % 32), 255))
			output[_util:convert_to_integer(i / 8) + 1] = value
			i = i + 8
		end
	end
	do
		local ret = _util:allocate_buffer(16)
		do
			local i = 0
			while i < #output do
				ret[i + 1] = output[i + 1]
				do i = i + 1 end
			end
		end
		do return ret end
	end
end

function jk.md5.MD5EncoderGeneric:addUnsigned(x, y)
	do return x + y end
end

function jk.md5.MD5EncoderGeneric:rotateLeft(num, cnt)
	local value = _vm:bitwise_or(_vm:bitwise_and(_vm:bitwise_left_shift(num, cnt), 4294967295), self:zeroFillRightShift(num, 32 - cnt))
	do return value end
end

function jk.md5.MD5EncoderGeneric:cmn(q, a, b, x, s, t)
	do return self:addUnsigned(self:rotateLeft(self:addUnsigned(self:addUnsigned(a, q), self:addUnsigned(x, t)), s), b) end
end

function jk.md5.MD5EncoderGeneric:ff(a, b, c, d, x, s, t)
	do return self:cmn(_vm:bitwise_or(_vm:bitwise_and(b, c), _vm:bitwise_and(_vm:bitwise_not(b), d)), a, b, x, s, t) end
end

function jk.md5.MD5EncoderGeneric:gg(a, b, c, d, x, s, t)
	do return self:cmn(_vm:bitwise_or(_vm:bitwise_and(b, d), _vm:bitwise_and(c, _vm:bitwise_not(d))), a, b, x, s, t) end
end

function jk.md5.MD5EncoderGeneric:hh(a, b, c, d, x, s, t)
	do return self:cmn(_vm:bitwise_xor(_vm:bitwise_xor(b, c), d), a, b, x, s, t) end
end

function jk.md5.MD5EncoderGeneric:ii(a, b, c, d, x, s, t)
	do return self:cmn(_vm:bitwise_xor(c, _vm:bitwise_or(b, _vm:bitwise_not(d))), a, b, x, s, t) end
end

function jk.md5.MD5EncoderGeneric:dictionary2array(dic)
	local arr = _vm:allocate_array(dic:getCount())
	do
		local i = 0
		while i < dic:getCount() do
			arr[i + 1] = self:unwrap(dic:getInteger(_g.jk.lang.String:forInteger(i), 0), 0)
			do i = i + 1 end
		end
	end
	do return arr end
end

function jk.md5.MD5EncoderGeneric:unwrap(value, fallback)
	if value ~= 0 then
		do return value end
	end
	do return fallback end
end

function jk.md5.MD5EncoderGeneric:zeroFillRightShift(num, count)
	local value = _vm:bitwise_right_shift(_vm:bitwise_and(num, 4294967295), count)
	do return value end
end
sling = sling or {}

sling.compiler = sling.compiler or {}

sling.compiler.PropertyVariableExpander = {}
sling.compiler.PropertyVariableExpander.__index = sling.compiler.PropertyVariableExpander
_vm:set_metatable(sling.compiler.PropertyVariableExpander, {})

function sling.compiler.PropertyVariableExpander._create()
	local v = _vm:set_metatable({}, sling.compiler.PropertyVariableExpander)
	return v
end

function sling.compiler.PropertyVariableExpander:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.PropertyVariableExpander'
	self['_isType.sling.compiler.PropertyVariableExpander'] = true
end

function sling.compiler.PropertyVariableExpander:_construct0()
	sling.compiler.PropertyVariableExpander._init(self)
	return self
end

function sling.compiler.PropertyVariableExpander:modifyName(prefix, name)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(prefix) end
	do
		local c0 = _g.jk.lang.String:getChar(name, 0)
		if c0 >= 97 and c0 <= 122 then
			do sb:appendCharacter(c0 - 97 + 65) end
			do sb:appendString(_g.jk.lang.String:getEndOfString(name, 1)) end
		else
			do sb:appendString(name) end
		end
		do return sb:toString() end
	end
end

function sling.compiler.PropertyVariableExpander:execute(root, resolver)
	local array = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.VariableDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local vd = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
				if vd ~= nil then
					if vd:hasModifier(_g.sling.model.Modifier.PROPERTY) == false then
						goto _continue1
					end
					do
						local name = vd:getNodeName()
						if _g.jk.lang.String:isEmpty(name) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty name", vd, nil))
						end
						do
							local dt = vd:getType()
							if not (dt ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No datatype", vd, nil))
							end
							if (_vm:to_table_with_key(dt, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
								local init = vd:getInitializer()
								if not (init ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to determine declaration data type (missing initializer)", vd, nil))
								end
								dt = _g.sling.util.ExpressionUtil:getExpressionDataType(init, resolver)
								if not (dt ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to determine expression data type", init, nil))
								end
							end
							do
								local parentNode = vd:getParent()
								if not (parentNode ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Declaration has no parent", vd, nil))
								end
								do
									local pp = _vm:to_table_with_key(parentNode, '_isType.sling.model.EntityDeclarationNode')
									if not (pp ~= nil) then
										local error = _g.sling.common.ReferenceError:forMessage("Property declaration is not enclosed inside an entity", vd, nil)
										do error:addRelatedMessage("This is the parent of the declaration", parentNode) end
										_vm:throw_error(error)
									end
									do
										local visibility = nil
										if vd:hasModifier(_g.sling.model.Modifier.PUBLIC) then
											visibility = _g.sling.model.Modifier.PUBLIC
										elseif vd:hasModifier(_g.sling.model.Modifier.PROTECTED) then
											visibility = _g.sling.model.Modifier.PROTECTED
										elseif vd:hasModifier(_g.sling.model.Modifier.PRIVATE) then
											visibility = _g.sling.model.Modifier.PRIVATE
										end
										if not (visibility ~= nil) then
											visibility = _g.sling.model.Modifier.PUBLIC
										end
										do
											local doGetter = true
											local doSetter = true
											local isVirtual = false
											local isGetOverride = false
											local isSetOverride = false
											if vd:hasModifier(_g.sling.model.Modifier.FINAL) or vd:hasModifier(_g.sling.model.Modifier.READONLY) then
												doSetter = false
											end
											if vd:hasModifier(_g.sling.model.Modifier.VIRTUAL) then
												isVirtual = true
											end
											if vd:hasModifier(_g.sling.model.Modifier.OVERRIDE) then
												isGetOverride = true
												isSetOverride = true
											else
												if vd:hasCustomModifier("getOverride") then
													isGetOverride = true
												end
												if vd:hasCustomModifier("setOverride") then
													isSetOverride = true
												end
											end
											do
												local settername = self:modifyName("set", name)
												local gettername = self:modifyName("get", name)
												if doGetter and _g.sling.util.EntityUtil:methodExists(pp, gettername) then
													doGetter = false
												end
												if doSetter and _g.sling.util.EntityUtil:methodExists(pp, settername) then
													doSetter = false
												end
												if doGetter then
													local gf = _g.sling.model.FunctionDeclarationNode:forName(gettername, false)
													do gf:setSource(vd:getSource()) end
													do gf:addCustomModifier("getterMethod") end
													do
														local dtd = _g.sling.util.DataTypeUtil:dupAsDataType(dt)
														do gf:setReturnType(dtd, false) end
														do gf:addModifier(visibility) end
														if isVirtual then
															do gf:addModifier(_g.sling.model.Modifier.VIRTUAL) end
														end
														if isGetOverride then
															do gf:addModifier(_g.sling.model.Modifier.OVERRIDE) end
														end
														do _g.sling.util.FunctionUtil:addStatement(gf, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName(name))) end
														do pp:addNode(gf) end
													end
												end
												if doSetter then
													local isDynamic = false
													local isStrict = false
													if vd:hasCustomModifier("dynamic") then
														isDynamic = true
														if vd:hasCustomModifier("strict") then
															isStrict = true
														end
													end
													do
														local sf = _g.sling.model.FunctionDeclarationNode:forName(settername, false)
														do sf:setSource(vd:getSource()) end
														do sf:addCustomModifier("setterMethod") end
														do sf:setReturnType(_g.sling.model.ReferenceDataTypeNode:forNode(pp, nil), false) end
														do sf:addModifier(visibility) end
														if isVirtual then
															do sf:addModifier(_g.sling.model.Modifier.VIRTUAL) end
														end
														if isSetOverride then
															do sf:addModifier(_g.sling.model.Modifier.OVERRIDE) end
														end
														do
															local dtd = nil
															if isDynamic then
																dtd = _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create())
															else
																dtd = _g.sling.util.DataTypeUtil:dupAsDataType(dt)
															end
															do
																local param = _g.sling.model.VariableDeclarationNode:instance(dtd, "v", nil)
																if vd:hasCustomModifier("notLiteral") then
																	do param:addCustomModifier("notLiteral") end
																end
																do sf:addToParameters(param) end
																do
																	local valuexpr = _g.sling.model.SymbolExpressionNode:forName("v")
																	if isDynamic then
																		valuexpr = _g.sling.compiler.JkopOps:createDynamicConverterExpression(valuexpr, dt, resolver)
																	end
																	do _g.sling.util.FunctionUtil:addStatement(sf, _g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName(name), valuexpr)) end
																	if isStrict then
																		local cc = _g.sling.model.LogicalNotExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forName(name))
																		local stmt = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("Error"), "throw", true)
																		do stmt:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue("not_" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(dt)))) end
																		do stmt:addToParameters(_g.sling.model.SymbolExpressionNode:forName("v")) end
																		do _g.sling.util.FunctionUtil:addStatement(sf, _g.sling.model.IfStatementNode:forStatement(cc, stmt)) end
																	end
																	do _g.sling.util.FunctionUtil:addStatement(sf, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create()))) end
																	do pp:addNode(sf) end
																end
															end
														end
													end
												end
												do vd:removeModifier(_g.sling.model.Modifier.PROPERTY) end
												do vd:removeModifier(visibility) end
												do vd:addModifier(_g.sling.model.Modifier.PRIVATE) end
											end
										end
									end
								end
							end
						end
					end
				end
				::_continue1::
				do n = n + 1 end
			end
		end
	end
end

sling.compiler.DynamicModelExpander = {}
sling.compiler.DynamicModelExpander.__index = sling.compiler.DynamicModelExpander
_vm:set_metatable(sling.compiler.DynamicModelExpander, {})

function sling.compiler.DynamicModelExpander._create()
	local v = _vm:set_metatable({}, sling.compiler.DynamicModelExpander)
	return v
end

function sling.compiler.DynamicModelExpander:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.DynamicModelExpander'
	self['_isType.sling.compiler.DynamicModelExpander'] = true
end

function sling.compiler.DynamicModelExpander:_construct0()
	sling.compiler.DynamicModelExpander._init(self)
	return self
end

sling.compiler.DynamicModelExpander.ModelNodeFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.DynamicModelExpander.ModelNodeFinder.__index = sling.compiler.DynamicModelExpander.ModelNodeFinder
_vm:set_metatable(sling.compiler.DynamicModelExpander.ModelNodeFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.DynamicModelExpander.ModelNodeFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.DynamicModelExpander.ModelNodeFinder)
	return v
end

function sling.compiler.DynamicModelExpander.ModelNodeFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.DynamicModelExpander.ModelNodeFinder'
	self['_isType.sling.compiler.DynamicModelExpander.ModelNodeFinder'] = true
	self.results = {}
end

function sling.compiler.DynamicModelExpander.ModelNodeFinder:_construct0()
	sling.compiler.DynamicModelExpander.ModelNodeFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.DynamicModelExpander.ModelNodeFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ModelDeclarationNode') ~= nil) and node:hasCustomModifier("dynamic") then
		do _g.jk.lang.Vector:append(self.results, node) end
	end
	do return true end
end

function sling.compiler.DynamicModelExpander.ModelNodeFinder:getResults()
	do return self.results end
end

function sling.compiler.DynamicModelExpander.ModelNodeFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.compiler.DynamicModelExpander:dataTypeToSymbolExpression(type)
	local refdt = _vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode')
	if not (refdt ~= nil) then
		do return nil end
	end
	do
		local sym = refdt:getSymbol()
		if not (sym ~= nil) then
			do return nil end
		end
		do
			local symdup = _vm:to_table_with_key(sym:dup(), '_isType.sling.model.SymbolNode')
			if not (symdup ~= nil) then
				do return nil end
			end
			do return _g.sling.model.SymbolExpressionNode:forSymbol(symdup) end
		end
	end
end

function sling.compiler.DynamicModelExpander:isDynamicMap(type)
	local symbolName = _g.sling.util.DataTypeUtil:getSymbolName(type)
	if not (symbolName ~= nil) then
		do return false end
	end
	if symbolName == "DynamicMap" then
		do return true end
	end
	do return false end
end

function sling.compiler.DynamicModelExpander:isDynamicVector(type)
	local symbolName = _g.sling.util.DataTypeUtil:getSymbolName(type)
	if not (symbolName ~= nil) then
		do return false end
	end
	if symbolName == "DynamicVector" then
		do return true end
	end
	do return false end
end

function sling.compiler.DynamicModelExpander:isLongInteger(type)
	local idt = _vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode')
	if not (idt ~= nil) then
		do return false end
	end
	do
		local type = idt:getType()
		if type == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or type == _g.sling.model.IntegerDataTypeNode.TYPE_ULONG or type == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 or type == _g.sling.model.IntegerDataTypeNode.TYPE_UINT64 then
			do return true end
		end
		do return false end
	end
end

function sling.compiler.DynamicModelExpander:execute(root)
	if not (root ~= nil) then
		do return end
	end
	do
		local cf = _g.sling.compiler.DynamicModelExpander.ModelNodeFinder._construct0(_g.sling.compiler.DynamicModelExpander.ModelNodeFinder._create())
		if not root:accept(cf) then
			do return end
		end
		do
			local array = cf:getResults()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local model = array[n + 1]
						if model ~= nil then
							local cdecl = _g.sling.model.ClassDeclarationNode:forName(model:getNodeName())
							do cdecl:setSource(model:getSource()) end
							do cdecl:setDescription(model:getDescription()) end
							do cdecl:copyModifiersFrom(model) end
							do cdecl:removeCustomModifier("dynamic") end
							if (_vm:to_table_with_key(model:getParent(), '_isType.sling.model.EntityDeclarationNode') ~= nil) then
								do cdecl:addModifier(_g.sling.model.Modifier.STATIC) end
							end
							do cdecl:setDependencies(model:getDependencies()) end
							do cdecl:setImportNamespaces(model:exportImportNamespaces(), false) end
							do cdecl:setImportEntities(model:exportImportEntities(), false) end
							do
								local fields = {}
								local array2 = model:getNodes()
								if array2 ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(array2)
									do
										n2 = 0
										while n2 < m2 do
											local variable = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
											if variable ~= nil then
												local pd = _g.sling.model.ext.NSlingPropertyDeclaration._construct0(_g.sling.model.ext.NSlingPropertyDeclaration._create())
												local propertyName = variable:getName()
												local encodedName = variable:getParamName()
												if _g.jk.lang.String:isEmpty(encodedName) then
													encodedName = propertyName
												end
												do pd:setName(propertyName) end
												do pd:setDescription(variable:getDescription()) end
												do pd:setSource(variable:getSource()) end
												do
													local originaltype = variable:getType()
													if (_vm:to_table_with_key(originaltype, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
														local pt = originaltype:getPrimaryType()
														if not (pt ~= nil) then
															_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No primary type", originaltype, nil))
														end
														do pd:setType(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.util.DataTypeUtil:dupAsDataType(pt)), false) end
													else
														do pd:setType(_g.sling.util.DataTypeUtil:dupAsDataType(originaltype), false) end
													end
													do
														local newtype = pd:getType()
														do pd:setDescription(variable:getDescription()) end
														do
															local getter = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
															if (_vm:to_table_with_key(newtype, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getString", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
																if self:isLongInteger(newtype) then
																	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getLongInteger", false)
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																else
																	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getInteger", false)
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getDouble", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getBoolean", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getBuffer", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
															elseif self:isDynamicMap(newtype) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getDynamicMap", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
															elseif self:isDynamicVector(newtype) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getDynamicVector", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
																local vdt = newtype
																local pdt = vdt:getPrimaryType()
																if (_vm:to_table_with_key(pdt, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																	local fc = _g.sling.model.FunctionCallExpressionNode:forName("getFieldAsStringVector")
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
																	if self:isLongInteger(pdt) then
																		local fc = _g.sling.model.FunctionCallExpressionNode:forName("getFieldAsLongIntegerVector")
																		do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																		do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																	else
																		local fc = _g.sling.model.FunctionCallExpressionNode:forName("getFieldAsIntegerVector")
																		do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																		do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																	end
																elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
																	local fc = _g.sling.model.FunctionCallExpressionNode:forName("getFieldAsDoubleVector")
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
																	local fc = _g.sling.model.FunctionCallExpressionNode:forName("getFieldAsBooleanVector")
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																	local fc = _g.sling.model.FunctionCallExpressionNode:forName("RETURN_VECTOR_FIELD_OBJECTS")
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do fc:addToParameters(self:dataTypeToSymbolExpression(pdt)) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																else
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported vector getter data type", pdt, nil))
																end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																local gdmfc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "getDynamicMap", false)
																do gdmfc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do
																	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(self:dataTypeToSymbolExpression(newtype), "forData", false)
																	do fc:addToParameters(gdmfc) end
																	do getter:addNode(_g.sling.model.ReturnStatementNode:forExpression(fc)) end
																end
															else
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported getter data type", newtype, nil))
															end
															do _g.sling.syntax.SlingNodeUtil:setPropertyGetterAsBlock(pd, pd:getSource(), getter, newtype) end
														end
														do
															local setter = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
															if (_vm:to_table_with_key(newtype, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setString", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
																if self:isLongInteger(newtype) then
																	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setLongInteger", false)
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																	do setter:addNode(fc) end
																else
																	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setInteger", false)
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																	do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																	do setter:addNode(fc) end
																end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setDouble", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setBoolean", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setBuffer", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forName("SET_VECTOR_FIELD")
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif self:isDynamicMap(newtype) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setObject", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif self:isDynamicVector(newtype) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setObject", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																do setter:addNode(fc) end
															elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("data"), "setObject", false)
																do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(encodedName)) end
																do
																	local vfc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("DynamicModel"), "asDynamicMap", false)
																	do vfc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																	do fc:addToParameters(vfc) end
																	do setter:addNode(fc) end
																end
															else
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported setter data type", newtype, nil))
															end
															do _g.sling.syntax.SlingNodeUtil:setPropertySetterAsBlock(pd, pd:getSource(), setter, newtype, "value") end
														end
														if (_vm:to_table_with_key(newtype, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
															local vdt = newtype
															local pdt = vdt:getPrimaryType()
															if not (pdt ~= nil) then
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No primary type", vdt, nil))
															end
															do
																local fname = _g.sling.common.CodeStringUtil:combineCamelCase({
																	"addTo",
																	propertyName
																})
																local addto = _g.sling.model.FunctionDeclarationNode:forName(fname, false)
																do addto:addModifier(_g.sling.model.Modifier.PUBLIC) end
																do addto:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(pdt), "value", nil)) end
																do
																	local cfname = nil
																	if (_vm:to_table_with_key(pdt, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																		cfname = "addStringToVectorField"
																	elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
																		if self:isLongInteger(pdt) then
																			cfname = "addLongIntegerToVectorField"
																		else
																			cfname = "addIntegerToVectorField"
																		end
																	elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
																		cfname = "addDoubleToVectorField"
																	elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
																		cfname = "addBooleanToVectorField"
																	elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
																		cfname = "addBufferToVectorField"
																	elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
																		cfname = "addObjectToVectorField"
																	elseif (_vm:to_table_with_key(pdt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																		cfname = "addObjectToVectorField"
																	else
																		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type in addTo method", pdt, nil))
																	end
																	do
																		local fc = _g.sling.model.FunctionCallExpressionNode:forName(cfname)
																		do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(propertyName)) end
																		do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("value")) end
																		do _g.sling.util.FunctionUtil:addStatement(addto, fc) end
																		do cdecl:addNode(addto) end
																	end
																end
															end
														end
														do
															local field = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
															local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("DynamicModelField"), "o", _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("DynamicModelField")))
															do field:addNode(vd) end
															do field:addNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.MemberAccessExpressionNode:forSymbolNames("o", "name"), _g.sling.model.StringLiteralExpressionNode:forValue(propertyName))) end
															do field:addNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.MemberAccessExpressionNode:forSymbolNames("o", "encodedName"), _g.sling.model.StringLiteralExpressionNode:forValue(encodedName))) end
															do
																local typename = nil
																if (_vm:to_table_with_key(newtype, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																	typename = "TYPE_STRING"
																elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
																	if self:isLongInteger(newtype) then
																		typename = "TYPE_LONG_INTEGER"
																	else
																		typename = "TYPE_INTEGER"
																	end
																elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
																	typename = "TYPE_DOUBLE"
																elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
																	typename = "TYPE_BOOLEAN"
																elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
																	typename = "TYPE_BUFFER"
																elseif self:isDynamicMap(newtype) then
																	typename = "TYPE_MAP"
																elseif self:isDynamicVector(newtype) then
																	typename = "TYPE_VECTOR"
																elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
																	typename = "TYPE_VECTOR"
																elseif (_vm:to_table_with_key(newtype, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																	typename = "TYPE_OBJECT"
																else
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type when determining data type", newtype, nil))
																end
																do field:addNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.MemberAccessExpressionNode:forSymbolNames("o", "type"), _g.sling.model.MemberAccessExpressionNode:forSymbolNames("DynamicModelField", typename))) end
																do field:addNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.MemberAccessExpressionNode:forSymbolNames("o", "description"), _g.sling.model.StringLiteralExpressionNode:forValue(pd:getDescription()))) end
																do
																	local array3 = variable:getAllCustomModifiers()
																	if array3 ~= nil then
																		local n3 = 0
																		local m3 = _g.jk.lang.Vector:getSize(array3)
																		do
																			n3 = 0
																			while n3 < m3 do
																				local mod = array3[n3 + 1]
																				if mod ~= nil then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("o"), "addToTags", false)
																					do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(mod)) end
																					do field:addNode(fc) end
																				end
																				do n3 = n3 + 1 end
																			end
																		end
																	end
																	do field:addNode(_g.sling.model.AdditionAssignmentExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName("v"), _g.sling.model.SymbolExpressionNode:forName("o"))) end
																	do _g.jk.lang.Vector:append(fields, field) end
																end
															end
														end
														do cdecl:addNode(pd) end
													end
												end
											end
											do n2 = n2 + 1 end
										end
									end
								end
								do cdecl:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
									"jk",
									"model"
								})) end
								do cdecl:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("DynamicModel"), 0)) end
								do
									local forData = _g.sling.model.FunctionDeclarationNode:forName("forData", false)
									do forData:addModifier(_g.sling.model.Modifier.PUBLIC) end
									do forData:addModifier(_g.sling.model.Modifier.STATIC) end
									do forData:setReturnType(_g.sling.model.ReferenceDataTypeNode:forNode(cdecl, nil), false) end
									do forData:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("DynamicMap"), "data", nil)) end
									do _g.sling.util.FunctionUtil:addStatement(forData, _g.sling.model.AssertStatementNode:forChild(_g.sling.model.SymbolExpressionNode:forName("data"))) end
									do
										local xob = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()))
										do xob:addToParameters(_g.sling.model.SymbolExpressionNode:forName("data")) end
										do _g.sling.util.FunctionUtil:addStatement(forData, _g.sling.model.ReturnStatementNode:forExpression(xob)) end
										do cdecl:addNode(forData) end
									end
								end
								do
									local gfi = _g.sling.model.FunctionDeclarationNode:forName("getFieldInformation", false)
									do gfi:addModifier(_g.sling.model.Modifier.PUBLIC) end
									do gfi:addModifier(_g.sling.model.Modifier.OVERRIDE) end
									do gfi:setReturnType(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ReferenceDataTypeNode:forName("DynamicModelField")), false) end
									do
										local vdinit = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ReferenceDataTypeNode:forName("DynamicModelField")))
										local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ReferenceDataTypeNode:forName("DynamicModelField")), "v", vdinit)
										do _g.sling.util.FunctionUtil:addStatement(gfi, vd) end
										if fields ~= nil then
											local n4 = 0
											local m4 = _g.jk.lang.Vector:getSize(fields)
											do
												n4 = 0
												while n4 < m4 do
													local field = fields[n4 + 1]
													if field ~= nil then
														do _g.sling.util.FunctionUtil:addStatement(gfi, field) end
													end
													do n4 = n4 + 1 end
												end
											end
										end
										do _g.sling.util.FunctionUtil:addStatement(gfi, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("v"))) end
										do cdecl:addNode(gfi) end
									end
								end
								do
									local metadata = model:getMetadata()
									if _g.jk.lang.String:isNotEmpty(metadata) then
										local gmm = _g.sling.model.FunctionDeclarationNode:forName("getModelMetadata", false)
										do gmm:addModifier(_g.sling.model.Modifier.PUBLIC) end
										do gmm:addModifier(_g.sling.model.Modifier.OVERRIDE) end
										do gmm:setReturnType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
										do _g.sling.util.FunctionUtil:addStatement(gmm, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.StringLiteralExpressionNode:forValue(metadata))) end
										do cdecl:addNode(gmm) end
									end
									do model:replaceWith(cdecl, false) end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
end

sling.compiler.LibraryManager = {}
sling.compiler.LibraryManager.__index = sling.compiler.LibraryManager
_vm:set_metatable(sling.compiler.LibraryManager, {})

function sling.compiler.LibraryManager._create()
	local v = _vm:set_metatable({}, sling.compiler.LibraryManager)
	return v
end

function sling.compiler.LibraryManager:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.LibraryManager'
	self['_isType.sling.compiler.LibraryManager'] = true
	self.directory = nil
	self.forcedLibraryVersions = {}
end

function sling.compiler.LibraryManager:_construct0()
	sling.compiler.LibraryManager._init(self)
	return self
end

function sling.compiler.LibraryManager:substituteCustomLibraries(libraries, customlibs)
	if _g.jk.lang.Vector:isEmpty(customlibs) then
		do return libraries end
	end
	do
		local v = {}
		local used = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
		if libraries ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(libraries)
			do
				n = 0
				while n < m do
					local lib = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(libraries[n + 1])
					if lib ~= nil then
						local library = lib
						local libname = _g.sling.compiler.LibraryName:parse(library)
						if libname ~= nil then
							if customlibs ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(customlibs)
								do
									n2 = 0
									while n2 < m2 do
										local clibname = customlibs[n2 + 1]
										if clibname ~= nil then
											if libname:getNamespace() == clibname:getNamespace() and libname:getName() == clibname:getName() then
												library = clibname:toString()
												do used:add(library) end
												do break end
											end
										end
										do n2 = n2 + 1 end
									end
								end
							end
						end
						do _g.jk.lang.Vector:append(v, library) end
					end
					do n = n + 1 end
				end
			end
		end
		if customlibs ~= nil then
			local n3 = 0
			local m3 = _g.jk.lang.Vector:getSize(customlibs)
			do
				n3 = 0
				while n3 < m3 do
					local clibname = customlibs[n3 + 1]
					if clibname ~= nil then
						local customlib = clibname:toString()
						if not used:contains(customlib) then
							do _g.jk.lang.Vector:append(v, customlib) end
						end
					end
					do n3 = n3 + 1 end
				end
			end
		end
		do return v end
	end
end

function sling.compiler.LibraryManager:getPlatformName()
end

function sling.compiler.LibraryManager:getLinkTargetFile(directory, moduleName)
end

function sling.compiler.LibraryManager:getLibraryDirectory()
	if not (self.directory ~= nil) then
		do return nil end
	end
	do
		local pname = self:getPlatformName()
		if not _g.jk.lang.String:isNotEmpty(pname) then
			do return nil end
		end
		do return self.directory:entry(pname) end
	end
end

function sling.compiler.LibraryManager:setForcedLibraryVersion(id, version)
	if not (id ~= nil) then
		do return end
	end
	self.forcedLibraryVersions[id] = version
end

sling.compiler.LibraryManager.RepositoryUrl = {}
sling.compiler.LibraryManager.RepositoryUrl.__index = sling.compiler.LibraryManager.RepositoryUrl
_vm:set_metatable(sling.compiler.LibraryManager.RepositoryUrl, {})

function sling.compiler.LibraryManager.RepositoryUrl._create()
	local v = _vm:set_metatable({}, sling.compiler.LibraryManager.RepositoryUrl)
	return v
end

function sling.compiler.LibraryManager.RepositoryUrl:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.LibraryManager.RepositoryUrl'
	self['_isType.sling.compiler.LibraryManager.RepositoryUrl'] = true
	self.url = nil
	self.authKey = nil
end

function sling.compiler.LibraryManager.RepositoryUrl:_construct0()
	sling.compiler.LibraryManager.RepositoryUrl._init(self)
	return self
end

function sling.compiler.LibraryManager.RepositoryUrl:forUrlString(str)
	local v = _g.sling.compiler.LibraryManager.RepositoryUrl._construct0(_g.sling.compiler.LibraryManager.RepositoryUrl._create())
	local uu = _g.jk.url.URL:forString(str, false)
	local username = uu:getUsername()
	if _g.jk.lang.String:isNotEmpty(username) then
		do uu:setUsername(nil) end
		do uu:setPassword(nil) end
		do v:setUrl(uu:toString()) end
		do v:setAuthKey(username) end
	else
		do v:setUrl(str) end
		do v:setAuthKey(nil) end
	end
	do return v end
end

function sling.compiler.LibraryManager.RepositoryUrl:getUrl()
	do return self.url end
end

function sling.compiler.LibraryManager.RepositoryUrl:setUrl(v)
	self.url = v
	do return self end
end

function sling.compiler.LibraryManager.RepositoryUrl:getAuthKey()
	do return self.authKey end
end

function sling.compiler.LibraryManager.RepositoryUrl:setAuthKey(v)
	self.authKey = v
	do return self end
end

function sling.compiler.LibraryManager:readRepositoryConfigFile(ctx, map)
	if not (map ~= nil) then
		do return nil end
	end
	if not map:isFile() then
		do _g.jk.log.Log:debug(ctx, "Repository map does not exist: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(map)) .. "'") end
		do return nil end
	end
	do _g.jk.log.Log:debug(ctx, "Reading repository map: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(map)) .. "'") end
	do
		local mapdata = _vm:to_table_with_key(_g.jk.json.JSONParser:parseFile(map), '_isType.jk.lang.DynamicMap')
		if not (mapdata ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read repository map: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(map)) .. "'", nil, nil))
		end
		do return mapdata end
	end
end

function sling.compiler.LibraryManager:getDefaultRepositoryUrls(urls)
	local url1 = _g.sling.compiler.LibraryManager.RepositoryUrl._construct0(_g.sling.compiler.LibraryManager.RepositoryUrl._create())
	do url1:setUrl("https://files.eqela.com/sling/libs/%s_%n_%v_%p.slib") end
	do _g.jk.lang.Vector:append(urls, url1) end
end

function sling.compiler.LibraryManager:getHubRepositoryUrls(urls)
	local token = _g.jk.env.EnvironmentVariable:get("SLING_SLIB_TOKEN")
	if _g.jk.lang.String:isNotEmpty(token) then
		local uu = _g.sling.compiler.LibraryManager.RepositoryUrl._construct0(_g.sling.compiler.LibraryManager.RepositoryUrl._create())
		do uu:setUrl("https://hub.eqela.com/download?type=slib&vendor=%s&name=%n&version=%v&platform=%p") end
		do uu:setAuthKey(token) end
		do _g.jk.lang.Vector:append(urls, uu) end
	end
end

function sling.compiler.LibraryManager:getRepositoryUrls(ctx)
	local v = {}
	local isFinal = false
	local ev = _g.jk.env.EnvironmentVariable:get("SLING_REPOSITORY_URLS")
	if _g.jk.lang.String:isNotEmpty(ev) then
		local array = _g.jk.lang.String:split(ev, 32, 0)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local url = array[n + 1]
					if url ~= nil then
						if url == "final" then
							isFinal = true
							do break end
						end
						if _g.jk.lang.String:isNotEmpty(url) then
							do _g.jk.lang.Vector:append(v, _g.sling.compiler.LibraryManager.RepositoryUrl:forUrlString(url)) end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
	if not isFinal and self.directory ~= nil then
		local slon = self.directory:entry("repositories.slon")
		if slon:isFile() then
			local list = _vm:to_table_with_key(_g.jk.slon.SLONParser:parseFile(slon), '_isType.jk.lang.DynamicVector')
			if not (list ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read repository list: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(slon)) .. "'", nil, nil))
			end
			do
				local array2 = list:toVector()
				if array2 ~= nil then
					local n2 = 0
					local m2 = _g.jk.lang.Vector:getSize(array2)
					do
						n2 = 0
						while n2 < m2 do
							local url = array2[n2 + 1]
							if url ~= nil then
								local urls = _g.jk.lang.String:asString(url)
								if not (urls ~= nil) then
									goto _continue2
								end
								if urls == "final" then
									isFinal = true
									do break end
								end
								do _g.jk.lang.Vector:append(v, _g.sling.compiler.LibraryManager.RepositoryUrl:forUrlString(urls)) end
							end
							::_continue2::
							do n2 = n2 + 1 end
						end
					end
				end
			end
		end
	end
	if not isFinal and self.directory ~= nil then
		local json = self.directory:entry("repositories.json")
		local mapdata = self:readRepositoryConfigFile(ctx, json)
		if mapdata ~= nil then
			local array3 = mapdata:getKeys()
			if array3 ~= nil then
				local n3 = 0
				local m3 = _g.jk.lang.Vector:getSize(array3)
				do
					n3 = 0
					while n3 < m3 do
						local name = array3[n3 + 1]
						if name ~= nil then
							local repo = mapdata:getDynamicMap(name)
							if repo ~= nil then
								local urls = repo:getDynamicMap(self:getPlatformName())
								if not (urls ~= nil) then
									urls = repo:getDynamicMap("default")
								end
								if urls ~= nil then
									local uu = urls:getString("url", nil)
									if _g.jk.lang.String:isNotEmpty(uu) then
										local url = _g.sling.compiler.LibraryManager.RepositoryUrl._construct0(_g.sling.compiler.LibraryManager.RepositoryUrl._create())
										do url:setUrl(uu) end
										do url:setAuthKey(urls:getString("authKey", nil)) end
										do _g.jk.lang.Vector:append(v, url) end
									else
										local uus = urls:getDynamicVector("urls")
										if uus ~= nil then
											local array4 = uus:toVectorOfStrings()
											if array4 ~= nil then
												local n4 = 0
												local m4 = _g.jk.lang.Vector:getSize(array4)
												do
													n4 = 0
													while n4 < m4 do
														local uu = array4[n4 + 1]
														if uu ~= nil then
															if _g.jk.lang.String:isNotEmpty(uu) then
																local url = _g.sling.compiler.LibraryManager.RepositoryUrl._construct0(_g.sling.compiler.LibraryManager.RepositoryUrl._create())
																do url:setUrl(uu) end
																do url:setAuthKey(urls:getString("authKey", nil)) end
																do _g.jk.lang.Vector:append(v, url) end
															end
														end
														do n4 = n4 + 1 end
													end
												end
											end
										end
									end
									if urls:getBoolean("final", false) == true then
										isFinal = true
										do break end
									end
								end
							end
						end
						do n3 = n3 + 1 end
					end
				end
			end
		end
	end
	if not isFinal then
		do self:getDefaultRepositoryUrls(v) end
		do self:getHubRepositoryUrls(v) end
	end
	if v ~= nil then
		local n5 = 0
		local m5 = _g.jk.lang.Vector:getSize(v)
		do
			n5 = 0
			while n5 < m5 do
				local url = v[n5 + 1]
				if url ~= nil then
					do _g.jk.log.Log:debug(ctx, "Repository URL: `" .. _g.jk.lang.String:safeString(url:getUrl()) .. "'") end
				end
				do n5 = n5 + 1 end
			end
		end
	end
	do return v end
end

function sling.compiler.LibraryManager:isInstalled(libid)
	local directory = self:getLibraryDirectory()
	if not (directory ~= nil) then
		do return false end
	end
	do
		local name = _g.sling.compiler.LibraryName:parse(libid)
		if not (name ~= nil) then
			do return false end
		end
		do
			local dir = directory:entry(name:getNamespace()):entry(name:getName()):entry(name:getVersion())
			do return dir:isDirectory() end
		end
	end
end

function sling.compiler.LibraryManager:getLibraryFileManifest(file)
	if not (file ~= nil) then
		do return nil end
	end
	do
		local reader = _g.jk.archive.ZipReader:forFile(file)
		if not (reader ~= nil) then
			do return nil end
		end
		do
			local entries = reader:getEntries()
			if not (entries ~= nil) then
				do return nil end
			end
			do
				local v = nil
				if entries ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(entries)
					do
						n = 0
						while n < m do
							local entry = entries[n + 1]
							if entry ~= nil then
								if entry:getName() == "slib.manifest" then
									local data = entry:getContentsUTF8()
									if data ~= nil then
										v = _vm:to_table_with_key(_g.jk.json.JSONParser:parse(data), '_isType.jk.lang.DynamicMap')
									end
									do break end
								end
							end
							do n = n + 1 end
						end
					end
				end
				do reader:close() end
				do return v end
			end
		end
	end
end

function sling.compiler.LibraryManager:installLibraryFromFile(ctx, file, overwrite)
	local directory = self:getLibraryDirectory()
	if not (directory ~= nil) then
		do _g.jk.log.Log:error(ctx, "LibraryManager: null directory") end
		do return false end
	end
	if not (file ~= nil) then
		do _g.jk.log.Log:error(ctx, "LibraryManager: null file to install") end
		do return false end
	end
	do _g.jk.log.Log:debug(ctx, "Installing library file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
	do
		local manifest = self:getLibraryFileManifest(file)
		if not (manifest ~= nil) then
			do _g.jk.log.Log:error(ctx, "Library file in incorrect format: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
			do return false end
		end
		do
			local namespace = manifest:getString("namespace", nil)
			local name = manifest:getString("name", nil)
			local version = manifest:getString("version", nil)
			if not _g.jk.lang.String:isNotEmpty(namespace) then
				do _g.jk.log.Log:error(ctx, "Library does not have namespace: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
				do return false end
			end
			if not _g.jk.lang.String:isNotEmpty(name) then
				do _g.jk.log.Log:error(ctx, "Library does not have name: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
				do return false end
			end
			if not _g.jk.lang.String:isNotEmpty(version) then
				do _g.jk.log.Log:error(ctx, "Library does not have version: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
				do return false end
			end
			do
				local output = directory:entry(namespace):entry(name):entry(version)
				if output:exists() then
					if overwrite then
						do _g.jk.log.Log:debug(ctx, "Library already installed: `" .. _g.jk.lang.String:safeString(output:getPath()) .. "'. Removing previously installed version.") end
						do output:removeRecursive() end
					else
						do _g.jk.log.Log:error(ctx, "Library already installed: `" .. _g.jk.lang.String:safeString(namespace) .. ":" .. _g.jk.lang.String:safeString(name) .. ":" .. _g.jk.lang.String:safeString(version) .. "'") end
						do return false end
					end
				end
				do _g.jk.log.Log:status(ctx, "[Installing] " .. _g.jk.lang.String:safeString(file:getPath()) .. " .. ") end
				do
					local r = _g.jk.archive.ZipReader:extractZipFileToDirectory(file, output, function(file)
						do _g.jk.log.Log:status(ctx, "[Installing] " .. _g.jk.lang.String:safeString(file:getPath())) end
					end)
					do _g.jk.log.Log:status(ctx, nil) end
					if not r then
						do _g.jk.log.Log:error(ctx, "Failed to install library file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
						do return false end
					end
					do _g.jk.log.Log:info(ctx, "Library installed: `" .. _g.jk.lang.String:safeString(namespace) .. ":" .. _g.jk.lang.String:safeString(name) .. ":" .. _g.jk.lang.String:safeString(version) .. "'") end
					do return true end
				end
			end
		end
	end
end

function sling.compiler.LibraryManager:installLibraryFromBuffer(ctx, buffer, overwrite)
	local file = _g.jk.env.TemporaryFile:create(nil)
	if not (file ~= nil) then
		do _g.jk.log.Log:error(ctx, "Failed to create a temporary file!") end
		do return false end
	end
	if not file:setContentsBuffer(buffer) then
		do _g.jk.log.Log:error(ctx, "Failed to write to file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
		do file:remove() end
		do return false end
	end
	do
		local v = self:installLibraryFromFile(ctx, file, overwrite)
		do file:remove() end
		do return v end
	end
end

function sling.compiler.LibraryManager:installLibraryById(ctx, libid, force)
	if force == false and self:isInstalled(libid) then
		do _g.jk.log.Log:error(ctx, "Library already installed: `" .. _g.jk.lang.String:safeString(libid) .. "'") end
		do return false end
	end
	do
		local name = _g.sling.compiler.LibraryName:parse(libid)
		if not (name ~= nil) then
			do _g.jk.log.Log:error(ctx, "Invalid library identifier: `" .. _g.jk.lang.String:safeString(libid) .. "'") end
			do return false end
		end
		do _g.jk.log.Log:debug(ctx, "Installing library by identifier: `" .. _g.jk.lang.String:safeString(libid) .. "'") end
		do
			local client = _g.jk.http.client.CustomWebClient._construct0(_g.jk.http.client.CustomWebClient._create())
			local array = self:getRepositoryUrls(ctx)
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local repo = array[n + 1]
						if repo ~= nil then
							local url = repo:getUrl()
							if _g.jk.lang.String:isEmpty(url) then
								goto _continue3
							end
							if _g.jk.lang.String:getIndexOfCharacter(url, 37, 0) < 0 then
								if _g.jk.lang.String:endsWith(url, "/") == false then
									url = _g.jk.lang.String:safeString(url) .. "/"
								end
								url = _g.jk.lang.String:safeString(url) .. "%s/%n/%v/%p"
							end
							url = _g.jk.lang.String:replaceString(url, "%s", _g.jk.url.URLEncoder:encode(name:getNamespace(), false, true))
							url = _g.jk.lang.String:replaceString(url, "%n", _g.jk.url.URLEncoder:encode(name:getName(), false, true))
							url = _g.jk.lang.String:replaceString(url, "%v", _g.jk.url.URLEncoder:encode(name:getVersion(), false, true))
							url = _g.jk.lang.String:replaceString(url, "%p", _g.jk.url.URLEncoder:encode(self:getPlatformName(), false, true))
							do
								local status = nil
								local data = nil
								local hdrs = _g.jk.lang.KeyValueList._construct0(_g.jk.lang.KeyValueList._create())
								local auth = repo:getAuthKey()
								if _g.jk.lang.String:isNotEmpty(auth) then
									do hdrs:add("Authorization", "Bearer " .. _g.jk.lang.String:safeString(auth)) end
								end
								do _g.jk.log.Log:debug(ctx, "Trying to retrieve URL: `" .. _g.jk.lang.String:safeString(url) .. "' ..") end
								do _g.jk.log.Log:status(ctx, "[Downloading] " .. _g.jk.lang.String:safeString(url) .. " .. ") end
								do client:query("GET", url, hdrs, nil, function(rstatus, rheaders, rdata)
									status = rstatus
									data = rdata
								end) end
								do _g.jk.log.Log:status(ctx, nil) end
								if status == "200" and data ~= nil then
									do _g.jk.log.Log:debug(ctx, "Successfully downloaded: `" .. _g.jk.lang.String:safeString(url) .. "'") end
									if not self:installLibraryFromBuffer(ctx, data, force) then
										do _g.jk.log.Log:error(ctx, "Failed to install downloaded library: `" .. _g.jk.lang.String:safeString(libid) .. "'") end
										do return false end
									end
									do return true end
								else
									do _g.jk.log.Log:debug(ctx, "Download failed: `" .. _g.jk.lang.String:safeString(url) .. "', response status=`" .. _g.jk.lang.String:safeString(status) .. "'") end
								end
							end
						end
						::_continue3::
						do n = n + 1 end
					end
				end
			end
			do _g.jk.log.Log:error(ctx, "Unable to find and install library: `" .. _g.jk.lang.String:safeString(libid) .. "'") end
			do return false end
		end
	end
end

function sling.compiler.LibraryManager:isOlderCompatibleVersion(thisVersion, processedVersion)
	if not (thisVersion ~= nil) then
		do return false end
	end
	if not (processedVersion ~= nil) then
		do return false end
	end
	if processedVersion == "local" then
		do return true end
	end
	do
		local acomps = _g.jk.lang.String:split(thisVersion, 46, 0)
		local sz = _g.jk.lang.Vector:getSize(acomps)
		if sz ~= 3 then
			do return false end
		end
		do
			local bcomps = _g.jk.lang.String:split(processedVersion, 46, 0)
			if _g.jk.lang.Vector:getSize(bcomps) ~= sz then
				do return false end
			end
			if not (_g.jk.lang.Vector:get(acomps, 0) == _g.jk.lang.Vector:get(bcomps, 0)) then
				do return false end
			end
			do
				local an2 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(acomps, 1))
				local bn2 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(bcomps, 1))
				if an2 < bn2 then
					do return true end
				end
				if an2 > bn2 then
					do return false end
				end
				do
					local an1 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(acomps, 2))
					local bn1 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(bcomps, 2))
					if an1 < bn1 then
						do return true end
					end
					do return false end
				end
			end
		end
	end
end

function sling.compiler.LibraryManager:isNewerCompatibleVersion(thisVersion, processedVersion)
	if not (thisVersion ~= nil) then
		do return false end
	end
	if not (processedVersion ~= nil) then
		do return false end
	end
	if thisVersion == "local" then
		do return true end
	end
	do
		local acomps = _g.jk.lang.String:split(thisVersion, 46, 0)
		local sz = _g.jk.lang.Vector:getSize(acomps)
		if sz ~= 3 then
			do return false end
		end
		do
			local bcomps = _g.jk.lang.String:split(processedVersion, 46, 0)
			if _g.jk.lang.Vector:getSize(bcomps) ~= sz then
				do return false end
			end
			if not (_g.jk.lang.Vector:get(acomps, 0) == _g.jk.lang.Vector:get(bcomps, 0)) then
				do return false end
			end
			do
				local an2 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(acomps, 1))
				local bn2 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(bcomps, 1))
				if an2 > bn2 then
					do return true end
				end
				if an2 < bn2 then
					do return false end
				end
				do
					local an1 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(acomps, 2))
					local bn1 = _g.jk.lang.String:toInteger(_g.jk.lang.Vector:get(bcomps, 2))
					if an1 > bn1 then
						do return true end
					end
					do return false end
				end
			end
		end
	end
end

function sling.compiler.LibraryManager:processRequiredLibraryToVector(ctx, alibname, results, resultVector, processed)
	local directory = self:getLibraryDirectory()
	if not (directory ~= nil) then
		do return false end
	end
	do
		local libname = alibname
		local name = _g.sling.compiler.LibraryName:parse(libname)
		if not (name ~= nil) then
			do _g.jk.log.Log:error(ctx, "Invalid library identifier: `" .. _g.jk.lang.String:safeString(libname) .. "'") end
			do return false end
		end
		do
			local id = _g.jk.lang.String:safeString(name:getNamespace()) .. ":" .. _g.jk.lang.String:safeString(name:getName())
			local forcedVersion = _g.jk.lang.Map:get(self.forcedLibraryVersions, id)
			if forcedVersion ~= nil then
				libname = _g.jk.lang.String:safeString(id) .. ":" .. _g.jk.lang.String:safeString(forcedVersion)
				if not ((function()
					name = _g.sling.compiler.LibraryName:parse(libname)
					do return name end
				end)() ~= nil) then
					do _g.jk.log.Log:error(ctx, "Invalid forced library identifier: `" .. _g.jk.lang.String:safeString(libname) .. "'") end
					do return false end
				end
				do _g.jk.log.Log:debug(ctx, "Forced library version `" .. _g.jk.lang.String:safeString(name:toString()) .. "' for original library `" .. _g.jk.lang.String:safeString(alibname) .. "'") end
			end
			do
				local processedVersion = _g.jk.lang.Map:get(processed, id)
				if processedVersion ~= nil then
					local thisVersion = name:getVersion()
					if processedVersion == thisVersion then
						do return true end
					end
					if self:isOlderCompatibleVersion(thisVersion, processedVersion) then
						do return true end
					end
					if self:isNewerCompatibleVersion(thisVersion, processedVersion) then
					else
						do _g.jk.log.Log:error(ctx, "Incompatible versions of library `" .. _g.jk.lang.String:safeString(id) .. "' required: `" .. _g.jk.lang.String:safeString(thisVersion) .. "' and `" .. _g.jk.lang.String:safeString(processedVersion) .. "'") end
						do return false end
					end
				end
				do
					local dir = directory:entry(name:getNamespace()):entry(name:getName()):entry(name:getVersion())
					if not dir:isDirectory() then
						if not self:installLibraryById(ctx, libname, false) then
							do _g.jk.log.Log:error(ctx, "Failed to install required library: `" .. _g.jk.lang.String:safeString(libname) .. "'") end
							do return false end
						end
					end
					if not dir:isDirectory() then
						do _g.jk.log.Log:error(ctx, "Library not found: `" .. _g.jk.lang.String:safeString(libname) .. "'") end
						do return false end
					end
					do _g.jk.lang.Map:set(processed, id, name:getVersion()) end
					if results ~= nil then
						results[id] = dir
					end
					do
						local mf = dir:entry("slib.manifest")
						if mf:isFile() then
							local manifest = _vm:to_table_with_key(_g.jk.json.JSONParser:parse(mf), '_isType.jk.lang.DynamicMap')
							if not (manifest ~= nil) then
								do _g.jk.log.Log:error(ctx, "Failed to parse manifest: `" .. _g.jk.lang.String:safeString(mf:getPath()) .. "'") end
								do return false end
							end
							do
								local libraries = manifest:getDynamicVector("libraries")
								if libraries ~= nil then
									local array = libraries:toVectorOfStrings()
									if array ~= nil then
										local n = 0
										local m = _g.jk.lang.Vector:getSize(array)
										do
											n = 0
											while n < m do
												local library = array[n + 1]
												if library ~= nil then
													if not self:processRequiredLibraryToVector(ctx, library, results, resultVector, processed) then
														do return false end
													end
												end
												do n = n + 1 end
											end
										end
									end
								end
							end
						end
						if resultVector ~= nil then
							do _g.jk.lang.Vector:append(resultVector, dir) end
						end
						do return true end
					end
				end
			end
		end
	end
end

function sling.compiler.LibraryManager:processRequiredLibraries(ctx, libnames)
	local vmap = {}
	local processed = {}
	local v = {}
	if libnames ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(libnames)
		do
			n = 0
			while n < m do
				local libname = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(libnames[n + 1])
				if libname ~= nil then
					if not self:processRequiredLibraryToVector(ctx, libname, vmap, v, processed) then
						do return nil end
					end
				end
				do n = n + 1 end
			end
		end
	end
	if v ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(v)
		do
			n2 = 0
			while n2 < m2 do
				local libdir = v[n2 + 1]
				if libdir ~= nil then
					do _g.jk.log.Log:debug(ctx, "Required library found in path: `" .. _g.jk.lang.String:safeString(libdir:getPath()) .. "'") end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	do return v end
end

function sling.compiler.LibraryManager:readDependencyFile(file)
	if not (file ~= nil) then
		do return nil end
	end
	do return file:readLinesVector() end
end

function sling.compiler.LibraryManager:generateModuleInfosForLibdirs(ctx, libdirs)
	local v = {}
	if libdirs ~= nil then
		local n = 0
		local m2 = _g.jk.lang.Vector:getSize(libdirs)
		do
			n = 0
			while n < m2 do
				local libdir = libdirs[n + 1]
				if libdir ~= nil then
					local entries = libdir:entries()
					if not (entries ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read directory: `" .. _g.jk.lang.String:safeString(libdir:getPath()) .. "'", nil, nil))
					end
					while true do
						local f = entries:next()
						if not (f ~= nil) then
							do break end
						end
						if f:hasExtension("sling") then
							local moduleName = f:getBasenameWithoutExtension()
							local apifile = f
							local linkTarget = self:getLinkTargetFile(f:getParent(), moduleName)
							local depfile = f:getSibling(_g.jk.lang.String:safeString(moduleName) .. ".deps")
							if linkTarget ~= nil and linkTarget:exists() and apifile:isFile() and depfile:isFile() then
								local timestamp = depfile:getLastModifiedTimeStamp()
								local dependencies = self:readDependencyFile(depfile)
								local m = _g.sling.compiler.LinkableModuleInfo._construct0(_g.sling.compiler.LinkableModuleInfo._create())
								do m:setModuleId(moduleName) end
								do m:setLinkTarget(linkTarget) end
								do m:setTimestamp(timestamp) end
								do m:setApifile(apifile) end
								do m:setDepfile(depfile) end
								do m:setDependencies(dependencies) end
								do _g.jk.lang.Vector:append(v, m) end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.compiler.LibraryManager:generateModuleInfosForBuild(ctx, dirs, customlibs)
	local libnames = {}
	if dirs ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(dirs)
		do
			n = 0
			while n < m do
				local dir = dirs[n + 1]
				if dir ~= nil then
					local pling = dir:entry("project.slon")
					if not pling:isFile() then
						pling = dir:entry("project.pling")
					end
					if not pling:isFile() then
						goto _continue4
					end
					do
						local pdata = _g.sling.syntax.PlingParser._construct1(_g.sling.syntax.PlingParser._create(), ctx):parseFileAsUnitSettings(pling, nil, nil)
						if not (pdata ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read project file: `" .. _g.jk.lang.String:safeString(pling:getPath()) .. "'", nil, nil))
						end
						do
							local libraries = pdata:getLibraries()
							if _g.jk.lang.Vector:isNotEmpty(libraries) then
								if libraries ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(libraries)
									do
										n2 = 0
										while n2 < m2 do
											local libname = libraries[n2 + 1]
											if libname ~= nil then
												do _g.jk.lang.Vector:append(libnames, libname) end
											end
											do n2 = n2 + 1 end
										end
									end
								end
							end
						end
					end
				end
				::_continue4::
				do n = n + 1 end
			end
		end
	end
	libnames = _g.sling.compiler.LibraryManager:substituteCustomLibraries(libnames, customlibs)
	do
		local libdirs = self:processRequiredLibraries(ctx, libnames)
		if not (libdirs ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process library dependencies", nil, nil))
		end
		do return self:generateModuleInfosForLibdirs(ctx, libdirs) end
	end
end

function sling.compiler.LibraryManager:getDirectory()
	do return self.directory end
end

function sling.compiler.LibraryManager:setDirectory(v)
	self.directory = v
	do return self end
end

sling.compiler.ModelExpanderForJkop = {}
sling.compiler.ModelExpanderForJkop.__index = sling.compiler.ModelExpanderForJkop
_vm:set_metatable(sling.compiler.ModelExpanderForJkop, {})

function sling.compiler.ModelExpanderForJkop._create()
	local v = _vm:set_metatable({}, sling.compiler.ModelExpanderForJkop)
	return v
end

function sling.compiler.ModelExpanderForJkop:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.ModelExpanderForJkop'
	self['_isType.sling.compiler.ModelExpanderForJkop'] = true
	self.generateAsJsonObject = true
	self.generateMethods = true
	self.generateProperties = false
end

function sling.compiler.ModelExpanderForJkop:_construct0()
	sling.compiler.ModelExpanderForJkop._init(self)
	return self
end

sling.compiler.ModelExpanderForJkop.ModelNodeFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.ModelExpanderForJkop.ModelNodeFinder.__index = sling.compiler.ModelExpanderForJkop.ModelNodeFinder
_vm:set_metatable(sling.compiler.ModelExpanderForJkop.ModelNodeFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.ModelExpanderForJkop.ModelNodeFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.ModelExpanderForJkop.ModelNodeFinder)
	return v
end

function sling.compiler.ModelExpanderForJkop.ModelNodeFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.ModelExpanderForJkop.ModelNodeFinder'
	self['_isType.sling.compiler.ModelExpanderForJkop.ModelNodeFinder'] = true
	self.results = {}
end

function sling.compiler.ModelExpanderForJkop.ModelNodeFinder:_construct0()
	sling.compiler.ModelExpanderForJkop.ModelNodeFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.ModelExpanderForJkop.ModelNodeFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ModelDeclarationNode') ~= nil) and node:hasCustomModifier("nojkop") == false then
		do _g.jk.lang.Vector:append(self.results, node) end
	end
	do return true end
end

function sling.compiler.ModelExpanderForJkop.ModelNodeFinder:getResults()
	do return self.results end
end

function sling.compiler.ModelExpanderForJkop.ModelNodeFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.compiler.ModelExpanderForJkop:convertPrimitiveType(type)
	if (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		local it = type
		if it:getType() == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
			do return _g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
				"jk",
				"lang",
				"LongIntegerObject"
			}) end
		end
		do return _g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
			"jk",
			"lang",
			"IntegerObject"
		}) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
		do return _g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
			"jk",
			"lang",
			"DoubleObject"
		}) end
	end
	if (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
		do return _g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
			"jk",
			"lang",
			"BooleanObject"
		}) end
	end
	do return nil end
end

function sling.compiler.ModelExpanderForJkop:dataTypeToSymbolExpression(type)
	local refdt = _vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode')
	if not (refdt ~= nil) then
		do return nil end
	end
	do
		local sym = refdt:getSymbol()
		if not (sym ~= nil) then
			do return nil end
		end
		do
			local symdup = _vm:to_table_with_key(sym:dup(), '_isType.sling.model.SymbolNode')
			if not (symdup ~= nil) then
				do return nil end
			end
			do return _g.sling.model.SymbolExpressionNode:forSymbol(symdup) end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:getUnboxingFunctionFor(vname, type)
	if _g.jk.lang.String:isEmpty(vname) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("getUnboxingFunctionFor: empty vname", type, nil))
	end
	if not (type ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("getUnboxingFunctionFor: null type for vname `" .. _g.jk.lang.String:safeString(vname) .. "'", nil, nil))
	end
	do
		local className = nil
		local method = nil
		if (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
			local it = type
			if it:getType() == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
				className = "LongInteger"
				method = "asLong"
			else
				className = "Integer"
				method = "asInteger"
			end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
			className = "Double"
			method = "asDouble"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
			className = "Boolean"
			method = "asBoolean"
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported primitive data type for unboxing model value: `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(type)) .. "'", type, nil))
		end
		do
			local ff = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName(className), method, false)
			do ff:addToParameters(_g.sling.model.SymbolExpressionNode:forName(vname)) end
			do return ff end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:getBoxingFunctionFor(vname, type)
	if _g.jk.lang.String:isEmpty(vname) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("getBoxingFunctionFor: empty vname", type, nil))
	end
	if not (type ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("getBoxingFunctionFor: null type for vname `" .. _g.jk.lang.String:safeString(vname) .. "'", nil, nil))
	end
	do
		local name = nil
		if (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
			local it = type
			if it:getType() == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
				name = "LongInteger"
			else
				name = "Integer"
			end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
			name = "Double"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
			name = "Boolean"
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported primitive data type for boxing model value: `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(type)) .. "'", type, nil))
		end
		do
			local call = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName(name), "asObject", false)
			do call:addToParameters(_g.sling.model.SymbolExpressionNode:forName(vname)) end
			do return call end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:addPropertyVariable(decl, name, type)
	local pdec = _g.sling.model.ext.NSlingPropertyDeclaration._construct0(_g.sling.model.ext.NSlingPropertyDeclaration._create())
	do pdec:setType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
	do pdec:setName(name) end
	do
		local setter = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do setter:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
		do setter:addModifier(_g.sling.model.Modifier.PUBLIC) end
		do setter:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), "value", nil)) end
		do
			local assx = _g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName("_" .. _g.jk.lang.String:safeString(name)), _g.sling.model.SymbolExpressionNode:forName("value"))
			do _g.sling.util.FunctionUtil:addStatement(setter, assx) end
			do pdec:setSetter(setter, false) end
			do
				local getter = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
				do getter:addModifier(_g.sling.model.Modifier.PUBLIC) end
				do getter:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
				do _g.sling.util.FunctionUtil:addStatement(getter, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("_" .. _g.jk.lang.String:safeString(name)))) end
				do pdec:setGetter(getter, false) end
				do decl:addNode(pdec) end
			end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:addPrimitivePropertyVariable(decl, name, type)
	local pdec = _g.sling.model.ext.NSlingPropertyDeclaration._construct0(_g.sling.model.ext.NSlingPropertyDeclaration._create())
	do pdec:setType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
	do pdec:setName(_g.sling.common.CodeStringUtil:combineCamelCase({
		name,
		"value"
	})) end
	do
		local setter = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do setter:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
		do setter:addModifier(_g.sling.model.Modifier.PUBLIC) end
		do setter:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), "value", nil)) end
		do
			local boxer = self:getBoxingFunctionFor("value", type)
			local assx = _g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName("_" .. _g.jk.lang.String:safeString(name)), boxer)
			do _g.sling.util.FunctionUtil:addStatement(setter, assx) end
			do pdec:setSetter(setter, false) end
			do
				local getter = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
				do getter:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
				do getter:addModifier(_g.sling.model.Modifier.PUBLIC) end
				do
					local unboxer = self:getUnboxingFunctionFor("_" .. _g.jk.lang.String:safeString(name), type)
					do _g.sling.util.FunctionUtil:addStatement(getter, _g.sling.model.ReturnStatementNode:forExpression(unboxer)) end
					do pdec:setGetter(getter, false) end
					do decl:addNode(pdec) end
				end
			end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:addSetterAndGetterMethod(decl, name, type)
	local setter = _g.sling.model.FunctionDeclarationNode:forName(_g.sling.common.CodeStringUtil:combineCamelCase({
		"set",
		name
	}), false)
	do setter:setReturnType(_g.sling.model.ReferenceDataTypeNode:forNode(decl, nil), false) end
	do setter:addModifier(_g.sling.model.Modifier.PUBLIC) end
	do setter:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), "value", nil)) end
	do
		local assx = _g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName("_" .. _g.jk.lang.String:safeString(name)), _g.sling.model.SymbolExpressionNode:forName("value"))
		do _g.sling.util.FunctionUtil:addStatement(setter, assx) end
		do _g.sling.util.FunctionUtil:addStatement(setter, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create()))) end
		do decl:addNode(setter) end
		do
			local getter = _g.sling.model.FunctionDeclarationNode:forName(_g.sling.common.CodeStringUtil:combineCamelCase({
				"get",
				name
			}), false)
			do getter:addModifier(_g.sling.model.Modifier.PUBLIC) end
			do getter:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(type), false) end
			do _g.sling.util.FunctionUtil:addStatement(getter, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("_" .. _g.jk.lang.String:safeString(name)))) end
			do decl:addNode(getter) end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:addPrimitiveSetterAndGetterMethod(decl, name, type)
	local setter = _g.sling.model.FunctionDeclarationNode:forName(_g.sling.common.CodeStringUtil:combineCamelCase({
		"set",
		name,
		"value"
	}), false)
	do setter:setReturnType(_g.sling.model.ReferenceDataTypeNode:forNode(decl, nil), false) end
	do setter:addModifier(_g.sling.model.Modifier.PUBLIC) end
	do
		local sptype = _g.sling.util.DataTypeUtil:dupAsDataType(type)
		do setter:addToParameters(_g.sling.model.VariableDeclarationNode:instance(sptype, "value", nil)) end
		do
			local boxer = self:getBoxingFunctionFor("value", type)
			local spcall = _g.sling.model.FunctionCallExpressionNode:forName(_g.sling.common.CodeStringUtil:combineCamelCase({
				"set",
				name
			}))
			do spcall:addToParameters(boxer) end
			do _g.sling.util.FunctionUtil:addStatement(setter, _g.sling.model.ReturnStatementNode:forExpression(spcall)) end
			do decl:addNode(setter) end
			do
				local getter = _g.sling.model.FunctionDeclarationNode:forName(_g.sling.common.CodeStringUtil:combineCamelCase({
					"get",
					name,
					"value"
				}), false)
				do getter:addModifier(_g.sling.model.Modifier.PUBLIC) end
				do
					local gptype = _g.sling.util.DataTypeUtil:dupAsDataType(type)
					local unboxer = self:getUnboxingFunctionFor("_" .. _g.jk.lang.String:safeString(name), type)
					do getter:setReturnType(gptype, false) end
					do _g.sling.util.FunctionUtil:addStatement(getter, _g.sling.model.ReturnStatementNode:forExpression(unboxer)) end
					do decl:addNode(getter) end
				end
			end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:getPropertyName(variable)
	if not (variable ~= nil) then
		do return nil end
	end
	do
		local v = variable:getName()
		if not (v ~= nil) then
			do return nil end
		end
		if _g.jk.lang.String:startsWith(v, "_", 0) then
			do return _g.jk.lang.String:getEndOfString(v, 1) end
		end
		do return v end
	end
end

function sling.compiler.ModelExpanderForJkop:execute(root)
	if not (root ~= nil) then
		do return end
	end
	do
		local cf = _g.sling.compiler.ModelExpanderForJkop.ModelNodeFinder._construct0(_g.sling.compiler.ModelExpanderForJkop.ModelNodeFinder._create())
		if not root:accept(cf) then
			do return end
		end
		do
			local array = cf:getResults()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local model = array[n + 1]
						if model ~= nil then
							local explicit = false
							if model:hasCustomModifier("explicit") then
								explicit = true
							end
							do
								local cdecl = _g.sling.model.ClassDeclarationNode:forName(model:getNodeName())
								do cdecl:addModifier(_g.sling.model.Modifier.PUBLIC) end
								if (_vm:to_table_with_key(model:getParent(), '_isType.sling.model.EntityDeclarationNode') ~= nil) then
									do cdecl:addModifier(_g.sling.model.Modifier.STATIC) end
								end
								do cdecl:setDependencies(model:getDependencies()) end
								do cdecl:setImportNamespaces(model:exportImportNamespaces(), false) end
								do cdecl:setImportEntities(model:exportImportEntities(), false) end
								do
									local array2 = model:getNodes()
									if array2 ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(array2)
										do
											n2 = 0
											while n2 < m2 do
												local variable = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
												if variable ~= nil then
													local pd = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
													local pn = variable:getNodeName()
													do pd:setSource(variable:getSource()) end
													do pd:setName("_" .. _g.jk.lang.String:safeString(pn)) end
													do
														local originaltype = variable:getType()
														if (_vm:to_table_with_key(originaltype, '_isType.sling.model.StringDataTypeNode') ~= nil) then
															do pd:setType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
														elseif (_vm:to_table_with_key(originaltype, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
															do pd:setType(_g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()), false) end
														elseif (_vm:to_table_with_key(originaltype, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
															local pt = originaltype:getPrimaryType()
															if not (pt ~= nil) then
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No primary type", originaltype, nil))
															end
															do
																local ptdup = nil
																if (_vm:to_table_with_key(pt, '_isType.sling.model.PrimitiveDataTypeNode') ~= nil) then
																	if not ((function()
																		ptdup = self:convertPrimitiveType(pt)
																		do return ptdup end
																	end)() ~= nil) then
																		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported primitive data type: `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(pt)) .. "'", pt, nil))
																		do return end
																	end
																else
																	ptdup = _g.sling.util.DataTypeUtil:dupAsDataType(pt)
																end
																do pd:setType(_g.sling.model.VectorDataTypeNode:forPrimaryType(ptdup), false) end
															end
														elseif (_vm:to_table_with_key(originaltype, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
															do pd:setType(_g.sling.util.DataTypeUtil:dupAsDataType(originaltype), false) end
														else
															local ctype = self:convertPrimitiveType(originaltype)
															if ctype ~= nil then
																do pd:setType(ctype, false) end
																if self.generateMethods then
																	do self:addPrimitiveSetterAndGetterMethod(cdecl, pn, originaltype) end
																end
																if self.generateProperties then
																	do self:addPrimitivePropertyVariable(cdecl, pn, originaltype) end
																end
															else
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type as model field: `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(originaltype)) .. "'", originaltype, nil))
															end
														end
														do
															local newtype = pd:getType()
															do pd:setDescription(variable:getDescription()) end
															do cdecl:addNode(pd) end
															if self.generateMethods then
																do self:addSetterAndGetterMethod(cdecl, pn, newtype) end
															end
															if self.generateProperties then
																do self:addPropertyVariable(cdecl, pn, newtype) end
															end
														end
													end
												end
												do n2 = n2 + 1 end
											end
										end
									end
									if self.generateAsJsonObject then
										do cdecl:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
											"jk",
											"json"
										})) end
										if explicit then
											do cdecl:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("JSONObjectAdapterExplicit"), 0)) end
										else
											do cdecl:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("JSONObjectAdapter"), 0)) end
										end
										do cdecl:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("StringObject"), 0)) end
										do
											local mto = _g.sling.model.FunctionDeclarationNode:forName("toJsonObject", false)
											do mto:addModifier(_g.sling.model.Modifier.OVERRIDE) end
											do mto:addModifier(_g.sling.model.Modifier.PUBLIC) end
											do mto:setReturnType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
											do
												local vdecl = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), "v", nil)
												do vdecl:setInitializer(_g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("DynamicMap")), false) end
												do _g.sling.util.FunctionUtil:addStatement(mto, vdecl) end
												do
													local array3 = cdecl:getNodes()
													if array3 ~= nil then
														local n3 = 0
														local m3 = _g.jk.lang.Vector:getSize(array3)
														do
															n3 = 0
															while n3 < m3 do
																local vardecl = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
																if vardecl ~= nil then
																	local fname = nil
																	local tt = vardecl:getType()
																	if (_vm:to_table_with_key(tt, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
																		fname = "SET_VALUE_VECTOR"
																	else
																		fname = "SET_VALUE_OBJECT"
																	end
																	do
																		local fc = _g.sling.model.FunctionCallExpressionNode:forName(fname)
																		do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("v")) end
																		do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(self:getPropertyName(vardecl))) end
																		do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName(vardecl:getNodeName())) end
																		do _g.sling.util.FunctionUtil:addStatement(mto, fc) end
																	end
																end
																do n3 = n3 + 1 end
															end
														end
													end
													do _g.sling.util.FunctionUtil:addStatement(mto, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("v"))) end
													do cdecl:addNode(mto) end
													do
														local mfr = _g.sling.model.FunctionDeclarationNode:forName("fromJsonObject", false)
														do mfr:addModifier(_g.sling.model.Modifier.OVERRIDE) end
														do mfr:addModifier(_g.sling.model.Modifier.PUBLIC) end
														do mfr:setReturnType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
														do mfr:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), "o", nil)) end
														do
															local vdecl2 = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), "v", nil)
															do vdecl2:setInitializer(_g.sling.model.DynamicCastExpressionNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("DynamicMap"), _g.sling.model.SymbolExpressionNode:forName("o")), false) end
															do _g.sling.util.FunctionUtil:addStatement(mfr, vdecl2) end
															do _g.sling.util.FunctionUtil:addStatement(mfr, _g.sling.model.AssertStatementNode:forChild(_g.sling.model.SymbolExpressionNode:forName("v"))) end
															do
																local array4 = cdecl:getNodes()
																if array4 ~= nil then
																	local n4 = 0
																	local m4 = _g.jk.lang.Vector:getSize(array4)
																	do
																		n4 = 0
																		while n4 < m4 do
																			local vardecl = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.VariableDeclarationNode')
																			if vardecl ~= nil then
																				local fname = nil
																				local typeParam = nil
																				local tt = vardecl:getType()
																				if (_vm:to_table_with_key(tt, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																					fname = "GET_VALUE_STRING"
																				elseif (_vm:to_table_with_key(tt, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
																					fname = "GET_VALUE_BUFFER"
																				elseif (_vm:to_table_with_key(tt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																					local reftt = tt
																					local refname = _g.sling.util.SymbolUtil:getSymbolNamesString(reftt:getSymbol(), 46)
																					if refname == "jk.lang.IntegerObject" then
																						fname = "GET_VALUE_INTEGER"
																					elseif refname == "jk.lang.LongIntegerObject" then
																						fname = "GET_VALUE_LONG_INTEGER"
																					elseif refname == "jk.lang.DoubleObject" then
																						fname = "GET_VALUE_DOUBLE"
																					elseif refname == "jk.lang.BooleanObject" then
																						fname = "GET_VALUE_BOOLEAN"
																					else
																						fname = "GET_VALUE_OBJECT"
																						typeParam = self:dataTypeToSymbolExpression(tt)
																					end
																				elseif (_vm:to_table_with_key(tt, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
																					local ss = tt:getPrimaryType()
																					if not (ss ~= nil) then
																						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No primary type", tt, nil))
																						do return end
																					end
																					if (_vm:to_table_with_key(ss, '_isType.sling.model.StringDataTypeNode') ~= nil) then
																						fname = "GET_VALUE_STRING_VECTOR"
																					elseif (_vm:to_table_with_key(ss, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
																						fname = "GET_VALUE_BUFFER_VECTOR"
																					elseif (_vm:to_table_with_key(ss, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
																						local refss = ss
																						local refname = _g.sling.util.SymbolUtil:getSymbolNamesString(refss:getSymbol(), 46)
																						if refname == "jk.lang.IntegerObject" then
																							fname = "GET_VALUE_INTEGER_VECTOR"
																						elseif refname == "jk.lang.LongIntegerObject" then
																							fname = "GET_VALUE_LONG_INTEGER_VECTOR"
																						elseif refname == "jk.lang.DoubleObject" then
																							fname = "GET_VALUE_DOUBLE_VECTOR"
																						elseif refname == "jk.lang.BooleanObject" then
																							fname = "GET_VALUE_BOOLEAN_VECTOR"
																						else
																							fname = "GET_VALUE_OBJECT_VECTOR"
																							typeParam = self:dataTypeToSymbolExpression(ss)
																						end
																					else
																						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported primary data type in vector: `" .. _g.jk.lang.String:safeString(ss:getNodeTypeName()) .. "'", ss, nil))
																					end
																				else
																					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type: `" .. _g.jk.lang.String:safeString(tt:getNodeTypeName()) .. "'", tt, nil))
																				end
																				if fname ~= nil then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forName(fname)
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName(vardecl:getNodeName())) end
																					if typeParam ~= nil then
																						do fc:addToParameters(typeParam) end
																					end
																					do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(self:getPropertyName(vardecl))) end
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("v")) end
																					do _g.sling.util.FunctionUtil:addStatement(mfr, fc) end
																				end
																			end
																			do n4 = n4 + 1 end
																		end
																	end
																end
																do _g.sling.util.FunctionUtil:addStatement(mfr, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.BooleanLiteralExpressionNode:forValue(true))) end
																do cdecl:addNode(mfr) end
																do
																	local fjs = _g.sling.model.FunctionDeclarationNode:forName("fromJsonString", false)
																	do fjs:addModifier(_g.sling.model.Modifier.PUBLIC) end
																	do fjs:setReturnType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
																	do fjs:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), "o", nil)) end
																	do
																		local fjsfc = _g.sling.model.FunctionCallExpressionNode:forName("fromJsonObject")
																		local fjsfcp = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("JSONParser"), "parse", false)
																		do fjsfcp:addToParameters(_g.sling.model.SymbolExpressionNode:forName("o")) end
																		do fjsfc:addToParameters(fjsfcp) end
																		do _g.sling.util.FunctionUtil:addStatement(fjs, _g.sling.model.ReturnStatementNode:forExpression(fjsfc)) end
																		do cdecl:addNode(fjs) end
																		do
																			local tjs = _g.sling.model.FunctionDeclarationNode:forName("toJsonString", false)
																			do tjs:addModifier(_g.sling.model.Modifier.PUBLIC) end
																			do tjs:setReturnType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
																			do
																				local tjsp = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("JSONEncoder"), "encode", false)
																				do tjsp:addToParameters(_g.sling.model.FunctionCallExpressionNode:forName("toJsonObject")) end
																				do _g.sling.util.FunctionUtil:addStatement(tjs, _g.sling.model.ReturnStatementNode:forExpression(tjsp)) end
																				do cdecl:addNode(tjs) end
																				do
																					local ts = _g.sling.model.FunctionDeclarationNode:forName("toString", false)
																					do ts:addModifier(_g.sling.model.Modifier.PUBLIC) end
																					do ts:setReturnType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
																					do
																						local tsp = _g.sling.model.FunctionCallExpressionNode:forName("toJsonString")
																						do _g.sling.util.FunctionUtil:addStatement(ts, _g.sling.model.ReturnStatementNode:forExpression(tsp)) end
																						do cdecl:addNode(ts) end
																						do
																							local forjs = _g.sling.model.FunctionDeclarationNode:forName("forJsonString", false)
																							do forjs:addModifier(_g.sling.model.Modifier.PUBLIC) end
																							do forjs:addModifier(_g.sling.model.Modifier.STATIC) end
																							do forjs:setReturnType(_g.sling.model.ReferenceDataTypeNode:forNode(cdecl, nil), false) end
																							do forjs:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), "o", nil)) end
																							do _g.sling.util.FunctionUtil:addStatement(forjs, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), "v", _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forNode(cdecl, nil)))) end
																							do
																								local ass = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("v"), "fromJsonString", false)
																								do ass:addToParameters(_g.sling.model.SymbolExpressionNode:forName("o")) end
																								do _g.sling.util.FunctionUtil:addStatement(forjs, _g.sling.model.AssertStatementNode:forChild(ass)) end
																								do _g.sling.util.FunctionUtil:addStatement(forjs, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("v"))) end
																								do cdecl:addNode(forjs) end
																								do
																									local forjo = _g.sling.model.FunctionDeclarationNode:forName("forJsonObject", false)
																									do forjo:addModifier(_g.sling.model.Modifier.PUBLIC) end
																									do forjo:addModifier(_g.sling.model.Modifier.STATIC) end
																									do forjo:setReturnType(_g.sling.model.ReferenceDataTypeNode:forNode(cdecl, nil), false) end
																									do forjo:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), "o", nil)) end
																									do _g.sling.util.FunctionUtil:addStatement(forjo, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), "v", _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forNode(cdecl, nil)))) end
																									do
																										local ax = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("v"), "fromJsonObject", false)
																										do ax:addToParameters(_g.sling.model.SymbolExpressionNode:forName("o")) end
																										do _g.sling.util.FunctionUtil:addStatement(forjo, _g.sling.model.AssertStatementNode:forChild(ax)) end
																										do _g.sling.util.FunctionUtil:addStatement(forjo, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("v"))) end
																										do cdecl:addNode(forjo) end
																									end
																								end
																							end
																						end
																					end
																				end
																			end
																		end
																	end
																end
															end
														end
													end
												end
											end
										end
									end
									do model:replaceWith(cdecl, false) end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
end

function sling.compiler.ModelExpanderForJkop:getGenerateAsJsonObject()
	do return self.generateAsJsonObject end
end

function sling.compiler.ModelExpanderForJkop:setGenerateAsJsonObject(v)
	self.generateAsJsonObject = v
	do return self end
end

function sling.compiler.ModelExpanderForJkop:getGenerateMethods()
	do return self.generateMethods end
end

function sling.compiler.ModelExpanderForJkop:setGenerateMethods(v)
	self.generateMethods = v
	do return self end
end

function sling.compiler.ModelExpanderForJkop:getGenerateProperties()
	do return self.generateProperties end
end

function sling.compiler.ModelExpanderForJkop:setGenerateProperties(v)
	self.generateProperties = v
	do return self end
end

sling.compiler.MacroHandler = {}
sling.compiler.MacroHandler.__index = sling.compiler.MacroHandler
_vm:set_metatable(sling.compiler.MacroHandler, {})

function sling.compiler.MacroHandler._create()
	local v = _vm:set_metatable({}, sling.compiler.MacroHandler)
	return v
end

function sling.compiler.MacroHandler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.MacroHandler'
	self['_isType.sling.compiler.MacroHandler'] = true
	self.expandMacroCalls = true
	self.deleteMacroDeclarations = true
end

function sling.compiler.MacroHandler:_construct0()
	sling.compiler.MacroHandler._init(self)
	return self
end

sling.compiler.MacroHandler.CallInfo = {}
sling.compiler.MacroHandler.CallInfo.__index = sling.compiler.MacroHandler.CallInfo
_vm:set_metatable(sling.compiler.MacroHandler.CallInfo, {})

function sling.compiler.MacroHandler.CallInfo._create()
	local v = _vm:set_metatable({}, sling.compiler.MacroHandler.CallInfo)
	return v
end

function sling.compiler.MacroHandler.CallInfo:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.MacroHandler.CallInfo'
	self['_isType.sling.compiler.MacroHandler.CallInfo'] = true
	self.call = nil
	self.decl = nil
end

function sling.compiler.MacroHandler.CallInfo:_construct0()
	sling.compiler.MacroHandler.CallInfo._init(self)
	return self
end

function sling.compiler.MacroHandler.CallInfo:getCall()
	do return self.call end
end

function sling.compiler.MacroHandler.CallInfo:setCall(v)
	self.call = v
	do return self end
end

function sling.compiler.MacroHandler.CallInfo:getDecl()
	do return self.decl end
end

function sling.compiler.MacroHandler.CallInfo:setDecl(v)
	self.decl = v
	do return self end
end

sling.compiler.MacroHandler.MyVisitor = _g.sling.common.NodeVisitor._create()
sling.compiler.MacroHandler.MyVisitor.__index = sling.compiler.MacroHandler.MyVisitor
_vm:set_metatable(sling.compiler.MacroHandler.MyVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.MacroHandler.MyVisitor._create()
	local v = _vm:set_metatable({}, sling.compiler.MacroHandler.MyVisitor)
	return v
end

function sling.compiler.MacroHandler.MyVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.MacroHandler.MyVisitor'
	self['_isType.sling.compiler.MacroHandler.MyVisitor'] = true
	self.resolver = nil
	self.decls = {}
	self.calls = {}
end

function sling.compiler.MacroHandler.MyVisitor:_construct0()
	sling.compiler.MacroHandler.MyVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.MacroHandler.MyVisitor:tryGetDeclaration(fcx)
	if not (fcx ~= nil) then
		do return nil end
	end
	do
		local xpr = fcx:getExpression()
		if not (xpr ~= nil) then
			do return nil end
		end
		do
			local names = _g.sling.util.SymbolUtil:expressionToSymbolNames(xpr)
			if not (names ~= nil) then
				do return nil end
			end
			do
				local targetr = self.resolver:tryResolveNames(xpr:getParent(), names)
				if not (targetr ~= nil) then
					do return nil end
				end
				do
					local target = targetr:getNode()
					if not (target ~= nil) then
						do return nil end
					end
					do
						local parent = _vm:to_table_with_key(target:getParent(), '_isType.sling.common.ContainerNode')
						if not (parent ~= nil) then
							do return nil end
						end
						do
							local fcpc = _g.jk.lang.Vector:getSize(fcx:getParameters())
							local array = parent:getNodeIndexForName(_g.jk.lang.Vector:getLast(names))
							if array ~= nil then
								local n = 0
								local m = _g.jk.lang.Vector:getSize(array)
								do
									n = 0
									while n < m do
										local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
										if node ~= nil then
											if _g.jk.lang.Vector:getSize(node:getParameters()) == fcpc then
												do return node end
											end
										end
										do n = n + 1 end
									end
								end
							end
							do return nil end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.MacroHandler.MyVisitor:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
		if node:hasCustomModifier("macro") then
			do _g.jk.lang.Vector:append(self.decls, node) end
		end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
		local cd = self:tryGetDeclaration(node)
		if cd ~= nil and cd:hasCustomModifier("macro") then
			local ci = _g.sling.compiler.MacroHandler.CallInfo._construct0(_g.sling.compiler.MacroHandler.CallInfo._create())
			do ci:setCall(node) end
			do ci:setDecl(cd) end
			do _g.jk.lang.Vector:append(self.calls, ci) end
			do self:setSkipChildren(true) end
		end
	end
	do return true end
end

function sling.compiler.MacroHandler.MyVisitor:getResolver()
	do return self.resolver end
end

function sling.compiler.MacroHandler.MyVisitor:setResolver(v)
	self.resolver = v
	do return self end
end

function sling.compiler.MacroHandler.MyVisitor:getDecls()
	do return self.decls end
end

function sling.compiler.MacroHandler.MyVisitor:setDecls(v)
	self.decls = v
	do return self end
end

function sling.compiler.MacroHandler.MyVisitor:getCalls()
	do return self.calls end
end

function sling.compiler.MacroHandler.MyVisitor:setCalls(v)
	self.calls = v
	do return self end
end

sling.compiler.MacroHandler.AdjustExpandedMacroVisitor = _g.sling.common.NodeVisitor._create()
sling.compiler.MacroHandler.AdjustExpandedMacroVisitor.__index = sling.compiler.MacroHandler.AdjustExpandedMacroVisitor
_vm:set_metatable(sling.compiler.MacroHandler.AdjustExpandedMacroVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor._create()
	local v = _vm:set_metatable({}, sling.compiler.MacroHandler.AdjustExpandedMacroVisitor)
	return v
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.MacroHandler.AdjustExpandedMacroVisitor'
	self['_isType.sling.compiler.MacroHandler.AdjustExpandedMacroVisitor'] = true
	self.call = nil
	self.decl = nil
	self.object = nil
	self.symbols = {}
	self.objectrefs = {}
	self.decls = {}
	self.datatypes = {}
	self.literals = {}
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:_construct0()
	sling.compiler.MacroHandler.AdjustExpandedMacroVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:visit(node)
	do node:setSource(nil) end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
		do _g.jk.lang.Vector:append(self.symbols, node) end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		do _g.jk.lang.Vector:append(self.datatypes, node) end
	elseif (_vm:to_table_with_key(node, '_isType.sling.common.NamedNode') ~= nil) then
		local name = node:getNodeName()
		if name ~= nil and _g.jk.lang.String:startsWith(name, "__", 0) and _g.jk.lang.String:endsWith(name, "__") then
			do _g.jk.lang.Vector:append(self.decls, node) end
		end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.StringLiteralExpressionNode') ~= nil) then
		do _g.jk.lang.Vector:append(self.literals, node) end
	end
	do return true end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:getParameterExpressionForName(rn)
	local n = 0
	local array = self.decl:getParameters()
	if array ~= nil then
		local n2 = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n2 = 0
			while n2 < m do
				local vd = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
				if vd ~= nil then
					if not (rn == vd:getNodeName()) then
						do n = n + 1 end
						goto _continue5
					end
					do return self.call:getParameter(n) end
				end
				::_continue5::
				do n2 = n2 + 1 end
			end
		end
	end
	do return nil end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:getNameForExpression(par)
	local parse = _vm:to_table_with_key(par, '_isType.sling.model.SymbolExpressionNode')
	if not (parse ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Parameter must be a symbol expression", par, nil))
	end
	do
		local nname = _g.sling.util.SymbolUtil:getSymbolName(parse:getSymbol())
		if _g.jk.lang.String:isEmpty(nname) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty name", par, nil))
		end
		do return nname end
	end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:processLiterals(token, entity)
	if self.literals ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.literals)
		do
			n = 0
			while n < m do
				local literal = self.literals[n + 1]
				if literal ~= nil then
					if token ~= nil and literal:hasCustomModifier("preprocessorLineValue") then
						do literal:setValue(_g.jk.lang.String:forInteger(token:getSourceLineNumber() + 1)) end
					elseif token ~= nil and literal:hasCustomModifier("preprocessorColumnValue") then
						do literal:setValue(_g.jk.lang.String:forInteger(token:getSourceColumnNumber() + 1)) end
					elseif token ~= nil and literal:hasCustomModifier("preprocessorFileValue") then
						local name = nil
						local tt = _vm:to_table_with_key(token, '_isType.sling.common.Token')
						if tt ~= nil then
							local ts = tt.source
							if ts ~= nil then
								local tsf = ts:getFile()
								if tsf ~= nil then
									name = tsf:getBasename()
								end
							end
						end
						if _g.jk.lang.String:isEmpty(name) then
							name = token:getSourceName()
						end
						do literal:setValue(name) end
					elseif entity ~= nil and literal:hasCustomModifier("preprocessorThisValue") then
						do literal:setValue(entity:getName()) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:processSymbols()
	if self.symbols ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.symbols)
		do
			n = 0
			while n < m do
				local node = self.symbols[n + 1]
				if node ~= nil then
					local names = _g.sling.util.SymbolUtil:getSymbolNames(node:getSymbol())
					if not (names ~= nil) then
						goto _continue6
					end
					if _g.jk.lang.Vector:getSize(names) ~= 1 then
						goto _continue6
					end
					do
						local name = _g.jk.lang.String:forObject(_g.jk.lang.Vector:get(names, 0))
						if _g.jk.lang.String:isEmpty(name) then
							goto _continue6
						end
						if _g.jk.lang.String:startsWith(name, "__", 0) and _g.jk.lang.String:endsWith(name, "__") then
							local rn = _g.jk.lang.String:getSubString(name, 2, _g.jk.lang.String:getLength(name) - 4)
							if _g.jk.lang.String:isEmpty(rn) == false then
								local par = self:getParameterExpressionForName(rn)
								if par ~= nil then
									local nname = self:getNameForExpression(par)
									do node:setSymbol(_g.sling.model.SymbolNode:forName(nname), false) end
									goto _continue6
								end
							end
						end
						do
							local nxp = self:getParameterExpressionForName(name)
							if not (nxp ~= nil) then
								goto _continue6
							end
							do
								local pdup = _g.sling.util.ExpressionUtil:dupAsExpression(nxp)
								do _g.sling.util.NodeUtil:replaceNode(node, pdup) end
							end
						end
					end
				end
				::_continue6::
				do n = n + 1 end
			end
		end
	end
	if self.datatypes ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.datatypes)
		do
			n2 = 0
			while n2 < m2 do
				local node = self.datatypes[n2 + 1]
				if node ~= nil then
					local symbol = node:getSymbol()
					if not (symbol ~= nil) then
						goto _continue7
					end
					do
						local names = _g.sling.util.SymbolUtil:getSymbolNames(symbol)
						if not (names ~= nil) then
							goto _continue7
						end
						if _g.jk.lang.Vector:getSize(names) ~= 1 then
							goto _continue7
						end
						do
							local name = _g.jk.lang.String:forObject(_g.jk.lang.Vector:get(names, 0))
							if _g.jk.lang.String:isEmpty(name) then
								goto _continue7
							end
							if _g.jk.lang.String:startsWith(name, "__", 0) and _g.jk.lang.String:endsWith(name, "__") then
								local rn = _g.jk.lang.String:getSubString(name, 2, _g.jk.lang.String:getLength(name) - 4)
								if _g.jk.lang.String:isEmpty(rn) == false then
									local par = self:getParameterExpressionForName(rn)
									if par ~= nil then
										local nname = self:getNameForExpression(par)
										do node:setSymbol(_g.sling.model.SymbolNode:forName(nname), false) end
										goto _continue7
									end
								end
							end
						end
					end
				end
				::_continue7::
				do n2 = n2 + 1 end
			end
		end
	end
	if self.decls ~= nil then
		local n3 = 0
		local m3 = _g.jk.lang.Vector:getSize(self.decls)
		do
			n3 = 0
			while n3 < m3 do
				local nn = self.decls[n3 + 1]
				if nn ~= nil then
					local name = nn:getNodeName()
					if name == nil then
						goto _continue8
					end
					do
						local rn = _g.jk.lang.String:getSubString(name, 2, _g.jk.lang.String:getLength(name) - 4)
						if _g.jk.lang.String:isEmpty(rn) then
							goto _continue8
						end
						do
							local par = self:getParameterExpressionForName(rn)
							if par == nil then
								goto _continue8
							end
							do
								local nname = self:getNameForExpression(par)
								do nn:renameNode(nname) end
							end
						end
					end
				end
				::_continue8::
				do n3 = n3 + 1 end
			end
		end
	end
	if self.objectrefs ~= nil then
		local n4 = 0
		local m4 = _g.jk.lang.Vector:getSize(self.objectrefs)
		do
			n4 = 0
			while n4 < m4 do
				local ref = self.objectrefs[n4 + 1]
				if ref ~= nil then
					local odup = _vm:to_table_with_key(self.object:dup(), '_isType.sling.common.ExpressionNode')
					if odup == nil then
						goto _continue9
					end
					do _g.sling.util.NodeUtil:replaceNode(ref, odup) end
				end
				::_continue9::
				do n4 = n4 + 1 end
			end
		end
	end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:getCall()
	do return self.call end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:setCall(v)
	self.call = v
	do return self end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:getDecl()
	do return self.decl end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:setDecl(v)
	self.decl = v
	do return self end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:getObject()
	do return self.object end
end

function sling.compiler.MacroHandler.AdjustExpandedMacroVisitor:setObject(v)
	self.object = v
	do return self end
end

function sling.compiler.MacroHandler:getParentExpression(call)
	if not (call ~= nil) then
		do return nil end
	end
	do
		local xpr = _vm:to_table_with_key(call:getExpression(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (xpr ~= nil) then
			do return nil end
		end
		do
			local xdup = _vm:to_table_with_key(xpr:dup(), '_isType.sling.model.MemberAccessExpressionNode')
			if not (xdup ~= nil) then
				do return nil end
			end
			do return xdup:removeLastNode() end
		end
	end
end

function sling.compiler.MacroHandler:substituteExpressionMacro(call, decl, body)
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Expression macros: Not implemented.", call, nil))
end

function sling.compiler.MacroHandler:substituteStatementMacro(visitor, call, decl, body)
	local pp = _vm:to_table_with_key(call:getParent(), '_isType.sling.model.BlockNode')
	if not (pp ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Statement macro was called in an invalid context (not inside a block)", call, nil))
	end
	do
		local bdup = _g.sling.util.NodeUtil:dupBlock(body)
		local av = _g.sling.compiler.MacroHandler.AdjustExpandedMacroVisitor._construct0(_g.sling.compiler.MacroHandler.AdjustExpandedMacroVisitor._create())
		do av:setCall(call) end
		do av:setObject(self:getParentExpression(call)) end
		do av:setDecl(decl) end
		do bdup:accept(av) end
		do av:processSymbols() end
		do av:processLiterals(call:getSource(), _g.sling.util.FindUtil:findNearestEntity(call)) end
		do
			local ip = pp:getInsertionPointForNode(call)
			if not (ip ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get insertion point for node", call, nil))
			end
			do
				local array = bdup:exportNodes()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local ndup = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
							if ndup ~= nil then
								do ndup:setSource(call:getSource()) end
								if not ip:insertBefore(ndup) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insert node", ndup, nil))
								end
								do ndup:accept(visitor) end
							end
							do n = n + 1 end
						end
					end
				end
				do _g.sling.util.NodeUtil:removeNode(call) end
			end
		end
	end
end

function sling.compiler.MacroHandler:substitute(ci, visitor)
	local call = ci:getCall()
	local decl = ci:getDecl()
	local body = decl:getBody()
	if not (body ~= nil) then
		body = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	end
	do
		local dt = decl:getReturnType()
		if not (dt ~= nil) then
			dt = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
		end
		if (_vm:to_table_with_key(dt, '_isType.sling.model.VoidDataTypeNode') ~= nil) then
			do self:substituteStatementMacro(visitor, call, decl, body) end
		else
			do self:substituteExpressionMacro(call, decl, body) end
		end
	end
end

function sling.compiler.MacroHandler:execute(ctx, root, resolver, removeDeclarations)
	if not (root ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("MacroHandler: null root", nil, nil))
	end
	do
		local visitor = _g.sling.compiler.MacroHandler.MyVisitor._construct0(_g.sling.compiler.MacroHandler.MyVisitor._create())
		do visitor:setResolver(resolver) end
		do root:accept(visitor) end
		do
			local decls = visitor:getDecls()
			while true do
				local v2 = _g.sling.compiler.MacroHandler.MyVisitor._construct0(_g.sling.compiler.MacroHandler.MyVisitor._create())
				do v2:setResolver(resolver) end
				do
					local array = visitor:getCalls()
					if array ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(array)
						do
							n = 0
							while n < m do
								local call = array[n + 1]
								if call ~= nil then
									do self:substitute(call, v2) end
								end
								do n = n + 1 end
							end
						end
					end
					if _g.jk.lang.Vector:getSize(v2:getCalls()) < 1 then
						do break end
					end
					visitor = v2
				end
			end
			if removeDeclarations then
				if decls ~= nil then
					local n2 = 0
					local m2 = _g.jk.lang.Vector:getSize(decls)
					do
						n2 = 0
						while n2 < m2 do
							local decl = decls[n2 + 1]
							if decl ~= nil then
								do _g.sling.util.NodeUtil:removeNode(decl) end
							end
							do n2 = n2 + 1 end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.MacroHandler:getExpandMacroCalls()
	do return self.expandMacroCalls end
end

function sling.compiler.MacroHandler:setExpandMacroCalls(v)
	self.expandMacroCalls = v
	do return self end
end

function sling.compiler.MacroHandler:getDeleteMacroDeclarations()
	do return self.deleteMacroDeclarations end
end

function sling.compiler.MacroHandler:setDeleteMacroDeclarations(v)
	self.deleteMacroDeclarations = v
	do return self end
end

sling.compiler.SlingCompiler = {}
sling.compiler.SlingCompiler.__index = sling.compiler.SlingCompiler
_vm:set_metatable(sling.compiler.SlingCompiler, {})

sling.compiler.SlingCompiler.globalBuildVersion = nil

function sling.compiler.SlingCompiler._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingCompiler)
	return v
end

function sling.compiler.SlingCompiler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingCompiler'
	self['_isType.sling.compiler.SlingCompiler'] = true
	self.ctx = nil
	self.configurationCache = {}
	self.depth = 0
	self.workDir = nil
	self.infomapCompiled = {}
	self.infomapLibraries = {}
	self.includes = nil
	self.customDefines = nil
	self.customPlingOptions = nil
	self.compilerVersion = nil
	self.customPreprocessors = nil
	self.rebuildAll = false
	self.customLibs = nil
	self.forcedLibraries = nil
end

function sling.compiler.SlingCompiler:_construct0()
	sling.compiler.SlingCompiler._init(self)
	return self
end

function sling.compiler.SlingCompiler:getGlobalBuildVersion()
	if not (_g.sling.compiler.SlingCompiler.globalBuildVersion ~= nil) then
		local dd = _g.jk.time.SystemClock:asDateTimeUTC()
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		do sb:appendInteger(dd:getYear()) end
		do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(dd:getMonth(), 2, "0")) end
		do sb:appendString(_g.jk.lang.String:forIntegerWithPadding(dd:getDayOfMonth(), 2, "0")) end
		_g.sling.compiler.SlingCompiler.globalBuildVersion = sb:toString()
	end
	do return _g.sling.compiler.SlingCompiler.globalBuildVersion end
end

function sling.compiler.SlingCompiler:sanitizeModuleId(id)
	if not (id ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local it = _g.jk.lang.String:iterate(id)
		while it ~= nil do
			local c = it:getNextChar()
			if _g.jk.lang.Character:isEOF(c) then
				do break end
			end
			if _g.jk.lang.Character:isUppercaseAlpha(c) or _g.jk.lang.Character:isLowercaseAlpha(c) or _g.jk.lang.Character:isDigit(c) or c == 46 then
				do sb:appendCharacter(c) end
			else
				do sb:appendCharacter(95) end
			end
		end
		do return sb:toString() end
	end
end

function sling.compiler.SlingCompiler:_construct1(ctx)
	sling.compiler.SlingCompiler._init(self)
	do self:setCtx(ctx) end
	return self
end

function sling.compiler.SlingCompiler:getTargetPlatformId()
end

function sling.compiler.SlingCompiler:getTargetPlatformName()
end

function sling.compiler.SlingCompiler:getDefines(v)
end

function sling.compiler.SlingCompiler:transform(ctx, node, resolver)
end

function sling.compiler.SlingCompiler:writeModuleSources(ctx, node, output)
end

function sling.compiler.SlingCompiler:createLibraryManager()
end

function sling.compiler.SlingCompiler:getLinkTargetFile(directory, moduleName)
end

function sling.compiler.SlingCompiler:addToForcedLibraries(library)
	if not _g.jk.lang.String:isNotEmpty(library) then
		do return end
	end
	if not (self.forcedLibraries ~= nil) then
		self.forcedLibraries = {}
	end
	do _g.jk.lang.Vector:append(self.forcedLibraries, library) end
end

function sling.compiler.SlingCompiler:getLibraryManager()
	local v = self:createLibraryManager()
	if not (v ~= nil) then
		do _g.jk.lang.Error:throw("failedToCreate", "libraryManager") end
	end
	do
		local flibs = self:getForcedLibraries()
		if flibs ~= nil then
			if flibs ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(flibs)
				do
					n = 0
					while n < m do
						local flib = flibs[n + 1]
						if flib ~= nil then
							local nn = _g.sling.compiler.LibraryName:parse(flib)
							if not (nn ~= nil) then
								do _g.jk.lang.Error:throw("invalidLibraryName", flib) end
							end
							do v:setForcedLibraryVersion(_g.jk.lang.String:safeString(nn:getNamespace()) .. ":" .. _g.jk.lang.String:safeString(nn:getName()), nn:getVersion()) end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do
			local dd = _g.jk.env.CommonPath:getHomeDirectory()
			if dd ~= nil then
				dd = dd:entry(".sling"):entry("libs")
			end
			if not (dd ~= nil) then
				dd = _g.jk.env.TemporaryDirectory:create()
			end
			do v:setDirectory(dd) end
			do return v end
		end
	end
end

function sling.compiler.SlingCompiler:addCustomPreprocessor(pp)
	if not (pp ~= nil) then
		do return end
	end
	if not (self.customPreprocessors ~= nil) then
		self.customPreprocessors = {}
	end
	do _g.jk.lang.Vector:append(self.customPreprocessors, pp) end
end

function sling.compiler.SlingCompiler:setCtx(ctx)
	self.ctx = ctx
	do return self end
end

function sling.compiler.SlingCompiler:getCtx()
	do return self.ctx end
end

function sling.compiler.SlingCompiler:setModuleInfoForLibraries(entries)
	self.infomapLibraries = {}
	if entries ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(entries)
		do
			n = 0
			while n < m do
				local entry = entries[n + 1]
				if entry ~= nil then
					local id = entry:getModuleId()
					if _g.jk.lang.String:isEmpty(id) then
						goto _continue10
					end
					self.infomapLibraries[id] = entry
				end
				::_continue10::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingCompiler:setWorkDir(dir)
	self.workDir = dir
end

function sling.compiler.SlingCompiler:getWorkDir()
	if not (self.workDir ~= nil) then
		self.workDir = _g.jk.env.TemporaryDirectory:create()
	end
	if not (self.workDir ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to create a temporary working directory", nil, nil))
	end
	do return self.workDir end
end

function sling.compiler.SlingCompiler:getWorkDirFile(name)
	do return self:getWorkDir():entry(name) end
end

function sling.compiler.SlingCompiler:getBuildDirFor(file)
	if not (file ~= nil) then
		do return nil end
	end
	do
		local mid = self:getModuleId(file)
		if not (mid ~= nil) then
			do return nil end
		end
		do
			local str = file:getPath()
			if _g.jk.lang.Vector:getSize(self.customLibs) > 0 then
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendString(str) end
				if self.customLibs ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(self.customLibs)
					do
						n = 0
						while n < m do
							local clib = self.customLibs[n + 1]
							if clib ~= nil then
								local lib = clib:toString()
								do sb:appendCharacter(58) end
								do sb:appendString(lib) end
							end
							do n = n + 1 end
						end
					end
				end
				str = sb:toString()
			end
			do
				local hash = _g.jk.sha.SHAEncoder:getSha1HashForString(str)
				if not (hash ~= nil) then
					hash = _g.jk.md5.MD5Encoder:encodeString(str)
				end
				if _g.jk.lang.String:isNotEmpty(hash) then
					mid = _g.jk.lang.String:safeString(mid) .. "-" .. _g.jk.lang.String:safeString(hash)
				end
				do return self:getWorkDirFile(mid):entry(self:getTargetPlatformId()) end
			end
		end
	end
end

function sling.compiler.SlingCompiler:changeDepth(dx)
	self.depth = self.depth + dx
end

function sling.compiler.SlingCompiler:logWarning(text)
	do _g.jk.log.Log:warning(self.ctx, "[slingc:" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.depth)) .. "] " .. _g.jk.lang.String:safeString(text)) end
end

function sling.compiler.SlingCompiler:logInfo(text)
	do _g.jk.log.Log:info(self.ctx, "[slingc:" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.depth)) .. "] " .. _g.jk.lang.String:safeString(text)) end
end

function sling.compiler.SlingCompiler:logDebug(text)
	do _g.jk.log.Log:debug(self.ctx, "[slingc:" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(self.depth)) .. "] " .. _g.jk.lang.String:safeString(text)) end
end

function sling.compiler.SlingCompiler:getRawModuleId(module)
	if not (module ~= nil) then
		do return nil end
	end
	if module:isFile() then
		do return module:getBasenameWithoutExtension() end
	end
	if module:isDirectory() then
		do return module:getBasename() end
	end
	do return nil end
end

function sling.compiler.SlingCompiler:getModuleId(module)
	do return _g.sling.compiler.SlingCompiler:sanitizeModuleId(self:getRawModuleId(module)) end
end

function sling.compiler.SlingCompiler:getModuleConfiguration(module, customPlingOptions)
	if not (module ~= nil) then
		do return nil end
	end
	do
		local path = module:getPath()
		if not (path ~= nil) then
			do return nil end
		end
		do
			local v = _g.jk.lang.Map:get(self.configurationCache, path)
			if not (v ~= nil) then
				local parser = _g.sling.syntax.PlingParser._construct1(_g.sling.syntax.PlingParser._create(), self.ctx)
				local baseopts = nil
				local projectPling = module:getParent():entry("project.slon")
				if not projectPling:isFile() then
					projectPling = module:getParent():entry("project.pling")
				end
				if projectPling:isFile() then
					baseopts = parser:parseFileAsMap(projectPling)
				else
					local commonPling = module:getParent():entry("common.pling")
					if commonPling:isFile() then
						baseopts = parser:parseFileAsMap(commonPling)
						do self:logWarning("Processing a deprecated common.pling file: `" .. _g.jk.lang.String:safeString(commonPling:getPath()) .. "'") end
					end
				end
				do
					local co = customPlingOptions
					if not (co ~= nil) then
						co = self:getCustomPlingOptions()
					end
					if module:isDirectory() then
						local modulePling = module:entry("module.slon")
						if not modulePling:isFile() then
							modulePling = module:entry("module.pling")
						end
						if modulePling:isFile() then
							v = parser:parseFileAsUnitSettings(modulePling, baseopts, co)
						else
							local thisPling = module:entry("this.slon")
							if not thisPling:isFile() then
								thisPling = module:entry("this.pling")
							end
							if thisPling:isFile() then
								v = parser:parseFileAsUnitSettings(thisPling, baseopts, co)
							end
						end
					end
					if not (v ~= nil) then
						local map = baseopts
						if not (map ~= nil) then
							map = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
						end
						if co ~= nil then
							do map:mergeFrom(co) end
						end
						v = parser:createSettingsForMap(map)
					end
					if _g.jk.lang.String:isEmpty(v:getModuleId()) then
						local pid = self:getModuleId(module)
						if pid ~= nil then
							do v:setModuleId(pid) end
						end
					end
					if _g.jk.lang.String:isEmpty(v:getProjectVersion()) then
						do v:setProjectVersion(_g.sling.compiler.SlingCompiler:getGlobalBuildVersion()) end
					end
					self.configurationCache[path] = v
				end
			end
			do return v end
		end
	end
end

function sling.compiler.SlingCompiler:isSlingModule(module)
	if not (module ~= nil) then
		do return false end
	end
	if module:isFile() then
		if module:hasExtension("sling") then
			do return true end
		end
	elseif module:isDirectory() then
		if module:entry("module.slon"):isFile() then
			do return true end
		end
		if module:entry("module.pling"):isFile() then
			do return true end
		end
		do
			local v = false
			local es = module:entries()
			while es ~= nil do
				local cfile = es:next()
				if not (cfile ~= nil) then
					do break end
				end
				if cfile:isFile() and cfile:hasExtension("sling") then
					v = true
					do break end
				end
			end
			if es ~= nil and (_vm:to_table_with_key(es, '_isType.jk.lang.Closable') ~= nil) then
				do es:close() end
			end
			do return v end
		end
	end
	do return false end
end

function sling.compiler.SlingCompiler:getContainingModule(dir, name)
	if not (dir ~= nil) then
		do return nil end
	end
	if not _g.jk.lang.String:isNotEmpty(name) then
		do return nil end
	end
	do
		local nn = name
		while true do
			local module = dir:entry(nn)
			if _g.sling.compiler.SlingCompiler:isSlingModule(module) then
				if nn == name then
					do return module end
				end
				do
					local remain = _g.jk.lang.String:getEndOfString(name, _g.jk.lang.String:getLength(nn) + 1)
					if _g.jk.lang.String:isNotEmpty(remain) then
						local v = self:getContainingModule(module, remain)
						if v ~= nil then
							do return module end
						end
					end
				end
			end
			do
				local dot = _g.jk.lang.String:getLastIndexOfCharacter(nn, 46, -1)
				if dot < 0 then
					do break end
				end
				nn = _g.jk.lang.String:getSubString(nn, 0, dot)
			end
		end
		do return nil end
	end
end

function sling.compiler.SlingCompiler:findSlingModuleInIncludes(name)
	if not _g.jk.lang.String:isNotEmpty(name) then
		do return nil end
	end
	if self.includes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.includes)
		do
			n = 0
			while n < m do
				local include = self.includes[n + 1]
				if include ~= nil then
					local module = self:getContainingModule(include, name)
					if module ~= nil then
						do return module end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return nil end
end

function sling.compiler.SlingCompiler:readSlingFile(file, showParseMessages)
	if not (file ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null file given to readSlingFile", nil, nil))
	end
	do
		local code = nil
		local parser = _g.sling.syntax.SlingParser._construct0(_g.sling.syntax.SlingParser._create())
		local error = nil
		do _g.jk.log.Log:status(self.ctx, "[Reading] " .. _g.jk.lang.String:safeString(file:getPath()) .. " ..") end
		if showParseMessages then
			do parser:setCtx(self.ctx) end
		end
		do
			local _status, _err = _vm:execute_protected_call(function()
				code = parser:parseFile(file)
			end)
			if _err then
				if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
					local e = _err
					error = e
					code = nil
				else
					_vm:throw_error(_err)
				end
			end
		end
		if code ~= nil then
			local fid = file:getBasenameWithoutExtension()
			if fid ~= nil then
				local us = _g.jk.lang.String:getIndexOfCharacter(fid, 64, 0)
				if us > 0 then
					do code:renameNode(_g.jk.lang.String:getSubString(fid, 0, us)) end
					do
						local def = _g.jk.lang.String:getEndOfString(fid, us + 1)
						if _g.jk.lang.String:isNotEmpty(def) then
							local flatblock = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
							local array = code:exportNodes()
							if array ~= nil then
								local n = 0
								local m = _g.jk.lang.Vector:getSize(array)
								do
									n = 0
									while n < m do
										local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
										if node ~= nil then
											do flatblock:addNode(node) end
										end
										do n = n + 1 end
									end
								end
							end
							do
								local cc = _g.sling.model.PreprocessorIsDefinedExpressionNode:forVariable(def)
								local vv = _g.sling.model.PreprocessorIfStatementNode:instance(cc, flatblock, nil)
								do vv:setSource(code:getSource()) end
								do code:addNode(vv) end
							end
						end
					end
				else
					do code:renameNode(fid) end
				end
			end
		end
		do _g.jk.log.Log:status(self.ctx, nil) end
		if error ~= nil then
			_vm:throw_error(error)
		end
		do return code end
	end
end

function sling.compiler.SlingCompiler:readSlingString(string, name)
	if not (string ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null string given to readSlingString", nil, nil))
	end
	do
		local code = nil
		local error = nil
		local parser = _g.sling.syntax.SlingParser._construct0(_g.sling.syntax.SlingParser._create())
		do parser:setCtx(self.ctx) end
		do _g.jk.log.Log:status(self.ctx, "[Reading string] ..") end
		do
			local _status, _err = _vm:execute_protected_call(function()
				code = parser:parseString(string, name)
			end)
			if _err then
				if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
					local e = _err
					error = e
					code = nil
				else
					_vm:throw_error(_err)
				end
			end
		end
		do _g.jk.log.Log:status(self.ctx, nil) end
		if error ~= nil then
			_vm:throw_error(error)
		end
		do return code end
	end
end

function sling.compiler.SlingCompiler:executePostFilters(node)
	do _g.sling.compiler.JcoOps:validateWidgets(self.ctx, node) end
end

function sling.compiler.SlingCompiler:getRelativeFile(file, path)
	if not (file ~= nil and path ~= nil) then
		do return nil end
	end
	if file:isFile() then
		do return file:getSibling(path) end
	end
	if file:isDirectory() then
		do return file:entry(path) end
	end
	do return nil end
end

function sling.compiler.SlingCompiler:getDependencyModulesForTree(tree, myName)
	local v = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(tree, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if decl ~= nil then
					local array2 = decl:getImportNamespaces()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local ns = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.SymbolNode')
								if ns ~= nil then
									local nn = _g.sling.util.SymbolUtil:getSymbolNamesString(ns, 46)
									if myName == nil or _g.jk.lang.String:isNotEqual(myName, nn) then
										do v:add(nn) end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					do
						local array3 = decl:getImportEntities()
						if array3 ~= nil then
							local n3 = 0
							local m3 = _g.jk.lang.Vector:getSize(array3)
							do
								n3 = 0
								while n3 < m3 do
									local ns = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.ImportEntityStatementNode')
									if ns ~= nil then
										local nn = _g.sling.util.SymbolUtil:getSymbolNamesString(ns:getContainer(), 46)
										if _g.jk.lang.String:isEmpty(nn) then
											goto _continue11
										end
										if myName == nil or _g.jk.lang.String:isNotEqual(myName, nn) then
											do v:add(nn) end
										end
									end
									::_continue11::
									do n3 = n3 + 1 end
								end
							end
						end
						do
							local array4 = decl:getImportStaticNamespaces()
							if array4 ~= nil then
								local n4 = 0
								local m4 = _g.jk.lang.Vector:getSize(array4)
								do
									n4 = 0
									while n4 < m4 do
										local im = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.ImportStaticMemberStatementNode')
										if im ~= nil then
											local cn = _g.sling.util.SymbolUtil:getSymbolNamesString(im:getContainer(), 46)
											if _g.jk.lang.String:isEmpty(cn) then
												goto _continue12
											end
											if myName == nil or _g.jk.lang.String:isNotEqual(myName, cn) then
												do v:add(cn) end
											end
										end
										::_continue12::
										do n4 = n4 + 1 end
									end
								end
							end
							do
								local array5 = decl:getDependencies()
								if array5 ~= nil then
									local n5 = 0
									local m5 = _g.jk.lang.Vector:getSize(array5)
									do
										n5 = 0
										while n5 < m5 do
											local dd = (function(o)
												if (_vm:get_variable_type(o) == 'string') then
													do return o end
												end
												do return nil end
											end)(array5[n5 + 1])
											if dd ~= nil then
												if _g.jk.lang.String:startsWith(dd, "module:", 0) then
													local mm = _g.jk.lang.String:getEndOfString(dd, 7)
													if _g.jk.lang.String:isNotEmpty(mm) then
														do v:add(mm) end
													end
												end
											end
											do n5 = n5 + 1 end
										end
									end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v:getAll() end
end

function sling.compiler.SlingCompiler:processDirectoryToContainer(dir, container)
	if not (dir ~= nil) then
		do return 0 end
	end
	do
		local v = 0
		local it = dir:entries()
		while it ~= nil do
			local ff = it:next()
			if not (ff ~= nil) then
				do break end
			end
			if ff:isDirectory() then
				local dn = _g.sling.common.CodeDirectoryNode._construct0(_g.sling.common.CodeDirectoryNode._create())
				do dn:setName(ff:getBasename()) end
				do
					local r = self:processDirectoryToContainer(ff, dn)
					if r > 0 then
						do container:addNode(dn) end
					end
					v = v + r
				end
			elseif ff:isFile() and ff:hasExtension("sling") then
				do container:addNode(self:readSlingFile(ff, true)) end
				do v = v + 1 end
			end
		end
		do return v end
	end
end

function sling.compiler.SlingCompiler:readModuleSourceCodeFromFile(file)
	if not (file ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null file for readModuleSourceCodeFromFile", nil, nil))
	end
	do
		local moduleId = self:getModuleId(file)
		if _g.jk.lang.String:isEmpty(moduleId) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty module ID for file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, nil))
		end
		do self:logDebug("Reading source code for module `" .. _g.jk.lang.String:safeString(moduleId) .. "': `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
		do
			local v = nil
			if file:isFile() then
				v = _g.sling.common.CodeUnitNode._construct0(_g.sling.common.CodeUnitNode._create())
				do v:setName(moduleId) end
				do v:addNode(self:readSlingFile(file, true)) end
			elseif file:isDirectory() then
				v = _g.sling.common.CodeUnitNode._construct0(_g.sling.common.CodeUnitNode._create())
				do v:setName(moduleId) end
				if self:processDirectoryToContainer(file, v) < 1 then
					v = nil
				end
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a valid module: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, nil))
			end
			do return v end
		end
	end
end

function sling.compiler.SlingCompiler:readModuleSourceCodeFromString(moduleName, string)
	local file = self:readSlingString(string, moduleName)
	if not (file ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read module source code from string.", nil, nil))
	end
	do
		local v = _g.sling.common.CodeUnitNode._construct0(_g.sling.common.CodeUnitNode._create())
		do v:setName(moduleName) end
		do v:addNode(file) end
		do return v end
	end
end

function sling.compiler.SlingCompiler:readAndPreprocessModuleSourceCode(file, customPlingOptions)
	local moduleId = self:getModuleId(file)
	local mod = self:readModuleSourceCodeFromFile(file)
	if not (mod ~= nil) then
		do return nil end
	end
	do
		local options = self:getModuleConfiguration(file, customPlingOptions)
		if options ~= nil then
			local moduleImports = options:getImports()
			if moduleImports ~= nil then
				local array = _g.sling.common.NodeFinder:findCompatibleNodes(mod, "class:sling.model.EntityDeclarationNode", false, true, false)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local e = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
							if e ~= nil then
								if (_vm:to_table_with_key(e:getParent(), '_isType.sling.model.EntityDeclarationNode') ~= nil) then
									goto _continue13
								end
								if moduleImports ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(moduleImports)
									do
										n2 = 0
										while n2 < m2 do
											local imp = (function(o)
												if (_vm:get_variable_type(o) == 'string') then
													do return o end
												end
												do return nil end
											end)(moduleImports[n2 + 1])
											if imp ~= nil then
												do e:addToImportNamespaces(_g.sling.model.SymbolNode:forVectorOfNames(_g.jk.text.StringUtil:toObjectVector(_g.jk.lang.String:split(imp, 46, 0)))) end
											end
											do n2 = n2 + 1 end
										end
									end
								end
							end
							::_continue13::
							do n = n + 1 end
						end
					end
				end
			end
			if options:getIgnoreModuleIdInNamespace() then
				do mod:renameNode(nil) end
			end
		end
		do self:preprocessModule(moduleId, mod, options) end
		do return mod end
	end
end

function sling.compiler.SlingCompiler:preprocessModule(moduleId, mod, opts)
	local options = opts
	if not (options ~= nil) then
		options = _g.sling.model.ext.NSlingUnitSettings._construct0(_g.sling.model.ext.NSlingUnitSettings._create())
	end
	do
		local moduleDefines = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
		local cversion = self.compilerVersion
		if not (cversion ~= nil) then
			cversion = "0.18.0"
		end
		do moduleDefines:setString("slingCompilerVersion", cversion) end
		do moduleDefines:setString("targetPlatformId", self:getTargetPlatformId()) end
		do moduleDefines:setString("targetPlatformName", self:getTargetPlatformName()) end
		do moduleDefines:setString("projectVersion", options:getProjectVersion()) end
		do moduleDefines:setString("projectId", options:getProjectId()) end
		do moduleDefines:setString("projectName", options:getProjectId()) end
		do moduleDefines:setString("projectTitle", options:getProjectTitle()) end
		do moduleDefines:setString("projectDescription", options:getProjectDescription()) end
		do moduleDefines:setString("projectCopyright", options:getProjectCopyright()) end
		do moduleDefines:setString("projectLicense", options:getProjectLicense()) end
		do moduleDefines:setString("moduleId", options:getModuleId()) end
		do moduleDefines:setString("moduleName", options:getModuleId()) end
		do moduleDefines:setString("moduleTitle", options:getModuleTitle()) end
		do moduleDefines:setString("moduleDescription", options:getModuleDescription()) end
		do moduleDefines:setString("target_platformid", self:getTargetPlatformId()) end
		do moduleDefines:setString("target_platform", self:getTargetPlatformName()) end
		do moduleDefines:setString("sling_compiler", "true") end
		do moduleDefines:setString("sling_compiler_version", cversion) end
		do moduleDefines:setString("sling_project_version", options:getProjectVersion()) end
		do moduleDefines:setString("sling_project_id", options:getProjectId()) end
		do moduleDefines:setString("sling_project_name", options:getProjectId()) end
		do moduleDefines:setString("sling_project_title", options:getProjectTitle()) end
		do moduleDefines:setString("sling_project_description", options:getProjectDescription()) end
		do moduleDefines:setString("sling_project_copyright", options:getProjectCopyright()) end
		do moduleDefines:setString("sling_project_license", options:getProjectLicense()) end
		do moduleDefines:setString("sling_module_id", options:getModuleId()) end
		do moduleDefines:setString("sling_module_name", options:getModuleId()) end
		do moduleDefines:setString("sling_module_title", options:getModuleTitle()) end
		do moduleDefines:setString("sling_module_description", options:getModuleDescription()) end
		do moduleDefines:setString("name", options:getProjectId()) end
		do moduleDefines:setString("title", options:getProjectTitle()) end
		do moduleDefines:setString("displayname", options:getProjectTitle()) end
		do moduleDefines:setString("version", options:getProjectVersion()) end
		do self:getDefines(moduleDefines) end
		do moduleDefines:mergeFrom(options:getDefines()) end
		do moduleDefines:mergeFrom(self.customDefines) end
		if self.ctx ~= nil and self.ctx:isInDebugMode() then
			do _g.jk.log.Log:debug(self.ctx, "Preprocessing with these defines: `" .. _g.jk.lang.String:safeString(_g.jk.json.JSONEncoder:encode(moduleDefines, false, false)) .. "'") end
		end
		do _g.sling.compiler.SlingOps:preprocess(self.ctx, mod, moduleDefines) end
		if options:getUseJkop() == false then
			local array = _g.sling.common.NodeFinder:findCompatibleNodes(mod, "class:sling.model.EntityDeclarationNode", false, true, false)
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
						if decl ~= nil then
							do decl:addCustomModifier("nojkop") end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do options:setIsMainUnit(false) end
		do mod:setSettings(options, false) end
		if not (moduleId == "jk.lang") then
			do _g.sling.compiler.JkopOps:addJkopAutomaticImports(self.ctx, mod) end
		end
		do self:executePreprocessorFilters(mod) end
	end
end

function sling.compiler.SlingCompiler:executePreprocessorFilters(mod)
	local ph = _g.sling.compiler.ProgressHelper:forMaximumValue(self.ctx, "Preprocessing", 9 + _g.jk.lang.Vector:getSize(self.customPreprocessors))
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:consolidateEntities(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:preprocessProperties(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.JkopOps:convertModelsToJkop(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.JcoOps:convertUIExpressionsToWidgets(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.JkopOps:convertWebApiToSympathy(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.JkopOps:convertWebApi2ToSympathy(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.JkopOps:protectStringConcatenationExpressions(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.JkopOps:processCriticalSections(self.ctx, mod) end
	do ph:onUpdate() end
	do _g.sling.compiler.Samtree2Ops:execute(self.ctx, mod) end
	if self.customPreprocessors ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.customPreprocessors)
		do
			n = 0
			while n < m do
				local pp = self.customPreprocessors[n + 1]
				if pp ~= nil then
					do ph:onUpdate() end
					do pp(self.ctx, mod) end
				end
				do n = n + 1 end
			end
		end
	end
	do ph:_end() end
end

function sling.compiler.SlingCompiler:initializeOutputDirectory(output)
	if not (output ~= nil) then
		do return end
	end
	if output:exists() then
		if output:removeRecursive() == false then
			local dbg = false
			if self.ctx ~= nil then
				dbg = self.ctx:isInDebugMode()
			end
			do
				local emsg = _g.sling.common.ErrorMessage:forText("FAILED to delete existing output directory: `" .. _g.jk.lang.String:safeString(output:getPath()) .. "'", nil, dbg, nil)
				local lerr = output:getLastErrorDescription()
				if _g.jk.lang.String:isEmpty(lerr) then
					lerr = "(no details for the error)"
				end
				do emsg:addRelatedMessage(_g.sling.common.ErrorMessage:forText(lerr, nil, dbg, nil)) end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage(emsg:toStringWithDebug(dbg), nil, nil))
			end
		end
		if output:exists() then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Output directory was successfully deleted, but the directory still exists! `" .. _g.jk.lang.String:safeString(output:getPath()) .. "'", nil, nil))
		end
	end
	do output:createDirectoryRecursive() end
end

function sling.compiler.SlingCompiler:getDependencyModulesFromFile(file)
	if not (file ~= nil) then
		do return nil end
	end
	do
		local v = {}
		local array = file:readLinesVector()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local line = array[n + 1]
					if line ~= nil then
						if _g.jk.lang.String:isNotEmpty(line) then
							do _g.jk.lang.Vector:append(v, line) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function sling.compiler.SlingCompiler:writeDependenciesToFile(deps, file)
	if not (file ~= nil) then
		do return end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if deps ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(deps)
			do
				n = 0
				while n < m do
					local dp = deps[n + 1]
					if dp ~= nil then
						do sb:appendString(dp) end
						do sb:appendCharacter(10) end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local str = sb:toString()
			if not (str ~= nil) then
				str = ""
			end
			if not file:setContentsUTF8(str) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, nil))
			end
		end
	end
end

function sling.compiler.SlingCompiler:getModuleInfo(name)
	local v = _g.jk.lang.Map:get(self.infomapCompiled, name)
	if v ~= nil then
		do return v end
	end
	do return _g.jk.lang.Map:get(self.infomapLibraries, name) end
end

function sling.compiler.SlingCompiler:getCompiledModuleInfo(name)
	do return _g.jk.lang.Map:get(self.infomapCompiled, name) end
end

function sling.compiler.SlingCompiler:updateModuleInfo(name, info)
	self.infomapCompiled[name] = info
end

function sling.compiler.SlingCompiler:getFileTimestamp(file)
	if not (file ~= nil) then
		do return 0 end
	end
	if file:isFile() == false then
		do return 0 end
	end
	do return file:getLastModifiedTimeStamp() end
end

function sling.compiler.SlingCompiler:getDirectoryTimestamp(dir)
	if dir:isFile() then
		do return self:getFileTimestamp(dir) end
	end
	do
		local v = 0
		local ff = _g.jk.fs.FileFinder:forRoot(dir)
		while true do
			local file = ff:next()
			if not (file ~= nil) then
				do break end
			end
			do
				local ts = file:getLastModifiedTimeStamp()
				if ts > v then
					v = ts
				end
			end
		end
		do return v end
	end
end

function sling.compiler.SlingCompiler:readDependencyHeaders(deps, modules, processed)
	if deps ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(deps)
		do
			n = 0
			while n < m do
				local dep = deps[n + 1]
				if dep ~= nil then
					if processed:contains(dep) then
						goto _continue14
					end
					do processed:add(dep) end
					do
						local info = self:getModuleInfo(dep)
						if not (info ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No module info for dependency: `" .. _g.jk.lang.String:safeString(dep) .. "'", nil, nil))
						end
						do
							local header = info:getHeader()
							if not (header ~= nil) then
								do self:logDebug("Read dependency header `" .. _g.jk.lang.String:safeString(dep) .. "' ..") end
								header = _g.sling.common.CodeUnitNode._construct0(_g.sling.common.CodeUnitNode._create())
								do
									local ff = self:readSlingFile(info:getApifile(), false)
									do _g.sling.compiler.SlingOps:consolidateEntities(self.ctx, ff) end
									do header:addNode(ff) end
									do info:setHeader(header) end
								end
							else
								do self:logDebug("Read dependency header `" .. _g.jk.lang.String:safeString(dep) .. "': Cached") end
							end
							do self:readDependencyHeaders(info:getDependencies(), modules, processed) end
							do
								local dupped = _g.sling.util.NodeUtil:dupAsNode(header)
								if not (dupped ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to duplicate header node", header, nil))
								end
								do
									local duppedCodeUnit = _vm:to_table_with_key(dupped, '_isType.sling.common.CodeUnitNode')
									if not (duppedCodeUnit ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Dupped header node is not CodeUnitNode", dupped, nil))
									end
									do _g.jk.lang.Vector:append(modules, duppedCodeUnit) end
								end
							end
						end
					end
				end
				::_continue14::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingCompiler:normalize(node, resolver)
	local ph = _g.sling.compiler.ProgressHelper:forFirstHalf(self.ctx, "Normalizing", 35)
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:performCommonAdjustments(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:addReturnToMainFunction(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:removeComments(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:addDefaultModifiersToDeclarations(node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandMacros(self.ctx, node, resolver, false) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandFileSystemReferenceExpressions(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandStubFunctions(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandVariablesWithPropertyModifier(self.ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:forceUnresolveSymbols(node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:createSlingConstructors(self.ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:forceUnresolveSymbols(node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:removeEmptyNamespaces(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandAssertStatements(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandErrorStatements(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandFailureLiterals(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandVariableDeclarationExpressionsInIfStatements(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandElseBlocksInLoopDeclarations(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:transferTrailingParametersToParameters(node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:convertRangeExpressionsToJkopRange(node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:convertReferenceSubscriptsToFunctionCalls(node, resolver) end
	do ph:onUpdate() end
	do resolver:execute(node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:removeExpressionDataTypeNodes(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:processStringComparisonOperators(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:processAdditionOperators(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandMembershipCheckExpressions(node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandForeachStatementsStatic(self.ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:setDefaultValuesInVariableDeclarations(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:processDefaultDataTypeValues(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandThisReferences(self.ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:addAwaitAndAsyncModifiers(node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:flattenPromiseExpressions(node) end
	do ph:onUpdate() end
	do resolver:execute(node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:fixInheritanceTypes(self.ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:performAutomaticTypeConversions(self.ctx, resolver, node) end
	do ph:onUpdate() end
	do resolver:resolveBaseClassDeclarationsForMethods(self.ctx, node) end
	do ph:_end() end
end

function sling.compiler.SlingCompiler:processModuleByPath(module, customPlingOptions)
	if not (module ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null module", nil, nil))
	end
	if not _g.sling.compiler.SlingCompiler:isSlingModule(module) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a sling module: `" .. _g.jk.lang.String:safeString(module:getPath()) .. "'", nil, nil))
	end
	do
		local moduleId = self:getModuleId(module)
		if not (moduleId ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No module ID", nil, nil))
		end
		do
			local info = self:getCompiledModuleInfo(moduleId)
			if info ~= nil then
				do self:logDebug("Module `" .. _g.jk.lang.String:safeString(moduleId) .. "' already processed. Not processing: `" .. _g.jk.lang.String:safeString(module:getPath()) .. "'.") end
				do
					local ts = info:getTimestamp()
					if ts < 1 then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Circular dependency detected: `" .. _g.jk.lang.String:safeString(moduleId) .. "'", nil, nil))
					end
					do return ts end
				end
			end
			do self:changeDepth(1) end
			do self:logDebug("Processing: `" .. _g.jk.lang.String:safeString(module:getPath()) .. "' ..") end
			info = _g.sling.compiler.LinkableModuleInfo._construct0(_g.sling.compiler.LinkableModuleInfo._create())
			do info:setModuleId(moduleId) end
			do self:updateModuleInfo(moduleId, info) end
			do
				local targetdir = self:getBuildDirFor(module)
				if not (targetdir ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No targetdir", nil, nil))
				end
				do self:logDebug("Target directory for `" .. _g.jk.lang.String:safeString(moduleId) .. "': `" .. _g.jk.lang.String:safeString(targetdir:getPath()) .. "'") end
				do
					local apifile = targetdir:entry(_g.jk.lang.String:safeString(moduleId) .. ".sling")
					local depfile = targetdir:entry(_g.jk.lang.String:safeString(moduleId) .. ".deps")
					do info:setLinkTarget(self:getLinkTargetFile(targetdir, moduleId)) end
					do info:setApifile(apifile) end
					do info:setDepfile(depfile) end
					do
						local doBuild = false
						local code = nil
						local deps = nil
						local lastBuildTimestamp = self:getFileTimestamp(depfile)
						local sourceCodeTimestamp = self:getDirectoryTimestamp(module)
						if self.rebuildAll == false and sourceCodeTimestamp <= lastBuildTimestamp then
							deps = self:getDependencyModulesFromFile(depfile)
						else
							doBuild = true
							code = self:readAndPreprocessModuleSourceCode(module, customPlingOptions)
							deps = self:getDependencyModulesForTree(code, moduleId)
						end
						do
							local selfdep = false
							if deps ~= nil then
								local n = 0
								local m = _g.jk.lang.Vector:getSize(deps)
								do
									n = 0
									while n < m do
										local dep = deps[n + 1]
										if dep ~= nil then
											if dep == moduleId then
												selfdep = true
												do break end
											end
										end
										do n = n + 1 end
									end
								end
							end
							if selfdep then
								do self:logWarning("Module `" .. _g.jk.lang.String:safeString(moduleId) .. "' depends on itself. Ignoring the self-dependency.") end
								do
									local ndeps = {}
									if deps ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(deps)
										do
											n2 = 0
											while n2 < m2 do
												local dep = deps[n2 + 1]
												if dep ~= nil then
													if not (dep == moduleId) then
														do _g.jk.lang.Vector:append(ndeps, dep) end
													end
												end
												do n2 = n2 + 1 end
											end
										end
									end
									deps = ndeps
								end
							end
							do info:setDependencies(deps) end
							do
								local depts = 0
								if deps ~= nil then
									local n3 = 0
									local m3 = _g.jk.lang.Vector:getSize(deps)
									do
										n3 = 0
										while n3 < m3 do
											local dep = deps[n3 + 1]
											if dep ~= nil then
												do self:logDebug("Processing dependency of `" .. _g.jk.lang.String:safeString(moduleId) .. "': `" .. _g.jk.lang.String:safeString(dep) .. "'") end
												do
													local ts = self:processModuleByName(dep)
													if ts > depts then
														depts = ts
													end
												end
											end
											do n3 = n3 + 1 end
										end
									end
								end
								if depts > lastBuildTimestamp then
									doBuild = true
								end
								if doBuild then
									do self:logInfo("Building: `" .. _g.jk.lang.String:safeString(module:getPath()) .. "' ..") end
									if not (code ~= nil) then
										code = self:readAndPreprocessModuleSourceCode(module, customPlingOptions)
									end
									do
										local modules = {}
										do _g.jk.lang.Vector:append(modules, code) end
										do self:logDebug("Reading dependency headers of `" .. _g.jk.lang.String:safeString(moduleId) .. "' ..") end
										do self:readDependencyHeaders(deps, modules, _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())) end
										do
											local tree = _g.sling.compiler.SlingOps:transformToProcessingTree(self.ctx, modules)
											if not (tree ~= nil) then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to transform code units to processing tree", nil, nil))
											end
											do
												local resolver = _g.sling.compiler.SlingTypeResolver._construct0(_g.sling.compiler.SlingTypeResolver._create())
												do self:normalize(tree, resolver) end
												do targetdir:removeRecursive() end
												do targetdir:createDirectoryRecursive() end
												do
													local _status, _err = _vm:execute_protected_call(function()
														do _g.sling.compiler.SlingOps:validateTree(self.ctx, resolver, tree) end
														do
															local owm = _g.sling.common.StringOutputWriterManager._construct0(_g.sling.common.StringOutputWriterManager._create())
															do _g.sling.syntax.SlingGenerator._construct2(_g.sling.syntax.SlingGenerator._create(), self.ctx, owm):dumpHeader(tree, moduleId) end
															do
																local apistring = owm:toString()
																if apistring ~= nil then
																	local existingapi = apifile:getContentsUTF8()
																	if existingapi == nil or not (apistring == existingapi) then
																		do apifile:setContentsUTF8(apistring) end
																	end
																end
																do self:writeDependenciesToFile(self:getDependencyModulesForTree(tree, nil), depfile) end
																do _g.sling.compiler.SlingOps:removeMacroDeclarations(self.ctx, tree) end
																do _g.sling.compiler.SlingOps:processTypedefEntities(self.ctx, tree, resolver) end
																do self:transform(self.ctx, tree, resolver) end
																do self:executePostFilters(tree) end
																do _g.sling.op.CommonOps:removeHeaderDeclarations(self.ctx, tree) end
																do _g.sling.op.CommonOps:removeEmptyNamespaces(self.ctx, tree) end
																do self:writeModuleSources(self.ctx, tree, targetdir) end
															end
														end
													end)
													if _err then
														if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
															local e = _err
															do targetdir:removeRecursive() end
															_vm:throw_error(e)
														else
															_vm:throw_error(_err)
														end
													end
												end
												do self:logInfo("Built: `" .. _g.jk.lang.String:safeString(moduleId) .. "'") end
											end
										end
									end
								else
									do self:logDebug("Already up to date: `" .. _g.jk.lang.String:safeString(moduleId) .. "'") end
								end
								do info:setTimestamp(self:getFileTimestamp(apifile)) end
								do self:changeDepth(-1) end
								do return info:getTimestamp() end
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingCompiler:processModuleByName(name)
	local module = self:findSlingModuleInIncludes(name)
	if module ~= nil then
		do return self:processModuleByPath(module, nil) end
	end
	do
		local info = self:getModuleInfo(name)
		if info ~= nil then
			local ts = info:getTimestamp()
			if ts >= 0 then
				do return ts end
			end
		end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find required module: `" .. _g.jk.lang.String:safeString(name) .. "'", nil, nil))
		do return 0 end
	end
end

function sling.compiler.SlingCompiler:addToModuleInfos(v, ids, handled)
	if ids ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(ids)
		do
			n = 0
			while n < m do
				local id = ids[n + 1]
				if id ~= nil then
					if handled:contains(id) then
						goto _continue15
					end
					do handled:add(id) end
					do
						local mi = self:getModuleInfo(id)
						if not (mi ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find module: `" .. _g.jk.lang.String:safeString(id) .. "'", nil, nil))
						end
						do self:addToModuleInfos(v, mi:getDependencies(), handled) end
						do _g.jk.lang.Vector:append(v, mi) end
					end
				end
				::_continue15::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingCompiler:toModuleInfos(modules)
	local v = {}
	local ids = {}
	if modules ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(modules)
		do
			n = 0
			while n < m do
				local module = modules[n + 1]
				if module ~= nil then
					do _g.jk.lang.Vector:append(ids, self:getModuleId(module)) end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local handled = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
		do self:addToModuleInfos(v, ids, handled) end
		do return v end
	end
end

function sling.compiler.SlingCompiler:getAllModulesForSource(source)
	if not (source ~= nil) then
		do return nil end
	end
	do
		local v = {}
		do _g.jk.lang.Vector:append(v, source) end
		do return self:toModuleInfos(v) end
	end
end

sling.compiler.SlingCompiler.CompileLibraryResult = {}
sling.compiler.SlingCompiler.CompileLibraryResult.__index = sling.compiler.SlingCompiler.CompileLibraryResult
_vm:set_metatable(sling.compiler.SlingCompiler.CompileLibraryResult, {})

function sling.compiler.SlingCompiler.CompileLibraryResult._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingCompiler.CompileLibraryResult)
	return v
end

function sling.compiler.SlingCompiler.CompileLibraryResult:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingCompiler.CompileLibraryResult'
	self['_isType.sling.compiler.SlingCompiler.CompileLibraryResult'] = true
	self.file = nil
	self.wasModified = false
end

function sling.compiler.SlingCompiler.CompileLibraryResult:_construct0()
	sling.compiler.SlingCompiler.CompileLibraryResult._init(self)
	return self
end

function sling.compiler.SlingCompiler.CompileLibraryResult:getFile()
	do return self.file end
end

function sling.compiler.SlingCompiler.CompileLibraryResult:setFile(v)
	self.file = v
	do return self end
end

function sling.compiler.SlingCompiler.CompileLibraryResult:getWasModified()
	do return self.wasModified end
end

function sling.compiler.SlingCompiler.CompileLibraryResult:setWasModified(v)
	self.wasModified = v
	do return self end
end

function sling.compiler.SlingCompiler:compileSlingLibrary(src, moduleDirs, outfile, outdir, customPlingOptions, incremental)
	if src ~= nil then
		do _g.jk.log.Log:debug(self.ctx, "Compiling library: `" .. _g.jk.lang.String:safeString(src:getPath()) .. "' ..") end
	else
		do _g.jk.log.Log:debug(self.ctx, "Compiling library ..") end
	end
	do
		local namespace = nil
		local name = nil
		local version = nil
		local title = nil
		local description = nil
		local copyright = nil
		local license = nil
		local libraries = nil
		local pmap = nil
		if src ~= nil then
			local pling = src:entry("project.slon")
			if not pling:isFile() then
				pling = src:entry("project.pling")
			end
			if pling:isFile() then
				local cpo = customPlingOptions
				if not (cpo ~= nil) then
					cpo = self:getCustomPlingOptions()
				end
				pmap = _g.sling.syntax.PlingParser._construct1(_g.sling.syntax.PlingParser._create(), self.ctx):parseFileAsUnitSettings(pling, nil, cpo)
			else
				do _g.jk.log.Log:warning(self.ctx, "Library project has no project file: `" .. _g.jk.lang.String:safeString(src:getPath()) .. "'") end
			end
		end
		if not (pmap ~= nil) and customPlingOptions ~= nil then
			pmap = _g.sling.syntax.PlingParser._construct1(_g.sling.syntax.PlingParser._create(), self.ctx):createSettingsForMap(customPlingOptions)
		end
		if pmap ~= nil then
			namespace = pmap:getVendorId()
			name = pmap:getProjectId()
			version = pmap:getProjectVersion()
			title = pmap:getProjectTitle()
			description = pmap:getProjectDescription()
			copyright = pmap:getProjectCopyright()
			license = pmap:getProjectLicense()
			libraries = pmap:getLibraries()
		end
		if _g.jk.lang.String:isEmpty(version) then
			version = _g.sling.compiler.SlingCompiler:getGlobalBuildVersion()
		end
		do
			local psrc = nil
			if src ~= nil then
				psrc = _g.sling.common.StaticSourceReference:forFile(src)
			end
			if _g.jk.lang.String:isEmpty(namespace) then
				do _g.sling.common.RefLog:warning(self.ctx, "No `vendorId' defined for project.", psrc) end
			end
			if _g.jk.lang.String:isEmpty(name) then
				do _g.sling.common.RefLog:warning(self.ctx, "No `projectId' defined for project.", psrc) end
			end
			if _g.jk.lang.String:isEmpty(version) then
				do _g.sling.common.RefLog:warning(self.ctx, "No `projectVersion' defined for project.", psrc) end
			end
			libraries = _g.sling.compiler.LibraryManager:substituteCustomLibraries(libraries, self.customLibs)
			do
				local outputfile = outfile
				if not (outputfile ~= nil) then
					local outputdir = outdir
					if not (outputdir ~= nil) and src ~= nil then
						outputdir = src:getParent()
					end
					if outputdir ~= nil and _g.jk.lang.String:isNotEmpty(namespace) and _g.jk.lang.String:isNotEmpty(name) and _g.jk.lang.String:isNotEmpty(version) then
						local filename = _g.jk.lang.String:safeString(namespace) .. "_" .. _g.jk.lang.String:safeString(name) .. "_" .. _g.jk.lang.String:safeString(version) .. "_" .. _g.jk.lang.String:safeString(self:getTargetPlatformId()) .. ".slib"
						outputfile = outputdir:entry(filename)
					end
				end
				if not (outputfile ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Output file was not specified and can not be automatically determined.", nil, nil))
					do return nil end
				end
				do
					local sources = {}
					if src ~= nil then
						local it = src:entries()
						while it ~= nil do
							local ff = it:next()
							if not (ff ~= nil) then
								do break end
							end
							if _g.sling.compiler.SlingCompiler:isSlingModule(ff) then
								do _g.jk.lang.Vector:append(sources, ff) end
							end
						end
					end
					if moduleDirs ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(moduleDirs)
						do
							n = 0
							while n < m do
								local moduleDir = moduleDirs[n + 1]
								if moduleDir ~= nil then
									local it = moduleDir:entries()
									while it ~= nil do
										local ff = it:next()
										if not (ff ~= nil) then
											do break end
										end
										if _g.sling.compiler.SlingCompiler:isSlingModule(ff) then
											do _g.jk.lang.Vector:append(sources, ff) end
										end
									end
								end
								do n = n + 1 end
							end
						end
					end
					if _g.jk.lang.Vector:isEmpty(sources) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No source modules found.", nil, nil))
					end
					if sources ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(sources)
						do
							n2 = 0
							while n2 < m2 do
								local source = sources[n2 + 1]
								if source ~= nil then
									do self:processModuleByPath(source, customPlingOptions) end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					do
						local files = {}
						local resources = {}
						if sources ~= nil then
							local n3 = 0
							local m3 = _g.jk.lang.Vector:getSize(sources)
							do
								n3 = 0
								while n3 < m3 do
									local source = sources[n3 + 1]
									if source ~= nil then
										local bd = self:getBuildDirFor(source)
										if bd ~= nil then
											local id = self:getModuleId(source)
											id = _g.jk.lang.String:safeString(id) .. "."
											do
												local fit = bd:entries()
												while fit ~= nil do
													local ff = fit:next()
													if not (ff ~= nil) then
														do break end
													end
													do
														local fn = ff:getBasename()
														if not _g.jk.lang.String:startsWith(fn, id, 0) then
															goto _continue16
														end
														if _g.jk.lang.String:getIndexOfCharacter(fn, 46, _g.jk.lang.String:getLength(id)) >= 0 then
															goto _continue16
														end
														do _g.jk.lang.Vector:append(files, ff) end
													end
													::_continue16::
												end
												do
													local srcdir = bd:entry("src")
													if srcdir:isDirectory() then
														do _g.jk.lang.Vector:append(files, srcdir) end
													end
													do
														local resdir = bd:entry("resources")
														if resdir:isDirectory() then
															local rit = resdir:entries()
															while rit ~= nil do
																local ff = rit:next()
																if not (ff ~= nil) then
																	do break end
																end
																do _g.jk.lang.Vector:append(resources, ff) end
															end
														end
													end
												end
											end
										end
									end
									do n3 = n3 + 1 end
								end
							end
						end
						if incremental and outputfile:isFile() then
							local dobuild = false
							local outputfilets = outputfile:getLastModifiedTimeStamp()
							if files ~= nil then
								local n4 = 0
								local m4 = _g.jk.lang.Vector:getSize(files)
								do
									n4 = 0
									while n4 < m4 do
										local ff = files[n4 + 1]
										if ff ~= nil then
											if ff:getLastModifiedTimeStamp() > outputfilets then
												dobuild = true
												do break end
											end
										end
										do n4 = n4 + 1 end
									end
								end
							end
							if not dobuild then
								do _g.jk.log.Log:debug(self.ctx, "No changes: `" .. _g.jk.lang.String:safeString(outputfile:getPath()) .. "'") end
								do return _g.sling.compiler.SlingCompiler.CompileLibraryResult._construct0(_g.sling.compiler.SlingCompiler.CompileLibraryResult._create()):setFile(outputfile):setWasModified(false) end
							end
						end
						do
							local tmpdir = _g.jk.env.TemporaryDirectory:create()
							if not (tmpdir ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to create temporary directory for building slib", nil, nil))
							end
							do tmpdir:removeRecursive() end
							do tmpdir:createDirectoryRecursive() end
							if files ~= nil then
								local n5 = 0
								local m5 = _g.jk.lang.Vector:getSize(files)
								do
									n5 = 0
									while n5 < m5 do
										local ff = files[n5 + 1]
										if ff ~= nil then
											local fn = ff:getBasename()
											local dest = tmpdir:entry(fn)
											do _g.jk.log.Log:debug(self.ctx, "Copy: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(ff)) .. "' -> `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(dest)) .. "'") end
											if not ff:copyFileOrDirectoryTo(dest) then
												do tmpdir:removeRecursive() end
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to copy file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(ff)) .. "'", nil, nil))
											end
										end
										do n5 = n5 + 1 end
									end
								end
							end
							if _g.jk.lang.Vector:isNotEmpty(resources) then
								local tmpresdir = tmpdir:entry("resources")
								do tmpresdir:createDirectoryRecursive() end
								if resources ~= nil then
									local n6 = 0
									local m6 = _g.jk.lang.Vector:getSize(resources)
									do
										n6 = 0
										while n6 < m6 do
											local ff = resources[n6 + 1]
											if ff ~= nil then
												local fn = ff:getBasename()
												local dest = tmpresdir:entry(fn)
												do _g.jk.log.Log:debug(self.ctx, "Copy resource: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(ff)) .. "' -> `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(dest)) .. "'") end
												if not ff:copyFileOrDirectoryTo(dest) then
													do tmpdir:removeRecursive() end
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to copy resource: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(ff)) .. "'", nil, nil))
												end
											end
											do n6 = n6 + 1 end
										end
									end
								end
							end
							do
								local manifest = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
								do manifest:setString("namespace", namespace) end
								do manifest:setString("name", name) end
								do manifest:setString("version", version) end
								do manifest:setString("title", title) end
								do manifest:setString("description", description) end
								do manifest:setString("copyright", copyright) end
								do manifest:setString("license", license) end
								if libraries ~= nil then
									local libs = _g.jk.lang.DynamicVector._construct0(_g.jk.lang.DynamicVector._create())
									if libraries ~= nil then
										local n7 = 0
										local m7 = _g.jk.lang.Vector:getSize(libraries)
										do
											n7 = 0
											while n7 < m7 do
												local library = (function(o)
													if (_vm:get_variable_type(o) == 'string') then
														do return o end
													end
													do return nil end
												end)(libraries[n7 + 1])
												if library ~= nil then
													do libs:appendString(library) end
												end
												do n7 = n7 + 1 end
											end
										end
									end
									do manifest:setObject("libraries", libs) end
								end
								do
									local mfile = tmpdir:entry("slib.manifest")
									if not mfile:setContentsUTF8(_g.jk.json.JSONEncoder:encode(manifest, true, false)) then
										do tmpdir:removeRecursive() end
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write slib manifest", nil, nil))
									end
									do outputfile:getParent():createDirectoryRecursive() end
									do
										local r = _g.jk.archive.ZipWriter:writeToZipRecursive(nil, outputfile, tmpdir, true)
										do tmpdir:removeRecursive() end
										if r == false or not outputfile:exists() then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to create slib file: `" .. _g.jk.lang.String:safeString(outputfile:getPath()) .. "'", nil, nil))
										end
										do _g.jk.log.Log:info(self.ctx, "Compiled: `" .. _g.jk.lang.String:safeString(outputfile:getPath()) .. "'") end
										do return _g.sling.compiler.SlingCompiler.CompileLibraryResult._construct0(_g.sling.compiler.SlingCompiler.CompileLibraryResult._create()):setFile(outputfile):setWasModified(true) end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingCompiler:getFinalVersion(version)
	local v = version
	if _g.jk.lang.String:isEmpty(v) then
		v = _g.sling.compiler.SlingCompiler:getGlobalBuildVersion()
	end
	do return v end
end

function sling.compiler.SlingCompiler:getFinalApplicationName(source, customName)
	local v = customName
	if _g.jk.lang.String:isEmpty(v) then
		v = self:getRawModuleId(source)
		if _g.jk.lang.String:isEmpty(v) then
			v = "application"
		end
	end
	do return v end
end

function sling.compiler.SlingCompiler:buildApplicationModules(source, customName, customVersion)
	local libraryManager = self:getLibraryManager()
	local incls = {}
	local array = self:getIncludes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local incl = array[n + 1]
				if incl ~= nil then
					do _g.jk.lang.Vector:append(incls, incl) end
				end
				do n = n + 1 end
			end
		end
	end
	if source ~= nil then
		do _g.jk.lang.Vector:append(incls, source:getParent()) end
	end
	do self:setModuleInfoForLibraries(libraryManager:generateModuleInfosForBuild(self.ctx, incls, self:getCustomLibs())) end
	do self:setIncludes(incls) end
	do
		local cpo = self:getCustomPlingOptions()
		if _g.jk.lang.String:isNotEmpty(customVersion) then
			if not (cpo ~= nil) then
				cpo = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
			end
			do cpo:setString("projectVersion", customVersion) end
		end
		if _g.jk.lang.String:isNotEmpty(customName) then
			if not (cpo ~= nil) then
				cpo = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
			end
			do cpo:setString("projectId", customName) end
		end
		do self:processModuleByPath(source, cpo) end
	end
end

function sling.compiler.SlingCompiler:buildToSlingLibrary(source, output, customVersion, install)
	local version = self:getFinalVersion(customVersion)
	local libraryManager = self:getLibraryManager()
	local incls = {}
	local array = self:getIncludes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local incl = array[n + 1]
				if incl ~= nil then
					do _g.jk.lang.Vector:append(incls, incl) end
				end
				do n = n + 1 end
			end
		end
	end
	do _g.jk.lang.Vector:append(incls, source) end
	do self:setModuleInfoForLibraries(libraryManager:generateModuleInfosForBuild(self.ctx, incls, self:getCustomLibs())) end
	do self:setIncludes(incls) end
	do
		local cpo = self:getCustomPlingOptions()
		local cve = version
		if _g.jk.lang.String:isNotEmpty(cve) then
			if not (cpo ~= nil) then
				cpo = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
			end
			do cpo:setString("projectVersion", cve) end
		end
		do
			local v = self:compileSlingLibrary(source, nil, nil, output, cpo, true)
			local vfile = v:getFile()
			do _g.jk.log.Log:info(self.ctx, "Library: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(vfile))) end
			if install and v:getWasModified() then
				if not libraryManager:installLibraryFromFile(self.ctx, vfile, true) then
					do _g.jk.lang.Error:throw("failedToInstall", vfile:getPath()) end
				end
			end
		end
	end
end

function sling.compiler.SlingCompiler:getIncludes()
	do return self.includes end
end

function sling.compiler.SlingCompiler:setIncludes(v)
	self.includes = v
	do return self end
end

function sling.compiler.SlingCompiler:getCustomDefines()
	do return self.customDefines end
end

function sling.compiler.SlingCompiler:setCustomDefines(v)
	self.customDefines = v
	do return self end
end

function sling.compiler.SlingCompiler:getCustomPlingOptions()
	do return self.customPlingOptions end
end

function sling.compiler.SlingCompiler:setCustomPlingOptions(v)
	self.customPlingOptions = v
	do return self end
end

function sling.compiler.SlingCompiler:getCompilerVersion()
	do return self.compilerVersion end
end

function sling.compiler.SlingCompiler:setCompilerVersion(v)
	self.compilerVersion = v
	do return self end
end

function sling.compiler.SlingCompiler:getCustomPreprocessors()
	do return self.customPreprocessors end
end

function sling.compiler.SlingCompiler:setCustomPreprocessors(v)
	self.customPreprocessors = v
	do return self end
end

function sling.compiler.SlingCompiler:getRebuildAll()
	do return self.rebuildAll end
end

function sling.compiler.SlingCompiler:setRebuildAll(v)
	self.rebuildAll = v
	do return self end
end

function sling.compiler.SlingCompiler:getCustomLibs()
	do return self.customLibs end
end

function sling.compiler.SlingCompiler:setCustomLibs(v)
	self.customLibs = v
	do return self end
end

function sling.compiler.SlingCompiler:getForcedLibraries()
	do return self.forcedLibraries end
end

function sling.compiler.SlingCompiler:setForcedLibraries(v)
	self.forcedLibraries = v
	do return self end
end

sling.compiler.SlingOps = {}
sling.compiler.SlingOps.__index = sling.compiler.SlingOps
_vm:set_metatable(sling.compiler.SlingOps, {})

function sling.compiler.SlingOps._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingOps)
	return v
end

function sling.compiler.SlingOps:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingOps'
	self['_isType.sling.compiler.SlingOps'] = true
end

function sling.compiler.SlingOps:_construct0()
	sling.compiler.SlingOps._init(self)
	return self
end

function sling.compiler.SlingOps:performCommonAdjustments(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.TryCatchStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local tcs = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.TryCatchStatementNode')
				if tcs ~= nil then
					if _g.jk.lang.Vector:getSize(tcs:getCatchBlocks()) < 1 then
						local evar = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ExceptionDataTypeNode._construct0(_g.sling.model.ExceptionDataTypeNode._create()), "e", nil)
						do tcs:addToCatchBlocks(_g.sling.model.CatchBlockNode:instance(evar, _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()))) end
					end
					do
						local array2 = tcs:getCatchBlocks()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local cb = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.CatchBlockNode')
									if cb ~= nil then
										local array3 = cb:getExceptions()
										if array3 ~= nil then
											local n3 = 0
											local m3 = _g.jk.lang.Vector:getSize(array3)
											do
												n3 = 0
												while n3 < m3 do
													local x = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
													if x ~= nil then
														if not (x:getType() ~= nil) then
															do x:setType(_g.sling.model.ExceptionDataTypeNode._construct0(_g.sling.model.ExceptionDataTypeNode._create()), false) end
														end
													end
													do n3 = n3 + 1 end
												end
											end
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:preprocess(ctx, node, defines)
	local pp = _g.sling.compiler.SlingPreprocessor:forDefines(defines)
	do pp:setCtx(ctx) end
	do pp:execute(node) end
end

function sling.compiler.SlingOps:processDefaultDataTypeValues(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.DataTypeDefaultValueExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.DataTypeDefaultValueExpressionNode')
				if nn ~= nil then
					local v = _g.sling.compiler.SlingOps:createDataTypeDefaultValue(nn:getType())
					if not (v ~= nil) then
						v = _g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())
					end
					do v:setSource(nn:getSource()) end
					do _g.sling.util.NodeUtil:replaceNode(nn, v) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:expandElseBlocksInLoopDeclarations(ctx, root)
	local array = _g.sling.common.NodeFinder:findNodesOfTypes(root, {
		"class:sling.model.WhileStatementNode",
		"class:sling.model.ForEachStatementNode"
	}, false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = array[n + 1]
				if node ~= nil then
					local prnt = _vm:to_table_with_key(node:getParent(), '_isType.sling.common.ContainerNode')
					if not (prnt ~= nil) then
						goto _continue17
					end
					do
						local elseBlock = nil
						if (_vm:to_table_with_key(node, '_isType.sling.model.ForEachStatementNode') ~= nil) then
							elseBlock = _vm:to_table_with_key(node, '_isType.sling.model.ForEachStatementNode'):exportElseBlock()
						end
						if (_vm:to_table_with_key(node, '_isType.sling.model.WhileStatementNode') ~= nil) then
							elseBlock = _vm:to_table_with_key(node, '_isType.sling.model.WhileStatementNode'):exportElseBlock()
						end
						if not (elseBlock ~= nil) then
							goto _continue17
						end
						do
							local brName = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(node, "islb")
							local brk = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), brName, nil)
							do prnt:insertAboveNode(brk, node) end
							do
								local array2 = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.BreakStatementNode", false, true, false)
								if array2 ~= nil then
									local n2 = 0
									local m2 = _g.jk.lang.Vector:getSize(array2)
									do
										n2 = 0
										while n2 < m2 do
											local brn = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.BreakStatementNode')
											if brn ~= nil then
												local brkIsTrue = _g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName(brName), _g.sling.model.BooleanLiteralExpressionNode:forValue(true))
												local brkParent = _vm:to_table_with_key(brn:getParent(), '_isType.sling.common.ContainerNode')
												if not (brkParent ~= nil) then
													goto _continue18
												end
												do brkParent:insertAboveNode(brkIsTrue, brn) end
											end
											::_continue18::
											do n2 = n2 + 1 end
										end
									end
								end
								do
									local exp = _g.sling.model.EqualsExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forName(brName), _g.sling.model.BooleanLiteralExpressionNode:forValue(false))
									local isn = _g.sling.model.IfStatementNode:instance(exp, elseBlock, nil)
									do prnt:insertBelowNode(isn, node) end
								end
							end
						end
					end
				end
				::_continue17::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:expandVariableDeclarationExpressionsInIfStatements(ctx, root)
	local array = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.IfStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ifst = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.IfStatementNode')
				if ifst ~= nil then
					local vxps = _g.sling.common.NodeFinder:findNodesOfType(ifst:getCondition(), "class:sling.model.VariableDeclarationExpressionNode", false, true, false)
					if _g.jk.lang.Vector:isEmpty(vxps) then
						goto _continue19
					end
					do
						local blck = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
						do _g.sling.util.NodeUtil:replaceAndExport(ifst, blck) end
						do
							local stms = {}
							if vxps ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(vxps)
								do
									n2 = 0
									while n2 < m2 do
										local vdex = _vm:to_table_with_key(vxps[n2 + 1], '_isType.sling.model.VariableDeclarationExpressionNode')
										if vdex ~= nil then
											local vdec = vdex:exportDeclaration()
											local symf = _g.sling.model.SymbolExpressionNode:forName(vdec:getName())
											do _g.sling.util.NodeUtil:replaceNode(vdex, symf) end
											do _g.jk.lang.Vector:append(stms, vdec) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
							do _g.jk.lang.Vector:append(stms, ifst) end
							do blck:setNodes(stms) end
						end
					end
				end
				::_continue19::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:expandPropertyDeclarationsToMethods(ctx, node, resolver)
	do _g.sling.compiler.PropertyDeclarationExpander._construct0(_g.sling.compiler.PropertyDeclarationExpander._create()):execute(ctx, node, resolver) end
end

function sling.compiler.SlingOps:expandVariablesWithPropertyModifier(ctx, resolver, node)
	do _g.sling.compiler.PropertyVariableExpander._construct0(_g.sling.compiler.PropertyVariableExpander._create()):execute(node, resolver) end
end

function sling.compiler.SlingOps:consolidateEntities(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local entity = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if entity ~= nil then
					local deps = {}
					local pimps = {}
					local eimps = {}
					local simps = {}
					local bts = {}
					local mods = {}
					local cmods = {}
					local array2 = entity:getNodes()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local childNode = array2[n2 + 1]
								if childNode ~= nil then
									if (_vm:to_table_with_key(childNode, '_isType.sling.model.DependencyDeclarationNode') ~= nil) then
										do _g.jk.lang.Vector:append(deps, childNode) end
									elseif (_vm:to_table_with_key(childNode, '_isType.sling.model.ImportPackageStatementNode') ~= nil) then
										do _g.jk.lang.Vector:append(pimps, childNode) end
									elseif (_vm:to_table_with_key(childNode, '_isType.sling.model.ImportEntityStatementNode') ~= nil) then
										do _g.jk.lang.Vector:append(eimps, childNode) end
									elseif (_vm:to_table_with_key(childNode, '_isType.sling.model.ImportStaticMemberStatementNode') ~= nil) then
										do _g.jk.lang.Vector:append(simps, childNode) end
									elseif (_vm:to_table_with_key(childNode, '_isType.sling.model.BaseTypeNode') ~= nil) then
										do _g.jk.lang.Vector:append(bts, childNode) end
									elseif (_vm:to_table_with_key(childNode, '_isType.sling.model.CommonModifierDeclarationNode') ~= nil) then
										do _g.jk.lang.Vector:append(mods, childNode) end
									elseif (_vm:to_table_with_key(childNode, '_isType.sling.model.CustomModifierDeclarationNode') ~= nil) then
										do _g.jk.lang.Vector:append(cmods, childNode) end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					if deps ~= nil then
						local n3 = 0
						local m3 = _g.jk.lang.Vector:getSize(deps)
						do
							n3 = 0
							while n3 < m3 do
								local dep = deps[n3 + 1]
								if dep ~= nil then
									do entity:addToDependencies(dep:getValue()) end
									do _g.sling.util.NodeUtil:removeNode(dep) end
								end
								do n3 = n3 + 1 end
							end
						end
					end
					if pimps ~= nil then
						local n4 = 0
						local m4 = _g.jk.lang.Vector:getSize(pimps)
						do
							n4 = 0
							while n4 < m4 do
								local imp = pimps[n4 + 1]
								if imp ~= nil then
									local ns = imp:exportPackage()
									if ns ~= nil then
										do entity:addToImportNamespaces(ns) end
									end
									do _g.sling.util.NodeUtil:removeNode(imp) end
								end
								do n4 = n4 + 1 end
							end
						end
					end
					if simps ~= nil then
						local n5 = 0
						local m5 = _g.jk.lang.Vector:getSize(simps)
						do
							n5 = 0
							while n5 < m5 do
								local simp = simps[n5 + 1]
								if simp ~= nil then
									do _g.sling.util.NodeUtil:exportNode(simp) end
									do entity:addToImportStaticNamespaces(simp) end
								end
								do n5 = n5 + 1 end
							end
						end
					end
					if eimps ~= nil then
						local n6 = 0
						local m6 = _g.jk.lang.Vector:getSize(eimps)
						do
							n6 = 0
							while n6 < m6 do
								local imp = eimps[n6 + 1]
								if imp ~= nil then
									do _g.sling.util.NodeUtil:exportNode(imp) end
									do entity:addToImportEntities(imp) end
								end
								do n6 = n6 + 1 end
							end
						end
					end
					if bts ~= nil then
						local n7 = 0
						local m7 = _g.jk.lang.Vector:getSize(bts)
						do
							n7 = 0
							while n7 < m7 do
								local bt = bts[n7 + 1]
								if bt ~= nil then
									do _g.sling.util.NodeUtil:exportNode(bt) end
									do entity:addToBaseTypes(bt) end
								end
								do n7 = n7 + 1 end
							end
						end
					end
					if mods ~= nil then
						local n8 = 0
						local m8 = _g.jk.lang.Vector:getSize(mods)
						do
							n8 = 0
							while n8 < m8 do
								local mod = mods[n8 + 1]
								if mod ~= nil then
									do entity:addModifier(mod:getType()) end
									do _g.sling.util.NodeUtil:removeNode(mod) end
								end
								do n8 = n8 + 1 end
							end
						end
					end
					if cmods ~= nil then
						local n9 = 0
						local m9 = _g.jk.lang.Vector:getSize(cmods)
						do
							n9 = 0
							while n9 < m9 do
								local cmod = cmods[n9 + 1]
								if cmod ~= nil then
									do entity:addCustomModifier(cmod:getType()) end
									do _g.sling.util.NodeUtil:removeNode(cmod) end
								end
								do n9 = n9 + 1 end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:preprocessProperties(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.ext.NSlingPropertyDeclaration", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local propdec = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ext.NSlingPropertyDeclaration')
				if propdec ~= nil then
					local generateVariable = false
					local bvn = propdec:getBackingVariableName()
					if _g.jk.lang.String:isEmpty(bvn) then
						bvn = "_" .. _g.jk.lang.String:safeString(propdec:getName())
					else
						generateVariable = true
					end
					if not _g.sling.util.NodeUtil:hasVisibilityModifier(propdec) then
						do propdec:addModifier(_g.sling.model.Modifier.PUBLIC) end
					end
					do
						local getter = propdec:getGetter()
						if getter == nil and propdec:hasCustomModifier("setonly") == false then
							local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
							do fd:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(propdec:getType()), false) end
							do fd:getCreateBody():addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName(bvn))) end
							do propdec:setGetter(fd, false) end
							generateVariable = true
							getter = fd
						end
						do
							local setter = propdec:getSetter()
							if setter == nil and propdec:hasCustomModifier("getonly") == false then
								local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
								do fd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(propdec:getType()), "value", nil)) end
								do
									local assx = _g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName(bvn), _g.sling.model.SymbolExpressionNode:forName("value"))
									do fd:getCreateBody():addNode(assx) end
									do propdec:setSetter(fd, false) end
									generateVariable = true
									setter = fd
								end
							end
							do
								local willset = propdec:getWillSetHandler()
								if willset ~= nil then
									do willset:addModifier(_g.sling.model.Modifier.PRIVATE) end
								end
								do
									local didset = propdec:getDidSetHandler()
									if didset ~= nil then
										do didset:addModifier(_g.sling.model.Modifier.PRIVATE) end
									end
									if getter ~= nil then
										do getter:copyModifiersFrom(propdec) end
										do getter:addCustomModifier("getterMethod") end
										if propdec:hasCustomModifier("getOverride") then
											do getter:addModifier(_g.sling.model.Modifier.OVERRIDE) end
										end
									end
									if setter ~= nil then
										do setter:copyModifiersFrom(propdec) end
										do setter:addCustomModifier("setterMethod") end
										if propdec:hasCustomModifier("setOverride") then
											do setter:addModifier(_g.sling.model.Modifier.OVERRIDE) end
										end
										if propdec:hasCustomModifier("notLiteral") then
											local parms = setter:getParameters()
											if parms ~= nil then
												local parm = _vm:to_table_with_key(_g.jk.lang.Vector:get(parms, 0), '_isType.sling.model.VariableDeclarationNode')
												if parm ~= nil then
													do parm:addCustomModifier("notLiteral") end
												end
											end
										end
									end
									if generateVariable then
										local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(propdec:getType()), bvn, propdec:exportInitializer())
										do vd:addModifier(_g.sling.model.Modifier.PRIVATE) end
										do _g.sling.util.NodeUtil:insertAboveNode(propdec, vd) end
									else
										local init = propdec:getInitializer()
										if init ~= nil then
											do _g.sling.common.RefLog:warning(ctx, "Initializer defined but not used.", init) end
										end
									end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:expandFileSystemReferenceExpressions(ctx, node)
	local types = {
		"class:sling.model.FileSystemDirectoryReferenceExpressionNode",
		"class:sling.model.FileSystemBinaryFileReferenceExpressionNode",
		"class:sling.model.FileSystemTextFileReferenceExpressionNode"
	}
	local array = _g.sling.common.NodeFinder:findNodesOfTypes(node, types, false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local fref = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FileSystemReferenceExpressionNode')
				if fref ~= nil then
					local curr = fref:getRelativeTo()
					local name = fref:getName()
					if curr == nil then
						goto _continue20
					end
					if _g.jk.lang.String:isEmpty(name) then
						goto _continue20
					end
					do
						local ff = curr:getParent()
						name = _g.jk.lang.String:replaceCharacter(name, 92, 47)
						do
							local array2 = _g.jk.lang.String:split(name, 47, 0)
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local comp = array2[n2 + 1]
										if comp ~= nil then
											if _g.jk.lang.String:isEmpty(comp) or comp == "." or comp == ".." then
												goto _continue21
											end
											ff = ff:entry(comp)
										end
										::_continue21::
										do n2 = n2 + 1 end
									end
								end
							end
							do
								local expr = nil
								if (_vm:to_table_with_key(fref, '_isType.sling.model.FileSystemDirectoryReferenceExpressionNode') ~= nil) then
									if not ff:isDirectory() then
										goto _continue20
									end
									expr = _g.sling.compiler.SlingOps:readDirectoryAsMapLiteral(ff)
								elseif (_vm:to_table_with_key(fref, '_isType.sling.model.FileSystemTextFileReferenceExpressionNode') ~= nil) then
									if not ff:isFile() then
										goto _continue20
									end
									expr = _g.sling.model.StringLiteralExpressionNode:forValue(ff:getContentsUTF8())
								elseif (_vm:to_table_with_key(fref, '_isType.sling.model.FileSystemBinaryFileReferenceExpressionNode') ~= nil) then
									if not ff:isFile() then
										goto _continue20
									end
									do
										local buff = ff:getContentsBuffer()
										if buff == nil then
											goto _continue20
										end
										expr = _g.sling.model.BufferLiteralExpressionNode:forValue(buff)
									end
								end
								if expr == nil then
									goto _continue20
								end
								do _g.sling.util.NodeUtil:replaceAndExport(fref, expr) end
							end
						end
					end
				end
				::_continue20::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:readDirectoryAsMapLiteral(dir)
	local it = dir:entries()
	if not (it ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
		do v:setDefaultDataType(_g.sling.model.MapDataTypeNode:forTypes(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())), false) end
		while true do
			local f = it:next()
			if not (f ~= nil) then
				do break end
			end
			if f:isFile() then
				local buf = f:getContentsBuffer()
				if not (buf ~= nil) then
					v = nil
					do break end
				end
				do
					local buflit = _g.sling.model.BufferLiteralExpressionNode:forValue(buf)
					do buflit:setType(_g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()), false) end
					do v:addToValues(_g.sling.model.KeyValueNode:forValues(_g.sling.model.StringLiteralExpressionNode:forValue(f:baseName()), buflit)) end
				end
			elseif f:isDirectory() then
				local dd = _g.sling.compiler.SlingOps:readDirectoryAsMapLiteral(f)
				if not (dd ~= nil) then
					v = nil
					do break end
				end
				do v:addToValues(_g.sling.model.KeyValueNode:forValues(_g.sling.model.StringLiteralExpressionNode:forValue(f:baseName()), dd)) end
			else
				goto _continue22
			end
			::_continue22::
		end
		if it ~= nil and (_vm:to_table_with_key(it, '_isType.jk.lang.Closable') ~= nil) then
			do it:close() end
		end
		do return v end
	end
end

function sling.compiler.SlingOps:expandMacros(ctx, node, resolver, removeDeclarations)
	do _g.sling.compiler.MacroHandler._construct0(_g.sling.compiler.MacroHandler._create()):execute(ctx, node, resolver, removeDeclarations) end
end

function sling.compiler.SlingOps:removeMacroDeclarations(ctx, node)
	local decls = {}
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.FunctionDeclarationNode", false, false, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("macro") then
						do _g.jk.lang.Vector:append(decls, decl) end
					end
				end
				do n = n + 1 end
			end
		end
	end
	if decls ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(decls)
		do
			n2 = 0
			while n2 < m2 do
				local decl = decls[n2 + 1]
				if decl ~= nil then
					do _g.sling.util.NodeUtil:removeNode(decl) end
				end
				do n2 = n2 + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:createSlingConstructorsForClass(ctx, tr, cl)
	if (_vm:to_table_with_key(cl, '_isType.sling.model.TemplateDeclarationNode') ~= nil) or (_vm:to_table_with_key(cl, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) then
		do return end
	end
	if cl:hasCustomModifier("typedef") then
		do return end
	end
	do
		local found = false
		local array = cl:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local nd = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ConstructorDeclarationNode')
					if nd ~= nil then
						found = true
						do break end
					end
					do n = n + 1 end
				end
			end
		end
		if found then
			do return end
		end
		do _g.sling.op.CommonOps:fixInheritanceTypes(ctx, tr, cl) end
		do
			local created = false
			local bc = tr:getBaseClass(cl)
			if bc ~= nil then
				local type = tr:getBaseClassType(cl)
				if type ~= nil and type:getMagical() then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No constructor found for class", cl, nil))
				end
				do _g.sling.compiler.SlingOps:createSlingConstructorsForClass(ctx, tr, bc) end
				do
					local array2 = bc:getNodes()
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local octor = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.ConstructorDeclarationNode')
								if octor ~= nil then
									do tr:resolveFunctionSignature(octor, tr) end
									do
										local nctor = _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create())
										do nctor:addModifier(_g.sling.model.Modifier.PUBLIC) end
										do _g.sling.util.FunctionUtil:copySignatureTo(octor, nctor) end
										do _g.sling.util.FunctionUtil:addBaseCall(nctor, false) end
										do cl:prependNode(nctor) end
										created = true
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
			end
			if not created then
				local nc = _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create())
				do nc:addModifier(_g.sling.model.Modifier.PUBLIC) end
				do nc:setBody(_g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()), false) end
				do cl:prependNode(nc) end
			end
		end
	end
end

function sling.compiler.SlingOps:createSlingConstructors(ctx, tr, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.ClassDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local cl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
				if cl ~= nil then
					do _g.sling.compiler.SlingOps:createSlingConstructorsForClass(ctx, tr, cl) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:processTypedefEntities(ctx, root, resolver)
	local array = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.ReferenceDataTypeNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ReferenceDataTypeNode')
				if node ~= nil then
					if node:getSymbol() == nil then
						goto _continue23
					end
					do
						local ee = resolver:getBoundEntity(node)
						if not (ee ~= nil) then
							goto _continue23
						end
						if not ee:hasCustomModifier("typedef") and (_vm:to_table_with_key(ee, '_isType.sling.model.TypeAliasDeclarationNode') ~= nil) == false then
							goto _continue23
						end
						do
							local bb = nil
							if (_vm:to_table_with_key(ee, '_isType.sling.model.TypeAliasDeclarationNode') ~= nil) then
								local bt = ee:getType()
								if not (bt ~= nil) then
									goto _continue23
								end
								bb = _g.sling.util.DataTypeUtil:dupAsDataType(bt)
							else
								local bt = resolver:getBaseClassType(ee)
								if not (bt ~= nil) then
									goto _continue23
								end
								bb = _g.sling.util.DataTypeUtil:dupAsReferenceDataType(bt)
							end
							do _g.sling.util.NodeUtil:replaceNode(node, bb) end
						end
					end
				end
				::_continue23::
				do n = n + 1 end
			end
		end
	end
	do
		local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.EntityDeclarationNode", false, true, false)
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.EntityDeclarationNode')
					if node ~= nil then
						if not node:hasCustomModifier("typedef") and (_vm:to_table_with_key(node, '_isType.sling.model.TypeAliasDeclarationNode') ~= nil) == false then
							goto _continue24
						end
						do
							local okToDelete = true
							local array3 = node:getNodes()
							if array3 ~= nil then
								local n3 = 0
								local m3 = _g.jk.lang.Vector:getSize(array3)
								do
									n3 = 0
									while n3 < m3 do
										local childNode = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.NodeObject')
										if childNode ~= nil then
											if (_vm:to_table_with_key(childNode, '_isType.sling.model.CommentNode') ~= nil) or (_vm:to_table_with_key(childNode, '_isType.sling.model.EmbedBlockNode') ~= nil) then
												goto _continue25
											end
											if childNode:hasModifier(_g.sling.model.Modifier.STATIC) == false then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Invalid declaration. Only static declarations, embed blocks and comments are allowed inside typedef entities.", node, nil))
												do return end
											end
											do childNode:removeCustomModifier("typedef") end
											okToDelete = false
										end
										::_continue25::
										do n3 = n3 + 1 end
									end
								end
							end
							if okToDelete then
								do _g.sling.util.NodeUtil:removeNode(node) end
							else
								do node:clearBaseTypes() end
							end
						end
					end
					::_continue24::
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.compiler.SlingOps:processStringComparisonOperators(ctx, root)
	local types = {
		"class:sling.model.EqualsExpressionNode",
		"class:sling.model.NotEqualsExpressionNode"
	}
	local array = _g.sling.common.NodeFinder:findNodesOfTypes(root, types, false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BinaryExpressionNode')
				if node ~= nil then
					local left = node:getLeft()
					if not (left ~= nil) then
						goto _continue26
					end
					do
						local ldt = _g.sling.util.ExpressionUtil:getExpressionDataType(left, nil)
						if (_vm:to_table_with_key(ldt, '_isType.sling.model.StringDataTypeNode') ~= nil) == false then
							goto _continue26
						end
						do
							local notequals = false
							if (_vm:to_table_with_key(node, '_isType.sling.model.NotEqualsExpressionNode') ~= nil) then
								notequals = true
							end
							do
								local lx = node:exportLeft()
								local rx = node:exportRight()
								if lx == nil or rx == nil then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to export nodes", node, nil))
								end
								do
									local se = _g.sling.model.StringEqualsExpressionNode._construct0(_g.sling.model.StringEqualsExpressionNode._create())
									do se:setSource(node:getSource()) end
									do se:setLeft(lx, false) end
									do se:setRight(rx, false) end
									do
										local v = nil
										if notequals then
											v = _g.sling.model.LogicalNotExpressionNode:forExpression(se)
										else
											v = se
										end
										do _g.sling.util.NodeUtil:replaceNode(node, v) end
									end
								end
							end
						end
					end
				end
				::_continue26::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:processAdditionOperators(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.AdditionAssignmentExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.AdditionAssignmentExpressionNode')
				if node ~= nil then
					local left = node:getLeft()
					if not (left ~= nil) then
						goto _continue27
					end
					do
						local ldt = _g.sling.util.ExpressionUtil:getExpressionDataType(left, nil)
						if (_vm:to_table_with_key(ldt, '_isType.sling.model.VectorDataTypeNode') ~= nil) == false then
							goto _continue27
						end
						do
							local lx = node:exportLeft()
							local rx = node:exportRight()
							if lx == nil or rx == nil then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to export nodes", node, nil))
							end
							do
								local v = _g.sling.model.AppendToVectorExpressionNode._construct0(_g.sling.model.AppendToVectorExpressionNode._create())
								do v:setSource(node:getSource()) end
								do v:setLeft(lx, false) end
								do v:setRight(rx, false) end
								do _g.sling.util.NodeUtil:replaceNode(node, v) end
							end
						end
					end
				end
				::_continue27::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:performAutomaticTypeConversions(ctx, resolver, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.common.ExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
				if node ~= nil then
					local xdt = resolver:getExpectedExpressionDataType(node)
					if not (xdt ~= nil) then
						goto _continue28
					end
					do
						local cdt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(node, nil)
						if not (cdt ~= nil) then
							goto _continue28
						end
						if resolver:isSame(cdt, xdt, nil) then
							goto _continue28
						end
						do
							local nnode = nil
							if (_vm:to_table_with_key(xdt, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
								if (_vm:to_table_with_key(cdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
									nnode = _g.sling.model.NotEqualsExpressionNode:instance(_g.sling.util.ExpressionUtil:dupAsExpression(node), _g.sling.model.IntegerLiteralExpressionNode:forValue(0))
								elseif (_vm:to_table_with_key(cdt, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
									nnode = _g.sling.model.NotEqualsExpressionNode:instance(_g.sling.util.ExpressionUtil:dupAsExpression(node), _g.sling.model.CharacterLiteralExpressionNode:forValue(0))
								elseif (_vm:to_table_with_key(cdt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
									nnode = _g.sling.model.NotEqualsExpressionNode:instance(_g.sling.util.ExpressionUtil:dupAsExpression(node), _g.sling.model.DoubleLiteralExpressionNode:forValue(0.0))
								elseif (_vm:to_table_with_key(cdt, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
									nnode = _g.sling.model.NotEqualsExpressionNode:instance(_g.sling.util.ExpressionUtil:dupAsExpression(node), _g.sling.model.FloatLiteralExpressionNode:forValue(0.0))
								elseif (_vm:to_table_with_key(cdt, '_isType.sling.model.PrimitiveDataTypeNode') ~= nil) then
								else
									nnode = _g.sling.model.NotEqualsExpressionNode:instance(_g.sling.util.ExpressionUtil:dupAsExpression(node), _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()))
								end
							elseif (_vm:to_table_with_key(xdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
								if (_vm:to_table_with_key(cdt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) or (_vm:to_table_with_key(cdt, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
									nnode = _g.sling.model.StaticCastExpressionNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(xdt), _g.sling.util.ExpressionUtil:dupAsExpression(node))
								end
							end
							if nnode ~= nil then
								do nnode:setSource(node:getSource()) end
								do _g.sling.util.NodeUtil:replaceNode(node, nnode) end
								if resolver ~= nil then
									do resolver:resolveExpression(nnode) end
								end
							end
						end
					end
				end
				::_continue28::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:mergeSlingUnitSettings(from, to)
	local array = from:getResources()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local resource = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ResourceFileNode')
				if resource ~= nil then
					do to:addToResources(resource) end
				end
				do n = n + 1 end
			end
		end
	end
	do to:setAndroidMetaData(_g.jk.lang.DynamicMap:forDynamicMaps(from:getAndroidMetaData(), to:getAndroidMetaData())) end
	do
		local array2 = from:getAndroidManifestCustomXmls()
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local o = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(array2[n2 + 1])
					if o ~= nil then
						do to:addToAndroidManifestCustomXmls(o) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do
			local array3 = from:getAndroidManifestApplicationCustomXmls()
			if array3 ~= nil then
				local n3 = 0
				local m3 = _g.jk.lang.Vector:getSize(array3)
				do
					n3 = 0
					while n3 < m3 do
						local o = (function(o)
							if (_vm:get_variable_type(o) == 'string') then
								do return o end
							end
							do return nil end
						end)(array3[n3 + 1])
						if o ~= nil then
							do to:addToAndroidManifestApplicationCustomXmls(o) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array4 = from:getAndroidPermissions()
				if array4 ~= nil then
					local n4 = 0
					local m4 = _g.jk.lang.Vector:getSize(array4)
					do
						n4 = 0
						while n4 < m4 do
							local o = (function(o)
								if (_vm:get_variable_type(o) == 'string') then
									do return o end
								end
								do return nil end
							end)(array4[n4 + 1])
							if o ~= nil then
								do to:addToAndroidPermissions(o) end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				do
					local array5 = from:getAndroidFeatures()
					if array5 ~= nil then
						local n5 = 0
						local m5 = _g.jk.lang.Vector:getSize(array5)
						do
							n5 = 0
							while n5 < m5 do
								local o = (function(o)
									if (_vm:get_variable_type(o) == 'string') then
										do return o end
									end
									do return nil end
								end)(array5[n5 + 1])
								if o ~= nil then
									do to:addToAndroidFeatures(o) end
								end
								do n5 = n5 + 1 end
							end
						end
					end
					do
						local array6 = from:getAndroidGradleDepends()
						if array6 ~= nil then
							local n6 = 0
							local m6 = _g.jk.lang.Vector:getSize(array6)
							do
								n6 = 0
								while n6 < m6 do
									local o = (function(o)
										if (_vm:get_variable_type(o) == 'string') then
											do return o end
										end
										do return nil end
									end)(array6[n6 + 1])
									if o ~= nil then
										do to:addToAndroidGradleDepends(o) end
									end
									do n6 = n6 + 1 end
								end
							end
						end
						do
							local array7 = from:getIosPods()
							if array7 ~= nil then
								local n7 = 0
								local m7 = _g.jk.lang.Vector:getSize(array7)
								do
									n7 = 0
									while n7 < m7 do
										local o = (function(o)
											if (_vm:get_variable_type(o) == 'string') then
												do return o end
											end
											do return nil end
										end)(array7[n7 + 1])
										if o ~= nil then
											do to:addToIosPods(o) end
										end
										do n7 = n7 + 1 end
									end
								end
							end
							do
								local array8 = from:getIosFrameworks()
								if array8 ~= nil then
									local n8 = 0
									local m8 = _g.jk.lang.Vector:getSize(array8)
									do
										n8 = 0
										while n8 < m8 do
											local o = (function(o)
												if (_vm:get_variable_type(o) == 'string') then
													do return o end
												end
												do return nil end
											end)(array8[n8 + 1])
											if o ~= nil then
												do to:addToIosFrameworks(o) end
											end
											do n8 = n8 + 1 end
										end
									end
								end
								do
									local array9 = from:getIosLinkLibs()
									if array9 ~= nil then
										local n9 = 0
										local m9 = _g.jk.lang.Vector:getSize(array9)
										do
											n9 = 0
											while n9 < m9 do
												local o = (function(o)
													if (_vm:get_variable_type(o) == 'string') then
														do return o end
													end
													do return nil end
												end)(array9[n9 + 1])
												if o ~= nil then
													do to:addToIosLinkLibs(o) end
												end
												do n9 = n9 + 1 end
											end
										end
									end
									do
										local array10 = from:getIosLdFlags()
										if array10 ~= nil then
											local n10 = 0
											local m10 = _g.jk.lang.Vector:getSize(array10)
											do
												n10 = 0
												while n10 < m10 do
													local o = (function(o)
														if (_vm:get_variable_type(o) == 'string') then
															do return o end
														end
														do return nil end
													end)(array10[n10 + 1])
													if o ~= nil then
														do to:addToIosLdFlags(o) end
													end
													do n10 = n10 + 1 end
												end
											end
										end
										do
											local array11 = from:getIosPlists()
											if array11 ~= nil then
												local n11 = 0
												local m11 = _g.jk.lang.Vector:getSize(array11)
												do
													n11 = 0
													while n11 < m11 do
														local o = (function(o)
															if (_vm:get_variable_type(o) == 'string') then
																do return o end
															end
															do return nil end
														end)(array11[n11 + 1])
														if o ~= nil then
															do to:addToIosPlists(o) end
														end
														do n11 = n11 + 1 end
													end
												end
											end
											do
												local array12 = from:getIosInfoPlistData()
												if array12 ~= nil then
													local n12 = 0
													local m12 = _g.jk.lang.Vector:getSize(array12)
													do
														n12 = 0
														while n12 < m12 do
															local o = (function(o)
																if (_vm:get_variable_type(o) == 'string') then
																	do return o end
																end
																do return nil end
															end)(array12[n12 + 1])
															if o ~= nil then
																do to:addToIosInfoPlistData(o) end
															end
															do n12 = n12 + 1 end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingOps:consolidateSlingUnitSettings(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local v = _vm:to_table_with_key(node:getSettings(), '_isType.sling.model.ext.NSlingUnitSettings')
		if not (v ~= nil) then
			local settings = {}
			local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.ext.NSlingUnitSettings", false, true, false)
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ext.NSlingUnitSettings')
						if child ~= nil then
							if child:getIsMainUnit() then
								v = child
							else
								do _g.jk.lang.Vector:append(settings, child) end
							end
							do _g.sling.util.NodeUtil:exportNode(child) end
						end
						do n = n + 1 end
					end
				end
			end
			if not (v ~= nil) then
				if _g.jk.lang.Vector:getSize(settings) < 1 then
					do return end
				end
				v = _g.jk.lang.Vector:get(settings, 0)
				do _g.jk.lang.Vector:remove(settings, 0) end
				if not (v ~= nil) then
					do return end
				end
			end
			if settings ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(settings)
				do
					n2 = 0
					while n2 < m2 do
						local snode = settings[n2 + 1]
						if snode ~= nil then
							do _g.sling.compiler.SlingOps:mergeSlingUnitSettings(snode, v) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			do node:setSettings(v, false) end
		end
	end
end

function sling.compiler.SlingOps:transferTrailingParametersToParameters(node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.FunctionCallExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local fcxp = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionCallExpressionNode')
				if fcxp ~= nil then
					local trxp = fcxp:exportTrailingParameter()
					if not (trxp ~= nil) then
						goto _continue29
					end
					do fcxp:addToParameters(trxp) end
				end
				::_continue29::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:transformToOutputModuleCombined(v, root, fileName)
	if not (root ~= nil and v ~= nil) then
		do return end
	end
	do
		local script = _g.sling.common.CodeFileNode._construct0(_g.sling.common.CodeFileNode._create())
		local array = root:exportNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						if (_vm:to_table_with_key(node, '_isType.sling.model.ResourceFileNode') ~= nil) then
							do v:addNode(node) end
							goto _continue30
						end
						do script:addNode(node) end
					end
					::_continue30::
					do n = n + 1 end
				end
			end
		end
		do v:addNode(script) end
		do
			local array2 = _g.sling.util.FindUtil:findCompatibleNodes(script, "class:sling.common.CodeUnitSettingsNode", false, true, false)
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local ss = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.CodeUnitSettingsNode')
						if ss ~= nil then
							do _g.sling.util.NodeUtil:exportNode(ss) end
							do v:addNode(ss) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			do _g.sling.compiler.SlingOps:consolidateSlingUnitSettings(v) end
			if _g.jk.lang.String:isNotEmpty(fileName) then
				do script:setName(fileName) end
			else
				local unit = _vm:to_table_with_key(v:getSettings(), '_isType.sling.model.ext.NSlingUnitSettings')
				local name = nil
				if unit ~= nil then
					name = unit:getModuleId()
					if _g.jk.lang.String:isEmpty(name) then
						name = unit:getProjectId()
					end
				end
				if _g.jk.lang.String:isEmpty(name) then
					name = "output"
				end
				do script:setName(name) end
			end
		end
	end
end

function sling.compiler.SlingOps:expandForeachStatementsStatic(ctx, tr, root)
	do _g.sling.compiler.ForEachHandler:expandForeachStatementsStatic(ctx, tr, root) end
end

function sling.compiler.SlingOps:expandForeachStatementsDynamic(root)
	do _g.sling.compiler.ForEachHandler:expandForeachStatementsDynamic(root) end
end

function sling.compiler.SlingOps:expandMembershipCheckExpressions(root)
	local array = _g.sling.util.FindUtil:findNodesOfType(root, "class:sling.model.ClassDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
				if decl ~= nil then
					local nojkop = decl:hasCustomModifier("nojkop")
					local array2 = _g.sling.util.FindUtil:findNodesOfType(decl, "class:sling.model.MembershipCheckExpressionNode", false, true, false)
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.MembershipCheckExpressionNode')
								if node ~= nil then
									local rval = node:getRight()
									if not (rval ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("membership check has no right value", node, nil))
									end
									do
										local rdtp = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(rval, nil)
										if not (rdtp ~= nil) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("right value data type is unknown", node, nil))
										end
										do
											local rplc = nil
											if (_vm:to_table_with_key(rdtp, '_isType.sling.model.VectorDataTypeNode') ~= nil) and not nojkop then
												local call = _g.sling.model.FunctionCallExpressionNode:forNames({
													"jk",
													"lang",
													"Vector",
													"contains"
												})
												do call:addToParameters(node:exportRight()) end
												do call:addToParameters(node:exportLeft()) end
												rplc = call
											elseif (_vm:to_table_with_key(rdtp, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) and not nojkop then
												local call = _g.sling.model.FunctionCallExpressionNode:forNames({
													"jk",
													"lang",
													"Array",
													"contains"
												})
												do call:addToParameters(node:exportRight()) end
												do call:addToParameters(node:exportLeft()) end
												rplc = call
											elseif (_vm:to_table_with_key(rdtp, '_isType.sling.model.StringDataTypeNode') ~= nil) and not nojkop then
												local call = _g.sling.model.FunctionCallExpressionNode:forNames({
													"jk",
													"lang",
													"String",
													"contains"
												})
												do call:addToParameters(node:exportRight()) end
												do call:addToParameters(node:exportLeft()) end
												rplc = call
											elseif (_vm:to_table_with_key(rdtp, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
												local call = _g.sling.model.FunctionCallExpressionNode:forMethod(node:exportRight(), "contains", false)
												do call:addToParameters(node:exportLeft()) end
												rplc = call
											elseif (_vm:to_table_with_key(rdtp, '_isType.sling.model.RangeDataTypeNode') ~= nil) then
												local lval = node:exportLeft()
												if not (lval ~= nil) then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("membership check has no left value", node, nil))
												end
												do
													local type = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(lval, nil)
													if (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) == false and (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) == false then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("unsupported left value type in membership check with range `" .. _g.jk.lang.String:safeString(type:getNodeTypeName()) .. "'", node, nil))
													end
													do
														local cond1 = nil
														local cond2 = nil
														local range = _vm:to_table_with_key(node:exportRight(), '_isType.sling.model.RangeExpressionNode')
														local lower = range:exportLowerBound()
														local upper = range:exportUpperBound()
														local xtype = range:getExclusionType()
														local duplv = _g.sling.util.ExpressionUtil:dupAsExpression(lval)
														if xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS then
															cond1 = _g.sling.model.GreaterThanExpressionNode:instance(lval, lower)
															cond2 = _g.sling.model.LessThanExpressionNode:instance(duplv, upper)
														elseif xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND then
															cond1 = _g.sling.model.GreaterOrEqualExpressionNode:instance(lval, lower)
															cond2 = _g.sling.model.LessThanExpressionNode:instance(duplv, upper)
														elseif xtype == _g.sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND then
															cond1 = _g.sling.model.GreaterThanExpressionNode:instance(lval, lower)
															cond2 = _g.sling.model.LessOrEqualExpressionNode:instance(duplv, upper)
														else
															cond1 = _g.sling.model.GreaterOrEqualExpressionNode:instance(lval, lower)
															cond2 = _g.sling.model.LessOrEqualExpressionNode:instance(duplv, upper)
														end
														rplc = _g.sling.model.LogicalAndExpressionNode:instance(cond1, cond2)
													end
												end
											else
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("unsupported right value type in membership check expression `" .. _g.jk.lang.String:safeString(rdtp:getNodeTypeName()) .. "'", node, nil))
											end
											do _g.sling.util.NodeUtil:replaceNode(node, rplc) end
										end
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:getRangeInstantiationFunctionCall(range)
	if not (range ~= nil) then
		do return nil end
	end
	do
		local lval = range:exportLowerBound()
		if not (lval ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Range expression has no lower bound", range, nil))
		end
		do
			local uval = range:exportUpperBound()
			if not (uval ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Range expression has no upper bound", range, nil))
			end
			do
				local call = _g.sling.model.FunctionCallExpressionNode:forNames({
					"jk",
					"lang",
					"Range",
					"forValues"
				})
				do call:addToParameters(lval) end
				do call:addToParameters(uval) end
				do call:addToParameters(_g.sling.model.IntegerLiteralExpressionNode:forValue(range:getExclusionType())) end
				do return call end
			end
		end
	end
end

function sling.compiler.SlingOps:convertRangeExpressionsToJkopRange(root)
	local array = _g.sling.util.FindUtil:findNodesOfType(root, "class:sling.model.ClassDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("nojkop") then
						goto _continue31
					end
					do
						local array2 = _g.sling.util.FindUtil:findNodesOfType(decl, "class:sling.model.RangeExpressionNode", false, true, false)
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.RangeExpressionNode')
									if node ~= nil then
										local prnt = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.MembershipCheckExpressionNode')
										if prnt ~= nil and prnt:getRight() == node then
											goto _continue32
										end
										do _g.sling.util.NodeUtil:replaceNode(node, _g.sling.compiler.SlingOps:getRangeInstantiationFunctionCall(node)) end
									end
									::_continue32::
									do n2 = n2 + 1 end
								end
							end
						end
					end
				end
				::_continue31::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:addNodeToTargetNamespace(node, target)
	if not (node ~= nil and target ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NamespaceNode') ~= nil) == false then
		do target:addNode(node) end
		do return end
	end
	do
		local ons = node
		local nn = ons:getNodeName()
		if _g.jk.lang.String:isEmpty(nn) then
			do target:addNode(node) end
			do return end
		end
		do
			local ans = _g.sling.util.NodeUtil:getOrCreateNamespace(target, nn)
			local array = ons:exportNodes()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
						if child ~= nil then
							do _g.sling.compiler.SlingOps:addNodeToTargetNamespace(child, ans) end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingOps:addContainerToNamespace(ctx, container, target)
	if not (container ~= nil and target ~= nil) then
		do return false end
	end
	do
		local array = container:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local modnode = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if modnode ~= nil then
						if (_vm:to_table_with_key(modnode, '_isType.sling.common.CodeFileNode') ~= nil) then
							local script = modnode
							local array2 = script:exportNodes()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
										if node ~= nil then
											do _g.sling.compiler.SlingOps:addNodeToTargetNamespace(node, target) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
						elseif (_vm:to_table_with_key(modnode, '_isType.sling.common.CodeDirectoryNode') ~= nil) then
							local tt = target
							local array3 = _g.jk.lang.String:split(modnode:getNodeName(), 46, 0)
							if array3 ~= nil then
								local n3 = 0
								local m3 = _g.jk.lang.Vector:getSize(array3)
								do
									n3 = 0
									while n3 < m3 do
										local comp = array3[n3 + 1]
										if comp ~= nil then
											tt = _g.sling.util.NodeUtil:getOrCreateNamespace(tt, comp)
										end
										do n3 = n3 + 1 end
									end
								end
							end
							if not self:addContainerToNamespace(ctx, modnode, tt) then
								do return false end
							end
						else
							do _g.jk.log.Log:error(ctx, "Unsupported node type in module `" .. _g.jk.lang.String:safeString(container:getNodeName()) .. "': `" .. _g.jk.lang.String:safeString(modnode:getNodeTypeName()) .. "'") end
							do return false end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return true end
	end
end

function sling.compiler.SlingOps:addDefaultModifiersToDeclarations(node)
	local array = _g.sling.util.FindUtil:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local entity = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if entity ~= nil then
					if (_vm:to_table_with_key(entity:getParent(), '_isType.sling.model.NamespaceNode') ~= nil) and _g.sling.util.NodeUtil:hasVisibilityModifier(entity) == false then
						do entity:addModifier(_g.sling.model.Modifier.PUBLIC) end
					end
					do
						local array2 = entity:getNodes()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local decl = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.NodeObject')
									if decl ~= nil then
										if _g.sling.util.NodeUtil:hasVisibilityModifier(decl) == false then
											if (_vm:to_table_with_key(decl, '_isType.sling.model.VariableDeclarationNode') ~= nil) and decl:hasModifier(_g.sling.model.Modifier.PROPERTY) then
												do decl:addModifier(_g.sling.model.Modifier.PUBLIC) end
											elseif (_vm:to_table_with_key(decl, '_isType.sling.model.ext.NSlingPropertyDeclaration') ~= nil) then
												do decl:addModifier(_g.sling.model.Modifier.PUBLIC) end
											elseif (_vm:to_table_with_key(decl, '_isType.sling.model.DestructorDeclarationNode') ~= nil) or (_vm:to_table_with_key(decl, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
											else
												do decl:addModifier(_g.sling.model.Modifier.PRIVATE) end
											end
										end
										if (_vm:to_table_with_key(entity, '_isType.sling.model.ScriptDeclarationNode') ~= nil) then
											do decl:addModifier(_g.sling.model.Modifier.STATIC) end
										elseif (_vm:to_table_with_key(decl, '_isType.sling.model.EntityDeclarationNode') ~= nil) and (_vm:to_table_with_key(decl, '_isType.sling.model.DelegateDeclarationNode') ~= nil) == false then
											do decl:addModifier(_g.sling.model.Modifier.STATIC) end
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:transformToProcessingTree(ctx, modules)
	local v = _g.sling.model.NamespaceNode._construct0(_g.sling.model.NamespaceNode._create())
	if modules ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(modules)
		do
			n = 0
			while n < m do
				local module = modules[n + 1]
				if module ~= nil then
					local target = v
					local modname = module:getNodeName()
					if _g.jk.lang.String:isNotEmpty(modname) then
						local array = _g.jk.lang.String:split(modname, 46, 0)
						if array ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array)
							do
								n2 = 0
								while n2 < m2 do
									local comp = array[n2 + 1]
									if comp ~= nil then
										target = _g.sling.util.NodeUtil:getOrCreateNamespace(target, comp)
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
					do
						local types = {
							"class:sling.common.CodeUnitSettingsNode",
							"class:sling.model.ResourceFileNode"
						}
						local array2 = _g.sling.common.NodeFinder:findCompatibleNodesForTypes(module, types, false, true, false)
						if array2 ~= nil then
							local n3 = 0
							local m3 = _g.jk.lang.Vector:getSize(array2)
							do
								n3 = 0
								while n3 < m3 do
									local fn = array2[n3 + 1]
									if fn ~= nil then
										do _g.sling.util.NodeUtil:exportNode(fn) end
										do target:addNode(fn) end
									end
									do n3 = n3 + 1 end
								end
							end
						end
						if not self:addContainerToNamespace(ctx, module, target) then
							do return nil end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.compiler.SlingOps:createDataTypeDefaultValue(type)
	do return _g.sling.util.DataTypeUtil:createDefaultValue(type) end
end

function sling.compiler.SlingOps:convertReferenceSubscriptsToFunctionCalls(node, resolver)
	local cache = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.SubscriptExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ssxp = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SubscriptExpressionNode')
				if ssxp ~= nil then
					local type = _vm:to_table_with_key(_g.sling.util.ExpressionUtil:tryGetExpressionDataType(ssxp:getChild(), resolver), '_isType.sling.model.ReferenceDataTypeNode')
					if not (type ~= nil) then
						goto _continue33
					end
					do
						local prnt = _vm:to_table_with_key(ssxp:getParent(), '_isType.sling.model.AssignmentExpressionNode')
						local tstr = _g.sling.util.SymbolUtil:getSymbolNamesString(type:getSymbol(), 46)
						local smap = cache:getDynamicMap(tstr)
						if not (smap ~= nil) then
							local entt = _g.sling.util.TypeResolver:getAndRequireBoundEntity(type)
							local getter = nil
							local setters = nil
							local array2 = entt:getNodes()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local fdecl = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.FunctionDeclarationNode')
										if fdecl ~= nil then
											if fdecl:hasCustomModifier("subscriptGet") then
												if getter ~= nil then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("subscriptGet modifier found in multiple functions", fdecl, nil))
												end
												do
													local rtrn = fdecl:getOwnReturnType()
													if not (rtrn ~= nil) or (_vm:to_table_with_key(rtrn, '_isType.sling.model.VoidDataTypeNode') ~= nil) then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("subscriptGet modifier found in a void returning function", fdecl, nil))
													end
													if fdecl:getParameterCount() ~= 1 then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("subscriptGet modifier found in a function does not have 1 parameter", fdecl, nil))
													end
													getter = fdecl
												end
											elseif fdecl:hasCustomModifier("subscriptSet") then
												local rtrn = fdecl:getOwnReturnType()
												if rtrn ~= nil and (_vm:to_table_with_key(rtrn, '_isType.sling.model.VoidDataTypeNode') ~= nil) == false then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("subscriptSet modifier found in a non-void returning function", fdecl, nil))
												end
												if fdecl:getParameterCount() ~= 2 then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("subscriptGet modifier found in a function does not have 2 parameter", fdecl, nil))
												end
												if not (setters ~= nil) then
													setters = {}
												end
												do _g.jk.lang.Vector:append(setters, fdecl) end
											end
										end
										do n2 = n2 + 1 end
									end
								end
							end
							smap = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
							do smap:setObject("getter", getter) end
							do smap:setObject("setters", setters) end
							do cache:setObject(tstr, smap) end
						end
						do
							local subx = ssxp:getSubscript()
							local call = nil
							local trgt = nil
							if prnt ~= nil and prnt:getLeft() == ssxp then
								local vparams = {}
								do _g.jk.lang.Vector:append(vparams, subx) end
								do _g.jk.lang.Vector:append(vparams, prnt:getRight()) end
								if vparams ~= nil then
									local n3 = 0
									local m3 = _g.jk.lang.Vector:getSize(vparams)
									do
										n3 = 0
										while n3 < m3 do
											local param = _vm:to_table_with_key(vparams[n3 + 1], '_isType.sling.common.ExpressionNode')
											if param ~= nil then
												do resolver:resolveExpression(param) end
											end
											do n3 = n3 + 1 end
										end
									end
								end
								do
									local setters = smap:getVector("setters")
									local setfunc = nil
									if setters ~= nil then
										local n4 = 0
										local m4 = _g.jk.lang.Vector:getSize(setters)
										do
											n4 = 0
											while n4 < m4 do
												local setf = _vm:to_table_with_key(setters[n4 + 1], '_isType.sling.model.FunctionDeclarationNode')
												if setf ~= nil then
													if resolver:matchesCallParameters(setf, vparams, nil, true, false) then
														setfunc = setf
														do break end
													end
												end
												do n4 = n4 + 1 end
											end
										end
									end
									if not (setfunc ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No subscriptSet function found for reference subscript", ssxp, nil))
									end
									do _g.sling.util.NodeUtil:exportNode(subx) end
									call = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
									do call:setExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(ssxp:exportChild(), _g.sling.model.SymbolExpressionNode:forName(setfunc:getNodeName())), false) end
									do call:addToParameters(subx) end
									do call:addToParameters(prnt:exportRight()) end
									trgt = prnt
								end
							else
								local getter = _vm:to_table_with_key(smap:get("getter"), '_isType.sling.model.FunctionDeclarationNode')
								if not (getter ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No subscriptGet function found for reference subscript", ssxp, nil))
								end
								do _g.sling.util.NodeUtil:exportNode(subx) end
								call = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
								do call:setExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(ssxp:exportChild(), _g.sling.model.SymbolExpressionNode:forName(getter:getNodeName())), false) end
								do call:addToParameters(subx) end
								trgt = ssxp
							end
							do _g.sling.util.NodeUtil:replaceAndExport(trgt, call) end
						end
					end
				end
				::_continue33::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:validateTree(ctx, resolver, node)
	do _g.jk.log.Log:status(ctx, "Validating node tree ..") end
	do _g.sling.compiler.SlingOps:validateCreateObjectExpressions(node) end
	do _g.sling.compiler.SlingOps:validateExpectedTypes(ctx, resolver, node) end
	do _g.sling.compiler.SlingOps:validateVariableDeclarations(ctx, node) end
	do _g.sling.compiler.SlingOps:validateInheritedInterfaces(ctx, resolver, node) end
	do _g.sling.compiler.SlingOps:validateFunctionDeclarations(ctx, node) end
end

function sling.compiler.SlingOps:validateCreateObjectExpressions(node)
	local array = _g.sling.util.FindUtil:findNodesOfType(node, "class:sling.model.CreateObjectExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local co = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.CreateObjectExpressionNode')
				if co ~= nil then
					local tp = co:getType()
					if (_vm:to_table_with_key(tp, '_isType.sling.model.PrimitiveDataTypeNode') ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Primitive data types are not allowed in create object expressions", tp, nil))
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:validateExpectedTypes(ctx, resolver, node)
	local array = _g.sling.util.FindUtil:findCompatibleNodes(node, "class:sling.common.ExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local xp = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
				if xp ~= nil then
					local ex = resolver:getExpectedExpressionDataType(xp)
					if not (ex ~= nil) or (_vm:to_table_with_key(ex, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) or (_vm:to_table_with_key(ex, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
						goto _continue34
					end
					do
						local et = resolver:mapType(_g.sling.util.ExpressionUtil:getExpressionDataType(xp, nil), nil)
						if not resolver:matches(ex, et, nil, false, false) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(et)) .. "' does not match expected data type `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(ex)) .. "'", xp, nil))
						end
					end
				end
				::_continue34::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:validateVariableDeclarations(ctx, node)
	local array = _g.sling.util.FindUtil:findCompatibleNodes(node, "class:sling.common.ContainerNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ContainerNode')
				if decl ~= nil then
					local vars = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
					if (_vm:to_table_with_key(decl, '_isType.sling.model.BlockNode') ~= nil) then
						local prnt = decl:getParent()
						if (_vm:to_table_with_key(prnt, '_isType.sling.model.ForEachStatementNode') ~= nil) then
							local array2 = prnt:getLefts()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local left = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
										if left ~= nil then
											local name = left:getNodeName()
											if vars:contains(name) then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Duplicate variable declaration found", left, nil))
											end
											do vars:add(name) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
						elseif (_vm:to_table_with_key(prnt, '_isType.sling.model.ForStatementNode') ~= nil) then
							local init = prnt:getInitializer()
							local array3 = init:getNodes()
							if array3 ~= nil then
								local n3 = 0
								local m3 = _g.jk.lang.Vector:getSize(array3)
								do
									n3 = 0
									while n3 < m3 do
										local vdec = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
										if vdec ~= nil then
											local name = vdec:getNodeName()
											if vars:contains(name) then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Duplicate variable declaration found", vdec, nil))
											end
											do vars:add(name) end
										end
										do n3 = n3 + 1 end
									end
								end
							end
						end
					end
					do
						local array4 = decl:getNodes()
						if array4 ~= nil then
							local n4 = 0
							local m4 = _g.jk.lang.Vector:getSize(array4)
							do
								n4 = 0
								while n4 < m4 do
									local vdec = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.VariableDeclarationNode')
									if vdec ~= nil then
										local name = vdec:getNodeName()
										if vars:contains(name) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Duplicate variable declaration found", vdec, nil))
										end
										do vars:add(name) end
									end
									do n4 = n4 + 1 end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingOps:validateInheritedInterfaces(ctx, resolver, node)
	local strl = resolver
	if not (strl ~= nil) then
		do return end
	end
	do
		local array = _g.sling.util.FindUtil:findNodesOfType(node, "class:sling.model.ClassDeclarationNode", false, true, false)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local cdec = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
					if cdec ~= nil then
						if cdec:hasModifier(_g.sling.model.Modifier.HEADER) then
							goto _continue35
						end
						do
							local array2 = cdec:getBaseTypes()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local btyp = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.BaseTypeNode')
										if btyp ~= nil then
											if btyp:getInheritType() ~= _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT then
												goto _continue36
											end
											do
												local type = btyp:getReferenceType()
												if type ~= nil and type:getMagical() then
													goto _continue36
												end
												do
													local intr = resolver:getAndRequireBoundInterface(type)
													local array3 = intr:getNodes()
													if array3 ~= nil then
														local n3 = 0
														local m3 = _g.jk.lang.Vector:getSize(array3)
														do
															n3 = 0
															while n3 < m3 do
																local idec = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.FunctionDeclarationNode')
																if idec ~= nil then
																	local icom = true
																	local array4 = cdec:getNodeIndexForName(idec:getNodeName())
																	if array4 ~= nil then
																		local n4 = 0
																		local m4 = _g.jk.lang.Vector:getSize(array4)
																		do
																			n4 = 0
																			while n4 < m4 do
																				local fdec = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.FunctionDeclarationNode')
																				if fdec ~= nil then
																					if _g.jk.lang.Vector:isNotEmpty(intr:getGenericTypes()) then
																						if _g.sling.compiler.SlingTypeResolver:hasSameSignature(idec, fdec, nil, true, true, false) then
																							icom = false
																							do break end
																						end
																					end
																					if _g.sling.compiler.SlingTypeResolver:hasSameSignature(idec, fdec, nil, false, false, false) then
																						icom = false
																						do break end
																					end
																				end
																				do n4 = n4 + 1 end
																			end
																		end
																	end
																	if icom then
																		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Incomplete implementation of an inherited interface", cdec, nil):addRelatedMessage("No matching method signature found", idec))
																	end
																end
																do n3 = n3 + 1 end
															end
														end
													end
												end
											end
										end
										::_continue36::
										do n2 = n2 + 1 end
									end
								end
							end
						end
					end
					::_continue35::
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.compiler.SlingOps:validateFunctionDeclarations(ctx, node)
	local array = _g.sling.util.FindUtil:findNodesOfType(node, "class:sling.model.FunctionDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local fdec = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
				if fdec ~= nil then
					local parent = fdec:getParent()
					if (_vm:to_table_with_key(parent, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
						goto _continue37
					end
					if (_vm:to_table_with_key(parent, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
						local cdec = parent
						if cdec:hasModifier(_g.sling.model.Modifier.HEADER) then
							goto _continue37
						end
						if fdec:hasModifier(_g.sling.model.Modifier.ABSTRACT) then
							if not cdec:hasModifier(_g.sling.model.Modifier.ABSTRACT) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("A class that contains abstract methods must be declared abstract.", cdec, nil):addRelatedMessage("An abstract method was found inside the class", fdec))
							end
							if fdec:getBody() ~= nil then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("An abstract method must not contain a body.", fdec, nil))
							end
						elseif fdec:getBody() == nil then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("A method without a body must be declared abstract.", fdec, nil))
						end
					elseif fdec:hasModifier(_g.sling.model.Modifier.ABSTRACT) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Functions declared as abstract must be inside a class", fdec, nil))
					end
				end
				::_continue37::
				do n = n + 1 end
			end
		end
	end
end

sling.compiler.Samtree2Ops = {}
sling.compiler.Samtree2Ops.__index = sling.compiler.Samtree2Ops
_vm:set_metatable(sling.compiler.Samtree2Ops, {})

function sling.compiler.Samtree2Ops._create()
	local v = _vm:set_metatable({}, sling.compiler.Samtree2Ops)
	return v
end

function sling.compiler.Samtree2Ops:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.Samtree2Ops'
	self['_isType.sling.compiler.Samtree2Ops'] = true
end

function sling.compiler.Samtree2Ops:_construct0()
	sling.compiler.Samtree2Ops._init(self)
	return self
end

sling.compiler.Samtree2Ops.ClassFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.Samtree2Ops.ClassFinder.__index = sling.compiler.Samtree2Ops.ClassFinder
_vm:set_metatable(sling.compiler.Samtree2Ops.ClassFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.Samtree2Ops.ClassFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.Samtree2Ops.ClassFinder)
	return v
end

function sling.compiler.Samtree2Ops.ClassFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.Samtree2Ops.ClassFinder'
	self['_isType.sling.compiler.Samtree2Ops.ClassFinder'] = true
	self.classes = {}
end

function sling.compiler.Samtree2Ops.ClassFinder:_construct0()
	sling.compiler.Samtree2Ops.ClassFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.Samtree2Ops.ClassFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) and node:hasCustomModifier("samnode") then
		do _g.jk.lang.Vector:append(self.classes, node) end
		do node:removeCustomModifier("samnode") end
	end
	do return true end
end

function sling.compiler.Samtree2Ops.ClassFinder:getClasses()
	do return self.classes end
end

function sling.compiler.Samtree2Ops.ClassFinder:setClasses(v)
	self.classes = v
	do return self end
end

sling.compiler.Samtree2Ops.VariableFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.Samtree2Ops.VariableFinder.__index = sling.compiler.Samtree2Ops.VariableFinder
_vm:set_metatable(sling.compiler.Samtree2Ops.VariableFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.Samtree2Ops.VariableFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.Samtree2Ops.VariableFinder)
	return v
end

function sling.compiler.Samtree2Ops.VariableFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.Samtree2Ops.VariableFinder'
	self['_isType.sling.compiler.Samtree2Ops.VariableFinder'] = true
	self.nodeVars = {}
	self.valueVars = {}
	self.vectorVars = {}
end

function sling.compiler.Samtree2Ops.VariableFinder:_construct0()
	sling.compiler.Samtree2Ops.VariableFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.Samtree2Ops.VariableFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		if node:hasCustomModifier("node") then
			do _g.jk.lang.Vector:append(self.nodeVars, node) end
			do node:removeCustomModifier("node") end
		elseif node:hasCustomModifier("vector") then
			do _g.jk.lang.Vector:append(self.vectorVars, node) end
			do node:removeCustomModifier("vector") end
		elseif node:hasCustomModifier("value") then
			do _g.jk.lang.Vector:append(self.valueVars, node) end
			do node:removeCustomModifier("value") end
		end
	end
	do return true end
end

function sling.compiler.Samtree2Ops.VariableFinder:getNodeVars()
	do return self.nodeVars end
end

function sling.compiler.Samtree2Ops.VariableFinder:setNodeVars(v)
	self.nodeVars = v
	do return self end
end

function sling.compiler.Samtree2Ops.VariableFinder:getValueVars()
	do return self.valueVars end
end

function sling.compiler.Samtree2Ops.VariableFinder:setValueVars(v)
	self.valueVars = v
	do return self end
end

function sling.compiler.Samtree2Ops.VariableFinder:getVectorVars()
	do return self.vectorVars end
end

function sling.compiler.Samtree2Ops.VariableFinder:setVectorVars(v)
	self.vectorVars = v
	do return self end
end

function sling.compiler.Samtree2Ops:modifyName(prefix, name)
	local sb = _g.jk.lang.StringBuilder:forString(prefix)
	local c0 = _g.jk.lang.String:getChar(name, 0)
	if c0 >= 97 and c0 <= 122 then
		do sb:appendCharacter(c0 - 97 + 65) end
		do sb:appendString(_g.jk.lang.String:getEndOfString(name, 1)) end
	else
		do sb:appendString(name) end
	end
	do return sb:toString() end
end

function sling.compiler.Samtree2Ops:execute(ctx, root)
	if not (root ~= nil) then
		do return end
	end
	do
		local cf = _g.sling.compiler.Samtree2Ops.ClassFinder._construct0(_g.sling.compiler.Samtree2Ops.ClassFinder._create())
		do root:acceptVisitor(cf) end
		do
			local array = cf:getClasses()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local class = array[n + 1]
						if class ~= nil then
							local gntn = nil
							if class:hasChildNode("getNodeTypeName") == false then
								gntn = _g.sling.model.FunctionDeclarationNode:forName("getNodeTypeName", true)
								do gntn:addModifier(_g.sling.model.Modifier.OVERRIDE) end
								do gntn:setReturnType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
								do
									local lit = _g.sling.model.StringLiteralExpressionNode:forValue(class:getNodeName())
									do _g.sling.util.FunctionUtil:addStatement(gntn, _g.sling.model.ReturnStatementNode:forExpression(lit)) end
									do class:addNode(gntn) end
								end
							end
							do
								local createnew = nil
								if class:hasChildNode("createNew") == false and class:hasModifier(_g.sling.model.Modifier.ABSTRACT) == false then
									createnew = _g.sling.model.FunctionDeclarationNode:forName("createNew", true)
									do createnew:addModifier(_g.sling.model.Modifier.OVERRIDE) end
									do createnew:setReturnType(_g.sling.model.ReferenceDataTypeNode:forName("NodeObject"), false) end
									do _g.sling.util.FunctionUtil:addStatement(createnew, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_CREATE_NEW")) end
									do class:addNode(createnew) end
								end
								do
									local copyto = nil
									if class:hasChildNode("copyTo") == false then
										copyto = _g.sling.model.FunctionDeclarationNode:forName("copyTo", true)
										do copyto:addModifier(_g.sling.model.Modifier.OVERRIDE) end
										do copyto:setReturnType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
										do copyto:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("NodeObject"), "o", nil)) end
										do _g.sling.util.FunctionUtil:addStatement(copyto, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_COPY_TO_BEGIN")) end
										do class:addNode(copyto) end
									end
									do
										local replacechild = nil
										if class:hasChildNode("replaceChild") == false then
											replacechild = _g.sling.model.FunctionDeclarationNode:forName("replaceChild", true)
											do replacechild:addModifier(_g.sling.model.Modifier.OVERRIDE) end
											do replacechild:setReturnType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
											do replacechild:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("NodeObject"), "oldnode", nil)) end
											do replacechild:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("NodeObject"), "newnode", nil)) end
											do replacechild:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), "doExport", nil)) end
											do _g.sling.util.FunctionUtil:addStatement(replacechild, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_REPLACE_CHILD_BEGIN")) end
											do class:addNode(replacechild) end
										end
										do
											local acceptvisitor = nil
											if class:hasChildNode("acceptVisitor") == false then
												acceptvisitor = _g.sling.model.FunctionDeclarationNode:forName("acceptVisitor", true)
												do acceptvisitor:addModifier(_g.sling.model.Modifier.OVERRIDE) end
												do acceptvisitor:setReturnType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
												do acceptvisitor:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forName("NodeVisitor"), "visitor", nil)) end
												do _g.sling.util.FunctionUtil:addStatement(acceptvisitor, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_ACCEPT_VISITOR_BEGIN")) end
												do class:addNode(acceptvisitor) end
											end
											do
												local destroy = nil
												if class:hasChildNode("destroy") == false then
													destroy = _g.sling.model.FunctionDeclarationNode:forName("destroy", true)
													do destroy:addModifier(_g.sling.model.Modifier.OVERRIDE) end
													do destroy:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
													do _g.sling.util.FunctionUtil:addStatement(destroy, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_DESTROY_BEGIN")) end
													do class:addNode(destroy) end
												end
												do
													local vf = _g.sling.compiler.Samtree2Ops.VariableFinder._construct0(_g.sling.compiler.Samtree2Ops.VariableFinder._create())
													do class:acceptVisitor(vf) end
													do
														local array2 = vf:getNodeVars()
														if array2 ~= nil then
															local n2 = 0
															local m2 = _g.jk.lang.Vector:getSize(array2)
															do
																n2 = 0
																while n2 < m2 do
																	local vv = array2[n2 + 1]
																	if vv ~= nil then
																		local vname = vv:getNodeName()
																		if _g.jk.lang.String:isEmpty(vname) then
																			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable name is empty", vv, nil))
																		end
																		if replacechild ~= nil then
																			local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_REPLACE_CHILD")
																			do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																			do _g.sling.util.FunctionUtil:addStatement(replacechild, fc) end
																		end
																		if copyto ~= nil then
																			local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_COPY_PROPERTY")
																			do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																			do _g.sling.util.FunctionUtil:addStatement(copyto, fc) end
																		end
																		if acceptvisitor ~= nil then
																			local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_VISIT_PROPERTY")
																			do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																			do _g.sling.util.FunctionUtil:addStatement(acceptvisitor, fc) end
																		end
																		if destroy ~= nil then
																			local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_DESTROY_PROPERTY")
																			do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																			do _g.sling.util.FunctionUtil:addStatement(destroy, fc) end
																		end
																		do
																			local nset = _g.sling.compiler.Samtree2Ops:modifyName("set", vname)
																			if class:hasChildNode(nset) == false then
																				local fset = _g.sling.model.FunctionDeclarationNode:forName(nset, true)
																				do fset:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
																				do
																					local dt = _g.sling.util.DataTypeUtil:dupAsDataType(vv:getType())
																					do fset:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, "v", nil)) end
																					do fset:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), "doExport", _g.sling.model.BooleanLiteralExpressionNode:forValue(false))) end
																					do
																						local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_SET_PROPERTY")
																						do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																						do _g.sling.util.FunctionUtil:addStatement(fset, fc) end
																						do class:addNode(fset) end
																					end
																				end
																			end
																			do
																				local nget = _g.sling.compiler.Samtree2Ops:modifyName("get", vname)
																				if class:hasChildNode(nget) == false then
																					local fget = _g.sling.model.FunctionDeclarationNode:forName(nget, true)
																					local dt = _g.sling.util.DataTypeUtil:dupAsDataType(vv:getType())
																					do fget:setReturnType(dt, false) end
																					do
																						local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_GET_PROPERTY")
																						do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																						do _g.sling.util.FunctionUtil:addStatement(fget, fc) end
																						do class:addNode(fget) end
																					end
																				end
																				do
																					local nexp = _g.sling.compiler.Samtree2Ops:modifyName("export", vname)
																					if class:hasChildNode(nexp) == false then
																						local fexp = _g.sling.model.FunctionDeclarationNode:forName(nexp, true)
																						local dt = _g.sling.util.DataTypeUtil:dupAsDataType(vv:getType())
																						do fexp:setReturnType(dt, false) end
																						do
																							local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_EXPORT_PROPERTY")
																							do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																							do _g.sling.util.FunctionUtil:addStatement(fexp, fc) end
																							do class:addNode(fexp) end
																						end
																					end
																				end
																			end
																		end
																	end
																	do n2 = n2 + 1 end
																end
															end
														end
														do
															local array3 = vf:getValueVars()
															if array3 ~= nil then
																local n3 = 0
																local m3 = _g.jk.lang.Vector:getSize(array3)
																do
																	n3 = 0
																	while n3 < m3 do
																		local vv = array3[n3 + 1]
																		if vv ~= nil then
																			local vtype = vv:getType()
																			if not (vtype ~= nil) or (_vm:to_table_with_key(vtype, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
																				local init = vv:getInitializer()
																				if not (init ~= nil) then
																					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Value variable has no data type or initializer", vv, nil))
																				end
																				do
																					local initdt = _g.sling.util.ExpressionUtil:getExpressionDataType(init, nil)
																					if not (initdt ~= nil) then
																						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Value variable initializer data type cannot be determined.", vv, nil))
																					end
																					vtype = initdt
																					do vv:setType(_g.sling.util.DataTypeUtil:dupAsDataType(vtype), false) end
																				end
																			end
																			do
																				local vname = vv:getNodeName()
																				if _g.jk.lang.String:isEmpty(vname) then
																					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable name is empty", vv, nil))
																				end
																				if copyto ~= nil then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_COPY_VALUE")
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																					do _g.sling.util.FunctionUtil:addStatement(copyto, fc) end
																				end
																				do
																					local nset = _g.sling.compiler.Samtree2Ops:modifyName("set", vname)
																					if class:hasChildNode(nset) == false then
																						local fset = _g.sling.model.FunctionDeclarationNode:forName(nset, true)
																						do fset:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
																						do
																							local dt = _g.sling.util.DataTypeUtil:dupAsDataType(vtype)
																							do fset:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, "v", nil)) end
																							do
																								local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_SET_VALUE")
																								do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																								do _g.sling.util.FunctionUtil:addStatement(fset, fc) end
																								do class:addNode(fset) end
																							end
																						end
																					end
																					do
																						local nget = _g.sling.compiler.Samtree2Ops:modifyName("get", vname)
																						if class:hasChildNode(nget) == false then
																							local fget = _g.sling.model.FunctionDeclarationNode:forName(nget, true)
																							local dt = _g.sling.util.DataTypeUtil:dupAsDataType(vtype)
																							do fget:setReturnType(dt, false) end
																							do
																								local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_GET_VALUE")
																								do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																								do _g.sling.util.FunctionUtil:addStatement(fget, fc) end
																								do class:addNode(fget) end
																							end
																						end
																					end
																				end
																			end
																		end
																		do n3 = n3 + 1 end
																	end
																end
															end
															do
																local array4 = vf:getVectorVars()
																if array4 ~= nil then
																	local n4 = 0
																	local m4 = _g.jk.lang.Vector:getSize(array4)
																	do
																		n4 = 0
																		while n4 < m4 do
																			local vv = array4[n4 + 1]
																			if vv ~= nil then
																				local vname = vv:getNodeName()
																				local dt = _g.sling.util.DataTypeUtil:dupAsDataType(vv:getType())
																				local isPrimitive = false
																				if vv:hasCustomModifier("value") then
																					do vv:removeCustomModifier("value") end
																					isPrimitive = true
																				end
																				do vv:setType(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())), false) end
																				if _g.jk.lang.String:isEmpty(vname) then
																					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable name is empty", vv, nil))
																				end
																				if replacechild ~= nil and isPrimitive == false then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_REPLACE_CHILD_IN_VECTOR")
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																					do _g.sling.util.FunctionUtil:addStatement(replacechild, fc) end
																				end
																				if copyto ~= nil then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forName((function(a, b, c)
																						if a then
																							do return b() end
																						end
																						do return c() end
																					end)(isPrimitive, function()
																						do return "IMPLEMENT_COPY_VALUE_VECTOR" end
																					end, function()
																						do return "IMPLEMENT_COPY_PROPERTY_VECTOR" end
																					end))
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																					do _g.sling.util.FunctionUtil:addStatement(copyto, fc) end
																				end
																				if acceptvisitor ~= nil and isPrimitive == false then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_VISIT_PROPERTY_VECTOR")
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																					do _g.sling.util.FunctionUtil:addStatement(acceptvisitor, fc) end
																				end
																				if destroy ~= nil and isPrimitive == false then
																					local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_DESTROY_PROPERTY_VECTOR")
																					do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																					do _g.sling.util.FunctionUtil:addStatement(destroy, fc) end
																				end
																				do
																					local nset = _g.sling.compiler.Samtree2Ops:modifyName("set", vname)
																					if class:hasChildNode(nset) == false then
																						local fset = _g.sling.model.FunctionDeclarationNode:forName(nset, true)
																						do fset:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
																						do fset:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())), "v", nil)) end
																						if isPrimitive == false then
																							do fset:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), "doExport", _g.sling.model.BooleanLiteralExpressionNode:forValue(false))) end
																						end
																						do
																							local fc = _g.sling.model.FunctionCallExpressionNode:forName((function(a, b, c)
																								if a then
																									do return b() end
																								end
																								do return c() end
																							end)(isPrimitive, function()
																								do return "IMPLEMENT_SET_VALUE_VECTOR" end
																							end, function()
																								do return "IMPLEMENT_SET_PROPERTY_VECTOR" end
																							end))
																							do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																							do _g.sling.util.FunctionUtil:addStatement(fset, fc) end
																							do class:addNode(fset) end
																						end
																					end
																					do
																						local nget = _g.sling.compiler.Samtree2Ops:modifyName("get", vname)
																						if class:hasChildNode(nget) == false then
																							local fget = _g.sling.model.FunctionDeclarationNode:forName(nget, true)
																							do fget:setReturnType(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())), false) end
																							do
																								local fc = _g.sling.model.FunctionCallExpressionNode:forName((function(a, b, c)
																									if a then
																										do return b() end
																									end
																									do return c() end
																								end)(isPrimitive, function()
																									do return "IMPLEMENT_GET_VALUE_VECTOR" end
																								end, function()
																									do return "IMPLEMENT_GET_PROPERTY_VECTOR" end
																								end))
																								do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																								do _g.sling.util.FunctionUtil:addStatement(fget, fc) end
																								do class:addNode(fget) end
																							end
																						end
																						if isPrimitive == false then
																							local nexp = _g.sling.compiler.Samtree2Ops:modifyName("export", vname)
																							if class:hasChildNode(nexp) == false then
																								local fexp = _g.sling.model.FunctionDeclarationNode:forName(nexp, true)
																								do fexp:setReturnType(_g.sling.model.VectorDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create())), false) end
																								do
																									local fc = _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_EXPORT_PROPERTY_VECTOR")
																									do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																									do _g.sling.util.FunctionUtil:addStatement(fexp, fc) end
																									do class:addNode(fexp) end
																								end
																							end
																						end
																						do
																							local nadd = _g.sling.compiler.Samtree2Ops:modifyName("addTo", vname)
																							if class:hasChildNode(nadd) == false then
																								local fadd = _g.sling.model.FunctionDeclarationNode:forName(nadd, true)
																								do fadd:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
																								do fadd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(dt), "v", nil)) end
																								do
																									local fc = _g.sling.model.FunctionCallExpressionNode:forName((function(a, b, c)
																										if a then
																											do return b() end
																										end
																										do return c() end
																									end)(isPrimitive, function()
																										do return "IMPLEMENT_ADD_TO_VALUE_VECTOR" end
																									end, function()
																										do return "IMPLEMENT_ADD_TO_PROPERTY_VECTOR" end
																									end))
																									do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																									do _g.sling.util.FunctionUtil:addStatement(fadd, fc) end
																									do class:addNode(fadd) end
																								end
																							end
																							do
																								local nclr = _g.sling.compiler.Samtree2Ops:modifyName("clear", vname)
																								if class:hasChildNode(nclr) == false then
																									local fclr = _g.sling.model.FunctionDeclarationNode:forName(nclr, true)
																									do fclr:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
																									do
																										local fc = _g.sling.model.FunctionCallExpressionNode:forName((function(a, b, c)
																											if a then
																												do return b() end
																											end
																											do return c() end
																										end)(isPrimitive, function()
																											do return "IMPLEMENT_CLEAR_VALUE_VECTOR" end
																										end, function()
																											do return "IMPLEMENT_CLEAR_PROPERTY_VECTOR" end
																										end))
																										do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vv, nil)) end
																										do _g.sling.util.FunctionUtil:addStatement(fclr, fc) end
																										do class:addNode(fclr) end
																									end
																								end
																								do dt:destroy() end
																							end
																						end
																					end
																				end
																			end
																			do n4 = n4 + 1 end
																		end
																	end
																end
																if replacechild ~= nil then
																	do _g.sling.util.FunctionUtil:addStatement(replacechild, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_REPLACE_CHILD_END")) end
																end
																if copyto ~= nil then
																	do _g.sling.util.FunctionUtil:addStatement(copyto, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_COPY_TO_END")) end
																end
																if acceptvisitor ~= nil then
																	do _g.sling.util.FunctionUtil:addStatement(acceptvisitor, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_ACCEPT_VISITOR_END")) end
																end
																if destroy ~= nil then
																	do _g.sling.util.FunctionUtil:addStatement(destroy, _g.sling.model.FunctionCallExpressionNode:forName("IMPLEMENT_DESTROY_END")) end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
end

sling.compiler.JkopOps = {}
sling.compiler.JkopOps.__index = sling.compiler.JkopOps
_vm:set_metatable(sling.compiler.JkopOps, {})

function sling.compiler.JkopOps._create()
	local v = _vm:set_metatable({}, sling.compiler.JkopOps)
	return v
end

function sling.compiler.JkopOps:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.JkopOps'
	self['_isType.sling.compiler.JkopOps'] = true
end

function sling.compiler.JkopOps:_construct0()
	sling.compiler.JkopOps._init(self)
	return self
end

function sling.compiler.JkopOps:expandToJkopSetContains(ctx, node)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.MembershipCheckExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.MembershipCheckExpressionNode')
				if nn ~= nil then
					local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
						"Set",
						"contains"
					})
					do fc:setSource(nn:getSource()) end
					do fc:addToParameters(nn:exportRight()) end
					do fc:addToParameters(nn:exportLeft()) end
					do nn:replaceWith(fc, false) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JkopOps:convertModelsToJkop(ctx, node)
	do _g.sling.compiler.DynamicModelExpander._construct0(_g.sling.compiler.DynamicModelExpander._create()):execute(node) end
	do _g.sling.compiler.ModelExpanderForJkop._construct0(_g.sling.compiler.ModelExpanderForJkop._create()):execute(node) end
end

function sling.compiler.JkopOps:convertWebApiToSympathy(ctx, node)
	local x = _g.sling.compiler.WebApiExpanderForSympathy._construct0(_g.sling.compiler.WebApiExpanderForSympathy._create())
	do x:setCtx(ctx) end
	do x:execute(node) end
end

function sling.compiler.JkopOps:convertWebApi2ToSympathy(ctx, node)
	local x = _g.sling.compiler.WebApi2ExpanderForSympathy._construct0(_g.sling.compiler.WebApi2ExpanderForSympathy._create())
	do x:setCtx(ctx) end
	do x:execute(node) end
end

function sling.compiler.JkopOps:protectStringConcatenationExpression(xpr)
	if not (xpr ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(xpr, '_isType.sling.model.StringLiteralExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.StringConcatenationExpressionNode') ~= nil) then
	else
		local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
			"jk",
			"lang",
			"String",
			"safeString"
		})
		do xpr:replaceWith(fc, true) end
		do fc:addToParameters(xpr) end
	end
end

function sling.compiler.JkopOps:protectStringConcatenationExpressions(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("nojkop") then
						goto _continue38
					end
					do
						local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(decl, "class:sling.model.StringConcatenationExpressionNode", false, true, false)
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local xpr = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.StringConcatenationExpressionNode')
									if xpr ~= nil then
										do _g.sling.compiler.JkopOps:protectStringConcatenationExpression(xpr:getLeft()) end
										do _g.sling.compiler.JkopOps:protectStringConcatenationExpression(xpr:getRight()) end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
				end
				::_continue38::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JkopOps:addJkopAutomaticImports(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if decl ~= nil then
					if (_vm:to_table_with_key(decl, '_isType.sling.model.ClassDeclarationNode') ~= nil) == false and (_vm:to_table_with_key(decl, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) == false and (_vm:to_table_with_key(decl, '_isType.sling.model.ModelDeclarationNode') ~= nil) == false then
						goto _continue39
					end
					if decl:hasCustomModifier("nojkop") then
						goto _continue39
					end
					if (_vm:to_table_with_key(decl:getParent(), '_isType.sling.model.EntityDeclarationNode') ~= nil) then
						goto _continue39
					end
					do
						local nspace = _g.sling.util.FindUtil:findNearestNamespace(decl)
						if nspace ~= nil and _g.jk.lang.String:equals(_g.sling.util.NodeUtil:getQualifiedNameString(nspace, 46), "jk.lang") then
							goto _continue39
						end
						do decl:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
							"jk",
							"lang"
						})) end
					end
				end
				::_continue39::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JkopOps:forceJkopVectorOperations(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("nojkop") then
						goto _continue40
					end
					do
						local types = {
							"class:sling.model.GetSizeExpressionNode",
							"class:sling.model.AppendToVectorExpressionNode"
						}
						local nodes = _g.sling.util.FindUtil:findNodesOfTypes(decl, types, false, true, false)
						if nodes ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(nodes)
							do
								n2 = 0
								while n2 < m2 do
									local node = nodes[n2 + 1]
									if node ~= nil then
										if (_vm:to_table_with_key(node, '_isType.sling.model.GetSizeExpressionNode') ~= nil) then
											local xpr = node:getExpression()
											local xprdt = _g.sling.util.ExpressionUtil:getExpressionDataType(xpr, nil)
											if xprdt ~= nil and (_vm:to_table_with_key(xprdt, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
												local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
													"Vector",
													"getSize"
												})
												do fc:addToParameters(node:exportExpression()) end
												do node:replaceWith(fc, false) end
											end
										elseif (_vm:to_table_with_key(node, '_isType.sling.model.AppendToVectorExpressionNode') ~= nil) then
											local left = node:exportLeft()
											local right = node:exportRight()
											local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
												"Vector",
												"append"
											})
											do fc:addToParameters(left) end
											do fc:addToParameters(right) end
											do node:replaceWith(fc, false) end
										else
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Incorrect node type", node, nil))
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
				end
				::_continue40::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JkopOps:processCriticalSections(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("nojkop") then
						goto _continue41
					end
					do
						local importProcessed = false
						local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(decl, "class:sling.model.CriticalSectionBlockNode", false, true, false)
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local csb = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.CriticalSectionBlockNode')
									if csb ~= nil then
										if not importProcessed then
											do decl:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
												"jk",
												"thread"
											})) end
											importProcessed = true
										end
										do
											local object = csb:exportObject()
											if not (object ~= nil) then
												object = _g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create())
											end
											do
												local block = csb:exportBlock()
												local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("CriticalSection"), "execute", true)
												do fc:setSource(csb:getSource()) end
												do fc:addToParameters(object) end
												do
													local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
													do fd:setBody(block, false) end
													do fd:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
													do fc:addToParameters(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)) end
													do _g.sling.util.NodeUtil:replaceNode(csb, fc) end
												end
											end
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
					end
				end
				::_continue41::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JkopOps:createDynamicConverterExpression(xpr, type, resolver)
	if not (type ~= nil) then
		do return xpr end
	end
	do
		local names = {}
		if (_vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
			local bound = resolver:getBoundNode(type)
			local array = _g.sling.util.NodeUtil:getQualifiedNameComponents(bound, true)
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local comp = (function(o)
							if (_vm:get_variable_type(o) == 'string') then
								do return o end
							end
							do return nil end
						end)(array[n + 1])
						if comp ~= nil then
							do _g.jk.lang.Vector:append(names, comp) end
						end
						do n = n + 1 end
					end
				end
			end
			do _g.jk.lang.Vector:append(names, "asThis") end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.StringDataTypeNode') ~= nil) then
			do _g.jk.lang.Vector:append(names, "jk") end
			do _g.jk.lang.Vector:append(names, "lang") end
			do _g.jk.lang.Vector:append(names, "String") end
			do _g.jk.lang.Vector:append(names, "asString") end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
			do _g.jk.lang.Vector:append(names, "jk") end
			do _g.jk.lang.Vector:append(names, "lang") end
			do _g.jk.lang.Vector:append(names, "Boolean") end
			do _g.jk.lang.Vector:append(names, "asBoolean") end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
			do _g.jk.lang.Vector:append(names, "jk") end
			do _g.jk.lang.Vector:append(names, "lang") end
			do _g.jk.lang.Vector:append(names, "Double") end
			do _g.jk.lang.Vector:append(names, "asDouble") end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
			if type:getType() == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
				do _g.jk.lang.Vector:append(names, "jk") end
				do _g.jk.lang.Vector:append(names, "lang") end
				do _g.jk.lang.Vector:append(names, "LongInteger") end
				do _g.jk.lang.Vector:append(names, "asLong") end
			else
				do _g.jk.lang.Vector:append(names, "jk") end
				do _g.jk.lang.Vector:append(names, "lang") end
				do _g.jk.lang.Vector:append(names, "Integer") end
				do _g.jk.lang.Vector:append(names, "asInteger") end
			end
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Dynamic conversion not supported for data tyoe: `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingNodeUtil:describeDataType(type)) .. "'", type, nil))
		end
		do
			local sex = nil
			if names ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(names)
				do
					n2 = 0
					while n2 < m2 do
						local name = names[n2 + 1]
						if name ~= nil then
							sex = _g.sling.model.MemberAccessExpressionNode:append(_g.sling.model.SymbolExpressionNode:forName(name), sex)
						end
						do n2 = n2 + 1 end
					end
				end
			end
			do
				local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(sex)
				do fc:addToParameters(xpr) end
				do return fc end
			end
		end
	end
end

sling.compiler.LinkableModuleInfo = {}
sling.compiler.LinkableModuleInfo.__index = sling.compiler.LinkableModuleInfo
_vm:set_metatable(sling.compiler.LinkableModuleInfo, {})

function sling.compiler.LinkableModuleInfo._create()
	local v = _vm:set_metatable({}, sling.compiler.LinkableModuleInfo)
	return v
end

function sling.compiler.LinkableModuleInfo:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.LinkableModuleInfo'
	self['_isType.sling.compiler.LinkableModuleInfo'] = true
	self.moduleId = nil
	self.linkTarget = nil
	self.timestamp = 0
	self.apifile = nil
	self.depfile = nil
	self.dependencies = nil
	self.header = nil
end

function sling.compiler.LinkableModuleInfo:_construct0()
	sling.compiler.LinkableModuleInfo._init(self)
	return self
end

function sling.compiler.LinkableModuleInfo:getModuleId()
	do return self.moduleId end
end

function sling.compiler.LinkableModuleInfo:setModuleId(v)
	self.moduleId = v
	do return self end
end

function sling.compiler.LinkableModuleInfo:getLinkTarget()
	do return self.linkTarget end
end

function sling.compiler.LinkableModuleInfo:setLinkTarget(v)
	self.linkTarget = v
	do return self end
end

function sling.compiler.LinkableModuleInfo:getTimestamp()
	do return self.timestamp end
end

function sling.compiler.LinkableModuleInfo:setTimestamp(v)
	self.timestamp = v
	do return self end
end

function sling.compiler.LinkableModuleInfo:getApifile()
	do return self.apifile end
end

function sling.compiler.LinkableModuleInfo:setApifile(v)
	self.apifile = v
	do return self end
end

function sling.compiler.LinkableModuleInfo:getDepfile()
	do return self.depfile end
end

function sling.compiler.LinkableModuleInfo:setDepfile(v)
	self.depfile = v
	do return self end
end

function sling.compiler.LinkableModuleInfo:getDependencies()
	do return self.dependencies end
end

function sling.compiler.LinkableModuleInfo:setDependencies(v)
	self.dependencies = v
	do return self end
end

function sling.compiler.LinkableModuleInfo:getHeader()
	do return self.header end
end

function sling.compiler.LinkableModuleInfo:setHeader(v)
	self.header = v
	do return self end
end

sling.compiler.ForEachHandler = {}
sling.compiler.ForEachHandler.__index = sling.compiler.ForEachHandler
_vm:set_metatable(sling.compiler.ForEachHandler, {})

function sling.compiler.ForEachHandler._create()
	local v = _vm:set_metatable({}, sling.compiler.ForEachHandler)
	return v
end

function sling.compiler.ForEachHandler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.ForEachHandler'
	self['_isType.sling.compiler.ForEachHandler'] = true
end

function sling.compiler.ForEachHandler:_construct0()
	sling.compiler.ForEachHandler._init(self)
	return self
end

function sling.compiler.ForEachHandler:setInitializer(vdec, init, tr)
	if not (vdec ~= nil) then
		do return end
	end
	do
		local type = vdec:getType()
		if not (type ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable has no data type", vdec, nil))
		end
		if type ~= nil and (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) == false then
			local xprt = _g.sling.util.ExpressionUtil:getExpressionDataType(init, tr)
			if xprt == nil or tr:isSame(xprt, type, nil) == false then
				local tdup = _g.sling.util.DataTypeUtil:dupAsDataType(type)
				init = _g.sling.model.DynamicCastExpressionNode:instance(tdup, init)
			end
		end
		do vdec:setInitializer(init, false) end
		if (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
			local rdtp = _vm:to_table_with_key(tr, '_isType.sling.compiler.SlingTypeResolver'):resolveVariableType(vdec)
			do vdec:setType(_g.sling.util.DataTypeUtil:dupAsDataType(rdtp), false) end
		end
	end
end

function sling.compiler.ForEachHandler:toStaticArrayIterator(fes, tr)
	local nvarname = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "n")
	local mvarname = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "m")
	local rr = fes:getRight()
	if not (rr ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", fes, nil))
	end
	do
		local cc = fes:getLeftCount()
		if cc < 1 then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Foreach statement has no left values", fes, nil))
		end
		do
			local array2 = fes:getLefts()
			if array2 ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array2)
				do
					n = 0
					while n < m do
						local lval = _vm:to_table_with_key(array2[n + 1], '_isType.sling.common.NodeObject')
						if lval ~= nil then
							if (_vm:to_table_with_key(lval, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported construct in foreach statement left values", lval, nil))
							end
						end
						do n = n + 1 end
					end
				end
			end
			do
				local v = {}
				local arrayvar = nil
				if (_vm:to_table_with_key(rr, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
					arrayvar = _vm:to_table_with_key(_g.sling.util.SymbolUtil:tryGetSymbolBindingForExpression(rr), '_isType.sling.model.VariableDeclarationNode')
				end
				if arrayvar == nil then
					local avname = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "array")
					arrayvar = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), avname, fes:exportRight())
					do _g.jk.lang.Vector:append(v, arrayvar) end
				end
				do
					local mblock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
					do _g.jk.lang.Vector:append(v, _g.sling.model.IfStatementNode:instance(_g.sling.model.NotEqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forBinding(arrayvar, nil)), mblock, nil)) end
					do
						local nvar = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), nvarname, nil)
						do mblock:addNode(nvar) end
						do
							local mvar = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), mvarname, _g.sling.model.GetSizeExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forBinding(arrayvar, nil)))
							do mblock:addNode(mvar) end
							do
								local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
								local initializer = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
								do initializer:addNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forBinding(nvar, nil), _g.sling.model.IntegerLiteralExpressionNode:forValue(0))) end
								do
									local finalizer = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
									do finalizer:addNode(_g.sling.model.PostIncrementExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forBinding(nvar, nil))) end
									do mblock:addNode(_g.sling.model.ForStatementNode:instance(initializer, _g.sling.model.LessThanExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forBinding(nvar, nil), _g.sling.model.SymbolExpressionNode:forBinding(mvar, nil)), finalizer, block)) end
									do
										local lefts = {}
										local array = _g.sling.model.SubscriptExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forBinding(arrayvar, nil), _g.sling.model.SymbolExpressionNode:forBinding(nvar, nil))
										local atype = _g.sling.util.ExpressionUtil:getExpressionDataType(array, tr)
										if atype ~= nil then
											local dval = _g.sling.util.DataTypeUtil:createDefaultValue(atype)
											if dval ~= nil then
												atype = _g.sling.util.ExpressionUtil:getExpressionDataType(dval, tr)
											end
										end
										if cc > 1 then
											local name = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "v")
											local vdecl = _g.sling.model.VariableDeclarationNode:forAutomatic(name, array)
											do block:addNode(vdecl) end
											do
												local count = 0
												local array3 = fes:exportLefts()
												if array3 ~= nil then
													local n2 = 0
													local m2 = _g.jk.lang.Vector:getSize(array3)
													do
														n2 = 0
														while n2 < m2 do
															local left = _vm:to_table_with_key(array3[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
															if left ~= nil then
																local init = _g.sling.model.SubscriptExpressionNode:instance(_g.sling.model.SymbolExpressionNode:forBinding(vdecl, nil), _g.sling.model.IntegerLiteralExpressionNode:forValue(count))
																do _g.sling.compiler.ForEachHandler:setInitializer(left, init, tr) end
																do block:addNode(left) end
																do _g.jk.lang.Vector:append(lefts, left) end
																do count = count + 1 end
															end
															do n2 = n2 + 1 end
														end
													end
												end
											end
										else
											local left = _g.sling.util.NodeUtil:exportLeftAsVariableDeclaration(fes)
											do block:addNode(left) end
											do _g.sling.compiler.ForEachHandler:setInitializer(left, array, tr) end
											do _g.jk.lang.Vector:append(lefts, left) end
										end
										do
											local ncks = nil
											if lefts ~= nil then
												local n3 = 0
												local m3 = _g.jk.lang.Vector:getSize(lefts)
												do
													n3 = 0
													while n3 < m3 do
														local left = lefts[n3 + 1]
														if left ~= nil then
															local type = left:getType()
															local dval = _g.sling.util.DataTypeUtil:createDefaultValue(type)
															if dval ~= nil then
																type = _g.sling.util.ExpressionUtil:getExpressionDataType(dval, tr)
															end
															do
																local nchk = nil
																if type == nil or (_vm:to_table_with_key(type, '_isType.sling.model.NullDataTypeNode') ~= nil) then
																	nchk = _g.sling.model.NotEqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forBinding(left, nil))
																end
																if not (nchk ~= nil) then
																	goto _continue42
																end
																if ncks ~= nil then
																	ncks = _g.sling.model.LogicalAndExpressionNode:instance(ncks, nchk)
																else
																	ncks = nchk
																end
															end
														end
														::_continue42::
														do n3 = n3 + 1 end
													end
												end
											end
											do
												local cxpr = fes:exportCondition()
												if cxpr ~= nil then
													if ncks ~= nil then
														ncks = _g.sling.model.LogicalAndExpressionNode:instance(ncks, cxpr)
													else
														ncks = cxpr
													end
												end
												if ncks ~= nil then
													do block:addNode(_g.sling.model.IfStatementNode:instance(ncks, fes:exportBlock(), nil)) end
												else
													local ebb = fes:exportBlock()
													if ebb ~= nil then
														local array4 = ebb:getNodes()
														if array4 ~= nil then
															local n4 = 0
															local m4 = _g.jk.lang.Vector:getSize(array4)
															do
																n4 = 0
																while n4 < m4 do
																	local en = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.common.NodeObject')
																	if en ~= nil then
																		do block:addNode(en) end
																	end
																	do n4 = n4 + 1 end
																end
															end
														end
													end
												end
												do return v end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.ForEachHandler:toCapeIterator(fes, tr)
	local rval = fes:exportRight()
	if not (rval ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", fes, nil))
	end
	do
		local blck = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
		local vnme = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "_vl")
		local vdec = _g.sling.model.VariableDeclarationNode:forAutomatic(vnme, rval)
		do blck:addNode(vdec) end
		do
			local blk1 = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
			do blck:addNode(_g.sling.model.IfStatementNode:instance(_g.sling.model.NotEqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forBinding(vdec, nil)), blk1, nil)) end
			do
				local inme = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "_it")
				local idec = _g.sling.model.VariableDeclarationNode:forAutomatic(inme, _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forBinding(vdec, nil), _g.sling.model.SymbolExpressionNode:forName("iterate"))))
				do blk1:addNode(idec) end
				do
					local blk2 = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
					local cond = _g.sling.model.LogicalAndExpressionNode:instance(_g.sling.model.NotEqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forBinding(idec, nil)), _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forBinding(idec, nil), _g.sling.model.SymbolExpressionNode:forName("hasNext"))))
					do blk1:addNode(_g.sling.model.WhileStatementNode:instance(cond, blk2, nil)) end
					do
						local next = _g.sling.util.NodeUtil:exportLeftAsVariableDeclaration(fes)
						if not (next ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", fes, nil))
						end
						do
							local type = next:getType()
							if not (type ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("foreach left value has no type", fes, nil))
							end
							do
								local init = _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forBinding(idec, nil), _g.sling.model.SymbolExpressionNode:forName("next")))
								if type ~= nil and (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) == false then
									init = _g.sling.model.DynamicCastExpressionNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(type), init)
								end
								do next:setInitializer(init, false) end
								do blk2:addNode(next) end
								do
									local fint = _g.sling.util.ExpressionUtil:getExpressionDataType(init, tr)
									if fint ~= nil and (_vm:to_table_with_key(fint, '_isType.sling.model.PrimitiveDataTypeNode') ~= nil) == false then
										do blk2:addNode(_g.sling.model.IfStatementNode:forStatement(_g.sling.model.NotEqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forBinding(next, nil)), _g.sling.model.ContinueStatementNode._construct0(_g.sling.model.ContinueStatementNode._create()))) end
									end
									do
										local cxpr = fes:exportCondition()
										local blk3 = nil
										if cxpr ~= nil then
											blk3 = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
											do blk2:addNode(_g.sling.model.IfStatementNode:instance(cxpr, blk3, nil)) end
										else
											blk3 = blk2
										end
										do
											local fblk = fes:exportBlock()
											if fblk ~= nil then
												local array = fblk:getNodes()
												if array ~= nil then
													local n = 0
													local m = _g.jk.lang.Vector:getSize(array)
													do
														n = 0
														while n < m do
															local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
															if node ~= nil then
																do blk3:addNode(node) end
															end
															do n = n + 1 end
														end
													end
												end
											end
											do
												local v = {}
												do _g.jk.lang.Vector:append(v, blck) end
												do return v end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.ForEachHandler:isCapeIterateable(tr, type)
	if not (type ~= nil) then
		do return false end
	end
	do
		local node = tr:getBoundEntity(type)
		if not (node ~= nil) then
			do return false end
		end
		if (_vm:to_table_with_key(node, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
			local qlf = _g.sling.util.NodeUtil:getQualifiedNameString(node, 46)
			do return _g.jk.lang.String:equals(qlf, "jk.lang.Iterateable") end
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
			local infc = tr:getImplementedInterfaceReference(node, {
				"jk",
				"lang",
				"Iterateable"
			})
			if not (infc ~= nil) then
				do return false end
			end
			do return true end
		end
		do return false end
	end
end

function sling.compiler.ForEachHandler:expandForeachStatementsStatic(ctx, tr, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.ForEachStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local fes = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ForEachStatementNode')
				if fes ~= nil then
					local bb = nil
					local rr = fes:getRight()
					if not (rr ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("foreach with null expression", fes, nil))
					end
					do
						local rexp = _g.sling.util.ExpressionUtil:getExpressionDataType(rr, tr)
						if (_vm:to_table_with_key(rexp, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
							bb = _g.sling.compiler.ForEachHandler:toStaticArrayIterator(fes, tr)
							if not (bb ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process the unrolling of static array foreach", fes, nil))
							end
						elseif (_vm:to_table_with_key(rexp, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
							bb = _g.sling.compiler.ForEachHandler:toStaticArrayIterator(fes, tr)
							if not (bb ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process the unrolling of vector foreach", fes, nil))
							end
						elseif (_vm:to_table_with_key(rexp, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) and _g.sling.compiler.ForEachHandler:isCapeIterateable(tr, rexp) then
							bb = _g.sling.compiler.ForEachHandler:toCapeIterator(fes, tr)
							if not (bb ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process the unrolling of iterator foreach", fes, nil))
							end
						else
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Don't know how to unroll foreach for data type `" .. _g.jk.lang.String:safeString(rexp:getNodeTypeName()) .. "'", fes, nil))
						end
						do
							local src = fes:getSource()
							if bb ~= nil then
								local n3 = 0
								local m2 = _g.jk.lang.Vector:getSize(bb)
								do
									n3 = 0
									while n3 < m2 do
										local cn = _vm:to_table_with_key(bb[n3 + 1], '_isType.sling.common.NodeObject')
										if cn ~= nil then
											do cn:setSource(src) end
										end
										do n3 = n3 + 1 end
									end
								end
							end
							if _g.jk.lang.Vector:getSize(bb) == 1 then
								local nd = _vm:to_table_with_key(_g.jk.lang.Vector:get(bb, 0), '_isType.sling.common.NodeObject')
								if not (nd ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("nd is null", fes, nil))
								end
								do _g.sling.util.NodeUtil:replaceNode(fes, nd) end
							else
								local pp = _vm:to_table_with_key(fes:getParent(), '_isType.sling.common.ContainerNode')
								if not (pp ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No container node parent", fes, nil))
								end
								do
									local ip = pp:getInsertionPointForNode(fes)
									if not (ip ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get insertion point", fes, nil))
									end
									if bb ~= nil then
										local n4 = 0
										local m3 = _g.jk.lang.Vector:getSize(bb)
										do
											n4 = 0
											while n4 < m3 do
												local n2 = _vm:to_table_with_key(bb[n4 + 1], '_isType.sling.common.NodeObject')
												if n2 ~= nil then
													if not ip:insertBefore(n2) then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insert node in insertion point", fes, nil))
													end
												end
												do n4 = n4 + 1 end
											end
										end
									end
									do _g.sling.util.NodeUtil:removeNode(fes) end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.ForEachHandler:expandForeachStatementsDynamic(root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.ForEachStatementNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local fes = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ForEachStatementNode')
				if fes ~= nil then
					local lefts = fes:exportLefts()
					if not (_g.jk.lang.Vector:getSize(lefts) == 1) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Only 1 left variable is supported.", fes, nil))
						do return end
					end
					do
						local left = _vm:to_table_with_key(_g.jk.lang.Vector:get(lefts, 0), '_isType.sling.model.VariableDeclarationNode')
						if not (left ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Invalid left variable", fes, nil))
							do return end
						end
						do
							local right = fes:exportRight()
							if not (right ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null right", fes, nil))
								do return end
							end
							do
								local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forArrayOfNames({
									"jk",
									"lang",
									"DynamicObject",
									"iterate"
								}))
								do fc:addToParameters(right) end
								do
									local varname = _g.sling.util.FunctionUtil:findUniqueVariableNameForNode(fes, "it")
									local mblock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
									local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), varname, fc)
									do mblock:addNode(vd) end
									do
										local wblock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
										local lvarname = left:getName()
										local itnextfc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName(varname), "next", false)
										do wblock:addNode(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), lvarname, itnextfc)) end
										do
											local ifcond = _g.sling.model.EqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forName(lvarname))
											do wblock:addNode(_g.sling.model.IfStatementNode:forStatement(ifcond, _g.sling.model.BreakStatementNode._construct0(_g.sling.model.BreakStatementNode._create()))) end
											do
												local bb = fes:exportBlock()
												if bb ~= nil then
													do wblock:addNode(bb) end
												end
												do
													local ww = _g.sling.model.WhileStatementNode:instance(_g.sling.model.NotEqualsExpressionNode:forNull(_g.sling.model.SymbolExpressionNode:forName(varname)), wblock, nil)
													do mblock:addNode(ww) end
													do _g.sling.util.NodeUtil:replaceNode(fes, mblock) end
												end
											end
										end
									end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

sling.compiler.LibraryName = {}
sling.compiler.LibraryName.__index = sling.compiler.LibraryName
_vm:set_metatable(sling.compiler.LibraryName, {})

function sling.compiler.LibraryName._create()
	local v = _vm:set_metatable({}, sling.compiler.LibraryName)
	return v
end

function sling.compiler.LibraryName:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.LibraryName'
	self['_isType.sling.compiler.LibraryName'] = true
	self['_isType.jk.lang.StringObject'] = true
	self.namespace = nil
	self.name = nil
	self.version = nil
end

function sling.compiler.LibraryName:_construct0()
	sling.compiler.LibraryName._init(self)
	return self
end

function sling.compiler.LibraryName:asLibraryName(o)
	local str = _g.jk.lang.String:asString(o)
	if not (str ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.compiler.LibraryName:parse(str)
		if not (v ~= nil) then
			do _g.jk.lang.Error:throw("invalidLibraryName", str) end
		end
		do return v end
	end
end

function sling.compiler.LibraryName:asLibraryNameVector(o)
	local it = _g.jk.lang.DynamicObject:iterate(o)
	if not (it ~= nil) then
		do return nil end
	end
	do
		local v = {}
		while true do
			local oo = it:next()
			if not (oo ~= nil) then
				do break end
			end
			do
				local ff = _g.sling.compiler.LibraryName:asLibraryName(oo)
				if ff ~= nil then
					do _g.jk.lang.Vector:append(v, ff) end
				end
			end
		end
		do return v end
	end
end

function sling.compiler.LibraryName:parse(string)
	if not (string ~= nil) then
		do return nil end
	end
	do
		local namespace = nil
		local name = nil
		local version = nil
		local vals = _g.jk.lang.String:split(string, 58, 3)
		local c = _g.jk.lang.Vector:getSize(vals)
		if c == 2 then
			name = _g.jk.lang.Vector:get(vals, 0)
			version = _g.jk.lang.Vector:get(vals, 1)
		elseif c == 3 then
			namespace = _g.jk.lang.Vector:get(vals, 0)
			name = _g.jk.lang.Vector:get(vals, 1)
			version = _g.jk.lang.Vector:get(vals, 2)
		else
			do return nil end
		end
		if _g.jk.lang.String:isEmpty(namespace) then
			namespace = "eqela"
		end
		if not _g.jk.lang.String:isNotEmpty(name) then
			do return nil end
		end
		if not _g.jk.lang.String:isNotEmpty(version) then
			do return nil end
		end
		do
			local v = _g.sling.compiler.LibraryName._construct0(_g.sling.compiler.LibraryName._create())
			do v:setNamespace(namespace) end
			do v:setName(name) end
			do v:setVersion(version) end
			do return v end
		end
	end
end

function sling.compiler.LibraryName:toString()
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	if self.namespace ~= nil then
		do sb:appendString(self.namespace) end
	end
	do sb:appendCharacter(58) end
	if self.name ~= nil then
		do sb:appendString(self.name) end
	end
	do sb:appendCharacter(58) end
	if self.version ~= nil then
		do sb:appendString(self.version) end
	end
	do return sb:toString() end
end

function sling.compiler.LibraryName:getNamespace()
	do return self.namespace end
end

function sling.compiler.LibraryName:setNamespace(v)
	self.namespace = v
	do return self end
end

function sling.compiler.LibraryName:getName()
	do return self.name end
end

function sling.compiler.LibraryName:setName(v)
	self.name = v
	do return self end
end

function sling.compiler.LibraryName:getVersion()
	do return self.version end
end

function sling.compiler.LibraryName:setVersion(v)
	self.version = v
	do return self end
end

sling.compiler.ProgressHelper = {}
sling.compiler.ProgressHelper.__index = sling.compiler.ProgressHelper
_vm:set_metatable(sling.compiler.ProgressHelper, {})

function sling.compiler.ProgressHelper._create()
	local v = _vm:set_metatable({}, sling.compiler.ProgressHelper)
	return v
end

function sling.compiler.ProgressHelper:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.ProgressHelper'
	self['_isType.sling.compiler.ProgressHelper'] = true
	self._ctx = nil
	self._message = nil
	self._startPercentage = 0.0
	self._maxPercentage = 1.0
	self._currentValue = 0
	self._maxValue = 0
end

function sling.compiler.ProgressHelper:_construct0()
	sling.compiler.ProgressHelper._init(self)
	return self
end

function sling.compiler.ProgressHelper:forMaximumValue(ctx, message, value)
	local v = _g.sling.compiler.ProgressHelper._construct0(_g.sling.compiler.ProgressHelper._create())
	do v:setCtx(ctx) end
	do v:setMessage(message) end
	do v:setCurrentValue(0) end
	do v:setMaxValue(value) end
	do return v end
end

function sling.compiler.ProgressHelper:forFirstHalf(ctx, message, value)
	local v = _g.sling.compiler.ProgressHelper._construct0(_g.sling.compiler.ProgressHelper._create())
	do v:setCtx(ctx) end
	do v:setMessage(message) end
	do v:setCurrentValue(0) end
	do v:setMaxValue(value * 2) end
	do return v end
end

function sling.compiler.ProgressHelper:forSecondHalf(ctx, message, value)
	local v = _g.sling.compiler.ProgressHelper._construct0(_g.sling.compiler.ProgressHelper._create())
	do v:setCtx(ctx) end
	do v:setMessage(message) end
	do v:setCurrentValue(value) end
	do v:setMaxValue(value * 2) end
	do return v end
end

function sling.compiler.ProgressHelper:toProgress(n, c)
	local f = (n + 1) / c
	f = f * (self:getMaxPercentage() - self:getStartPercentage())
	f = f + self:getStartPercentage()
	do return _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(_util:convert_to_integer(f * 100.0))) .. "%" end
end

function sling.compiler.ProgressHelper:onUpdate()
	do _g.jk.log.Log:status(self:getCtx(), "[" .. _g.jk.lang.String:safeString(self:toProgress(self:getCurrentValue(), self:getMaxValue())) .. "] " .. _g.jk.lang.String:safeString(self:getMessage()) .. " ..") end
	do self:setCurrentValue(self:getCurrentValue() + 1) end
end

function sling.compiler.ProgressHelper:_end()
	do _g.jk.log.Log:status(self:getCtx(), nil) end
end

function sling.compiler.ProgressHelper:getCtx()
	do return self._ctx end
end

function sling.compiler.ProgressHelper:doSetCtx(value)
	self._ctx = value
end

function sling.compiler.ProgressHelper:setCtx(v)
	do self:doSetCtx(v) end
	do return v end
end

function sling.compiler.ProgressHelper:getMessage()
	do return self._message end
end

function sling.compiler.ProgressHelper:doSetMessage(value)
	self._message = value
end

function sling.compiler.ProgressHelper:setMessage(v)
	do self:doSetMessage(v) end
	do return v end
end

function sling.compiler.ProgressHelper:getStartPercentage()
	do return self._startPercentage end
end

function sling.compiler.ProgressHelper:doSetStartPercentage(value)
	self._startPercentage = value
end

function sling.compiler.ProgressHelper:setStartPercentage(v)
	do self:doSetStartPercentage(v) end
	do return v end
end

function sling.compiler.ProgressHelper:getMaxPercentage()
	do return self._maxPercentage end
end

function sling.compiler.ProgressHelper:doSetMaxPercentage(value)
	self._maxPercentage = value
end

function sling.compiler.ProgressHelper:setMaxPercentage(v)
	do self:doSetMaxPercentage(v) end
	do return v end
end

function sling.compiler.ProgressHelper:getCurrentValue()
	do return self._currentValue end
end

function sling.compiler.ProgressHelper:doSetCurrentValue(value)
	self._currentValue = value
end

function sling.compiler.ProgressHelper:setCurrentValue(v)
	do self:doSetCurrentValue(v) end
	do return v end
end

function sling.compiler.ProgressHelper:getMaxValue()
	do return self._maxValue end
end

function sling.compiler.ProgressHelper:doSetMaxValue(value)
	self._maxValue = value
end

function sling.compiler.ProgressHelper:setMaxValue(v)
	do self:doSetMaxValue(v) end
	do return v end
end

sling.compiler.JcoOps = {}
sling.compiler.JcoOps.__index = sling.compiler.JcoOps
_vm:set_metatable(sling.compiler.JcoOps, {})

function sling.compiler.JcoOps._create()
	local v = _vm:set_metatable({}, sling.compiler.JcoOps)
	return v
end

function sling.compiler.JcoOps:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.JcoOps'
	self['_isType.sling.compiler.JcoOps'] = true
end

function sling.compiler.JcoOps:_construct0()
	sling.compiler.JcoOps._init(self)
	return self
end

sling.compiler.JcoOps.UIExpressionFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.JcoOps.UIExpressionFinder.__index = sling.compiler.JcoOps.UIExpressionFinder
_vm:set_metatable(sling.compiler.JcoOps.UIExpressionFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.JcoOps.UIExpressionFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.JcoOps.UIExpressionFinder)
	return v
end

function sling.compiler.JcoOps.UIExpressionFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.JcoOps.UIExpressionFinder'
	self['_isType.sling.compiler.JcoOps.UIExpressionFinder'] = true
	self.results = {}
end

function sling.compiler.JcoOps.UIExpressionFinder:_construct0()
	sling.compiler.JcoOps.UIExpressionFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.JcoOps.UIExpressionFinder:visit(node)
	local uinode = _vm:to_table_with_key(node, '_isType.sling.model.UIExpressionNode')
	if uinode ~= nil then
		do _g.jk.lang.Vector:append(self.results, uinode) end
		do self:setSkipChildren(true) end
	end
	do return true end
end

function sling.compiler.JcoOps.UIExpressionFinder:getResults()
	do return self.results end
end

function sling.compiler.JcoOps.UIExpressionFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.compiler.JcoOps:findUIExpressions(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local xprs = _g.sling.compiler.JcoOps.UIExpressionFinder._construct0(_g.sling.compiler.JcoOps.UIExpressionFinder._create())
		do return xprs:getResults() end
	end
end

function sling.compiler.JcoOps:expandAllUIExpressions(node)
	local array = _g.sling.compiler.JcoOps:findUIExpressions(node)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local expr = array[n + 1]
				if expr ~= nil then
					local method = _g.sling.util.FindUtil:findNearestFunctionBase(expr)
					if not (method ~= nil) then
						goto _continue43
					end
					if method:hasCustomModifier("nojkop") then
						goto _continue43
					end
					do
						local entity = _g.sling.util.FindUtil:findNearestEntity(method)
						if entity ~= nil and entity:hasCustomModifier("nojkop") then
							goto _continue43
						end
						do
							local body = method:getBody()
							if not (body ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get method body", method, nil))
							end
							do
								local ip = nil
								local pp = _vm:to_table_with_key(expr, '_isType.sling.common.NodeObject')
								while true do
									local nn = pp:getParent()
									if not (nn ~= nil) then
										pp = nil
										do break end
									end
									if (_vm:to_table_with_key(nn, '_isType.sling.model.BlockNode') ~= nil) then
										ip = nn:getInsertionPointForNode(pp)
										do break end
									end
									pp = nn
								end
								if not (ip ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("UI Expression is not inside a block!", expr, nil))
								end
								do
									local vd = _g.sling.compiler.JcoOps:handleUIExpressionNode(expr, nil, method, body, ip, nil, "context", false, false)
									if not (vd ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failure in handling UI expressions", node, nil))
									end
									do _g.sling.util.NodeUtil:replaceNode(expr, _g.sling.model.SymbolExpressionNode:forBinding(vd, nil)) end
								end
							end
						end
					end
				end
				::_continue43::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JcoOps:convertGetExpressionToFunctionCall(node, isExact, parentNode)
	if (_vm:to_table_with_key(node, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
		local nsym = node
		local symName = _g.sling.util.SymbolUtil:getSymbolName(nsym:getSymbol())
		if _g.jk.lang.String:isEmpty(symName) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No name for symbol", nsym, nil))
		end
		do
			local fname = nil
			if isExact then
				fname = symName
			else
				fname = _g.sling.common.CodeStringUtil:combineCamelCase({
					"get",
					"widget",
					symName
				})
			end
			do
				local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(parentNode, fname, false)
				do fc:setSource(node:getSource()) end
				do return fc end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
		local nfc = node
		local nxpr = nfc:getExpression()
		if not (nxpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No expression in function call", nfc, nil))
		end
		do
			local nsym = _vm:to_table_with_key(nxpr, '_isType.sling.model.SymbolExpressionNode')
			if not (nsym ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Function call expression is not a symbol!", nfc, nil))
			end
			do
				local symName = _g.sling.util.SymbolUtil:getSymbolName(nsym:getSymbol())
				if _g.jk.lang.String:isEmpty(symName) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No name for symbol", nsym, nil))
				end
				do
					local fname = nil
					if isExact then
						fname = symName
					else
						fname = _g.sling.common.CodeStringUtil:combineCamelCase({
							"get",
							"widget",
							symName
						})
					end
					do
						local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(parentNode, fname, false)
						do fc:setSource(node:getSource()) end
						do
							local array = nfc:exportParameters()
							if array ~= nil then
								local n = 0
								local m = _g.jk.lang.Vector:getSize(array)
								do
									n = 0
									while n < m do
										local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
										if param ~= nil then
											do fc:addToParameters(param) end
										end
										do n = n + 1 end
									end
								end
							end
							do return fc end
						end
					end
				end
			end
		end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported expression as get expression: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", node, nil))
	do return nil end
end

function sling.compiler.JcoOps:isNameValid(name)
	if not (name ~= nil) then
		do return false end
	end
	do
		local it = _g.jk.lang.String:iterate(name)
		while it ~= nil do
			local c = it:getNextChar()
			if c < 1 then
				do break end
			end
			if c >= 97 and c <= 122 then
			elseif c >= 65 and c <= 90 then
			elseif c >= 48 and c <= 57 then
			elseif c == 95 then
			else
				do return false end
			end
		end
		do return true end
	end
end

function sling.compiler.JcoOps:convertSetExpressionToFunctionCall(node, leftName, value, isExact, isCommon, parentNode)
	if _g.jk.lang.String:isEmpty(leftName) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No value for key", node, nil))
	end
	if not _g.sling.compiler.JcoOps:isNameValid(leftName) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Invalid name for set expression: `" .. _g.jk.lang.String:safeString(leftName) .. "'", node, nil))
	end
	do
		local fcall = nil
		if isCommon then
			fcall = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("Widget"), "setWidgetId", false)
			do fcall:addToParameters(parentNode) end
		else
			local fname = nil
			if isExact then
				fname = _g.sling.common.CodeStringUtil:combineCamelCase({
					"set",
					leftName
				})
			else
				fname = _g.sling.common.CodeStringUtil:combineCamelCase({
					"set",
					"widget",
					leftName
				})
			end
			fcall = _g.sling.model.FunctionCallExpressionNode:forMethod(parentNode, fname, false)
		end
		do fcall:setSource(node:getSource()) end
		do
			local array = node:exportKeyParams()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local pp = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
						if pp ~= nil then
							do fcall:addToParameters(pp) end
						end
						do n = n + 1 end
					end
				end
			end
			if value ~= nil then
				do fcall:addToParameters(value) end
			end
			do return fcall end
		end
	end
end

function sling.compiler.JcoOps:handlePropertyValueDeclaration(node, parentNode)
	local lefto = node:getKey()
	if not (lefto ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No key", node, nil))
	end
	do
		local righto = node:exportValue()
		if not (righto ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No value", node, nil))
		end
		do return _g.sling.compiler.JcoOps:convertSetExpressionToFunctionCall(node, lefto, righto, node:hasCustomModifier("exact"), node:hasCustomModifier("common"), parentNode) end
	end
end

function sling.compiler.JcoOps:handleUIExpressionNode(node, entity, method, block, insertionPoint, parentNode, contextVariableName, declareClassVariables, includeAddStatement)
	local dt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(node, nil)
	if dt ~= nil then
		dt = _g.sling.util.DataTypeUtil:dupAsDataType(dt)
	end
	do
		local xpr = node:exportExpression()
		local createXpr = nil
		if dt ~= nil then
			local oo = _g.sling.model.CreateObjectExpressionNode:forType(dt)
			do oo:setSource(node:getSource()) end
			do oo:addToParameters(_g.sling.model.SymbolExpressionNode:forName(contextVariableName)) end
			createXpr = oo
		elseif xpr ~= nil then
			createXpr = xpr
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("UI expression has neither data type nor expression", node, nil))
		end
		do
			local vname = node:getName()
			local isOriginal = true
			if _g.jk.lang.String:isEmpty(vname) then
				vname = _g.sling.util.FunctionUtil:findUniqueVariableNameInFunction(method, "widget")
				isOriginal = false
			end
			if _g.jk.lang.String:isEmpty(vname) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find a unique variable name for `widget'", method, nil))
			end
			do
				local vd = _g.sling.model.VariableDeclarationNode:forName(vname)
				do vd:setSource(node:getSource()) end
				if declareClassVariables and isOriginal then
					do vd:addModifier(_g.sling.model.Modifier.PRIVATE) end
					if not (entity ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to declare a class variable: Not inside an entity", node, nil))
					end
					if dt ~= nil then
						do vd:setType(_g.sling.util.DataTypeUtil:dupAsDataType(dt), false) end
						do entity:addNode(vd) end
						if insertionPoint ~= nil then
							do insertionPoint:insertBefore(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forBinding(vd, nil), createXpr)) end
						else
							do block:addNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forBinding(vd, nil), createXpr)) end
						end
					else
						do vd:setType(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), false) end
						do vd:setInitializer(createXpr, false) end
						do entity:addNode(vd) end
					end
				else
					do vd:setType(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), false) end
					do vd:setInitializer(createXpr, false) end
					if insertionPoint ~= nil then
						do insertionPoint:insertBefore(vd) end
					else
						do block:addNode(vd) end
					end
				end
				do
					local array = node:exportChildren()
					if array ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(array)
						do
							n = 0
							while n < m do
								local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
								if child ~= nil then
									if (_vm:to_table_with_key(child, '_isType.sling.model.CommentNode') ~= nil) then
										if insertionPoint ~= nil then
											do insertionPoint:insertBefore(child) end
										else
											do block:addNode(child) end
										end
									elseif (_vm:to_table_with_key(child, '_isType.sling.model.UIExpressionNode') ~= nil) then
										do _g.sling.compiler.JcoOps:handleUIExpressionNode(child, entity, method, block, insertionPoint, _g.sling.model.SymbolExpressionNode:forBinding(vd, nil), contextVariableName, declareClassVariables, true) end
									elseif (_vm:to_table_with_key(child, '_isType.sling.model.PropertyValueDeclarationNode') ~= nil) then
										local v = _g.sling.compiler.JcoOps:handlePropertyValueDeclaration(child, _g.sling.model.SymbolExpressionNode:forBinding(vd, nil))
										if insertionPoint ~= nil then
											do insertionPoint:insertBefore(v) end
										else
											do block:addNode(v) end
										end
									else
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node inside UI expression: `" .. _g.jk.lang.String:safeString(child:getNodeTypeName()) .. "'", child, nil))
									end
								end
								do n = n + 1 end
							end
						end
					end
					if includeAddStatement then
						local addCall = _g.sling.model.FunctionCallExpressionNode:forMethod(parentNode, "addWidget", false)
						do addCall:setSource(node:getSource()) end
						do addCall:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(vd, nil)) end
						do
							local array2 = node:exportLayoutParams()
							if array2 ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(array2)
								do
									n2 = 0
									while n2 < m2 do
										local layoutParam = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.common.ExpressionNode')
										if layoutParam ~= nil then
											do addCall:addToParameters(layoutParam) end
										end
										do n2 = n2 + 1 end
									end
								end
							end
							if insertionPoint ~= nil then
								do insertionPoint:insertBefore(addCall) end
							else
								do block:addNode(addCall) end
							end
						end
					end
					do return vd end
				end
			end
		end
	end
end

function sling.compiler.JcoOps:createScreenForMainWidget(root)
	local array = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.ClassDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("widget") == false then
						goto _continue44
					end
					if decl:hasCustomModifier("main") == false then
						goto _continue44
					end
					if decl:hasCustomModifier("nojkop") then
						goto _continue44
					end
					do
						local screen = _g.sling.model.ClassDeclarationNode:forName(_g.jk.lang.String:safeString(decl:getNodeName()) .. "Screen")
						do screen:addToDependencies("module:jk.lang") end
						do screen:addToDependencies("module:jk.ui") end
						do screen:addToDependencies("module:jk.widget") end
						do screen:addBaseTypeExtends(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
							"jk",
							"widget",
							"ScreenForWidget"
						})) end
						do screen:addModifier(_g.sling.model.Modifier.PUBLIC) end
						do screen:addCustomModifier("screen") end
						do screen:addCustomModifier("main") end
						do
							local init = _g.sling.model.FunctionDeclarationNode:forName("initialize", false)
							do init:addModifier(_g.sling.model.Modifier.PUBLIC) end
							do init:addModifier(_g.sling.model.Modifier.OVERRIDE) end
							do _g.sling.util.FunctionUtil:addBaseCall(init, false) end
							do
								local ci = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forNode(decl, nil))
								do ci:addToParameters(_g.sling.model.SymbolExpressionNode:forName("context")) end
								do
									local fc = _g.sling.model.FunctionCallExpressionNode:forName("setWidget")
									do fc:addToParameters(ci) end
									do _g.sling.util.FunctionUtil:addStatement(init, fc) end
									do screen:addNode(init) end
									do
										local pp = _vm:to_table_with_key(decl:getParent(), '_isType.sling.common.ContainerNode')
										if not (pp ~= nil) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No parent container!", decl, nil))
										end
										do pp:addNode(screen) end
										do decl:removeCustomModifier("main") end
									end
								end
							end
						end
					end
				end
				::_continue44::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JcoOps:expandWidgetClasses(root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local entity = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if entity ~= nil then
					if not entity:hasCustomModifier("widget") then
						goto _continue45
					end
					if entity:hasCustomModifier("nojkop") then
						goto _continue45
					end
					do
						local decls = {}
						local array2 = entity:getNodes()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.UIExpressionNode')
									if node ~= nil then
										do _g.jk.lang.Vector:append(decls, node) end
									end
									do n2 = n2 + 1 end
								end
							end
						end
						do
							local declsz = _g.jk.lang.Vector:getSize(decls)
							if declsz > 1 then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple UI expressions found inside one entity", entity, nil))
							end
							do
								local decl = _g.jk.lang.Vector:get(decls, 0)
								do entity:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
									"jk",
									"lang"
								})) end
								do entity:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
									"jk",
									"ui"
								})) end
								do entity:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
									"jk",
									"gfx"
								})) end
								do
									local ppns = _vm:to_table_with_key(entity:getParent(), '_isType.sling.model.NamespaceNode')
									if ppns == nil or not (_g.sling.util.NodeUtil:getQualifiedNameString(ppns, 46) == "jk.widget") then
										do entity:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
											"jk",
											"widget"
										})) end
									end
									if decl ~= nil then
										local dt = _vm:to_table_with_key(_g.sling.util.ExpressionUtil:tryGetExpressionDataType(decl, nil), '_isType.sling.model.ReferenceDataTypeNode')
										if dt ~= nil then
											dt = _g.sling.util.DataTypeUtil:dupAsReferenceDataType(dt)
										end
										if dt ~= nil then
											do entity:addBaseTypeExtends(dt) end
										end
									end
									do
										local method = nil
										local array3 = entity:getNodes()
										if array3 ~= nil then
											local n3 = 0
											local m3 = _g.jk.lang.Vector:getSize(array3)
											do
												n3 = 0
												while n3 < m3 do
													local ctor = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.ConstructorDeclarationNode')
													if ctor ~= nil then
														local params = ctor:getParameters()
														if params == nil or _g.jk.lang.Vector:getSize(params) ~= 1 then
															goto _continue46
														end
														do
															local pp = _vm:to_table_with_key(_g.jk.lang.Vector:get(params, 0), '_isType.sling.model.VariableDeclarationNode')
															if not (pp ~= nil) then
																goto _continue46
															end
															do
																local ppdt = _vm:to_table_with_key(pp:getType(), '_isType.sling.model.ReferenceDataTypeNode')
																if not (ppdt ~= nil) then
																	goto _continue46
																end
																do
																	local ppdtname = _g.sling.util.DataTypeUtil:getSymbolName(ppdt)
																	if not (ppdtname == "GuiApplicationContext") then
																		goto _continue46
																	end
																	method = ctor
																end
															end
														end
													end
													::_continue46::
													do n3 = n3 + 1 end
												end
											end
										end
										if not (method ~= nil) then
											local v = _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create())
											do v:addModifier(_g.sling.model.Modifier.PUBLIC) end
											do v:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
												"jk",
												"ui",
												"GuiApplicationContext"
											}), "context", nil)) end
											do _g.sling.util.FunctionUtil:addBaseCall(v, false) end
											do entity:prependNode(v) end
											method = v
										end
										do
											local forContext = nil
											local array4 = entity:getNodes()
											if array4 ~= nil then
												local n4 = 0
												local m4 = _g.jk.lang.Vector:getSize(array4)
												do
													n4 = 0
													while n4 < m4 do
														local ff = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.FunctionDeclarationNode')
														if ff ~= nil then
															if _g.jk.lang.String:equals(ff:getName(), "forContext") then
																local pps = ff:getParameters()
																if not (pps ~= nil) or _g.jk.lang.Vector:getSize(pps) ~= 1 then
																	goto _continue47
																end
																do
																	local pp = _vm:to_table_with_key(_g.jk.lang.Vector:get(pps, 0), '_isType.sling.model.VariableDeclarationNode')
																	if not (pp ~= nil) then
																		goto _continue47
																	end
																	do
																		local ppdt = _vm:to_table_with_key(pp:getType(), '_isType.sling.model.ReferenceDataTypeNode')
																		if not (ppdt ~= nil) then
																			goto _continue47
																		end
																		if not (_g.sling.util.DataTypeUtil:getSymbolName(ppdt) == "GuiApplicationContext") then
																			goto _continue47
																		end
																		forContext = ff
																		do break end
																	end
																end
															end
														end
														::_continue47::
														do n4 = n4 + 1 end
													end
												end
											end
											if not (forContext ~= nil) then
												forContext = _g.sling.model.FunctionDeclarationNode:forName("forContext", false)
												do forContext:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
													"jk",
													"ui",
													"GuiApplicationContext"
												}), "context", nil)) end
												do
													local bd = forContext:getCreateBody()
													if bd ~= nil then
														local cx = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()))
														do cx:addToParameters(_g.sling.model.SymbolExpressionNode:forName("context")) end
														do bd:addNode(_g.sling.model.ReturnStatementNode:forExpression(cx)) end
													end
												end
											end
											if decl ~= nil then
												local shouldDoEarlyCreate = false
												local hasEarly = entity:hasCustomModifier("earlyCreate")
												local hasLate = entity:hasCustomModifier("lateCreate")
												if hasEarly and hasLate then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Cannot specify both #earlyCreate and #lateCreate at the same time", entity, nil))
												elseif hasEarly then
													shouldDoEarlyCreate = true
												elseif hasLate then
													shouldDoEarlyCreate = false
												else
												end
												do
													local uiExpressionDestination = nil
													if not shouldDoEarlyCreate then
														local createMethod = _g.sling.model.FunctionDeclarationNode:forName("createWidget", false)
														do createMethod:addModifier(_g.sling.model.Modifier.OVERRIDE) end
														do createMethod:addModifier(_g.sling.model.Modifier.PUBLIC) end
														do _g.sling.util.FunctionUtil:addBaseCall(createMethod, false) end
														do entity:addNode(createMethod) end
														uiExpressionDestination = createMethod
													else
														uiExpressionDestination = method
													end
													do
														local body = uiExpressionDestination:getCreateBody()
														local thisWidgetVariable = _g.sling.model.VariableDeclarationNode:forName("thisWidget")
														do thisWidgetVariable:setType(_g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()), false) end
														do thisWidgetVariable:setInitializer(_g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create()), false) end
														do thisWidgetVariable:addModifier(_g.sling.model.Modifier.FINAL) end
														do thisWidgetVariable:addCustomModifier("used") end
														do body:addNode(thisWidgetVariable) end
														do
															local array5 = decl:exportChildren()
															if array5 ~= nil then
																local n5 = 0
																local m5 = _g.jk.lang.Vector:getSize(array5)
																do
																	n5 = 0
																	while n5 < m5 do
																		local node = _vm:to_table_with_key(array5[n5 + 1], '_isType.sling.common.NodeObject')
																		if node ~= nil then
																			if (_vm:to_table_with_key(node, '_isType.sling.model.CommentNode') ~= nil) then
																				do body:addNode(node) end
																			elseif (_vm:to_table_with_key(node, '_isType.sling.model.UIExpressionNode') ~= nil) then
																				do _g.sling.compiler.JcoOps:handleUIExpressionNode(node, entity, uiExpressionDestination, body, nil, nil, "context", true, true) end
																			elseif (_vm:to_table_with_key(node, '_isType.sling.model.PropertyValueDeclarationNode') ~= nil) then
																				local v = _g.sling.compiler.JcoOps:handlePropertyValueDeclaration(node, nil)
																				do body:addNode(v) end
																			else
																				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node inside UI expression: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", node, nil))
																			end
																		end
																		do n5 = n5 + 1 end
																	end
																end
															end
															do _g.sling.util.NodeUtil:removeNode(decl) end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
				::_continue45::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JcoOps:validateWidgets(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.ClassDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local decl = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ClassDeclarationNode')
				if decl ~= nil then
					if decl:hasCustomModifier("nojkop") then
						goto _continue48
					end
					do
						local name = decl:getNodeName()
						if name ~= nil then
							local hasWidgetName = _g.jk.lang.String:endsWith(name, "Widget") and _g.jk.lang.String:endsWith(name, "ForWidget") == false
							if hasWidgetName and name == "Widget" and _g.sling.util.NodeUtil:getQualifiedNameString(decl, 46) == "jk.widget.Widget" then
								hasWidgetName = false
							end
							do
								local hasWidgetModifier = decl:hasCustomModifier("widget")
								if hasWidgetName == true and hasWidgetModifier == false then
									do _g.sling.common.RefLog:warning(ctx, "Class name ends with `Widget', but it does not have the #widget modifier.", decl) end
								end
								do
									local hasCustomModifier = decl:hasCustomModifier("ignoreNamingConvention")
									if hasWidgetModifier == true and hasWidgetName == false and hasCustomModifier == false then
										do _g.sling.common.RefLog:warning(ctx, "Class has the #widget modifier, but class name does not end with `Widget'.", decl) end
									end
								end
							end
						end
					end
				end
				::_continue48::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.JcoOps:convertUIExpressionsToWidgets(ctx, node)
	do _g.sling.compiler.JcoOps:expandWidgetClasses(node) end
	do _g.sling.compiler.JcoOps:expandAllUIExpressions(node) end
	do _g.sling.compiler.JcoOps:createScreenForMainWidget(node) end
end

function sling.compiler.JcoOps:convertTreeDeclarationsToJkDom(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(node, "class:sling.model.EntityDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local entity = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.EntityDeclarationNode')
				if entity ~= nil then
					local mustImport = false
					local array2 = _g.sling.common.NodeFinder:findCompatibleNodes(entity, "class:sling.model.ext.NSlingTreeDeclarationExpression", false, true, false)
					if array2 ~= nil then
						local n2 = 0
						local m2 = _g.jk.lang.Vector:getSize(array2)
						do
							n2 = 0
							while n2 < m2 do
								local decl = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.ext.NSlingTreeDeclarationExpression')
								if decl ~= nil then
									local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
									do fd:setReturnType(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
										"jk",
										"dom",
										"Node"
									}), false) end
									do
										local fdx = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)
										local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(fdx)
										local body = fd:getCreateBody()
										do body:addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()))) end
										do _g.sling.util.NodeUtil:replaceNode(decl, fc) end
										mustImport = true
									end
								end
								do n2 = n2 + 1 end
							end
						end
					end
					if mustImport then
						do _g.sling.util.EntityUtil:addToImportNamespacesUnique(entity, _g.sling.model.SymbolNode:forArrayOfNames({
							"jk",
							"dom"
						})) end
					end
				end
				do n = n + 1 end
			end
		end
	end
end

sling.compiler.WebApiExpanderForSympathy = {}
sling.compiler.WebApiExpanderForSympathy.__index = sling.compiler.WebApiExpanderForSympathy
_vm:set_metatable(sling.compiler.WebApiExpanderForSympathy, {})

function sling.compiler.WebApiExpanderForSympathy._create()
	local v = _vm:set_metatable({}, sling.compiler.WebApiExpanderForSympathy)
	return v
end

function sling.compiler.WebApiExpanderForSympathy:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.WebApiExpanderForSympathy'
	self['_isType.sling.compiler.WebApiExpanderForSympathy'] = true
	self.ctx = nil
end

function sling.compiler.WebApiExpanderForSympathy:_construct0()
	sling.compiler.WebApiExpanderForSympathy._init(self)
	return self
end

sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder.__index = sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder
_vm:set_metatable(sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder)
	return v
end

function sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder'
	self['_isType.sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder'] = true
	self.results = {}
end

function sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder:_construct0()
	sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) and node:hasCustomModifier("webapi") and node:hasCustomModifier("nojkop") == false then
		do _g.jk.lang.Vector:append(self.results, node) end
	end
	do return true end
end

function sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder:getResults()
	do return self.results end
end

function sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder:setResults(v)
	self.results = v
	do return self end
end

sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder.__index = sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder
_vm:set_metatable(sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder)
	return v
end

function sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder'
	self['_isType.sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder'] = true
	self.results = {}
end

function sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder:_construct0()
	sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingWebApiStatement') ~= nil) then
		do _g.jk.lang.Vector:append(self.results, node) end
	end
	do return true end
end

function sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder:getResults()
	do return self.results end
end

function sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.compiler.WebApiExpanderForSympathy:createInvalidRequestAssert(xpr)
	local ass = _g.sling.model.AssertStatementNode:forChild(xpr)
	local errb = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "sendJSONObject", false)
	do errb:addToParameters(_g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("HTTPServerJSONResponse"), "forInvalidRequest", false)) end
	do ass:setErrorBlock(_g.sling.model.BlockNode:forStatement(errb), false) end
	do return ass end
end

function sling.compiler.WebApiExpanderForSympathy:createNotAuthenticatedAssert(xpr)
	local ass = _g.sling.model.AssertStatementNode:forChild(xpr)
	local errb = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "sendJSONObject", false)
	do errb:addToParameters(_g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("HTTPServerJSONResponse"), "forNotAuthenticated", false)) end
	do ass:setErrorBlock(_g.sling.model.BlockNode:forStatement(errb), false) end
	do return ass end
end

function sling.compiler.WebApiExpanderForSympathy:createValidateStringStatement(varname)
	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("String"), "isNotEmpty", false)
	do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName(varname)) end
	do return self:createInvalidRequestAssert(fc) end
end

function sling.compiler.WebApiExpanderForSympathy:processWebApiStatements(body)
	local sf = _g.sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder._construct0(_g.sling.compiler.WebApiExpanderForSympathy.WebApiStatementFinder._create())
	if not body:accept(sf) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("failure in statement finder", body, nil))
	end
	do
		local array = sf:getResults()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local statement = array[n + 1]
					if statement ~= nil then
						if (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiSampleRequest') ~= nil) or (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiSampleResponse') ~= nil) then
							if not statement:remove() then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to remove node", statement, nil))
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInPathStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							if type ~= nil then
								do _g.sling.common.RefLog:warning(self.ctx, "Data type is currently ignored", type) end
							end
							do
								local stmts = {}
								do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), name, _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "popResource", false))) end
								do _g.jk.lang.Vector:append(stmts, self:createValidateStringStatement(name)) end
								do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInQueryParameterStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							if type ~= nil then
								do _g.sling.common.RefLog:warning(self.ctx, "Data type is currently ignored", type) end
							end
							do
								local stmts = {}
								local myfc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "getQueryParameter", false)
								do myfc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(name)) end
								do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), name, myfc)) end
								if statement:getOptional() == false then
									do _g.jk.lang.Vector:append(stmts, self:createValidateStringStatement(name)) end
								end
								do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInPostStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							local stmts = {}
							local varname = _g.jk.lang.String:safeString(name) .. "BodyData"
							do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), varname, _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "getBodyJSONMap", false))) end
							do _g.jk.lang.Vector:append(stmts, self:createInvalidRequestAssert(_g.sling.model.SymbolExpressionNode:forName(varname))) end
							do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), name, _g.sling.model.CreateObjectExpressionNode:forType(type))) end
							do
								local fromxpr = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName(name), "fromJsonObject", false)
								do fromxpr:addToParameters(_g.sling.model.SymbolExpressionNode:forName(varname)) end
								do _g.jk.lang.Vector:append(stmts, self:createInvalidRequestAssert(fromxpr)) end
								do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInSessionStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							local stmts = {}
							local reqfc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "getSession", false)
							local reqfcc = _g.sling.model.DynamicCastExpressionNode:instance(type, reqfc)
							do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), name, reqfcc)) end
							do _g.jk.lang.Vector:append(stmts, self:createNotAuthenticatedAssert(_g.sling.model.SymbolExpressionNode:forName(name))) end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiOutErrorStatement') ~= nil) then
							local code = statement:exportCode()
							local data = statement:exportData()
							local stmts = {}
							local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "sendJSONObject", false)
							local fec = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("HTTPServerJSONResponse"), "forError", false)
							do fec:addToParameters(code) end
							do fc:addToParameters(fec) end
							do _g.jk.lang.Vector:append(stmts, fc) end
							if data ~= nil then
								do _g.sling.common.RefLog:warning(self.ctx, "Data parameter is currently ignored", data) end
							end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiOutOkStatement') ~= nil) then
							local data = statement:exportData()
							local stmts = {}
							local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "sendJSONObject", false)
							local fec = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("HTTPServerJSONResponse"), "forOk", false)
							do fec:addToParameters(data) end
							do fc:addToParameters(fec) end
							do _g.jk.lang.Vector:append(stmts, fc) end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiOutObjectStatement') ~= nil) then
							local data = statement:exportData()
							local stmts = {}
							local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("req"), "sendJSONObject", false)
							do fc:addToParameters(data) end
							do _g.jk.lang.Vector:append(stmts, fc) end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						else
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported webapi statement: `" .. _g.jk.lang.String:safeString(statement:getNodeTypeName()) .. "'", statement, nil))
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.compiler.WebApiExpanderForSympathy:execute(root)
	if not (root ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null root", nil, nil))
	end
	do
		local cf = _g.sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder._construct0(_g.sling.compiler.WebApiExpanderForSympathy.WebApiClassFinder._create())
		if not root:accept(cf) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failure in class finder", root, nil))
		end
		do
			local mainClass = nil
			local array = cf:getResults()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local wac = array[n + 1]
						if wac ~= nil then
							if _g.sling.util.EntityUtil:methodExists(wac, "initialize") then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("The initialize() method in a #webapi class cannot be manually declared.", wac, nil))
							end
							do
								local im = _g.sling.model.FunctionDeclarationNode:forName("initialize", true)
								do im:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
								do im:addModifier(_g.sling.model.Modifier.OVERRIDE) end
								do im:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
									"jk",
									"http",
									"server",
									"HTTPServerBase"
								}), "server", nil)) end
								do _g.sling.util.FunctionUtil:addBaseCall(im, false) end
								do
									local toRemove = {}
									local initBlock = nil
									local array2 = wac:getNodes()
									if array2 ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(array2)
										do
											n2 = 0
											while n2 < m2 do
												local node = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.InitializerFunctionDeclarationNode')
												if node ~= nil then
													local nb = node:getBody()
													if not (nb ~= nil) then
														goto _continue49
													end
													if not (initBlock ~= nil) then
														initBlock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
													end
													do
														local array3 = nb:exportNodes()
														if array3 ~= nil then
															local n3 = 0
															local m3 = _g.jk.lang.Vector:getSize(array3)
															do
																n3 = 0
																while n3 < m3 do
																	local statement = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.NodeObject')
																	if statement ~= nil then
																		do initBlock:addNode(statement) end
																	end
																	do n3 = n3 + 1 end
																end
															end
														end
														do _g.jk.lang.Vector:append(toRemove, node) end
													end
												end
												::_continue49::
												do n2 = n2 + 1 end
											end
										end
									end
									if initBlock ~= nil then
										do _g.sling.util.FunctionUtil:addStatement(im, initBlock) end
									end
									do
										local array4 = wac:getNodes()
										if array4 ~= nil then
											local n4 = 0
											local m4 = _g.jk.lang.Vector:getSize(array4)
											do
												n4 = 0
												while n4 < m4 do
													local wh = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration')
													if wh ~= nil then
														local fc = _g.sling.model.FunctionCallExpressionNode:forName(_g.jk.lang.String:toLowerCase(wh:getMethod()))
														do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(wh:getPath())) end
														do
															local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
															do fd:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
															do fd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
																"jk",
																"http",
																"server",
																"HTTPServerRequest"
															}), "req", nil)) end
															do fd:setBody(wh:exportBody(), false) end
															do fc:addToParameters(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)) end
															do _g.sling.util.FunctionUtil:addStatement(im, fc) end
															do self:processWebApiStatements(fd:getBody()) end
															do _g.jk.lang.Vector:append(toRemove, wh) end
														end
													end
													do n4 = n4 + 1 end
												end
											end
										end
										do
											local array5 = wac:getNodes()
											if array5 ~= nil then
												local n5 = 0
												local m5 = _g.jk.lang.Vector:getSize(array5)
												do
													n5 = 0
													while n5 < m5 do
														local node = _vm:to_table_with_key(array5[n5 + 1], '_isType.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration')
														if node ~= nil then
															local fc = _g.sling.model.FunctionCallExpressionNode:forName("child")
															do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(node:getPath())) end
															do fc:addToParameters(node:exportExpression()) end
															do _g.sling.util.FunctionUtil:addStatement(im, fc) end
															do _g.jk.lang.Vector:append(toRemove, node) end
														end
														do n5 = n5 + 1 end
													end
												end
											end
											if toRemove ~= nil then
												local n6 = 0
												local m6 = _g.jk.lang.Vector:getSize(toRemove)
												do
													n6 = 0
													while n6 < m6 do
														local node = toRemove[n6 + 1]
														if node ~= nil then
															do node:remove() end
														end
														do n6 = n6 + 1 end
													end
												end
											end
											do wac:addNode(im) end
											do wac:removeCustomModifier("webapi") end
											do
												local isInSympathy = _g.sling.util.NodeUtil:getQualifiedNameString(wac:getParent(), 46) == "jk.http.server"
												if not isInSympathy then
													do wac:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
														"jk",
														"http",
														"server"
													})) end
												end
												do
													local bts = wac:getBaseTypes()
													if bts == nil or _g.jk.lang.Vector:getSize(bts) < 1 then
														do wac:addBaseTypeExtends(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
															"jk",
															"http",
															"server",
															"HTTPServerRequestHandlerMap"
														})) end
													end
													if wac:hasCustomModifier("main") then
														if not (mainClass ~= nil) then
															mainClass = wac
														end
														do wac:removeCustomModifier("main") end
													end
												end
											end
										end
									end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
			if mainClass ~= nil then
				do mainClass:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
					"jk",
					"server",
					"web"
				})) end
				do
					local mf = _g.sling.model.MainFunctionDeclarationNode._construct0(_g.sling.model.MainFunctionDeclarationNode._create())
					do mf:setArgumentArrayName("args") end
					do
						local webserver = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("WebServer"))
						local newthis = _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()))
						local rx = _g.sling.model.MemberAccessExpressionNode:forNodes(webserver, _g.sling.model.SymbolExpressionNode:forName("executeForHandler"))
						local fc = _g.sling.model.FunctionCallExpressionNode:forExpression(rx)
						do fc:addToParameters(newthis) end
						do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("args")) end
						do _g.sling.util.FunctionUtil:addStatement(mf, _g.sling.model.ReturnStatementNode:forExpression(fc)) end
						do mainClass:addNode(mf) end
					end
				end
			end
		end
	end
end

function sling.compiler.WebApiExpanderForSympathy:getCtx()
	do return self.ctx end
end

function sling.compiler.WebApiExpanderForSympathy:setCtx(v)
	self.ctx = v
	do return self end
end

sling.compiler.PropertyDeclarationExpander = {}
sling.compiler.PropertyDeclarationExpander.__index = sling.compiler.PropertyDeclarationExpander
_vm:set_metatable(sling.compiler.PropertyDeclarationExpander, {})

function sling.compiler.PropertyDeclarationExpander._create()
	local v = _vm:set_metatable({}, sling.compiler.PropertyDeclarationExpander)
	return v
end

function sling.compiler.PropertyDeclarationExpander:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.PropertyDeclarationExpander'
	self['_isType.sling.compiler.PropertyDeclarationExpander'] = true
end

function sling.compiler.PropertyDeclarationExpander:_construct0()
	sling.compiler.PropertyDeclarationExpander._init(self)
	return self
end

function sling.compiler.PropertyDeclarationExpander:modifyName(prefix, name)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString(prefix) end
	do
		local c0 = _g.jk.lang.String:getChar(name, 0)
		if c0 >= 97 and c0 <= 122 then
			do sb:appendCharacter(c0 - 97 + 65) end
			do sb:appendString(_g.jk.lang.String:getEndOfString(name, 1)) end
		else
			do sb:appendString(name) end
		end
		do return sb:toString() end
	end
end

function sling.compiler.PropertyDeclarationExpander:createMethodName(prefix, name, pp, decl)
	local fname = self:modifyName(prefix, name)
	if _g.sling.util.EntityUtil:methodExists(pp, fname) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Property method `" .. _g.jk.lang.String:safeString(fname) .. "' already exists in parent entity. Unable to generate method.", decl, nil):addRelatedMessage("This is the parent entity", pp))
	end
	do return fname end
end

function sling.compiler.PropertyDeclarationExpander:execute(ctx, root, resolver)
	local array = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.ext.NSlingPropertyDeclaration", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local vd = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ext.NSlingPropertyDeclaration')
				if vd ~= nil then
					local name = vd:getName()
					if _g.jk.lang.String:isEmpty(name) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty property name", vd, nil))
					end
					do
						local dt = vd:getType()
						if dt == nil or (_vm:to_table_with_key(dt, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
							local init = vd:getInitializer()
							if not (init ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to determine declaration data type (missing initializer)", vd, nil))
							end
							dt = _g.sling.util.ExpressionUtil:getExpressionDataType(init, nil)
						end
						do
							local parentNode = vd:getParent()
							if not (parentNode ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Declaration has no parent", vd, nil))
							end
							do
								local pp = _vm:to_table_with_key(parentNode, '_isType.sling.model.EntityDeclarationNode')
								if not (pp ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Property declaration is not enclosed inside an entity", vd, nil):addRelatedMessage("This is the parent of the declaration", parentNode))
								end
								do
									local getter = vd:exportGetter()
									if getter ~= nil then
										do getter:setName(self:createMethodName("get", name, pp, vd)) end
										do getter:addCustomModifier("propertyMethod") end
										do pp:addNode(getter) end
									end
									do
										local willset = vd:exportWillSetHandler()
										if willset ~= nil then
											do willset:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
											do willset:setName(self:createMethodName("onWillSet", name, pp, vd)) end
											do willset:addCustomModifier("propertyMethod") end
											do pp:addNode(willset) end
										end
										do
											local didset = vd:exportDidSetHandler()
											if didset ~= nil then
												do didset:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
												do didset:setName(self:createMethodName("onDidSet", name, pp, vd)) end
												do didset:addCustomModifier("propertyMethod") end
												do pp:addNode(didset) end
											end
											do
												local setter = vd:exportSetter()
												if setter ~= nil then
													do setter:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
													do setter:setName(self:createMethodName("doSet", name, pp, vd)) end
													do setter:addCustomModifier("propertyMethod") end
													do pp:addNode(setter) end
													do
														local setname = self:createMethodName("set", name, pp, vd)
														local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
														do fd:setReturnType(_g.sling.util.DataTypeUtil:dupAsDataType(vd:getType()), false) end
														do fd:setName(setname) end
														do fd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(vd:getType()), "v", nil)) end
														do
															local body = fd:getCreateBody()
															if didset ~= nil then
																do body:addNode(_g.sling.model.VariableDeclarationNode:instance(_g.sling.util.DataTypeUtil:dupAsDataType(vd:getType()), "ov", _g.sling.model.FunctionCallExpressionNode:forName(getter:getName()))) end
															end
															if willset ~= nil then
																local wsfc = _g.sling.model.FunctionCallExpressionNode:forName(willset:getName())
																do wsfc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("v")) end
																do body:addNode(wsfc) end
															end
															do
																local setterfc = _g.sling.model.FunctionCallExpressionNode:forName(setter:getName())
																do setterfc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("v")) end
																do body:addNode(setterfc) end
																if didset ~= nil then
																	local dsfc = _g.sling.model.FunctionCallExpressionNode:forName(didset:getName())
																	do dsfc:addToParameters(_g.sling.model.SymbolExpressionNode:forName("ov")) end
																	do body:addNode(dsfc) end
																end
																do body:addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("v"))) end
																do pp:addNode(fd) end
															end
														end
													end
												end
												do _g.sling.util.NodeUtil:removeNode(vd) end
											end
										end
									end
								end
							end
						end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local array2 = _g.sling.common.NodeFinder:findNodesOfType(root, "class:sling.model.SymbolNode", false, true, false)
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local symbol = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.SymbolNode')
					if symbol ~= nil then
						local propdec = _vm:to_table_with_key(symbol:getBinding(), '_isType.sling.model.ext.NSlingPropertyDeclaration')
						if not (propdec ~= nil) then
							goto _continue50
						end
						do
							local xpr = _vm:to_table_with_key(symbol:getParent(), '_isType.sling.model.SymbolExpressionNode')
							if not (xpr ~= nil) then
								goto _continue50
							end
							do
								local assx = self:getAssignmentExpressionForSymbolIfLeftValue(xpr)
								if assx ~= nil then
									local left = assx:exportLeft()
									local right = assx:exportRight()
									local fc = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
									do fc:setExpression(left, false) end
									do fc:addToParameters(right) end
									do _g.sling.util.NodeUtil:replaceNode(assx, fc) end
									do _g.sling.util.SymbolUtil:setName(symbol, self:modifyName("set", _g.sling.util.SymbolUtil:getSymbolName(symbol))) end
									do symbol:setBinding(nil, nil) end
									do xpr:setResolvedDataType(nil, false) end
									if resolver ~= nil then
										do resolver:resolveExpression(xpr) end
									end
								else
									local rx = xpr
									local max = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
									if max ~= nil then
										if max:getChildExpression() == xpr then
											rx = max
										elseif max:getParentExpression() == xpr then
											local maxp = _vm:to_table_with_key(max:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
											if not (maxp ~= nil) then
												rx = xpr
											else
												if maxp:getChildExpression() ~= max then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Corrupted member access expression tree. Cannot turn into function call.", max, nil))
												end
												do
													local top = _g.sling.model.MemberAccessExpressionNode:findFromChild(max)
													if not (top ~= nil) then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Corrupted member access expression tree: Unable to find child from max", max, nil))
													end
													do maxp:exportChildExpression() end
													do _g.sling.util.NodeUtil:replaceAndExport(top, max) end
													do maxp:setChildExpression(max:exportParentExpression(), false) end
													do
														local fc = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
														do fc:setExpression(top, false) end
														do max:setParentExpression(fc, false) end
														rx = nil
													end
												end
											end
										end
									end
									if rx ~= nil then
										local fc = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
										do _g.sling.util.NodeUtil:replaceAndExport(rx, fc) end
										do fc:setExpression(rx, false) end
									end
									do _g.sling.util.SymbolUtil:setName(symbol, self:modifyName("get", _g.sling.util.SymbolUtil:getSymbolName(symbol))) end
									do symbol:setBinding(nil, nil) end
									do xpr:setResolvedDataType(nil, false) end
									if resolver ~= nil then
										do resolver:resolveExpression(xpr) end
									end
								end
							end
						end
					end
					::_continue50::
					do n2 = n2 + 1 end
				end
			end
		end
		if resolver ~= nil then
			do resolver:execute(root) end
		end
	end
end

function sling.compiler.PropertyDeclarationExpander:getAssignmentExpressionForSymbolIfLeftValue(xpr)
	if not (xpr ~= nil) then
		do return nil end
	end
	do
		local ass1 = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.AssignmentExpressionNode')
		if ass1 ~= nil and ass1:getLeft() == xpr then
			do return ass1 end
		end
		do
			local maxbot = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
			if maxbot ~= nil and maxbot:getChildExpression() == xpr then
				local max = _g.sling.model.MemberAccessExpressionNode:findFromChild(xpr)
				if max ~= nil then
					local ass2 = _vm:to_table_with_key(max:getParent(), '_isType.sling.model.AssignmentExpressionNode')
					if ass2 ~= nil and ass2:getLeft() == max then
						do return ass2 end
					end
				end
			end
			do return nil end
		end
	end
end

sling.compiler.SlingTypeResolver = _g.sling.util.TypeResolver._create()
sling.compiler.SlingTypeResolver.__index = sling.compiler.SlingTypeResolver
_vm:set_metatable(sling.compiler.SlingTypeResolver, {
	__index = _g.sling.util.TypeResolver
})

function sling.compiler.SlingTypeResolver._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingTypeResolver)
	return v
end

function sling.compiler.SlingTypeResolver:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingTypeResolver'
	self['_isType.sling.compiler.SlingTypeResolver'] = true
	self.ignoreFailedPaths = false
end

function sling.compiler.SlingTypeResolver:_construct0()
	sling.compiler.SlingTypeResolver._init(self)
	do _g.sling.util.TypeResolver._construct0(self) end
	return self
end

function sling.compiler.SlingTypeResolver:createTypeMapforEntity(entity, typeParameters)
	if not (typeParameters ~= nil) then
		do return nil end
	end
	if not (entity ~= nil) then
		do return nil end
	end
	do
		local gts = self:getAllGenericTypes(entity)
		if not (gts ~= nil) then
			do return nil end
		end
		do
			local it = _g.jk.lang.Vector:iterate(typeParameters)
			local v = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
			local rit = _g.jk.lang.Vector:iterate(gts)
			while true do
				local ndo = rit:next()
				if not (ndo ~= nil) then
					do break end
				end
				do
					local nd = _vm:to_table_with_key(ndo, '_isType.sling.model.TemplateDeclarationNode')
					if not (nd ~= nil) then
						goto _continue51
					end
					do
						local nn = _g.sling.util.NodeUtil:getQualifiedNameString(nd, 46)
						if _g.jk.lang.String:isEmpty(nn) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty name for generic type", nd, nil))
						end
						do
							local tt = _vm:to_table_with_key(it:next(), '_isType.sling.common.DataTypeNode')
							if not (tt ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Ran out of data type parameters when generating type map", entity, nil))
							end
							do v:setObject(nn, tt) end
						end
					end
				end
				::_continue51::
			end
			do return _g.sling.common.TypeMap:forDynamicMap(v) end
		end
	end
end

function sling.compiler.SlingTypeResolver:addToTypemap(v, type, entity)
	if not (v ~= nil and type ~= nil and entity ~= nil) then
		do return end
	end
	do
		local tps = self:getTypeParametersForNode(type)
		if _g.jk.lang.Vector:isEmpty(tps) then
			do return end
		end
		do
			local gee = _vm:to_table_with_key(entity, '_isType.sling.model.GenericCapableEntityDeclarationNode')
			if not (gee ~= nil) then
				do return end
			end
			do
				local gts = self:getAllGenericTypes(gee)
				if _g.jk.lang.Vector:isEmpty(gts) then
					do return end
				end
				do
					local typemap = v:getTypemap()
					if not (typemap ~= nil) then
						typemap = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
						do v:setTypemap(typemap) end
					end
					do
						local n = 0
						while true do
							local tt = _vm:to_table_with_key(_g.jk.lang.Vector:get(gts, n), '_isType.sling.model.TemplateDeclarationNode')
							local vv = _vm:to_table_with_key(_g.jk.lang.Vector:get(tps, n), '_isType.sling.common.DataTypeNode')
							if tt == nil or vv == nil then
								do break end
							end
							do n = n + 1 end
							do typemap:set(_g.sling.util.NodeUtil:getQualifiedNameString(tt, 46), vv) end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:isNodeBefore(nodea, nodeb, block)
	local array = block:getNodes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local nn = array[n + 1]
				if nn ~= nil then
					if nn == nodeb then
						do return false end
					end
					if nn == nodea then
						do return true end
					end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function sling.compiler.SlingTypeResolver:tryResolveChildInContainer(container, beforeNode, childName, staticOnly)
	if not (container ~= nil) then
		do return nil end
	end
	do
		local n = 0
		local idx = container:getNodeIndexForName(childName)
		while true do
			local v = _g.jk.lang.Vector:get(idx, n)
			if not (v ~= nil) then
				do break end
			end
			if beforeNode ~= nil and (_vm:to_table_with_key(container, '_isType.sling.model.BlockNode') ~= nil) and self:isNodeBefore(v, beforeNode, container) == false then
				do n = n + 1 end
				goto _continue52
			end
			if staticOnly then
				if not v:hasModifier(_g.sling.model.Modifier.STATIC) then
					do n = n + 1 end
					goto _continue52
				end
			end
			do
				local rr = _g.sling.common.ResolveResult._construct0(_g.sling.common.ResolveResult._create())
				do rr:setNode(v) end
				do return rr end
			end
			::_continue52::
		end
		do
			local entity = _vm:to_table_with_key(container, '_isType.sling.model.EntityDeclarationNode')
			if entity ~= nil then
				local array = entity:getBaseTypes()
				if array ~= nil then
					local n2 = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n2 = 0
						while n2 < m do
							local basetype = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.BaseTypeNode')
							if basetype ~= nil then
								local type = basetype:getReferenceType()
								if not (type ~= nil) then
									goto _continue53
								end
								do
									local _rval = nil
									local _status, _err = _vm:execute_protected_call(function()
										do self:resolveDataType(type) end
										do
											local be = _g.sling.util.TypeResolver:getAndRequireBoundContainer(type)
											local v = self:tryResolveChildInContainer(be, nil, childName, staticOnly)
											if v ~= nil then
												do self:addToTypemap(v, type, be) end
												_rval = {}
												_rval.value = v
												do return end
											end
										end
									end)
									if _err then
										if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
											local e = _err
											if not self.ignoreFailedPaths then
												_vm:throw_error(e)
											end
										else
											_vm:throw_error(_err)
										end
									end
									if _rval then
										do return _rval.value end
									end
								end
							end
							::_continue53::
							do n2 = n2 + 1 end
						end
					end
				end
			end
			do return nil end
		end
	end
end

function sling.compiler.SlingTypeResolver:resolveChild(parent, childName)
	if not (parent ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("resolveChild: null parent", nil, nil))
	end
	if not (childName ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("resolveChild: null childName", nil, nil))
	end
	if (_vm:to_table_with_key(parent, '_isType.sling.common.ContainerNode') ~= nil) then
		local v = self:tryResolveChildInContainer(parent, nil, childName, false)
		if v ~= nil then
			do return v end
		end
	elseif (_vm:to_table_with_key(parent, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		local ref = _g.sling.util.TypeResolver:getAndRequireBoundContainer(parent:getType())
		do return self:resolveChild(ref, childName) end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Declaration of `" .. _g.jk.lang.String:safeString(childName) .. "' was not found here", parent, nil))
	do return nil end
end

function sling.compiler.SlingTypeResolver:resolveAbsoluteNames(context, names)
	local v = _vm:to_table_with_key(_g.sling.util.FindUtil:findRootNamespace(context), '_isType.sling.common.NodeObject')
	if not (v ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to find root namespace", context, nil))
	end
	do
		local sz = _g.jk.lang.Vector:getSize(names)
		local rr = _g.sling.common.ResolveResult:forNode(v)
		do
			local n = 0
			while n < sz do
				local vv = self:resolveChild(rr:getNode(), _g.jk.lang.Vector:get(names, n))
				local typemap = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
				do typemap:copyFrom(rr:getTypemap()) end
				do typemap:copyFrom(vv:getTypemap()) end
				do vv:setTypemap(typemap) end
				rr = vv
				do n = n + 1 end
			end
		end
		do return rr end
	end
end

function sling.compiler.SlingTypeResolver:resolveAbsoluteNamesNode(context, names)
	local v = self:resolveAbsoluteNames(context, names)
	if not (v ~= nil) then
		do return nil end
	end
	do return v:getNode() end
end

function sling.compiler.SlingTypeResolver:resolveNames(context, names)
	if not (context ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No context", nil, nil))
	end
	if not (names ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No names", nil, nil))
	end
	do
		local firstName = _g.jk.lang.Vector:get(names, 0)
		if _g.jk.lang.String:isEmpty(firstName) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("First name to resolve is empty!", context, nil))
		end
		do
			local pp = self:resolveName(context, firstName)
			local sz = _g.jk.lang.Vector:getSize(names)
			do
				local n = 1
				while n < sz do
					local npp = self:resolveChild(pp:getNode(), _g.jk.lang.Vector:get(names, n))
					local typemap = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
					do typemap:copyFrom(pp:getTypemap()) end
					do typemap:copyFrom(npp:getTypemap()) end
					do npp:setTypemap(typemap) end
					pp = npp
					do n = n + 1 end
				end
			end
			do return pp end
		end
	end
end

function sling.compiler.SlingTypeResolver:tryResolveNames(context, names)
	do
		local _rval = nil
		local _status, _err = _vm:execute_protected_call(function()
			_rval = {}
			_rval.value = self:resolveNames(context, names)
			do return end
		end)
		if _err then
		end
		if _rval then
			do return _rval.value end
		end
	end
	do return nil end
end

function sling.compiler.SlingTypeResolver:resolveName(context, name)
	if not (name ~= nil) then
		do return nil end
	end
	do
		local node = context
		local pnode = nil
		while node ~= nil do
			local entity = _vm:to_table_with_key(node, '_isType.sling.model.EntityDeclarationNode')
			if entity ~= nil then
				local fromBaseType = (_vm:to_table_with_key(pnode, '_isType.sling.model.BaseTypeNode') ~= nil)
				if not fromBaseType then
					local v = self:tryResolveChildInContainer(entity, nil, name, false)
					if v ~= nil then
						do return v end
					end
				end
				do
					local array = entity:getImportEntities()
					if array ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(array)
						do
							n = 0
							while n < m do
								local importEntity = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ImportEntityStatementNode')
								if importEntity ~= nil then
									local container = importEntity:getContainer()
									local entity = importEntity:getEntity()
									local names = _g.sling.util.SymbolUtil:getSymbolNames(_g.sling.util.SymbolUtil:mergeSymbols(container, entity))
									local nsref = nil
									local error = nil
									do
										local _status, _err = _vm:execute_protected_call(function()
											nsref = self:resolveAbsoluteNamesNode(entity, names)
										end)
										if _err then
											if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
												local ee = _err
												error = ee
											else
												_vm:throw_error(_err)
											end
										end
									end
									if not (nsref ~= nil) then
										local re = _g.sling.common.ReferenceError:forMessage("Imported entity not found: `" .. _g.jk.lang.String:safeString(_g.sling.util.SymbolUtil:getSymbolNamesString(entity, 46)) .. "'", entity, nil)
										if error ~= nil then
											do re:addRelatedMessageObject(error:getError()) end
										end
										_vm:throw_error(re)
									end
									do
										local allMembers = importEntity:getAllMembers()
										if not allMembers then
											local nn = _vm:to_table_with_key(nsref, '_isType.sling.common.NamedNode')
											if nn ~= nil then
												if _g.jk.lang.String:equals(name, nn:getNodeName()) then
													do return _g.sling.common.ResolveResult:forNode(nn) end
												end
											end
										else
											local v = self:tryResolveChildInContainer(_vm:to_table_with_key(nsref, '_isType.sling.common.ContainerNode'), nil, name, false)
											if v ~= nil then
												do return v end
											end
										end
									end
								end
								do n = n + 1 end
							end
						end
					end
					do
						local array2 = entity:getImportStaticNamespaces()
						if array2 ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(array2)
							do
								n2 = 0
								while n2 < m2 do
									local importNamespace = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.ImportStaticMemberStatementNode')
									if importNamespace ~= nil then
										local container = importNamespace:getContainer()
										local members = importNamespace:getMember()
										local names = _g.sling.util.SymbolUtil:getSymbolNames(_g.sling.util.SymbolUtil:mergeSymbols(container, members))
										local nsref = nil
										local error = nil
										do
											local _status, _err = _vm:execute_protected_call(function()
												nsref = self:resolveAbsoluteNamesNode(entity, names)
											end)
											if _err then
												if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
													local ee = _err
													error = ee
												else
													_vm:throw_error(_err)
												end
											end
										end
										if not (nsref ~= nil) then
											local re = _g.sling.common.ReferenceError:forMessage("Static import not found: `" .. _g.jk.lang.String:safeString(_g.sling.util.SymbolUtil:getSymbolNamesString(importNamespace:getMember(), 46)) .. "'", importNamespace, nil)
											if error ~= nil then
												do re:addRelatedMessageObject(error:getError()) end
											end
											_vm:throw_error(re)
										end
										do
											local allMembers = importNamespace:getAllMembers()
											if not allMembers then
												local nn = _vm:to_table_with_key(nsref, '_isType.sling.common.NamedNode')
												if nn ~= nil then
													if _g.jk.lang.String:equals(name, nn:getNodeName()) and nn:hasModifier(_g.sling.model.Modifier.STATIC) then
														do return _g.sling.common.ResolveResult:forNode(nn) end
													end
												end
											else
												local v = self:tryResolveChildInContainer(_vm:to_table_with_key(nsref, '_isType.sling.common.ContainerNode'), nil, name, true)
												if v ~= nil then
													do return v end
												end
											end
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
						do
							local array3 = entity:getImportNamespaces()
							if array3 ~= nil then
								local n3 = 0
								local m3 = _g.jk.lang.Vector:getSize(array3)
								do
									n3 = 0
									while n3 < m3 do
										local importNamespace = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.SymbolNode')
										if importNamespace ~= nil then
											local names = _g.sling.util.SymbolUtil:getSymbolNames(importNamespace)
											local nsref = nil
											local error = nil
											do
												local _status, _err = _vm:execute_protected_call(function()
													nsref = _vm:to_table_with_key(self:resolveAbsoluteNamesNode(entity, names), '_isType.sling.model.NamespaceNode')
												end)
												if _err then
													if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
														local ee = _err
														error = ee
													else
														_vm:throw_error(_err)
													end
												end
											end
											if not (nsref ~= nil) then
												if self.ignoreFailedPaths then
													goto _continue54
												end
												do
													local re = _g.sling.common.ReferenceError:forMessage("Namespace not found: `" .. _g.jk.lang.String:safeString(_g.sling.util.SymbolUtil:getSymbolNamesString(importNamespace, 46)) .. "'", importNamespace, nil)
													if error ~= nil then
														do re:addRelatedMessageObject(error:getError()) end
													end
													_vm:throw_error(re)
												end
											end
											do
												local v = self:tryResolveChildInContainer(nsref, nil, name, false)
												if v ~= nil then
													do return v end
												end
											end
										end
										::_continue54::
										do n3 = n3 + 1 end
									end
								end
							end
							do
								local gentity = _vm:to_table_with_key(node, '_isType.sling.model.GenericCapableEntityDeclarationNode')
								if gentity ~= nil then
									local array4 = gentity:getGenericTypes()
									if array4 ~= nil then
										local n4 = 0
										local m4 = _g.jk.lang.Vector:getSize(array4)
										do
											n4 = 0
											while n4 < m4 do
												local type = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.TemplateDeclarationNode')
												if type ~= nil then
													if _g.jk.lang.String:equals(type:getName(), name) then
														do return _g.sling.common.ResolveResult:forNode(type) end
													end
												end
												do n4 = n4 + 1 end
											end
										end
									end
								end
								if fromBaseType then
									pnode = node
									node = node:getParent()
									goto _continue55
								end
							end
						end
					end
				end
			else
				local container = _vm:to_table_with_key(node, '_isType.sling.common.ContainerNode')
				if container ~= nil then
					local v = self:tryResolveChildInContainer(container, pnode, name, false)
					if v ~= nil then
						do return v end
					end
				end
			end
			do
				local fd = _vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationBaseNode')
				if fd ~= nil then
					local array5 = fd:getGenericTypes()
					if array5 ~= nil then
						local n5 = 0
						local m5 = _g.jk.lang.Vector:getSize(array5)
						do
							n5 = 0
							while n5 < m5 do
								local type = _vm:to_table_with_key(array5[n5 + 1], '_isType.sling.model.TemplateDeclarationNode')
								if type ~= nil then
									if _g.jk.lang.String:equals(type:getName(), name) then
										do return _g.sling.common.ResolveResult:forNode(type) end
									end
								end
								do n5 = n5 + 1 end
							end
						end
					end
				end
				do
					local forloop = _vm:to_table_with_key(node, '_isType.sling.model.ForStatementNode')
					if forloop ~= nil then
						local inits = forloop:getInitializer()
						local array6 = inits:getNodes()
						if array6 ~= nil then
							local n6 = 0
							local m6 = _g.jk.lang.Vector:getSize(array6)
							do
								n6 = 0
								while n6 < m6 do
									local init = _vm:to_table_with_key(array6[n6 + 1], '_isType.sling.common.NamedNode')
									if init ~= nil then
										if _g.jk.lang.String:equals(name, init:getNodeName()) then
											do return _g.sling.common.ResolveResult:forNode(init) end
										end
									end
									do n6 = n6 + 1 end
								end
							end
						end
					end
					do
						local fes = _vm:to_table_with_key(node, '_isType.sling.model.ForEachStatementNode')
						if fes ~= nil then
							local array7 = fes:getLefts()
							if array7 ~= nil then
								local n7 = 0
								local m7 = _g.jk.lang.Vector:getSize(array7)
								do
									n7 = 0
									while n7 < m7 do
										local left = _vm:to_table_with_key(array7[n7 + 1], '_isType.sling.model.VariableDeclarationNode')
										if left ~= nil then
											if _g.jk.lang.String:equals(left:getName(), name) then
												do return _g.sling.common.ResolveResult:forNode(left) end
											end
										end
										do n7 = n7 + 1 end
									end
								end
							end
						end
						do
							local _function = _vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationBaseNode')
							if _function ~= nil then
								local array8 = _function:getParameters()
								if array8 ~= nil then
									local n8 = 0
									local m8 = _g.jk.lang.Vector:getSize(array8)
									do
										n8 = 0
										while n8 < m8 do
											local parameter = _vm:to_table_with_key(array8[n8 + 1], '_isType.sling.common.NamedNode')
											if parameter ~= nil then
												if _g.jk.lang.String:equals(name, parameter:getNodeName()) then
													do return _g.sling.common.ResolveResult:forNode(parameter) end
												end
											end
											do n8 = n8 + 1 end
										end
									end
								end
							end
							do
								local cb = _vm:to_table_with_key(node, '_isType.sling.model.CatchBlockNode')
								if cb ~= nil then
									local array9 = cb:getExceptions()
									if array9 ~= nil then
										local n9 = 0
										local m9 = _g.jk.lang.Vector:getSize(array9)
										do
											n9 = 0
											while n9 < m9 do
												local variable = _vm:to_table_with_key(array9[n9 + 1], '_isType.sling.model.VariableDeclarationNode')
												if variable ~= nil then
													if _g.jk.lang.String:equals(name, variable:getName()) then
														do return _g.sling.common.ResolveResult:forNode(variable) end
													end
												end
												do n9 = n9 + 1 end
											end
										end
									end
								end
								pnode = node
								node = node:getParent()
							end
						end
					end
				end
			end
			::_continue55::
		end
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No matching declaration was found: `" .. _g.jk.lang.String:safeString(name) .. "'", context, nil))
		do return nil end
	end
end

function sling.compiler.SlingTypeResolver:tryResolveDataType(ctx, rdt)
	do
		local _status, _err = _vm:execute_protected_call(function()
			do self:resolveDataType(rdt) end
		end)
		if _err then
			if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
				local e = _err
				if ctx ~= nil and ctx:isInDebugMode() then
					do _g.jk.log.Log:debug(ctx, e:toStringWithDebug(true)) end
				end
				do return false end
			else
				_vm:throw_error(_err)
			end
		end
	end
	do return true end
end

function sling.compiler.SlingTypeResolver:storeTypeParameters(symbol)
	do symbol:setTypeParameters(nil, false) end
	do
		local params = self:getTypeParametersForNode(symbol)
		if params ~= nil then
			local v = {}
			if params ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(params)
				do
					n = 0
					while n < m do
						local dt = _vm:to_table_with_key(params[n + 1], '_isType.sling.common.DataTypeNode')
						if dt ~= nil then
							do _g.jk.lang.Vector:append(v, _g.sling.util.DataTypeUtil:dupAsDataType(dt)) end
						end
						do n = n + 1 end
					end
				end
			end
			do symbol:setTypeParameters(v, false) end
		end
	end
end

function sling.compiler.SlingTypeResolver:resolveDataType(odt)
	if not (odt ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(odt, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
		do return end
	end
	do
		local rdt = _vm:to_table_with_key(odt, '_isType.sling.model.ReferenceDataTypeNode')
		if not (rdt ~= nil) then
			do return end
		end
		do
			local symbol = rdt:getSymbol()
			if not (symbol ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null symbol", rdt, nil))
			end
			if rdt:getMagical() then
				local v = _g.sling.model.MagicalClassDeclarationNode._construct0(_g.sling.model.MagicalClassDeclarationNode._create())
				do v:setSymbol(_vm:to_table_with_key(_g.sling.util.NodeUtil:dupAsNode(symbol), '_isType.sling.model.SymbolNode'), false) end
				do symbol:setBinding(v, nil) end
				do return end
			end
			do
				local binding = symbol:getBinding()
				if binding ~= nil then
					if (_vm:to_table_with_key(binding, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) == false and binding:getParent() == nil then
						do symbol:setBinding(nil, nil) end
					else
						do return end
					end
				end
				do
					local names = _g.sling.util.SymbolUtil:getSymbolNames(symbol)
					if not (names ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No names for symbol", symbol, nil))
					end
					do
						local _status, _err = _vm:execute_protected_call(function()
							local result = self:resolveNames(rdt, names)
							do _g.sling.compiler.SlingTypeResolver:storeTypeParameters(symbol) end
							do symbol:setBinding(result:getNode(), result:getTypemap()) end
							do self:resolveDataTypes(symbol) end
						end)
						if _err then
							if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
								local error = _err
								local re = _g.sling.common.ReferenceError:forMessage("Failed to resolve symbol", symbol, nil)
								do re:addRelatedMessageObject(error:getError()) end
								_vm:throw_error(re)
							else
								_vm:throw_error(_err)
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:getResolveError(xpr)
	local sxpr = _vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode')
	if not (sxpr ~= nil) then
		do return _g.sling.common.ReferenceError:forMessage("Failed to resolve expression", xpr, nil) end
	end
	do
		local symbol = sxpr:getSymbol()
		local name = nil
		if not (symbol ~= nil) then
			name = "(null symbol in expression)"
		else
			name = _g.sling.util.SymbolUtil:getSymbolNamesString(symbol, 46)
		end
		if _g.jk.lang.String:isEmpty(name) and symbol ~= nil then
			local comps = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			if comps ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(comps)
				do
					n = 0
					while n < m do
						local comp = _vm:to_table_with_key(comps[n + 1], '_isType.sling.model.SymbolNameComponentNode')
						if comp ~= nil then
							if sb:count() > 0 then
								do sb:appendCharacter(46) end
							end
							do sb:appendString(comp:getName()) end
						end
						do n = n + 1 end
					end
				end
			end
			if sb:count() > 0 then
				do sb:appendString(" (original name; bound node name was empty)") end
			end
			name = sb:toString()
		end
		if _g.jk.lang.String:isEmpty(name) then
			name = "(empty symbol components)"
		end
		do return _g.sling.common.ReferenceError:forMessage("Failure while resolving symbol expression: `" .. _g.jk.lang.String:safeString(name) .. "'", xpr, nil) end
	end
end

function sling.compiler.SlingTypeResolver:getPossibleBindingsFromBaseTypes(container, name, v)
	local entity = _vm:to_table_with_key(container, '_isType.sling.model.EntityDeclarationNode')
	if not (entity ~= nil) then
		do return end
	end
	do
		local array = entity:getBaseTypes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						local type = basetype:getReferenceType()
						if not (type ~= nil) then
							goto _continue56
						end
						do
							local _status, _err = _vm:execute_protected_call(function()
								do self:resolveDataType(type) end
								do
									local be = _g.sling.util.TypeResolver:getAndRequireBoundContainer(type)
									local rr = self:tryResolveChildInContainer(be, nil, name, false)
									if rr ~= nil then
										do self:addToTypemap(rr, type, be) end
										do _g.jk.lang.Vector:append(v, rr) end
									end
									do self:getPossibleBindingsFromBaseTypes(be, name, v) end
								end
							end)
							if _err then
								if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
									local e = _err
									if not self.ignoreFailedPaths then
										_vm:throw_error(e)
									end
								else
									_vm:throw_error(_err)
								end
							end
						end
					end
					::_continue56::
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:getPossibleBindings(xpr)
	if not (xpr ~= nil) then
		do return nil end
	end
	do
		local symbol = xpr:getSymbol()
		if not (symbol ~= nil) then
			do return nil end
		end
		do
			local binding = _g.sling.util.SymbolUtil:tryGetSymbolBindingForExpression(xpr)
			if not (binding ~= nil) then
				do return nil end
			end
			do
				local bp = _vm:to_table_with_key(binding:getParent(), '_isType.sling.common.ContainerNode')
				if not (bp ~= nil) then
					local v = {}
					local rr = _g.sling.common.ResolveResult._construct0(_g.sling.common.ResolveResult._create())
					do rr:setNode(binding) end
					do rr:setTypemap(symbol:getBindingTypemap()) end
					do rr:setTypeParameters(symbol:getTypeParameters()) end
					do _g.jk.lang.Vector:append(v, rr) end
					do return v end
				end
				do
					local name = _g.sling.util.SymbolUtil:getSymbolName(symbol)
					if _g.jk.lang.String:isEmpty(name) then
						do return nil end
					end
					do
						local v = {}
						local array = bp:getNodeIndexForName(name)
						if array ~= nil then
							local n = 0
							local m = _g.jk.lang.Vector:getSize(array)
							do
								n = 0
								while n < m do
									local node = array[n + 1]
									if node ~= nil then
										local rr = _g.sling.common.ResolveResult._construct0(_g.sling.common.ResolveResult._create())
										do rr:setNode(node) end
										do rr:setTypemap(symbol:getBindingTypemap()) end
										do rr:setTypeParameters(symbol:getTypeParameters()) end
										do _g.jk.lang.Vector:append(v, rr) end
									end
									do n = n + 1 end
								end
							end
						end
						do self:getPossibleBindingsFromBaseTypes(bp, name, v) end
						do return v end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:handleInferTypes(dt1, dt2, tnames, typemap)
	if (_vm:to_table_with_key(dt1, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local tref = _g.sling.util.SymbolUtil:tryGetSymbolBinding(dt1:getSymbol())
		if tref ~= nil then
			local name1 = _g.sling.util.NodeUtil:getQualifiedNameString(tref, 46)
			if name1 ~= nil and tnames:contains(name1) then
				if typemap:contains(name1) == false then
					do typemap:set(name1, dt2) end
				end
			end
		end
	end
	do
		local tp1 = self:getTypeParametersForNode(dt1)
		local tp2 = self:getTypeParametersForNode(dt2)
		if tp1 ~= nil and tp2 ~= nil then
			local n1 = 0
			local n2 = 0
			while true do
				local tp1dt = _vm:to_table_with_key(_g.jk.lang.Vector:get(tp1, n1), '_isType.sling.common.DataTypeNode')
				local tp2dt = _vm:to_table_with_key(_g.jk.lang.Vector:get(tp2, n2), '_isType.sling.common.DataTypeNode')
				if tp1dt ~= nil and tp2dt ~= nil then
					do self:handleInferTypes(tp1dt, tp2dt, tnames, typemap) end
				else
					do break end
				end
				do n1 = n1 + 1 end
				do n2 = n2 + 1 end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:inferTypeMapFromCallParameters(fd, params)
	if not (fd ~= nil) then
		do return nil end
	end
	do
		local generics = fd:getGenericTypes()
		if not _g.jk.lang.Vector:isNotEmpty(generics) then
			do return nil end
		end
		do
			local myparams = fd:getParameters()
			local v = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
			local n1 = 0
			local n2 = 0
			local tnames = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
			if generics ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(generics)
				do
					n = 0
					while n < m do
						local generic = _vm:to_table_with_key(generics[n + 1], '_isType.sling.model.TemplateDeclarationNode')
						if generic ~= nil then
							local name = _g.sling.util.NodeUtil:getQualifiedNameString(generic, 46)
							if name ~= nil then
								do tnames:add(name) end
							end
						end
						do n = n + 1 end
					end
				end
			end
			while true do
				local vd = _vm:to_table_with_key(_g.jk.lang.Vector:get(myparams, n1), '_isType.sling.model.VariableDeclarationNode')
				local pp = _vm:to_table_with_key(_g.jk.lang.Vector:get(params, n2), '_isType.sling.common.ExpressionNode')
				do n1 = n1 + 1 end
				do n2 = n2 + 1 end
				if vd == nil or pp == nil then
					do break end
				end
				do
					local dt1 = self:resolveVariableType(vd)
					local dt2 = _g.sling.util.ExpressionUtil:getExpressionDataType(pp, self)
					if dt1 == nil and dt2 == nil then
						goto _continue57
					end
					if dt1 == nil or dt2 == nil then
						do break end
					end
					do self:handleInferTypes(dt1, dt2, tnames, v) end
				end
				::_continue57::
			end
			do return v end
		end
	end
end

sling.compiler.SlingTypeResolver.MatchingComponents = {}
sling.compiler.SlingTypeResolver.MatchingComponents.__index = sling.compiler.SlingTypeResolver.MatchingComponents
_vm:set_metatable(sling.compiler.SlingTypeResolver.MatchingComponents, {})

function sling.compiler.SlingTypeResolver.MatchingComponents._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingTypeResolver.MatchingComponents)
	return v
end

function sling.compiler.SlingTypeResolver.MatchingComponents:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingTypeResolver.MatchingComponents'
	self['_isType.sling.compiler.SlingTypeResolver.MatchingComponents'] = true
	self.declaration = nil
	self.binding = nil
	self.typemap = nil
end

function sling.compiler.SlingTypeResolver.MatchingComponents:_construct0()
	sling.compiler.SlingTypeResolver.MatchingComponents._init(self)
	return self
end

function sling.compiler.SlingTypeResolver.MatchingComponents:getDeclaration()
	do return self.declaration end
end

function sling.compiler.SlingTypeResolver.MatchingComponents:setDeclaration(v)
	self.declaration = v
	do return self end
end

function sling.compiler.SlingTypeResolver.MatchingComponents:getBinding()
	do return self.binding end
end

function sling.compiler.SlingTypeResolver.MatchingComponents:setBinding(v)
	self.binding = v
	do return self end
end

function sling.compiler.SlingTypeResolver.MatchingComponents:getTypemap()
	do return self.typemap end
end

function sling.compiler.SlingTypeResolver.MatchingComponents:setTypemap(v)
	self.typemap = v
	do return self end
end

function sling.compiler.SlingTypeResolver:getFunctionMatchingComponents(decls, params, oxpr)
	local fcomps = {}
	if decls ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(decls)
		do
			n = 0
			while n < m do
				local declbind = decls[n + 1]
				if declbind ~= nil then
					local node = declbind:getNode()
					local binding = nil
					local decl = nil
					if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
						if not node:hasCustomModifier("macro") then
							decl = node
							binding = node
						end
					elseif (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
						local dt = _vm:to_table_with_key(self:resolveVariableType(node), '_isType.sling.model.FunctionDataTypeNode')
						if dt ~= nil then
							local dd = dt:getDeclaration()
							if dd ~= nil then
								decl = dd
								binding = node
							end
						end
					end
					if not (decl ~= nil) then
						goto _continue58
					end
					do
						local typemap = nil
						if decl:hasModifier(_g.sling.model.Modifier.STATIC) then
							typemap = self:inferTypeMapFromCallParameters(decl, params)
						else
							typemap = self:getTypeMapFromExpression(oxpr)
						end
						do
							local tps = declbind:getTypeParameters()
							if tps ~= nil then
								local bindmap = self:createTypeMapforEntity(_vm:to_table_with_key(_g.sling.util.FindUtil:findNearestEntity(decl), '_isType.sling.model.GenericCapableEntityDeclarationNode'), tps)
								if bindmap ~= nil then
									typemap = _g.sling.common.TypeMap:merge(bindmap, typemap)
								end
							end
							do
								local refmap = declbind:getTypemap()
								if refmap ~= nil then
									typemap = _g.sling.common.TypeMap:merge(refmap, typemap)
								end
								do
									local v = _g.sling.compiler.SlingTypeResolver.MatchingComponents._construct0(_g.sling.compiler.SlingTypeResolver.MatchingComponents._create())
									do v:setDeclaration(decl) end
									do v:setTypemap(typemap) end
									do v:setBinding(binding) end
									do _g.jk.lang.Vector:append(fcomps, v) end
								end
							end
						end
					end
				end
				::_continue58::
				do n = n + 1 end
			end
		end
	end
	do return fcomps end
end

function sling.compiler.SlingTypeResolver:resolveFunctionDeclaration(fc)
	if not (fc ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("resolveFunctionDeclaration: null fc", nil, nil))
	end
	do
		local xpr = fc:getExpression()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Function call has no expression", fc, nil))
		end
		do self:resolveExpression(xpr) end
		do
			local array = fc:getParameters()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
						if param ~= nil then
							do self:resolveExpression(param) end
						end
						do n = n + 1 end
					end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.FunctionDeclarationExpressionNode') ~= nil) then
				local v = xpr:getDeclaration()
				if not (v ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Function declaration expression has no declaration!", xpr, nil))
				end
				do return v end
			end
			do
				local oxpr = xpr
				if (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
					xpr = xpr:getLastNode()
				end
				do
					local rt = xpr:getResolvedDataType()
					if (_vm:to_table_with_key(rt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
						do return nil end
					end
					if (_vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
						local binds = self:getPossibleBindings(xpr)
						if _g.jk.lang.Vector:isEmpty(binds) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to find any candidates for function: `" .. _g.jk.lang.String:safeString(_g.sling.util.SymbolUtil:getSymbolNamesString(xpr:getSymbol(), 46)) .. "'", xpr, nil))
						end
						do
							local prams = fc:getParameters()
							local comps = self:getFunctionMatchingComponents(binds, prams, oxpr)
							if comps ~= nil then
								local n2 = 0
								local m2 = _g.jk.lang.Vector:getSize(comps)
								do
									n2 = 0
									while n2 < m2 do
										local comp = comps[n2 + 1]
										if comp ~= nil then
											if self:matchesCallParameters(comp:getDeclaration(), prams, comp:getTypemap(), true, true) then
												local decl = comp:getDeclaration()
												do self:setBindingForFunctionCallSymbol(xpr, comp:getBinding(), comp:getTypemap()) end
												do return decl end
											end
										end
										do n2 = n2 + 1 end
									end
								end
							end
							do
								local nems = nil
								if comps ~= nil then
									local n3 = 0
									local m3 = _g.jk.lang.Vector:getSize(comps)
									do
										n3 = 0
										while n3 < m3 do
											local comp = comps[n3 + 1]
											if comp ~= nil then
												if self:matchesCallParameters(comp:getDeclaration(), prams, comp:getTypemap(), false, true) then
													if not (nems ~= nil) then
														nems = {}
													end
													do _g.jk.lang.Vector:append(nems, comp) end
												end
											end
											do n3 = n3 + 1 end
										end
									end
								end
								if nems ~= nil then
									local most = self:resolveMostExactFunctionDeclaration(nems, prams)
									if most ~= nil then
										local decl = most:getDeclaration()
										do self:setBindingForFunctionCallSymbol(xpr, most:getBinding(), most:getTypemap()) end
										do return decl end
									end
								end
								do
									local error = _g.sling.common.ReferenceError:forMessage("Unable to find the requested function: `" .. _g.jk.lang.String:safeString(_g.sling.syntax.SlingGenerator:getFunctionCallDisplayString(fc)) .. "'", xpr, nil)
									if binds ~= nil then
										local n4 = 0
										local m4 = _g.jk.lang.Vector:getSize(binds)
										do
											n4 = 0
											while n4 < m4 do
												local bind = binds[n4 + 1]
												if bind ~= nil then
													do error:addRelatedMessage("Possible candidate", bind:getNode()) end
												end
												do n4 = n4 + 1 end
											end
										end
									end
									_vm:throw_error(error)
								end
							end
						end
					end
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported child expression type for function call: `" .. _g.jk.lang.String:safeString(xpr:getNodeTypeName()) .. "'", xpr, nil))
					do return nil end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:resolveMostExactFunctionDeclaration(comps, prams)
	if not (_g.jk.lang.Vector:getSize(prams) > 0) then
		do return nil end
	end
	do
		local size = _g.jk.lang.Vector:getSize(comps)
		if not (size > 0) then
			do return nil end
		end
		if size == 1 then
			do return _g.jk.lang.Vector:getFirst(comps) end
		end
		do
			local hscr = -1
			local mcom = nil
			if comps ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(comps)
				do
					n = 0
					while n < m do
						local comp = comps[n + 1]
						if comp ~= nil then
							local decl = comp:getDeclaration()
							local dprm = decl:getParameters()
							local i = 0
							local c = 0
							while true do
								local vd = _vm:to_table_with_key(_g.jk.lang.Vector:get(dprm, i), '_isType.sling.model.VariableDeclarationNode')
								local pp = _vm:to_table_with_key(_g.jk.lang.Vector:get(prams, i), '_isType.sling.common.ExpressionNode')
								if vd == nil or pp == nil then
									do break end
								end
								do i = i + 1 end
								do
									local d1 = vd:getType()
									local d2 = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(pp, nil)
									c = c + self:getPrimitiveDataTypeLikenessScore(d2, d1)
								end
							end
							if c > hscr then
								hscr = c
								mcom = comp
							end
						end
						do n = n + 1 end
					end
				end
			end
			do return mcom end
		end
	end
end

function sling.compiler.SlingTypeResolver:setBindingForFunctionCallSymbol(symbol, decl, typemap)
	local ss = symbol:getSymbol()
	if ss ~= nil then
		do ss:setBinding(decl, typemap) end
	end
end

function sling.compiler.SlingTypeResolver:doReduceDimension(original)
	if not (original ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("reduceDimension: null original", nil, nil))
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
		do return original:getPrimaryType() end
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
		local ptype = original:getPrimaryType()
		if (_vm:to_table_with_key(ptype, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
			local dts = ptype:getBaseTypes()
			local sz = _g.jk.lang.Vector:getSize(dts)
			if sz == 1 then
				do return _vm:to_table_with_key(dts[0 + 1], '_isType.sling.common.DataTypeNode') end
			else
				do return _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()) end
			end
		end
		do return ptype end
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
		do return _g.sling.model.IntegerDataTypeNode:forType(_g.sling.model.IntegerDataTypeNode.TYPE_UINT8) end
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.StringDataTypeNode') ~= nil) then
		do return _g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()) end
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.MapDataTypeNode') ~= nil) then
		do return original:getValueType() end
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.RangeDataTypeNode') ~= nil) then
		do return _g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()) end
	end
	if (_vm:to_table_with_key(original, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local iterref = self:getImplementedInterfaceReference(_g.sling.util.TypeResolver:getAndRequireBoundEntity(original), {
			"jk",
			"lang",
			"Iterateable"
		})
		if iterref ~= nil then
			local type = _vm:to_table_with_key(_g.jk.lang.Vector:getFirst(self:getTypeParametersForNode(iterref)), '_isType.sling.common.DataTypeNode')
			if type ~= nil then
				do return type end
			end
		end
	end
	do return nil end
end

function sling.compiler.SlingTypeResolver:reduceDimension(original)
	local v = self:doReduceDimension(original)
	if not (v ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to reduce data type to a lower dimension: `" .. _g.jk.lang.String:safeString(original:getNodeTypeName()) .. "'", original, nil))
	end
	do return v end
end

function sling.compiler.SlingTypeResolver:resolveVariableType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null variable", nil, nil))
	end
	do
		local type = node:getType()
		if not (type ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type for variable", node, nil))
		end
		if (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) == false then
			do return type end
		end
		do
			local init = node:getInitializer()
			if init ~= nil then
				do return _g.sling.util.ExpressionUtil:getExpressionDataType(init, self) end
			end
			do
				local fes = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.ForEachStatementNode')
				if fes ~= nil then
					local right = fes:getRight()
					if not (right ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No right expression", fes, nil))
					end
					do return self:reduceDimension(_g.sling.util.ExpressionUtil:getExpressionDataType(right, nil)) end
				end
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Variable declaration with automatic type but not inside foreach and no initializer", node, nil))
				do return nil end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:resolvePropertyVariableType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null property variable", nil, nil))
	end
	do
		local type = node:getType()
		if not (type ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type for property variable", node, nil))
		end
		if (_vm:to_table_with_key(type, '_isType.sling.model.AutomaticDataTypeNode') ~= nil) == false then
			do return type end
		end
		do
			local init = node:getInitializer()
			if init ~= nil then
				do return _g.sling.util.ExpressionUtil:getExpressionDataType(init, self) end
			end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Property variable declaration with automatic type but without initializer", node, nil))
			do return nil end
		end
	end
end

function sling.compiler.SlingTypeResolver:resolveToDataType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null node in resolveToDataType", node, nil))
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NamespaceNode') ~= nil) then
		do return _g.sling.model.ReferenceDataTypeNode:forNode(node, nil) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
		do return _g.sling.model.ReferenceDataTypeNode:forNode(node, nil) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		do return _g.sling.util.DataTypeUtil:dupAsDataType(self:resolveVariableType(node)) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingPropertyDeclaration') ~= nil) then
		do return _g.sling.util.DataTypeUtil:dupAsDataType(self:resolvePropertyVariableType(node)) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
		local array = node:getParameters()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local cnode = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
					if cnode ~= nil then
						do self:resolveExpressions(cnode:getInitializer()) end
					end
					do n = n + 1 end
				end
			end
		end
		do return _g.sling.model.FunctionDataTypeNode:forFunction(node) end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EnumValueNode') ~= nil) then
		local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.EnumDeclarationNode')
		if not (pp ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Enum value is not inside an enum declaration", node, nil))
		end
		do return _g.sling.model.ReferenceDataTypeNode:forNode(pp, nil) end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported type when resolving to data type: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", node, nil))
	do return nil end
end

function sling.compiler.SlingTypeResolver:getTypeMapFromExpression(xpr)
	if not (xpr ~= nil) then
		do return nil end
	end
	do
		local max = _vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode')
		if not (max ~= nil) then
			do return nil end
		end
		do
			local last = max:getLastNode()
			if not (last ~= nil) then
				do return nil end
			end
			do
				local parent = _g.sling.model.MemberAccessExpressionNode:getPreviousNode(last)
				if not (parent ~= nil) then
					do return nil end
				end
				do return self:getTypeMapFromDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(parent, self)) end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:getTypeMapFromDataType(dt)
	local pdt = _vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode')
	if not (pdt ~= nil) then
		do return nil end
	end
	do
		local entity = self:getBoundEntity(pdt)
		if not (entity ~= nil) then
			do return nil end
		end
		do
			local v = nil
			if entity ~= nil and (_vm:to_table_with_key(entity, '_isType.sling.model.GenericCapableEntityDeclarationNode') ~= nil) then
				v = self:createTypeMapforEntity(entity, self:getTypeParametersForNode(pdt))
			end
			do
				local array = entity:getBaseTypes()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local basetype = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
							if basetype ~= nil then
								local tm2 = self:getTypeMapFromDataType(basetype:getReferenceType())
								if tm2 ~= nil then
									if not (v ~= nil) then
										v = tm2
									else
										do v:copyFrom(tm2) end
									end
								end
							end
							do n = n + 1 end
						end
					end
				end
				do return v end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:findInferredTemplate(fc, decl, name)
	if not (fc ~= nil) then
		do return nil end
	end
	if not (decl ~= nil) then
		do return nil end
	end
	if not (name ~= nil) then
		do return nil end
	end
	do
		local parameters = fc:getParameters()
		if not (parameters ~= nil) then
			do return nil end
		end
		do
			local pit = _g.jk.lang.Vector:iterate(parameters)
			if not (pit ~= nil) then
				do return nil end
			end
			do
				local dparams = decl:getParameters()
				if not (dparams ~= nil) then
					do return nil end
				end
				do
					local dit = _g.jk.lang.Vector:iterate(dparams)
					if not (dit ~= nil) then
						do return nil end
					end
					while true do
						local decl = _vm:to_table_with_key(dit:next(), '_isType.sling.model.VariableDeclarationNode')
						if decl == nil then
							do break end
						end
						do
							local xpr = _vm:to_table_with_key(pit:next(), '_isType.sling.common.ExpressionNode')
							if xpr == nil then
								do break end
							end
							do
								local xprdt = _g.sling.util.ExpressionUtil:getExpressionDataType(xpr, self)
								if xprdt == nil then
									goto _continue59
								end
								do
									local ddt = self:resolveVariableType(decl)
									if ddt == nil then
										goto _continue59
									end
									if (_vm:to_table_with_key(ddt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) and name == _g.sling.util.SymbolUtil:getSymbolName(ddt:getSymbol()) then
										do return xprdt end
									end
									if (_vm:to_table_with_key(ddt, '_isType.sling.model.DataTypeExtenderNode') ~= nil) and (_vm:to_table_with_key(xprdt, '_isType.sling.model.DataTypeExtenderNode') ~= nil) then
										local pt = ddt:getPrimaryType()
										if pt ~= nil and (_vm:to_table_with_key(pt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) and name == _g.sling.util.SymbolUtil:getSymbolName(pt:getSymbol()) then
											local x = xprdt:getPrimaryType()
											if x ~= nil then
												do return x end
											end
										end
									end
									do
										local ddtparams = self:getTypeParametersForNode(ddt)
										local xprparams = self:getTypeParametersForNode(xprdt)
										if _g.jk.lang.Vector:isEmpty(ddtparams) == false and _g.jk.lang.Vector:isEmpty(xprparams) == false then
											local n = 0
											local found = -1
											if ddtparams ~= nil then
												local n2 = 0
												local m = _g.jk.lang.Vector:getSize(ddtparams)
												do
													n2 = 0
													while n2 < m do
														local tpdt = _vm:to_table_with_key(ddtparams[n2 + 1], '_isType.sling.common.DataTypeNode')
														if tpdt ~= nil then
															if (_vm:to_table_with_key(tpdt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) and name == _g.sling.util.SymbolUtil:getSymbolName(tpdt:getSymbol()) then
																found = n
																do break end
															end
															do n = n + 1 end
														end
														do n2 = n2 + 1 end
													end
												end
											end
											if found >= 0 then
												local n = 0
												if xprparams ~= nil then
													local n3 = 0
													local m2 = _g.jk.lang.Vector:getSize(xprparams)
													do
														n3 = 0
														while n3 < m2 do
															local tpdt = _vm:to_table_with_key(xprparams[n3 + 1], '_isType.sling.common.DataTypeNode')
															if tpdt ~= nil then
																if n == found then
																	do return tpdt end
																end
																do n = n + 1 end
															end
															do n3 = n3 + 1 end
														end
													end
												end
											end
										end
									end
								end
							end
						end
						::_continue59::
					end
					do return nil end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:findInferredTemplateForDataType(dt, fcx, fdecl)
	local rt = _vm:to_table_with_key(dt, '_isType.sling.model.ReferenceDataTypeNode')
	if rt ~= nil then
		local be = _vm:to_table_with_key(self:getBoundNode(rt), '_isType.sling.model.TemplateDeclarationNode')
		if be ~= nil then
			local inft = self:findInferredTemplate(fcx, fdecl, be:getName())
			if inft ~= nil then
				do return inft end
			end
		end
	end
	do return dt end
end

function sling.compiler.SlingTypeResolver:substituteInferredTemplates(adt, fcx, fdecl)
	local changed = false
	do self:resolveDataType(adt) end
	do
		local dt = _g.sling.util.DataTypeUtil:dupAsDataType(adt)
		local tps = self:getTypeParametersForNode(dt)
		if tps ~= nil then
			if tps ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(tps)
				do
					n = 0
					while n < m do
						local tp = _vm:to_table_with_key(tps[n + 1], '_isType.sling.common.DataTypeNode')
						if tp ~= nil then
							local ntp = self:substituteInferredTemplates(tp, fcx, fdecl)
							if ntp ~= tp then
								do _g.sling.util.NodeUtil:replaceNode(tp, ntp) end
								changed = true
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do
			local v = self:findInferredTemplateForDataType(dt, fcx, fdecl)
			if v ~= adt then
				changed = true
			end
			if not changed then
				do return adt end
			end
			do return v end
		end
	end
end

function sling.compiler.SlingTypeResolver:getIntegerType(type)
	local idtn = _vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode')
	if not (idtn ~= nil) then
		do return 0 end
	end
	do return idtn:getType() end
end

function sling.compiler.SlingTypeResolver:resolveExpression(xpr)
	if not (xpr ~= nil) then
		do return end
	end
	do
		local xprdt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(xpr, nil)
		if xprdt ~= nil then
			do return end
		end
		do
			local pdt = nil
			local pref = nil
			local pn = _g.sling.model.MemberAccessExpressionNode:getPreviousNode(xpr)
			if pn ~= nil then
				pdt = _g.sling.util.ExpressionUtil:getExpressionDataType(pn, self)
			end
			if pdt ~= nil then
				do
					local _status, _err = _vm:execute_protected_call(function()
						if (_vm:to_table_with_key(pdt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
							pref = _g.sling.model.MagicalClassDeclarationNode._construct0(_g.sling.model.MagicalClassDeclarationNode._create())
						else
							if (_vm:to_table_with_key(pdt, '_isType.sling.model.ExpressionDataTypeNode') ~= nil) then
								local xpr2 = pdt:getExpression()
								pdt = _g.sling.util.ExpressionUtil:getExpressionDataType(xpr2, self)
							end
							if (_vm:to_table_with_key(pdt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) == false then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Not a reference data type", pn, nil))
							end
							pref = _g.sling.util.TypeResolver:getAndRequireBoundContainer(pdt)
						end
					end)
					if _err then
						if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
							local error = _err
							local re = self:getResolveError(xpr)
							do re:addRelatedMessageObject(error:getError()) end
							_vm:throw_error(re)
						else
							_vm:throw_error(_err)
						end
					end
				end
			end
			if pref ~= nil and (_vm:to_table_with_key(pref, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
				local fcx = xpr
				if (_vm:to_table_with_key(fcx:getExpression(), '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
					do xpr:setResolvedDataType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
				elseif (_vm:to_table_with_key(fcx:getExpression(), '_isType.sling.model.CurrentObjectExpressionNode') ~= nil) then
					do xpr:setResolvedDataType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
				else
					local fdecl = self:resolveFunctionDeclaration(fcx)
					if not (fdecl ~= nil) then
						do xpr:setResolvedDataType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
						do return end
					end
					do
						local rt = fdecl:getReturnType()
						if not (rt ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Function has no return type", fdecl, nil))
						end
						do
							local rttm = self:getTypeMapFromExpression(fcx:getExpression())
							rt = self:mapType(rt, rttm)
							rt = self:substituteInferredTemplates(rt, fcx, fdecl)
							do
								local rtdup = _g.sling.util.DataTypeUtil:dupAsDataType(rt)
								if fdecl:hasModifier(_g.sling.model.Modifier.ASYNCHRONOUS) and (_vm:to_table_with_key(rtdup, '_isType.sling.model.PromiseDataTypeNode') ~= nil) == false then
									do xpr:setResolvedDataType(_g.sling.model.PromiseDataTypeNode:forPrimaryType(rtdup), false) end
								else
									do xpr:setResolvedDataType(rtdup, false) end
								end
							end
						end
					end
				end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
				local symbol = xpr:getSymbol()
				if not (symbol ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Symbol expression has null symbol", xpr, nil))
				end
				do
					local _status, _err = _vm:execute_protected_call(function()
						local targetref = symbol:getBinding()
						local targetmap = symbol:getBindingTypemap()
						if not (targetref ~= nil) then
							if pref ~= nil then
								local sn = _g.sling.util.SymbolUtil:getSymbolName(symbol)
								if _g.jk.lang.String:isEmpty(sn) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty symbol", xpr, nil))
								end
								do
									local tt = self:resolveChild(pref, sn)
									targetref = tt:getNode()
									targetmap = tt:getTypemap()
								end
							else
								local names = _g.sling.util.SymbolUtil:expressionToSymbolNames(xpr)
								if _g.jk.lang.Vector:getSize(names) < 1 then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Symbol expression has no symbol names", xpr, nil))
								end
								if symbol:hasModifier(_g.sling.model.Modifier.GLOBAL) then
									local rr = self:resolveAbsoluteNames(symbol, names)
									targetref = rr:getNode()
									targetmap = rr:getTypemap()
								else
									local tt = self:resolveNames(xpr, names)
									targetref = tt:getNode()
									targetmap = tt:getTypemap()
								end
							end
							if (_vm:to_table_with_key(targetref, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
								local vd = targetref
								if (_vm:to_table_with_key(vd:getType(), '_isType.sling.model.AutomaticDataTypeNode') ~= nil) then
									do self:resolveExpression(vd:getInitializer()) end
								end
							end
							do symbol:setBinding(targetref, targetmap) end
							do
								local tpfn = self:getTypeParametersForNode(pdt)
								if tpfn ~= nil then
									local vv = {}
									if tpfn ~= nil then
										local n2 = 0
										local m = _g.jk.lang.Vector:getSize(tpfn)
										do
											n2 = 0
											while n2 < m do
												local tp = tpfn[n2 + 1]
												if tp ~= nil then
													if (_vm:to_table_with_key(tp, '_isType.sling.common.NodeObject') ~= nil) then
														do _g.jk.lang.Vector:append(vv, _g.sling.util.NodeUtil:dupAsNode(tp)) end
													else
														do _g.jk.lang.Vector:append(vv, tp) end
													end
												end
												do n2 = n2 + 1 end
											end
										end
									end
									do symbol:setTypeParameters(vv, false) end
								else
									do symbol:setTypeParameters(nil, false) end
								end
							end
						end
						do
							local rt = self:resolveToDataType(targetref)
							if pdt ~= nil then
								rt = self:mapType(rt, self:getTypeMapFromDataType(pdt))
								rt = self:mapType(rt, targetmap)
							end
							do xpr:setResolvedDataType(rt, false) end
						end
					end)
					if _err then
						if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
							local error = _err
							local re = self:getResolveError(xpr)
							do re:addRelatedMessageObject(error:getError()) end
							_vm:throw_error(re)
						else
							_vm:throw_error(_err)
						end
					end
				end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
				local child = xpr:getChildExpression()
				if child ~= nil then
					do self:setSameResolvedType(xpr, child) end
				end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.CreateObjectExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(xpr:getType()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.AssignmentExpressionBaseNode') ~= nil) then
				local left = xpr:getLeft()
				if left ~= nil then
					do self:setSameResolvedType(xpr, left) end
				end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.StringConcatenationExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.LogicalExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.CurrentObjectExpressionNode') ~= nil) then
				local entity = _g.sling.util.FindUtil:findNearestEntity(xpr)
				if not (entity ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing entity", xpr, nil))
				end
				do xpr:setResolvedDataType(_g.sling.model.ReferenceDataTypeNode:forNode(entity, nil), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
				local entity = _g.sling.util.FindUtil:findNearestEntity(xpr)
				if not (entity ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing entity", xpr, nil))
				end
				do
					local bc = self:getBaseClass(entity)
					if not (bc ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Enclosing entity has no base class", xpr, nil))
					end
					do xpr:setResolvedDataType(_g.sling.model.ReferenceDataTypeNode:forNode(bc, nil), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.ArithmeticExpressionNode') ~= nil) then
				if (_vm:to_table_with_key(xpr, '_isType.sling.model.ModuloExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.AdditionExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.DivisionExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.MultiplicationExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.SubtractionExpressionNode') ~= nil) then
					local aex = _vm:to_table_with_key(xpr, '_isType.sling.model.ArithmeticExpressionNode')
					local left = aex:getLeft()
					if not (left ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No left", aex, nil))
					end
					do
						local right = aex:getRight()
						if not (right ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No right", aex, nil))
						end
						do
							local ldt = _g.sling.util.ExpressionUtil:getExpressionDataType(left, self)
							local rdt = _g.sling.util.ExpressionUtil:getExpressionDataType(right, self)
							local xdt = nil
							if (_vm:to_table_with_key(ldt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT64) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT64) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT or self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT32) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT or self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT32) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT or self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT16) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT or self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT16) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT8 then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_INT8 then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_ULONG or self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT64) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_ULONG or self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT64) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT or self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT32) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT or self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT32) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_USHORT or self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT16) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_USHORT or self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT16) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and self:getIntegerType(ldt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT8 then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and self:getIntegerType(rdt) == _g.sling.model.IntegerDataTypeNode.TYPE_UINT8 then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							elseif (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							elseif (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(rdt)
							else
								xdt = _g.sling.util.DataTypeUtil:dupAsDataType(ldt)
							end
							if not (xdt ~= nil) then
								xdt = _g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create())
							end
							do xpr:setResolvedDataType(xdt, false) end
							do return end
						end
					end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.TypeCheckExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.StaticCastExpressionNode') ~= nil) then
				local dt = xpr:getType()
				if not (dt ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No data type", xpr, nil))
				end
				do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(dt), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.DynamicCastExpressionNode') ~= nil) then
				local dt = xpr:getType()
				if not (dt ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No data type", xpr, nil))
				end
				do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(dt), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.PreDecrementExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.PostDecrementExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.PreIncrementExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.PostIncrementExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.NegativeNumberExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.BitwiseNotExpressionNode') ~= nil) then
				local ux = xpr
				local child = ux:getExpression()
				if not (child ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null expression", ux, nil))
				end
				do self:setSameResolvedType(xpr, child) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.ForceUnwrapOptionalExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.SafeUnwrapOptionalExpressionNode') ~= nil) then
				local ux = xpr
				local child = ux:getExpression()
				if not (child ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null expression", ux, nil))
				end
				do
					local op = _g.sling.util.ExpressionUtil:getExpressionDataType(child, self)
					if (_vm:to_table_with_key(op, '_isType.sling.model.OptionalDataTypeNode') ~= nil) == false then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unwrapping of non optional data type is not allowed", op, nil))
					end
					do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(op:getPrimaryType()), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.ArrayCreationExpressionNode') ~= nil) then
				local acx = xpr
				local pt = acx:getPrimaryType()
				if pt ~= nil then
					local c = acx:getDimensionCount()
					local v = _g.sling.util.DataTypeUtil:dupAsDataType(pt)
					do
						local i = 0
						while i < c do
							v = _g.sling.model.StaticArrayDataTypeNode:forPrimaryType(v, nil)
							do i = i + 1 end
						end
					end
					do xpr:setResolvedDataType(v, false) end
					do return end
				end
				do
					local lit = acx:getArrayLiteral()
					if lit ~= nil then
						do self:setSameResolvedType(xpr, lit) end
						do return end
					end
					do xpr:setResolvedDataType(_g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), nil), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.ArrayLiteralExpressionNode') ~= nil) then
				local lit = xpr
				local type = lit:getType()
				if type ~= nil then
					do xpr:setResolvedDataType(_g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.util.DataTypeUtil:dupAsDataType(type), nil), false) end
					do return end
				end
				do xpr:setResolvedDataType(_g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), nil), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.EmptyExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.GetSizeExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.SubscriptExpressionNode') ~= nil) then
				local sex = xpr
				local child = sex:getChild()
				if not (child ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Subscript expression has no child", sex, nil))
				end
				do
					local dt = _g.sling.util.ExpressionUtil:getExpressionDataType(child, self)
					local sss = _g.jk.lang.Vector:getSize(sex:getSubscripts())
					do
						local n = 0
						while n < sss do
							dt = self:reduceDimension(dt)
							do n = n + 1 end
						end
					end
					do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(dt), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.FunctionDeclarationExpressionNode') ~= nil) then
				local proto = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
				local odecl = xpr:getDeclaration()
				if not (odecl ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No function declaration in expression", xpr, nil))
				end
				do _g.sling.util.FunctionUtil:copySignatureTo(odecl, proto) end
				do
					local dt = _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create())
					do dt:setDeclaration(proto, false) end
					do xpr:setResolvedDataType(dt, false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.BitwiseAndExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.BitwiseOrExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.BitwiseXorExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.ShiftLeftExpressionNode') ~= nil) or (_vm:to_table_with_key(xpr, '_isType.sling.model.ShiftRightExpressionNode') ~= nil) then
				local bex = xpr
				local left = bex:getLeft()
				if not (left ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", bex, nil))
				end
				do self:setSameResolvedType(xpr, left) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.DataTypeDefaultValueExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.AppendToVectorExpressionNode') ~= nil) then
				local left = xpr:getLeft()
				if not (left ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", xpr, nil))
				end
				do self:setSameResolvedType(xpr, left) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.ConditionalExpressionNode') ~= nil) then
				local aex = _vm:to_table_with_key(xpr, '_isType.sling.model.ConditionalExpressionNode')
				local left = aex:getTrueExpr()
				if not (left ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No left", aex, nil))
				end
				do
					local right = aex:getFalseExpr()
					if not (right ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No right", aex, nil))
					end
					do self:resolveExpression(right) end
					do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(left, self)), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.EmbedBlockNode') ~= nil) then
				local dd = xpr:getDefaultDataType()
				if dd == nil then
					dd = _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create())
				else
					dd = _g.sling.util.DataTypeUtil:dupAsDataType(dd)
				end
				do xpr:setResolvedDataType(dd, false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.TryCatchExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.MapLiteralExpressionNode') ~= nil) then
				local dd = xpr:getDefaultDataType()
				if not (dd ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Map literal has no default data type", xpr, nil))
				end
				dd = _g.sling.util.DataTypeUtil:dupAsDataType(dd)
				do xpr:setResolvedDataType(dd, false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.TupleExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.MultipleExpressionNode') ~= nil) then
				local xprs = xpr:getExpressions()
				if _g.jk.lang.Vector:isEmpty(xprs) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No expressions", xpr, nil))
				end
				do
					local lxp = _vm:to_table_with_key(_g.jk.lang.Vector:get(xprs, _g.jk.lang.Vector:getSize(xprs) - 1), '_isType.sling.common.ExpressionNode')
					if not (lxp ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null last expression", xpr, nil))
					end
					do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(lxp, self)), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.MembershipCheckExpressionNode') ~= nil) then
				do xpr:setResolvedDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.AwaitExpressionNode') ~= nil) then
				local pe = xpr:getExpression()
				if not (pe ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Await expression has no primary expression", xpr, nil))
				end
				do self:resolveExpression(pe) end
				do
					local dt = _g.sling.util.ExpressionUtil:getExpressionDataType(pe, self)
					local promise = _vm:to_table_with_key(dt, '_isType.sling.model.PromiseDataTypeNode')
					if not (promise ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type: `" .. _g.jk.lang.String:safeString(dt:getNodeTypeName()) .. "'. Promise expected.", dt, nil))
					end
					do
						local propri = promise:getPrimaryType()
						if not (propri ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Promise has no primary type", promise, nil))
						end
						do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(propri), false) end
						do return end
					end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.PromiseExpressionNode') ~= nil) then
				local pe = xpr:getExpression()
				if not (pe ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Promise expression has no primary expression", xpr, nil))
				end
				do self:resolveExpression(pe) end
				do
					local dt = _g.sling.util.ExpressionUtil:getExpressionDataType(pe, self)
					if (_vm:to_table_with_key(dt, '_isType.sling.model.PromiseDataTypeNode') ~= nil) == false then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type: `" .. _g.jk.lang.String:safeString(dt:getNodeTypeName()) .. "' in promise expression. Promise expected", dt, nil))
					end
					do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(dt), false) end
					do return end
				end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.PromiseLiteralExpressionNode') ~= nil) then
				local tp = xpr:getType()
				if not (tp ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Promise literal expression has no type", xpr, nil))
				end
				do xpr:setResolvedDataType(_g.sling.model.PromiseDataTypeNode:forPrimaryType(_g.sling.util.DataTypeUtil:dupAsDataType(tp)), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.GetAddressExpressionNode') ~= nil) then
				local pe = xpr:getExpression()
				if not (pe ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("AddressOfExpression has no primary expression", xpr, nil))
				end
				do self:resolveExpression(pe) end
				do xpr:setResolvedDataType(_g.sling.model.PointerDataTypeNode:forPrimaryType(_g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(pe, self))), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.GetReferenceExpressionNode') ~= nil) then
				local pe = xpr:getExpression()
				if not (pe ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("GetReferenceExpression has no primary expression", xpr, nil))
				end
				do self:resolveExpression(pe) end
				do xpr:setResolvedDataType(_g.sling.model.VariableReferenceDataTypeNode:forPrimaryType(_g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(pe, self))), false) end
				do return end
			end
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.GetValueExpressionNode') ~= nil) then
				local pe = xpr:getExpression()
				if not (pe ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("DereferenceExpression has no primary expression", xpr, nil))
				end
				do self:resolveExpression(pe) end
				do
					local dt = _g.sling.util.ExpressionUtil:getExpressionDataType(pe, self)
					if (_vm:to_table_with_key(dt, '_isType.sling.model.PointerDataTypeNode') ~= nil) then
						local dtp = dt
						do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(dtp:getPrimaryType()), false) end
					elseif (_vm:to_table_with_key(dt, '_isType.sling.model.VariableReferenceDataTypeNode') ~= nil) then
						local dtp = dt
						do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(dtp:getPrimaryType()), false) end
					else
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type is neither pointer nor variable reference", dt, nil))
					end
					do return end
				end
			end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported expression type in resolver: `" .. _g.jk.lang.String:safeString(xpr:getNodeTypeName()) .. "'", xpr, nil))
		end
	end
end

function sling.compiler.SlingTypeResolver:setSameResolvedType(xpr, child)
	do xpr:setResolvedDataType(_g.sling.util.DataTypeUtil:dupAsDataType(_g.sling.util.ExpressionUtil:getExpressionDataType(child, self)), false) end
end

function sling.compiler.SlingTypeResolver:resolveDataTypes(node)
	local array = _g.sling.util.FindUtil:findCompatibleNodes(node, "class:sling.model.ReferenceDataTypeNode", true, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local rdt = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ReferenceDataTypeNode')
				if rdt ~= nil then
					do self:resolveDataType(rdt) end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local array2 = _g.sling.util.FindUtil:findCompatibleNodes(node, "class:sling.model.ExpressionDataTypeNode", false, true, false)
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local xdt = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.ExpressionDataTypeNode')
					if xdt ~= nil then
						local xpr = xdt:getExpression()
						if xpr ~= nil then
							do self:resolveExpression(xpr) end
						end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:isSameTypeObject(primary, other)
	if primary == nil and other == nil then
		do return true end
	end
	if primary == nil or other == nil then
		do return false end
	end
	do
		local ta = _vm:get_datatype_info(primary)
		local tb = _vm:get_datatype_info(other)
		if ta == tb then
			do return true end
		end
		do return false end
	end
end

function sling.compiler.SlingTypeResolver:isSame(primary, other, typemap)
	if primary == nil and other == nil then
		do return true end
	end
	if primary == nil or other == nil then
		do return false end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local aother = _vm:to_table_with_key(other, '_isType.sling.common.DataTypeNode')
		local primdt = primary
		if primdt:getMagical() then
			if other == nil or (_vm:to_table_with_key(other, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) == false then
				do return false end
			end
			do return true end
		end
		do
			local tr = primdt
			if typemap ~= nil then
				local ntr = self:mapType(tr, typemap)
				if ntr ~= tr then
					do return self:isSame(ntr, aother, nil) end
				end
			end
			if tr ~= nil and (_vm:to_table_with_key(tr, '_isType.sling.model.UnknownDataTypeNode') ~= nil) then
				do return true end
			end
			do
				local otherref = _vm:to_table_with_key(aother, '_isType.sling.model.ReferenceDataTypeNode')
				if not (otherref ~= nil) then
					do return false end
				end
				do
					local me = _vm:to_table_with_key(tr, '_isType.sling.model.ReferenceDataTypeNode')
					if not (me ~= nil) then
						do return false end
					end
					do
						local r = self:getBoundEntity(me)
						local oref = self:getBoundEntity(otherref)
						if r ~= oref then
							if (_vm:to_table_with_key(r, '_isType.sling.model.TemplateDeclarationNode') ~= nil) and (_vm:to_table_with_key(oref, '_isType.sling.model.TemplateDeclarationNode') ~= nil) then
								do return self:isSameTemplate(r, oref, typemap) end
							end
							do return false end
						end
						do
							local tp1 = self:getTypeParametersForNode(me)
							local tp2 = self:getTypeParametersForNode(otherref)
							if _g.jk.lang.Vector:isEmpty(tp1) and _g.jk.lang.Vector:isEmpty(tp2) then
								do return true end
							end
							if tp1 == nil or tp2 == nil then
								do return false end
							end
							do
								local it1 = _g.jk.lang.Vector:iterate(tp1)
								local it2 = _g.jk.lang.Vector:iterate(tp2)
								while true do
									local o1 = _vm:to_table_with_key(it1:next(), '_isType.sling.common.DataTypeNode')
									if typemap ~= nil then
										o1 = self:mapType(o1, typemap)
									end
									do
										local o2 = _vm:to_table_with_key(it2:next(), '_isType.sling.common.DataTypeNode')
										if o1 == nil then
											if o2 == nil then
												do break end
											end
											do return false end
										end
										if o2 == nil then
											do return false end
										end
										if self:isSame(o1, o2, typemap) == false then
											do return false end
										end
									end
								end
								do return true end
							end
						end
					end
				end
			end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.ExpressionDataTypeNode') ~= nil) then
		local xdt = _g.sling.util.ExpressionUtil:getExpressionDataType(primary:getExpression(), nil)
		do return self:isSame(xdt, other, typemap) end
	end
	if not self:isSameTypeObject(primary, other) then
		do return false end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		if (_vm:to_table_with_key(other, '_isType.sling.model.IntegerDataTypeNode') ~= nil) == false then
			do return false end
		end
		do
			local ptype = primary:getType()
			local otype = other:getType()
			do return ptype == otype end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.MapDataTypeNode') ~= nil) then
		if (_vm:to_table_with_key(other, '_isType.sling.model.MapDataTypeNode') ~= nil) == false then
			do return false end
		end
		do
			local pm = primary
			local om = other
			if self:isSame(pm:getKeyType(), om:getKeyType(), typemap) == false then
				do return false end
			end
			if self:isSame(pm:getValueType(), om:getValueType(), typemap) == false then
				do return false end
			end
			do return true end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.MultiDimensionalArrayDataTypeNode') ~= nil) then
		local oa = _vm:to_table_with_key(other, '_isType.sling.model.MultiDimensionalArrayDataTypeNode')
		if not (oa ~= nil) then
			do return false end
		end
		do return oa:getDimensions() == primary:getDimensions() end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.MultipleDataTypeNode') ~= nil) then
		do return false end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.NullDataTypeNode') ~= nil) then
		do return false end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.PointerDataTypeNode') ~= nil) then
		local otherp = _vm:to_table_with_key(other, '_isType.sling.model.PointerDataTypeNode')
		if not (otherp ~= nil) then
			do return false end
		end
		do
			local tpt = primary:getPrimaryType()
			local opt = otherp:getPrimaryType()
			if tpt == nil and opt == nil then
				do return true end
			end
			if tpt ~= nil then
				do return self:isSame(tpt, opt, typemap) end
			end
			do return false end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.VariableReferenceDataTypeNode') ~= nil) then
		local otherp = _vm:to_table_with_key(other, '_isType.sling.model.VariableReferenceDataTypeNode')
		if not (otherp ~= nil) then
			do return false end
		end
		do
			local tpt = primary:getPrimaryType()
			local opt = otherp:getPrimaryType()
			if tpt == nil and opt == nil then
				do return true end
			end
			if tpt ~= nil then
				do return self:isSame(tpt, opt, typemap) end
			end
			do return false end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
		local othera = _vm:to_table_with_key(other, '_isType.sling.model.StaticArrayDataTypeNode')
		if not (othera ~= nil) then
			do return false end
		end
		do
			local thissize = primary:getSize()
			local othersize = othera:getSize()
			if thissize ~= nil or othersize ~= nil then
				if not (thissize ~= nil) then
					do return false end
				end
				if not (othersize ~= nil) then
					do return false end
				end
				if (_vm:to_table_with_key(thissize, '_isType.sling.model.IntegerLiteralExpressionNode') ~= nil) == false or (_vm:to_table_with_key(othersize, '_isType.sling.model.IntegerLiteralExpressionNode') ~= nil) == false then
					do return false end
				end
				if thissize:getValue() ~= othersize:getValue() then
					do return false end
				end
			end
			do return self:isSame(primary:getPrimaryType(), othera:getPrimaryType(), typemap) end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
		local otherv = _vm:to_table_with_key(other, '_isType.sling.model.VectorDataTypeNode')
		if not (otherv ~= nil) then
			do return false end
		end
		do return self:isSame(primary:getPrimaryType(), otherv:getPrimaryType(), typemap) end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.SetDataTypeNode') ~= nil) then
		local otherv = _vm:to_table_with_key(other, '_isType.sling.model.SetDataTypeNode')
		if not (otherv ~= nil) then
			do return false end
		end
		do return self:isSame(primary:getPrimaryType(), otherv:getPrimaryType(), typemap) end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.PromiseDataTypeNode') ~= nil) then
		local otherv = _vm:to_table_with_key(other, '_isType.sling.model.PromiseDataTypeNode')
		if not (otherv ~= nil) then
			do return false end
		end
		do return self:isSame(primary:getPrimaryType(), otherv:getPrimaryType(), typemap) end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
		if not (_vm:to_table_with_key(other, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
			do return false end
		end
		do
			local myee = _g.sling.util.FindUtil:findNearestEntity(primary)
			local ooee = _g.sling.util.FindUtil:findNearestEntity(other)
			do return myee == ooee end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.OptionalDataTypeNode') ~= nil) then
		local otherv = _vm:to_table_with_key(other, '_isType.sling.model.OptionalDataTypeNode')
		if not (otherv ~= nil) then
			do return false end
		end
		do
			local optpr1 = primary:getPrimaryType()
			if not (optpr1 ~= nil) then
				do return false end
			end
			do
				local optpr2 = otherv:getPrimaryType()
				if not (optpr2 ~= nil) then
					do return false end
				end
				do return self:isSame(optpr1, optpr2, typemap) end
			end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
		local primc = primary
		local otherc = _vm:to_table_with_key(other, '_isType.sling.model.ConstrainedDataTypeNode')
		if not (otherc ~= nil) then
			do return false end
		end
		if not self:isSame(primc:getPrimaryType(), otherc:getPrimaryType(), typemap) then
			do return false end
		end
		do
			local baseTypes = primc:getBaseTypes()
			if baseTypes ~= nil then
				local otl = otherc:getBaseTypes()
				if not (otl ~= nil) then
					do return false end
				end
				do
					local it1 = _g.jk.lang.Vector:iterate(baseTypes)
					local it2 = _g.jk.lang.Vector:iterate(otl)
					while true do
						local o1 = nil
						local o2 = nil
						if it1 ~= nil then
							o1 = _vm:to_table_with_key(it1:next(), '_isType.sling.common.DataTypeNode')
						end
						if it2 ~= nil then
							o2 = _vm:to_table_with_key(it2:next(), '_isType.sling.common.DataTypeNode')
						end
						if o1 == nil then
							if o2 == nil then
								do break end
							end
							do return false end
						end
						if o2 == nil then
							do return false end
						end
						if not self:isSame(o1, o2, typemap) then
							do return false end
						end
					end
				end
			end
			do return true end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
		local fother = _vm:to_table_with_key(other, '_isType.sling.model.FunctionDataTypeNode')
		if not (fother ~= nil) then
			do return false end
		end
		do return _g.sling.compiler.SlingTypeResolver:hasSameSignature(primary:getDeclaration(), fother:getDeclaration(), typemap, false, false, true) end
	end
	do return true end
end

function sling.compiler.SlingTypeResolver:isSameTemplate(primary, aother, typemap)
	if not (primary ~= nil) then
		do return false end
	end
	do
		local other = _vm:to_table_with_key(aother, '_isType.sling.model.TemplateDeclarationNode')
		if not (other ~= nil) then
			do return false end
		end
		do
			local bts1 = primary:getBaseTypes()
			local bts2 = other:getBaseTypes()
			if _g.jk.lang.Vector:isEmpty(bts1) then
				if _g.jk.lang.Vector:isEmpty(bts2) then
					do return true end
				end
				do return false end
			end
			if _g.jk.lang.Vector:isEmpty(bts2) then
				do return false end
			end
			do
				local n1 = 0
				local n2 = 0
				while true do
					if n1 >= _g.jk.lang.Vector:getSize(bts1) then
						if n2 >= _g.jk.lang.Vector:getSize(bts2) then
							do break end
						end
						do return false end
					end
					if n2 >= _g.jk.lang.Vector:getSize(bts2) then
						do return false end
					end
					do
						local bt1 = _vm:to_table_with_key(_g.jk.lang.Vector:get(bts1, n1), '_isType.sling.model.BaseTypeNode')
						local bt2 = _vm:to_table_with_key(_g.jk.lang.Vector:get(bts2, n2), '_isType.sling.model.BaseTypeNode')
						do n1 = n1 + 1 end
						do n2 = n2 + 1 end
						if bt1 == nil then
							if bt2 == nil then
								goto _continue60
							end
							do return false end
						end
						if bt2 == nil then
							do return false end
						end
						do
							local dt1 = bt1:getReferenceType()
							local dt2 = bt2:getReferenceType()
							if dt1 == nil then
								if dt2 == nil then
									goto _continue60
								end
								do return false end
							end
							if dt2 == nil then
								do return false end
							end
							if not self:isSame(dt1, dt2, typemap) then
								do return false end
							end
						end
					end
					::_continue60::
				end
				do return true end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:getPrimitiveDataTypeLikenessScore(primary, other)
	if not (primary ~= nil) then
		do return 0 end
	end
	if not (other ~= nil) then
		do return 0 end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		if other ~= nil and (_vm:to_table_with_key(other, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
			local tp1 = primary:getType()
			local tp2 = other:getType()
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 1 end
				end
			end
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
					do return 1 end
				end
			end
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_INT then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT then
					do return 3 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 1 end
				end
			end
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
					do return 3 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 1 end
				end
			end
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT then
					do return 4 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT16 then
					do return 3 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 1 end
				end
			end
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_INT16 then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT16 then
					do return 4 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT then
					do return 3 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 1 end
				end
			end
			if tp1 == _g.sling.model.IntegerDataTypeNode.TYPE_INT8 then
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT8 then
					do return 4 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_SHORT or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT16 then
					do return 3 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT32 then
					do return 2 end
				end
				if tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_LONG or tp2 == _g.sling.model.IntegerDataTypeNode.TYPE_INT64 then
					do return 1 end
				end
			end
		end
	end
	if (_vm:to_table_with_key(primary, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
		if other ~= nil then
			if (_vm:to_table_with_key(other, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
				do return 3 end
			end
			if (_vm:to_table_with_key(other, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
				do return 2 end
			end
			if (_vm:to_table_with_key(other, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
				do return 1 end
			end
		end
	end
	do return 0 end
end

function sling.compiler.SlingTypeResolver:isBaseDataTypeOf(entity, candidate)
	if not (entity ~= nil and candidate ~= nil) then
		do return false end
	end
	do
		local array = entity:getBaseTypes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local basetype = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
					if basetype ~= nil then
						local bound = self:getBoundEntity(basetype:getReferenceType())
						if not (bound ~= nil) then
							goto _continue61
						end
						do
							local ref = self:getBoundEntity(candidate)
							if not (ref ~= nil) then
								goto _continue61
							end
							if ref == bound then
								do return true end
							end
						end
					end
					::_continue61::
					do n = n + 1 end
				end
			end
		end
		do return false end
	end
end

function sling.compiler.SlingTypeResolver:matches(primary, other, typemap, exact, allowFloatDowncast)
	local pdt = self:getActualType(primary)
	local odt = self:getActualType(other)
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.StringDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
			do return true end
		end
		if not exact then
			if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
				do return true end
			end
			if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
				do return true end
			end
		end
		do return false end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
		if allowFloatDowncast then
			if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
				do return true end
			end
			if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.FloatDataTypeNode') ~= nil) then
				do return true end
			end
		end
		if exact then
			if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
				do return pdt:getType() == odt:getType() end
			end
		elseif odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
			do return true end
		end
		do return false end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.PromiseDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
			do return true end
		end
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.VectorDataTypeNode') ~= nil) then
			local othistype = pdt:getPrimaryType()
			local thistype = othistype
			local othertype = other:getPrimaryType()
			if typemap ~= nil then
				thistype = self:mapType(thistype, typemap)
			end
			if thistype ~= nil or othertype ~= nil then
				if thistype == nil then
					do return false end
				end
				if othertype == nil then
					do return false end
				end
				if (_vm:to_table_with_key(thistype, '_isType.sling.model.UnknownDataTypeNode') ~= nil) == false then
					if not self:isSame(othistype, othertype, typemap) then
						do return false end
					end
				end
			end
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
			do return true end
		end
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
			local othistype = pdt:getPrimaryType()
			local thistype = othistype
			local othertype = odt:getPrimaryType()
			if (_vm:to_table_with_key(othistype, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
				do return self:matches(othistype, othertype, typemap, false, false) end
			end
			if typemap ~= nil then
				thistype = self:mapType(thistype, typemap)
			end
			if thistype ~= nil or othertype ~= nil then
				if not (thistype ~= nil) then
					do return false end
				end
				if not (othertype ~= nil) then
					do return false end
				end
				if (_vm:to_table_with_key(thistype, '_isType.sling.model.UnknownDataTypeNode') ~= nil) == false then
					if not self:isSame(othistype, othertype, typemap) then
						do return false end
					end
				end
			end
			do
				local thissize = pdt:getSize()
				local othersize = odt:getSize()
				if thissize ~= nil or othersize ~= nil then
					if not (thissize ~= nil) then
						do return false end
					end
					if not (othersize ~= nil) then
						do return false end
					end
					if (_vm:to_table_with_key(thissize, '_isType.sling.model.IntegerLiteralExpressionNode') ~= nil) == false or (_vm:to_table_with_key(othersize, '_isType.sling.model.IntegerLiteralExpressionNode') ~= nil) == false then
						do return false end
					end
					if thissize:getValue() ~= othersize:getValue() then
						do return false end
					end
				end
				do return true end
			end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local refdt = pdt
		if refdt:getMagical() then
			do return true end
		end
		if typemap ~= nil then
			local ntr = self:mapType(pdt, typemap)
			if ntr ~= pdt then
				do return self:matches(ntr, odt, nil, false, false) end
			end
		end
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
			do return true end
		end
		if self:isSame(pdt, odt, typemap) then
			do return true end
		end
		if (_vm:to_table_with_key(odt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
			local ref = self:getBoundEntity(odt)
			if ref ~= nil then
				local array = ref:getBaseTypes()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local btn = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.BaseTypeNode')
							if btn ~= nil then
								local tt = btn:getReferenceType()
								if tt ~= nil and self:matches(pdt, tt, typemap, false, false) then
									do return true end
								end
							end
							do n = n + 1 end
						end
					end
				end
			end
		end
		do return false end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
		if odt ~= nil and ((_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.StringDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.VectorDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.MapDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.FunctionDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) or (_vm:to_table_with_key(odt, '_isType.sling.model.BufferDataTypeNode') ~= nil)) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.PointerDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.VariableReferenceDataTypeNode') ~= nil) then
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.DateTimeDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.DecimalDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.MapDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.UnknownDataTypeNode') ~= nil) then
		do return true end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
		do return true end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
		local baseTypes = pdt:getBaseTypes()
		if _g.jk.lang.Vector:isEmpty(baseTypes) then
			do return true end
		end
		if (_vm:to_table_with_key(other, '_isType.sling.model.ConstrainedDataTypeNode') ~= nil) then
			local bts = other:getBaseTypes()
			if bts ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(bts)
				do
					n2 = 0
					while n2 < m2 do
						local basetype = _vm:to_table_with_key(bts[n2 + 1], '_isType.sling.common.DataTypeNode')
						if basetype ~= nil then
							if self:matches(pdt, basetype, typemap, false, false) then
								do return true end
							end
						end
						do n2 = n2 + 1 end
					end
				end
			end
		end
		if baseTypes ~= nil then
			local n3 = 0
			local m3 = _g.jk.lang.Vector:getSize(baseTypes)
			do
				n3 = 0
				while n3 < m3 do
					local basetype = _vm:to_table_with_key(baseTypes[n3 + 1], '_isType.sling.common.DataTypeNode')
					if basetype ~= nil then
						if (_vm:to_table_with_key(other, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) and (_vm:to_table_with_key(basetype, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
							if self:isBaseDataTypeOf(self:getBoundEntity(other), basetype) then
								do return true end
							end
						end
						if self:matches(basetype, other, typemap, false, false) then
							do return true end
						end
					end
					do n3 = n3 + 1 end
				end
			end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	if (_vm:to_table_with_key(pdt, '_isType.sling.model.TypeInfoDataTypeNode') ~= nil) then
		if odt ~= nil and (_vm:to_table_with_key(odt, '_isType.sling.model.NullDataTypeNode') ~= nil) then
			do return true end
		end
		do return self:isSame(pdt, odt, typemap) end
	end
	do return self:isSame(pdt, odt, typemap) end
end

function sling.compiler.SlingTypeResolver:matchesCallParameters(fd, pms, typemap, exact, allowFloatDowncast)
	if not (fd ~= nil) then
		do return false end
	end
	do
		local myparams = fd:getParameters()
		local n1 = 0
		local n2 = 0
		while true do
			local vd = _vm:to_table_with_key(_g.jk.lang.Vector:get(myparams, n1), '_isType.sling.model.VariableDeclarationNode')
			local pp = _vm:to_table_with_key(_g.jk.lang.Vector:get(pms, n2), '_isType.sling.common.ExpressionNode')
			if vd == nil and pp == nil then
				do break end
			end
			if vd == nil and pp ~= nil then
				do return false end
			end
			if vd ~= nil and pp == nil then
				if vd:getInitializer() ~= nil then
					do break end
				end
				do return false end
			end
			do n1 = n1 + 1 end
			do n2 = n2 + 1 end
			do
				local dt1 = nil
				local dt2 = nil
				if vd ~= nil then
					dt1 = vd:getType()
				end
				if pp ~= nil then
					dt2 = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(pp, nil)
				end
				if not (dt1 ~= nil) then
					if not (dt2 ~= nil) then
						goto _continue62
					end
					do return false end
				end
				if not (dt2 ~= nil) then
					do return false end
				end
				if not self:matches(dt1, dt2, typemap, exact, allowFloatDowncast) then
					do return false end
				end
			end
			::_continue62::
		end
		do return true end
	end
end

function sling.compiler.SlingTypeResolver:getMatchingConstructor(entity, parameters, typemap)
	if not (entity ~= nil) then
		do return nil end
	end
	do
		local array = entity:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local ct = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ConstructorDeclarationNode')
					if ct ~= nil then
						if self:matchesCallParameters(ct, parameters, typemap, false, false) then
							do return ct end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return nil end
	end
end

function sling.compiler.SlingTypeResolver:isSameDeclaration(oba, obb, typemap, ignoreName)
	if oba == nil or obb == nil then
		do return false end
	end
	if ignoreName == false then
		local nta = oba:getNodeName()
		local ntb = obb:getNodeName()
		if not (nta == ntb) then
			do return false end
		end
	end
	do
		local typea = oba:getType()
		local typeb = obb:getType()
		if typea == nil then
			if typeb ~= nil then
				do return false end
			end
		elseif self:isSame(typea, typeb, typemap) == false then
			do return false end
		end
		do return true end
	end
end

function sling.compiler.SlingTypeResolver:compareParameterArrays(parameters, nps, typemap, ignoreVariableNames)
	if _g.jk.lang.Vector:isEmpty(nps) then
		if _g.jk.lang.Vector:isEmpty(parameters) then
			do return true end
		end
		do return false end
	end
	if _g.jk.lang.Vector:isEmpty(parameters) then
		do return false end
	end
	if _g.jk.lang.Vector:getSize(nps) ~= _g.jk.lang.Vector:getSize(parameters) then
		do return false end
	end
	do
		local ita = _g.jk.lang.Vector:iterate(parameters)
		local itb = _g.jk.lang.Vector:iterate(nps)
		if ita == nil then
			if itb ~= nil then
				do return false end
			end
			do return true end
		end
		if itb == nil then
			do return false end
		end
		while true do
			local oba = _vm:to_table_with_key(ita:next(), '_isType.sling.common.NodeObject')
			local obb = _vm:to_table_with_key(itb:next(), '_isType.sling.common.NodeObject')
			if oba == nil then
				if obb ~= nil then
					do return false end
				end
				do break end
			end
			if obb == nil then
				do return false end
			end
			if (_vm:to_table_with_key(oba, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
				if _g.sling.compiler.SlingTypeResolver:isSameDeclaration(oba, _vm:to_table_with_key(obb, '_isType.sling.model.VariableDeclarationNode'), typemap, ignoreVariableNames) == false then
					do return false end
				end
			elseif (_vm:to_table_with_key(oba, '_isType.sling.model.VariableArgumentsDeclarationNode') ~= nil) then
				local obbv = _vm:to_table_with_key(obb, '_isType.sling.model.VariableArgumentsDeclarationNode')
				if not (obbv ~= nil) then
					do return false end
				end
				if not _g.sling.compiler.SlingTypeResolver:isSameDeclaration(oba:getVariableDeclaration(), obbv:getVariableDeclaration(), typemap, ignoreVariableNames) then
					do return false end
				end
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unknown parameter node type when comparing signatures: `" .. _g.jk.lang.String:safeString(oba:getNodeTypeName()) .. "'", oba, nil))
				do return false end
			end
		end
		do return true end
	end
end

function sling.compiler.SlingTypeResolver:hasSameSignature(anode, bnode, typemap, ignoreType, ignoreParameters, ignoreName)
	if ignoreName == false then
		local nn = bnode:getNodeName()
		if not (nn ~= nil) then
			if anode:getNodeName() ~= nil then
				do return false end
			end
		elseif not (nn == anode:getNodeName()) then
			do return false end
		end
	end
	if ignoreType == false then
		local nt = bnode:getReturnType()
		local type = anode:getReturnType()
		if not (nt ~= nil) then
			if type ~= nil then
				do return false end
			end
		else
			if not (type ~= nil) then
				do return false end
			end
			if not self:isSame(type, nt, typemap) then
				do return false end
			end
		end
	end
	if ignoreParameters == false then
		if _g.sling.compiler.SlingTypeResolver:compareParameterArrays(anode:getParameters(), bnode:getParameters(), typemap, true) == false then
			do return false end
		end
	end
	do return true end
end

function sling.compiler.SlingTypeResolver:doFindBaseclassDeclaration(fdecl, ee, lookHere, typemap, ignoreType, ignoreParameters, typemapr)
	if ee == nil or (_vm:to_table_with_key(ee, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
		do return nil end
	end
	if lookHere then
		local array = ee:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local eef = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
					if eef ~= nil then
						if _g.sling.compiler.SlingTypeResolver:hasSameSignature(eef, fdecl, typemap, ignoreType, ignoreParameters, false) then
							if typemapr ~= nil then
								do typemapr:clear() end
								if typemap ~= nil then
									do typemap:copyTo(typemapr) end
								end
							end
							do return eef end
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do
		local array2 = ee:getBaseTypes()
		if array2 ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n2 = 0
				while n2 < m2 do
					local btn = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.BaseTypeNode')
					if btn ~= nil then
						local type = btn:getReferenceType()
						if not (type ~= nil) then
							goto _continue63
						end
						do
							local ref = self:getBoundEntity(type)
							if not (ref ~= nil) then
								goto _continue63
							end
							if (_vm:to_table_with_key(ref, '_isType.sling.model.MagicalClassDeclarationNode') ~= nil) then
								goto _continue63
							end
							do
								local ntypemap = nil
								local tps = self:getTypeParametersForNode(type)
								if tps ~= nil then
									ntypemap = self:createTypeMapforEntity(_vm:to_table_with_key(ref, '_isType.sling.model.GenericCapableEntityDeclarationNode'), tps)
								end
								if ref ~= nil then
									local mf = _g.sling.compiler.SlingTypeResolver:doFindBaseclassDeclaration(fdecl, ref, true, ntypemap, ignoreType, ignoreParameters, typemapr)
									if mf ~= nil then
										do return mf end
									end
								end
							end
						end
					end
					::_continue63::
					do n2 = n2 + 1 end
				end
			end
		end
		do return nil end
	end
end

function sling.compiler.SlingTypeResolver:tryFindBaseclassDeclaration(fdecl, ignoreType, ignoreParameters, typemapr)
	if not (fdecl ~= nil) then
		do return nil end
	end
	do
		local pp = _vm:to_table_with_key(fdecl:getParent(), '_isType.sling.model.EntityDeclarationNode')
		if not (pp ~= nil) then
			do return nil end
		end
		do
			local v = _g.sling.compiler.SlingTypeResolver:doFindBaseclassDeclaration(fdecl, pp, false, nil, ignoreType, ignoreParameters, typemapr)
			do return v end
		end
	end
end

function sling.compiler.SlingTypeResolver:resolveBaseClassDeclaration(fdecl, requireModifier)
	if not (fdecl ~= nil) then
		do return end
	end
	do
		local bd = fdecl:getBaseClassDeclaration()
		if bd ~= nil then
			do return end
		end
		do
			local hasModifier = fdecl:hasModifier(_g.sling.model.Modifier.OVERRIDE)
			if requireModifier == false or hasModifier then
				local typemapr = _g.sling.common.TypeMap._construct0(_g.sling.common.TypeMap._create())
				local bcd = _g.sling.compiler.SlingTypeResolver:tryFindBaseclassDeclaration(fdecl, false, false, typemapr)
				if bcd == nil and hasModifier then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find base class declaration for overriding method", fdecl, nil))
				end
				do fdecl:setBaseClassDeclaration(bcd, typemapr) end
				if bcd ~= nil then
					do bcd:addToOverridingDeclarations(fdecl) end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:doFindImplementedInterfaceMethods(v, fdecl, ee, lookHere, typemap, typemapr)
	if not (v ~= nil) then
		do return end
	end
	do
		local ii = _vm:to_table_with_key(ee, '_isType.sling.model.InterfaceDeclarationNode')
		if ii ~= nil and lookHere then
			local array = ii:getNodes()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local eef = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
						if eef ~= nil then
							if _g.sling.compiler.SlingTypeResolver:hasSameSignature(eef, fdecl, typemap, false, false, false) then
								if typemapr ~= nil then
									do typemapr:clear() end
									if typemap ~= nil then
										do typemap:copyTo(typemapr) end
									end
								end
								do _g.jk.lang.Vector:append(v, eef) end
								do break end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
		do
			local array2 = ee:getBaseTypes()
			if array2 ~= nil then
				local n2 = 0
				local m2 = _g.jk.lang.Vector:getSize(array2)
				do
					n2 = 0
					while n2 < m2 do
						local btn = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.BaseTypeNode')
						if btn ~= nil then
							local type = btn:getReferenceType()
							if not (type ~= nil) then
								goto _continue64
							end
							do
								local ref = self:getBoundEntity(type)
								if not (ref ~= nil) then
									goto _continue64
								end
								if (_vm:to_table_with_key(ref, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
								elseif (_vm:to_table_with_key(ref, '_isType.sling.model.ClassDeclarationNode') ~= nil) and ref:hasModifier(_g.sling.model.Modifier.ABSTRACT) then
								else
									goto _continue64
								end
								do
									local ntypemap = nil
									local tps = self:getTypeParametersForNode(type)
									if tps ~= nil then
										ntypemap = self:createTypeMapforEntity(_vm:to_table_with_key(ref, '_isType.sling.model.GenericCapableEntityDeclarationNode'), tps)
									end
									if ref ~= nil then
										do self:doFindImplementedInterfaceMethods(v, fdecl, ref, true, ntypemap, typemapr) end
									end
								end
							end
						end
						::_continue64::
						do n2 = n2 + 1 end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:findImplementedInterfaceMethod(fdecl)
	if not (fdecl ~= nil) then
		do return nil end
	end
	do
		local v = fdecl:getImplementedDeclarations()
		if not (v ~= nil) then
			local ee = _vm:to_table_with_key(fdecl:getParent(), '_isType.sling.model.EntityDeclarationNode')
			if not (ee ~= nil) then
				do return nil end
			end
			v = {}
			do self:doFindImplementedInterfaceMethods(v, fdecl, ee, false, nil, nil) end
		end
		do return _g.jk.lang.Vector:get(v, 0) end
	end
end

function sling.compiler.SlingTypeResolver:findAllImplementedInterfaceMethods(fdecl, force)
	if not (fdecl ~= nil) then
		do return nil end
	end
	do
		local v = fdecl:getImplementedDeclarations()
		if not (v ~= nil) or force then
			local ee = _vm:to_table_with_key(fdecl:getParent(), '_isType.sling.model.EntityDeclarationNode')
			if not (ee ~= nil) then
				do return nil end
			end
			v = {}
			do self:doFindImplementedInterfaceMethods(v, fdecl, ee, false, nil, nil) end
		end
		do return v end
	end
end

function sling.compiler.SlingTypeResolver:resolveImplementedInterfaces(fdecl, force)
	if not (fdecl ~= nil) then
		do return end
	end
	do
		local impls = self:findAllImplementedInterfaceMethods(fdecl, force)
		do fdecl:setImplementedDeclarations(impls) end
		if impls ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(impls)
			do
				n = 0
				while n < m do
					local impl = impls[n + 1]
					if impl ~= nil then
						do impl:addToOverridingDeclarations(fdecl) end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

sling.compiler.SlingTypeResolver.DataTypeResolverVisitor = _g.sling.common.NodeVisitor._create()
sling.compiler.SlingTypeResolver.DataTypeResolverVisitor.__index = sling.compiler.SlingTypeResolver.DataTypeResolverVisitor
_vm:set_metatable(sling.compiler.SlingTypeResolver.DataTypeResolverVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingTypeResolver.DataTypeResolverVisitor)
	return v
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingTypeResolver.DataTypeResolverVisitor'
	self['_isType.sling.compiler.SlingTypeResolver.DataTypeResolverVisitor'] = true
	self.resolver = nil
	self.ignoreErrors = false
	self.ctx = nil
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:_construct0()
	sling.compiler.SlingTypeResolver.DataTypeResolverVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) and node:hasCustomModifier("macro") then
		do self:setSkipChildren(true) end
	elseif (_vm:to_table_with_key(node, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		if self.ignoreErrors then
			do self.resolver:tryResolveDataType(self.ctx, node) end
		else
			do self.resolver:resolveDataType(node) end
		end
	end
	do return true end
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:getResolver()
	do return self.resolver end
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:setResolver(v)
	self.resolver = v
	do return self end
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:getIgnoreErrors()
	do return self.ignoreErrors end
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:setIgnoreErrors(v)
	self.ignoreErrors = v
	do return self end
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:getCtx()
	do return self.ctx end
end

function sling.compiler.SlingTypeResolver.DataTypeResolverVisitor:setCtx(v)
	self.ctx = v
	do return self end
end

sling.compiler.SlingTypeResolver.ExpressionResolverVisitor = _g.sling.common.NodeVisitor._create()
sling.compiler.SlingTypeResolver.ExpressionResolverVisitor.__index = sling.compiler.SlingTypeResolver.ExpressionResolverVisitor
_vm:set_metatable(sling.compiler.SlingTypeResolver.ExpressionResolverVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingTypeResolver.ExpressionResolverVisitor)
	return v
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingTypeResolver.ExpressionResolverVisitor'
	self['_isType.sling.compiler.SlingTypeResolver.ExpressionResolverVisitor'] = true
	self.resolver = nil
	self.ignoreErrors = false
	self.ctx = nil
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:_construct0()
	sling.compiler.SlingTypeResolver.ExpressionResolverVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) and node:hasCustomModifier("macro") then
		do self:setSkipChildren(true) end
	elseif (_vm:to_table_with_key(node, '_isType.sling.common.ExpressionNode') ~= nil) then
		if self.ignoreErrors then
			do
				local _status, _err = _vm:execute_protected_call(function()
					do self.resolver:resolveExpression(node) end
				end)
				if _err then
					if (_vm:to_table_with_key(_err, '_isType.sling.common.ReferenceError') ~= nil) then
						local e = _err
						if self.ctx ~= nil and self.ctx:isInDebugMode() then
							do _g.jk.log.Log:debug(self.ctx, e:toStringWithDebug(true)) end
						end
					else
						_vm:throw_error(_err)
					end
				end
			end
		else
			do self.resolver:resolveExpression(node) end
		end
	end
	do return true end
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:getResolver()
	do return self.resolver end
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:setResolver(v)
	self.resolver = v
	do return self end
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:getIgnoreErrors()
	do return self.ignoreErrors end
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:setIgnoreErrors(v)
	self.ignoreErrors = v
	do return self end
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:getCtx()
	do return self.ctx end
end

function sling.compiler.SlingTypeResolver.ExpressionResolverVisitor:setCtx(v)
	self.ctx = v
	do return self end
end

function sling.compiler.SlingTypeResolver:execute(node)
	if node ~= nil then
		do node:accept(_g.sling.compiler.SlingTypeResolver.DataTypeResolverVisitor._construct0(_g.sling.compiler.SlingTypeResolver.DataTypeResolverVisitor._create()):setResolver(self)) end
		do node:accept(_g.sling.compiler.SlingTypeResolver.ExpressionResolverVisitor._construct0(_g.sling.compiler.SlingTypeResolver.ExpressionResolverVisitor._create()):setResolver(self)) end
	end
end

function sling.compiler.SlingTypeResolver:tryExecute(ctx, node)
	if node ~= nil then
		do node:accept(_g.sling.compiler.SlingTypeResolver.DataTypeResolverVisitor._construct0(_g.sling.compiler.SlingTypeResolver.DataTypeResolverVisitor._create()):setCtx(ctx):setIgnoreErrors(true):setResolver(self)) end
		do node:accept(_g.sling.compiler.SlingTypeResolver.ExpressionResolverVisitor._construct0(_g.sling.compiler.SlingTypeResolver.ExpressionResolverVisitor._create()):setCtx(ctx):setIgnoreErrors(true):setResolver(self)) end
	end
end

function sling.compiler.SlingTypeResolver:resolveBaseClassDeclarationsForMethods(ctx, root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.FunctionDeclarationNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local ff = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.FunctionDeclarationNode')
				if ff ~= nil then
					if (_vm:to_table_with_key(ff:getParent(), '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
						goto _continue65
					end
					if ff:hasCustomModifier("magical") == false then
						do self:resolveBaseClassDeclaration(ff, false) end
					end
					do self:resolveImplementedInterfaces(ff, false) end
				end
				::_continue65::
				do n = n + 1 end
			end
		end
	end
end

function sling.compiler.SlingTypeResolver:getIgnoreFailedPaths()
	do return self.ignoreFailedPaths end
end

function sling.compiler.SlingTypeResolver:setIgnoreFailedPaths(v)
	self.ignoreFailedPaths = v
	do return self end
end

sling.compiler.SlingPreprocessor = {}
sling.compiler.SlingPreprocessor.__index = sling.compiler.SlingPreprocessor
_vm:set_metatable(sling.compiler.SlingPreprocessor, {})

function sling.compiler.SlingPreprocessor._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingPreprocessor)
	return v
end

function sling.compiler.SlingPreprocessor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingPreprocessor'
	self['_isType.sling.compiler.SlingPreprocessor'] = true
	self.variables = nil
	self.ctx = nil
end

function sling.compiler.SlingPreprocessor:_construct0()
	sling.compiler.SlingPreprocessor._init(self)
	return self
end

sling.compiler.SlingPreprocessor.MyVisitor = _g.sling.common.NodeVisitor._create()
sling.compiler.SlingPreprocessor.MyVisitor.__index = sling.compiler.SlingPreprocessor.MyVisitor
_vm:set_metatable(sling.compiler.SlingPreprocessor.MyVisitor, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.SlingPreprocessor.MyVisitor._create()
	local v = _vm:set_metatable({}, sling.compiler.SlingPreprocessor.MyVisitor)
	return v
end

function sling.compiler.SlingPreprocessor.MyVisitor:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.SlingPreprocessor.MyVisitor'
	self['_isType.sling.compiler.SlingPreprocessor.MyVisitor'] = true
	self.ifs = nil
	self.values = nil
	self.thiss = nil
	self.parents = nil
	self.errors = nil
	self.resources = nil
	self.templates = nil
end

function sling.compiler.SlingPreprocessor.MyVisitor:_construct0()
	sling.compiler.SlingPreprocessor.MyVisitor._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.SlingPreprocessor.MyVisitor:visit(node)
	if node == nil then
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ThisDataTypeNode') ~= nil) then
		if self.thiss == nil then
			self.thiss = {}
		end
		do _g.jk.lang.Vector:append(self.thiss, node) end
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ParentDataTypeNode') ~= nil) then
		if self.parents == nil then
			self.parents = {}
		end
		do _g.jk.lang.Vector:append(self.parents, node) end
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreprocessorIfStatementNode') ~= nil) then
		if self.ifs == nil then
			self.ifs = {}
		end
		do _g.jk.lang.Vector:append(self.ifs, node) end
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreprocessorValueExpressionNode') ~= nil) then
		if self.values == nil then
			self.values = {}
		end
		do _g.jk.lang.Vector:append(self.values, node) end
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ErrorStatementNode') ~= nil) then
		if self.errors == nil then
			self.errors = {}
		end
		do _g.jk.lang.Vector:append(self.errors, node) end
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ResourceFileNode') ~= nil) then
		if self.resources == nil then
			self.resources = {}
		end
		do _g.jk.lang.Vector:append(self.resources, node) end
		do return true end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TemplateStatementNode') ~= nil) then
		if self.templates == nil then
			self.templates = {}
		end
		do _g.jk.lang.Vector:append(self.templates, node) end
		do return true end
	end
	do return true end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getIfs()
	do return self.ifs end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setIfs(v)
	self.ifs = v
	do return self end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getValues()
	do return self.values end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setValues(v)
	self.values = v
	do return self end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getThiss()
	do return self.thiss end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setThiss(v)
	self.thiss = v
	do return self end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getParents()
	do return self.parents end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setParents(v)
	self.parents = v
	do return self end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getErrors()
	do return self.errors end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setErrors(v)
	self.errors = v
	do return self end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getResources()
	do return self.resources end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setResources(v)
	self.resources = v
	do return self end
end

function sling.compiler.SlingPreprocessor.MyVisitor:getTemplates()
	do return self.templates end
end

function sling.compiler.SlingPreprocessor.MyVisitor:setTemplates(v)
	self.templates = v
	do return self end
end

function sling.compiler.SlingPreprocessor:forDefines(defines)
	local v = _g.sling.compiler.SlingPreprocessor._construct0(_g.sling.compiler.SlingPreprocessor._create())
	if defines ~= nil then
		local array = defines:getKeys()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local key = array[n + 1]
					if key ~= nil then
						do v:set(key, defines:getString(key, nil)) end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do return v end
end

function sling.compiler.SlingPreprocessor:set(key, value)
	if not (self.variables ~= nil) then
		self.variables = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	end
	do self.variables:setString(key, value) end
end

function sling.compiler.SlingPreprocessor:evaluate(cond)
	if not (cond ~= nil) then
		do return false end
	end
	if (_vm:to_table_with_key(cond, '_isType.sling.model.LogicalOrExpressionNode') ~= nil) then
		if self:evaluate(cond:getLeft()) then
			do return true end
		end
		if self:evaluate(cond:getRight()) then
			do return true end
		end
		do return false end
	end
	if (_vm:to_table_with_key(cond, '_isType.sling.model.LogicalAndExpressionNode') ~= nil) then
		if not self:evaluate(cond:getLeft()) then
			do return false end
		end
		if not self:evaluate(cond:getRight()) then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(cond, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) then
		if self:evaluate(cond:getExpression()) then
			do return false end
		end
		do return true end
	end
	if (_vm:to_table_with_key(cond, '_isType.sling.model.PreprocessorIsDefinedExpressionNode') ~= nil) then
		local v2 = cond:getVariable()
		if _g.jk.lang.String:isNotEmpty(v2) then
			local oo = self:getVariableValue(v2, self.variables, cond)
			if oo ~= nil then
				do return true end
			end
		end
		do return false end
	end
	do _g.sling.common.RefLog:error(self.ctx, "Node not supported in preprocessor context", cond, nil) end
	do return false end
end

function sling.compiler.SlingPreprocessor:getVariableValue(variable, variables, node)
	if not (node ~= nil) then
		do return nil end
	end
	if not (variable ~= nil) then
		do return nil end
	end
	if _g.jk.lang.String:startsWith(variable, "__", 0) and _g.jk.lang.String:endsWith(variable, "__") then
		local token = _vm:to_table_with_key(node:getSource(), '_isType.sling.common.Token')
		if token == nil then
			local nn = node
			while nn ~= nil do
				token = _vm:to_table_with_key(nn:getSource(), '_isType.sling.common.Token')
				if token ~= nil then
					do break end
				end
				nn = nn:getParent()
			end
		end
		if token ~= nil then
			if variable == "__LINE__" then
				do return _g.jk.lang.String:forInteger(token.line + 1) end
			end
			if variable == "__COLUMN__" then
				do return _g.jk.lang.String:forInteger(token.column + 1) end
			end
			if variable == "__FILE__" then
				local src = token.source
				if not (src ~= nil) then
					do return nil end
				end
				do
					local file = src:getFile()
					if not (file ~= nil) then
						do return nil end
					end
					do return file:getBasename() end
				end
			end
		end
		if variable == "__THIS__" or variable == "__THIS_SYMBOL__" then
			local ee = _g.sling.util.FindUtil:findNearestEntity(node)
			if not (ee ~= nil) then
				do return nil end
			end
			do return ee:getNodeName() end
		end
		if variable == "__THISQN__" then
			local ee = _g.sling.util.FindUtil:findNearestEntity(node)
			if not (ee ~= nil) then
				do return nil end
			end
			do return _g.sling.util.NodeUtil:getQualifiedNameString(ee, 46) end
		end
	end
	if not (variables ~= nil) then
		do return nil end
	end
	do return variables:getString(variable, nil) end
end

function sling.compiler.SlingPreprocessor:execute(root)
	if not (root ~= nil) then
		do return end
	end
	do
		local vv = _g.sling.compiler.SlingPreprocessor.MyVisitor._construct0(_g.sling.compiler.SlingPreprocessor.MyVisitor._create())
		if not root:accept(vv) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to execute visitor", root, nil))
		end
		do
			local values = vv:getValues()
			if values ~= nil then
				if values ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(values)
					do
						n = 0
						while n < m do
							local value = _vm:to_table_with_key(values[n + 1], '_isType.sling.model.PreprocessorValueExpressionNode')
							if value ~= nil then
								if value:getParent() == nil then
									goto _continue66
								end
								do
									local variable = value:getVariable()
									if _g.jk.lang.String:isEmpty(variable) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty variable", value, nil))
									end
									do
										local str = self:getVariableValue(variable, self.variables, value)
										if str == nil then
											do _g.sling.common.RefLog:warning(self.ctx, "Variable `" .. _g.jk.lang.String:safeString(variable) .. "' is not defined", value) end
											str = ""
										end
										do
											local ltr = _g.sling.model.StringLiteralExpressionNode:forValue(str)
											if variable == "__THIS_SYMBOL__" or variable == "__THISQN__" then
												do ltr:addCustomModifier("symbol") end
											elseif variable == "__LINE__" then
												do ltr:addCustomModifier("preprocessorLineValue") end
											elseif variable == "__COLUMN__" then
												do ltr:addCustomModifier("preprocessorColumnValue") end
											elseif variable == "__FILE__" then
												do ltr:addCustomModifier("preprocessorFileValue") end
											elseif variable == "__THIS__" then
												do ltr:addCustomModifier("preprocessorThisValue") end
											end
											if not value:replaceWith(ltr, false) then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to replace node", value, nil))
											end
										end
									end
								end
							end
							::_continue66::
							do n = n + 1 end
						end
					end
				end
			end
			do
				local ifs = vv:getIfs()
				if ifs ~= nil then
					local it = _g.jk.lang.Vector:iterateReverse(ifs)
					while it ~= nil do
						local pif = _vm:to_table_with_key(it:next(), '_isType.sling.model.PreprocessorIfStatementNode')
						if pif == nil then
							do break end
						end
						if pif:getParent() == nil then
							do _g.sling.common.RefLog:debug(self.ctx, "Skipping a preprocessor if statement with no parent", pif) end
							goto _continue67
						end
						do
							local cond = pif:getCondition()
							if not (cond ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", pif, nil))
							end
							do
								local cb = nil
								if self:evaluate(cond) then
									cb = pif:getIfBlock()
								else
									cb = pif:getElseBlock()
								end
								if cb ~= nil then
									local cbnodes = cb:getNodes()
									if cbnodes ~= nil and _g.jk.lang.Vector:getSize(cbnodes) == 1 then
										local thenode = _vm:to_table_with_key(_g.jk.lang.Vector:get(cbnodes, 0), '_isType.sling.common.NodeObject')
										do cb:exportNodes() end
										if not pif:replaceWith(thenode, false) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to replace node", pif, nil))
										end
										goto _continue67
									end
									do
										local pcont = _vm:to_table_with_key(pif:getParent(), '_isType.sling.common.ContainerNode')
										if not (pcont ~= nil) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Parent is not a ContainerNode. Cannot insert block contents.", pif, nil))
										end
										do
											local ip = pcont:getInsertionPointForNode(pif)
											if not (ip ~= nil) then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get insertion point for this node", pif, nil))
											end
											do
												local nds = cb:exportNodes()
												if nds ~= nil then
													local n2 = 0
													local m2 = _g.jk.lang.Vector:getSize(nds)
													do
														n2 = 0
														while n2 < m2 do
															local node = _vm:to_table_with_key(nds[n2 + 1], '_isType.sling.common.NodeObject')
															if node ~= nil then
																if not ip:insertBefore(node) then
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insert replacement node: `" .. _g.jk.lang.String:safeString(node:getNodeTypeName()) .. "'", pif, nil))
																end
															end
															do n2 = n2 + 1 end
														end
													end
												end
											end
										end
									end
								end
								if not pif:remove() then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to remove node", pif, nil))
								end
							end
						end
						::_continue67::
					end
				end
				do
					local thiss = vv:getThiss()
					if thiss ~= nil then
						if thiss ~= nil then
							local n3 = 0
							local m3 = _g.jk.lang.Vector:getSize(thiss)
							do
								n3 = 0
								while n3 < m3 do
									local ts = _vm:to_table_with_key(thiss[n3 + 1], '_isType.sling.model.ThisDataTypeNode')
									if ts ~= nil then
										if ts:getParent() == nil then
											goto _continue68
										end
										do
											local ee = _g.sling.util.FindUtil:findNearestEntity(ts)
											if not (ee ~= nil) then
												_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`this' encountered without an enclosing entity.", ts, nil))
											end
											do
												local ndt = _g.sling.model.ReferenceDataTypeNode:forNode(ee, nil)
												local gee = _vm:to_table_with_key(ee, '_isType.sling.model.GenericCapableEntityDeclarationNode')
												if gee ~= nil then
													local tps = {}
													local array = gee:getGenericTypes()
													if array ~= nil then
														local n4 = 0
														local m4 = _g.jk.lang.Vector:getSize(array)
														do
															n4 = 0
															while n4 < m4 do
																local temp = _vm:to_table_with_key(array[n4 + 1], '_isType.sling.model.TemplateDeclarationNode')
																if temp ~= nil then
																	do _g.jk.lang.Vector:append(tps, _g.sling.model.ReferenceDataTypeNode:forNode(temp, nil)) end
																end
																do n4 = n4 + 1 end
															end
														end
													end
													do
														local sym = ndt:getSymbol()
														if sym ~= nil then
															do sym:setTypeParameters(tps, false) end
														end
													end
												end
												do _g.sling.util.NodeUtil:replaceNode(ts, ndt) end
											end
										end
									end
									::_continue68::
									do n3 = n3 + 1 end
								end
							end
						end
					end
					do
						local parents = vv:getParents()
						if parents ~= nil then
							if parents ~= nil then
								local n5 = 0
								local m5 = _g.jk.lang.Vector:getSize(parents)
								do
									n5 = 0
									while n5 < m5 do
										local ts = _vm:to_table_with_key(parents[n5 + 1], '_isType.sling.model.ParentDataTypeNode')
										if ts ~= nil then
											if ts:getParent() == nil then
												goto _continue69
											end
											do
												local ee = _g.sling.util.FindUtil:findNearestEntity(ts)
												if not (ee ~= nil) then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`parent' encountered without an enclosing entity.", ts, nil))
												end
												do
													local ee2 = _g.sling.util.FindUtil:findNearestEntity(ee)
													if not (ee2 ~= nil) then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`parent' encountered in a top level entity.", ts, nil))
													end
													do
														local ndt = _g.sling.model.ReferenceDataTypeNode:forNode(ee2, nil)
														local gee = _vm:to_table_with_key(ee2, '_isType.sling.model.GenericCapableEntityDeclarationNode')
														if gee ~= nil then
															local tps = {}
															local array2 = gee:getGenericTypes()
															if array2 ~= nil then
																local n6 = 0
																local m6 = _g.jk.lang.Vector:getSize(array2)
																do
																	n6 = 0
																	while n6 < m6 do
																		local temp = _vm:to_table_with_key(array2[n6 + 1], '_isType.sling.model.TemplateDeclarationNode')
																		if temp ~= nil then
																			do _g.jk.lang.Vector:append(tps, _g.sling.model.ReferenceDataTypeNode:forNode(temp, nil)) end
																		end
																		do n6 = n6 + 1 end
																	end
																end
															end
															do
																local sym = ndt:getSymbol()
																if sym ~= nil then
																	do sym:setTypeParameters(tps, false) end
																end
															end
														end
														do _g.sling.util.NodeUtil:replaceNode(ts, ndt) end
													end
												end
											end
										end
										::_continue69::
										do n5 = n5 + 1 end
									end
								end
							end
						end
						do
							local resources = vv:getResources()
							if resources ~= nil then
								if resources ~= nil then
									local n7 = 0
									local m7 = _g.jk.lang.Vector:getSize(resources)
									do
										n7 = 0
										while n7 < m7 do
											local resource = _vm:to_table_with_key(resources[n7 + 1], '_isType.sling.model.ResourceFileNode')
											if resource ~= nil then
												local condition = resource:getCondition()
												if _g.jk.lang.String:isEmpty(condition) then
													goto _continue70
												end
												do
													local oo = self:getVariableValue(condition, self.variables, resource)
													if oo ~= nil then
														goto _continue70
													end
													if not resource:remove() then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to remove resource node that does not match preprocessor rules", resource, nil))
													end
												end
											end
											::_continue70::
											do n7 = n7 + 1 end
										end
									end
								end
							end
							do
								local templates = vv:getTemplates()
								if templates ~= nil then
									if templates ~= nil then
										local n8 = 0
										local m8 = _g.jk.lang.Vector:getSize(templates)
										do
											n8 = 0
											while n8 < m8 do
												local template = templates[n8 + 1]
												if template ~= nil then
													local pcont = _vm:to_table_with_key(template:getParent(), '_isType.sling.common.ContainerNode')
													if not (pcont ~= nil) then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Parent is not a ContainerNode. Cannot insert block contents.", template, nil))
													end
													do
														local ip = pcont:getInsertionPointForNode(template)
														if not (ip ~= nil) then
															_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get insertion point for this node", template, nil))
														end
														do
															local name = template:getName()
															if _g.jk.lang.String:isEmpty(name) then
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No filename for template", template, nil))
															end
															do
																local relativeTo = template:getRelativeTo()
																if not (relativeTo ~= nil) then
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No relative path for template", template, nil))
																end
																do
																	local file = relativeTo:getParent()
																	name = _g.jk.lang.String:replaceCharacter(name, 92, 47)
																	do
																		local array3 = _g.jk.lang.String:split(name, 47, 0)
																		if array3 ~= nil then
																			local n9 = 0
																			local m9 = _g.jk.lang.Vector:getSize(array3)
																			do
																				n9 = 0
																				while n9 < m9 do
																					local comp = array3[n9 + 1]
																					if comp ~= nil then
																						if _g.jk.lang.String:isEmpty(comp) or comp == "." or comp == ".." then
																							goto _continue71
																						end
																						file = file:entry(comp)
																					end
																					::_continue71::
																					do n9 = n9 + 1 end
																				end
																			end
																		end
																		if not self:processTemplateFile(template, file, template:getSymbol(), ip) then
																			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process template file: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(file)) .. "'", template, nil))
																		end
																		if not template:remove() then
																			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to remove processed template node", template, nil))
																		end
																	end
																end
															end
														end
													end
												end
												do n8 = n8 + 1 end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingPreprocessor:processTemplateFile(node, file, symbol, ip)
	if not (file ~= nil) then
		do return false end
	end
	if not (symbol ~= nil) then
		do return false end
	end
	if not (ip ~= nil) then
		do return false end
	end
	do
		local content = file:getContentsUTF8()
		if not (content ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read file: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(file)) .. "'", node, nil))
		end
		do
			local it = _g.jk.lang.String:iterate(content)
			if not (it ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to iterate over file contents: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(file)) .. "'", node, nil))
			end
			do
				local code = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				local isCode = false
				local pc = 0
				while true do
					local c = it:getNextChar()
					if isCode and pc == 37 then
						if c == 125 then
							local cs = sb:toString()
							do sb:clear() end
							if _g.jk.lang.String:startsWith(cs, "=", 0) then
								do code:appendString(_g.sling.util.SymbolUtil:getSymbolNamesString(symbol, 46)) end
								do code:appendString(".appendString(") end
								do code:appendString(_g.jk.lang.String:strip(_g.jk.lang.String:getEndOfString(cs, 1))) end
								do code:appendString(")\n") end
							else
								do code:appendString(cs) end
								do code:appendCharacter(10) end
							end
							isCode = false
							pc = 0
							goto _continue72
						end
						do sb:appendCharacter(pc) end
					end
					if isCode == false and pc == 123 then
						if c == 37 then
							local text = sb:toString()
							do sb:clear() end
							do code:appendString(_g.sling.util.SymbolUtil:getSymbolNamesString(symbol, 46)) end
							do code:appendString(".appendString(\"") end
							do code:appendString(_g.sling.common.CodeStringUtil:escapeStringLiteralCStyle(text)) end
							do code:appendString("\")\n") end
							isCode = true
							pc = 0
							goto _continue72
						end
						do sb:appendCharacter(pc) end
					end
					if isCode and c == 37 then
						pc = c
						goto _continue72
					end
					if isCode == false and c == 123 then
						pc = c
						goto _continue72
					end
					if c < 1 then
						do break end
					end
					do sb:appendCharacter(c) end
					pc = c
					::_continue72::
				end
				if isCode then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("File ends with an open code segment: `" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(file)) .. "'", node, nil))
				end
				do
					local text = sb:toString()
					if _g.jk.lang.String:isEmpty(text) == false then
						do code:appendString(_g.sling.util.SymbolUtil:getSymbolNamesString(symbol, 46)) end
						do code:appendString(".appendString(\"") end
						do code:appendString(_g.sling.common.CodeStringUtil:escapeStringLiteralCStyle(text)) end
						do code:appendString("\")\n") end
					end
					do
						local codestr = code:toString()
						if _g.jk.lang.String:isEmpty(codestr) == false then
							local stmts = _g.sling.syntax.SlingParser._construct0(_g.sling.syntax.SlingParser._create()):parseStringAsStatements(codestr, "[" .. _g.jk.lang.String:safeString(_g.sling.common.MessageFormatter:getFilePath(file)) .. "]")
							if not (stmts ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to parse embedded code", node, nil))
							end
							do
								local array = stmts:exportNodes()
								if array ~= nil then
									local n = 0
									local m = _g.jk.lang.Vector:getSize(array)
									do
										n = 0
										while n < m do
											local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
											if node ~= nil then
												if not ip:insertBefore(node) then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insert parsed node", node, nil))
												end
											end
											do n = n + 1 end
										end
									end
								end
								do stmts:destroy() end
							end
						end
						do return true end
					end
				end
			end
		end
	end
end

function sling.compiler.SlingPreprocessor:getVariables()
	do return self.variables end
end

function sling.compiler.SlingPreprocessor:setVariables(v)
	self.variables = v
	do return self end
end

function sling.compiler.SlingPreprocessor:getCtx()
	do return self.ctx end
end

function sling.compiler.SlingPreprocessor:setCtx(v)
	self.ctx = v
	do return self end
end

sling.compiler.WebApi2ExpanderForSympathy = {}
sling.compiler.WebApi2ExpanderForSympathy.__index = sling.compiler.WebApi2ExpanderForSympathy
_vm:set_metatable(sling.compiler.WebApi2ExpanderForSympathy, {})

function sling.compiler.WebApi2ExpanderForSympathy._create()
	local v = _vm:set_metatable({}, sling.compiler.WebApi2ExpanderForSympathy)
	return v
end

function sling.compiler.WebApi2ExpanderForSympathy:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.WebApi2ExpanderForSympathy'
	self['_isType.sling.compiler.WebApi2ExpanderForSympathy'] = true
	self.ctx = nil
end

function sling.compiler.WebApi2ExpanderForSympathy:_construct0()
	sling.compiler.WebApi2ExpanderForSympathy._init(self)
	return self
end

sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder.__index = sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder
_vm:set_metatable(sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder)
	return v
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder'
	self['_isType.sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder'] = true
	self.results = {}
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder:_construct0()
	sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) and node:hasCustomModifier("webapi2") and node:hasCustomModifier("nojkop") == false then
		do _g.jk.lang.Vector:append(self.results, node) end
	end
	do return true end
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder:getResults()
	do return self.results end
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder:setResults(v)
	self.results = v
	do return self end
end

sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder = _g.sling.common.NodeVisitor._create()
sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder.__index = sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder
_vm:set_metatable(sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder, {
	__index = _g.sling.common.NodeVisitor
})

function sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder._create()
	local v = _vm:set_metatable({}, sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder)
	return v
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder'
	self['_isType.sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder'] = true
	self.results = {}
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder:_construct0()
	sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder._init(self)
	do _g.sling.common.NodeVisitor._construct0(self) end
	return self
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder:visit(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ext.NSlingWebApiStatement') ~= nil) then
		do _g.jk.lang.Vector:append(self.results, node) end
	end
	do return true end
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder:getResults()
	do return self.results end
end

function sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder:setResults(v)
	self.results = v
	do return self end
end

function sling.compiler.WebApi2ExpanderForSympathy:getDynamicMapMethod(type, primitivesOnly)
	if not (type ~= nil) then
		do return "get" end
	end
	do
		local method = nil
		if (_vm:to_table_with_key(type, '_isType.sling.model.ObjectDataTypeNode') ~= nil) or ((_vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) and primitivesOnly == false) then
			method = "get"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.StringDataTypeNode') ~= nil) then
			method = "getString"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
			if type:getType() == _g.sling.model.IntegerDataTypeNode.TYPE_LONG then
				method = "getLongInteger"
			else
				method = "getInteger"
			end
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
			method = "getBoolean"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) then
			method = "getDouble"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.BufferDataTypeNode') ~= nil) and primitivesOnly == false then
			method = "getBuffer"
		elseif (_vm:to_table_with_key(type, '_isType.sling.model.VectorDataTypeNode') ~= nil) and primitivesOnly == false then
			method = "getVector"
		else
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported data type.", type, nil))
		end
		do return method end
	end
end

function sling.compiler.WebApi2ExpanderForSympathy:createInvalidRequestAssert(xpr, res)
	local ass = _g.sling.model.AssertStatementNode:forChild(xpr)
	local err = _g.sling.model.FunctionCallExpressionNode:forName("setInvalidRequest")
	do err:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(res, nil)) end
	do ass:setErrorBlock(_g.sling.model.BlockNode:forStatement(err), false) end
	do return ass end
end

function sling.compiler.WebApi2ExpanderForSympathy:createNotAuthenticatedAssert(xpr, res)
	local ass = _g.sling.model.AssertStatementNode:forChild(xpr)
	local err = _g.sling.model.FunctionCallExpressionNode:forName("setNotAuthenticated")
	do err:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(res, nil)) end
	do ass:setErrorBlock(_g.sling.model.BlockNode:forStatement(err), false) end
	do return ass end
end

function sling.compiler.WebApi2ExpanderForSympathy:createValidateStringStatement(varname, res)
	local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("String"), "isNotEmpty", false)
	do fc:addToParameters(_g.sling.model.SymbolExpressionNode:forName(varname)) end
	do return self:createInvalidRequestAssert(fc, res) end
end

function sling.compiler.WebApi2ExpanderForSympathy:processWebApiStatements(body, req, res, vars)
	local sf = _g.sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder._construct0(_g.sling.compiler.WebApi2ExpanderForSympathy.WebApiStatementFinder._create())
	if not body:accept(sf) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to accept webapi2 statement finder", body, nil))
	end
	do
		local array = sf:getResults()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local statement = array[n + 1]
					if statement ~= nil then
						if (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiSampleRequest') ~= nil) or (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiSampleResponse') ~= nil) then
							if not statement:remove() then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to remove node", statement, nil))
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInPathStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							if type ~= nil then
								do _g.sling.common.RefLog:warning(self.ctx, "Data type is currently ignored", type) end
							end
							do
								local stmts = {}
								local fcall = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forBinding(vars, nil), "getString", false)
								do fcall:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(name)) end
								do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:forAutomatic(name, fcall)) end
								do _g.jk.lang.Vector:append(stmts, self:createValidateStringStatement(name, res)) end
								do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInQueryParameterStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							if type ~= nil then
								do _g.sling.common.RefLog:warning(self.ctx, "Data type is currently ignored", type) end
							end
							do
								local stmts = {}
								local fcall = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forBinding(req, nil), "getQueryParameter", false)
								do fcall:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(name)) end
								do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:forAutomatic(name, fcall)) end
								if statement:getOptional() == false then
									do _g.jk.lang.Vector:append(stmts, self:createValidateStringStatement(name, res)) end
								end
								do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInPostStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							local stmts = {}
							local varname = _g.jk.lang.String:safeString(name) .. "BodyData"
							do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:forAutomatic(varname, _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forBinding(req, nil), "getBodyJSONMap", false))) end
							do _g.jk.lang.Vector:append(stmts, self:createInvalidRequestAssert(_g.sling.model.SymbolExpressionNode:forName(varname), res)) end
							do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:forAutomatic(name, _g.sling.model.CreateObjectExpressionNode:forType(type))) end
							do
								local fromxpr = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName(name), "fromJsonObject", false)
								do fromxpr:addToParameters(_g.sling.model.SymbolExpressionNode:forName(varname)) end
								do _g.jk.lang.Vector:append(stmts, self:createInvalidRequestAssert(fromxpr, res)) end
								do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
							end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiInSessionStatement') ~= nil) then
							local name = statement:getName()
							local type = statement:exportType()
							local stmts = {}
							local reqfc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forBinding(req, nil), "getSession", false)
							local reqfcc = _g.sling.model.DynamicCastExpressionNode:instance(type, reqfc)
							do _g.jk.lang.Vector:append(stmts, _g.sling.model.VariableDeclarationNode:forAutomatic(name, reqfcc)) end
							do _g.jk.lang.Vector:append(stmts, self:createNotAuthenticatedAssert(_g.sling.model.SymbolExpressionNode:forName(name), res)) end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiOutErrorStatement') ~= nil) then
							local code = statement:exportCode()
							local data = statement:exportData()
							local stmts = {}
							local errfc = _g.sling.model.FunctionCallExpressionNode:forName("setErrorResponse")
							do errfc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(res, nil)) end
							do errfc:addToParameters(code) end
							do _g.jk.lang.Vector:append(stmts, errfc) end
							if data ~= nil then
								do _g.sling.common.RefLog:warning(self.ctx, "Data parameter is currently ignored", data) end
							end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiOutOkStatement') ~= nil) then
							local data = statement:exportData()
							local stmts = {}
							local okayc = _g.sling.model.FunctionCallExpressionNode:forName("setOkResponse")
							do okayc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(res, nil)) end
							if data ~= nil then
								do okayc:addToParameters(data) end
							end
							do _g.jk.lang.Vector:append(stmts, okayc) end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						elseif (_vm:to_table_with_key(statement, '_isType.sling.model.ext.NSlingWebApiOutObjectStatement') ~= nil) then
							local data = statement:exportData()
							local stmts = {}
							local objfc = _g.sling.model.FunctionCallExpressionNode:forName("setJsonObjectResponse")
							do objfc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(res, nil)) end
							do objfc:addToParameters(data) end
							do _g.jk.lang.Vector:append(stmts, objfc) end
							do _g.sling.util.NodeUtil:replaceWithNodes(statement, stmts) end
						else
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported webapi statement: `" .. _g.jk.lang.String:safeString(statement:getNodeTypeName()) .. "'", statement, nil))
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.compiler.WebApi2ExpanderForSympathy:execute(root)
	if not (root ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null root", nil, nil))
	end
	do
		local cf = _g.sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder._construct0(_g.sling.compiler.WebApi2ExpanderForSympathy.WebApiClassFinder._create())
		if not root:accept(cf) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to accept webapi2 class finder", root, nil))
		end
		do
			local mc = nil
			local array = cf:getResults()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local wac = array[n + 1]
						if wac ~= nil then
							if _g.sling.util.EntityUtil:methodExists(wac, "initRoutes") then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("The initRoutes() method in a #webapi2 class cannot be manually declared.", wac, nil))
							end
							do
								local ir = _g.sling.model.FunctionDeclarationNode:forName("initRoutes", true)
								do ir:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
								do ir:addModifier(_g.sling.model.Modifier.OVERRIDE) end
								do _g.sling.util.FunctionUtil:addBaseCall(ir, false) end
								do
									local toRemove = {}
									local ib = nil
									local array2 = wac:getNodes()
									if array2 ~= nil then
										local n2 = 0
										local m2 = _g.jk.lang.Vector:getSize(array2)
										do
											n2 = 0
											while n2 < m2 do
												local ii = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.InitializerFunctionDeclarationNode')
												if ii ~= nil then
													local nb = ii:getBody()
													if not (nb ~= nil) then
														goto _continue73
													end
													if not (ib ~= nil) then
														ib = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
													end
													do
														local array3 = nb:exportNodes()
														if array3 ~= nil then
															local n3 = 0
															local m3 = _g.jk.lang.Vector:getSize(array3)
															do
																n3 = 0
																while n3 < m3 do
																	local st = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.common.NodeObject')
																	if st ~= nil then
																		do ib:addNode(st) end
																	end
																	do n3 = n3 + 1 end
																end
															end
														end
														do _g.jk.lang.Vector:append(toRemove, ii) end
													end
												end
												::_continue73::
												do n2 = n2 + 1 end
											end
										end
									end
									if ib ~= nil then
										do _g.sling.util.FunctionUtil:addStatement(ir, ib) end
									end
									do
										local array4 = wac:getNodes()
										if array4 ~= nil then
											local n4 = 0
											local m4 = _g.jk.lang.Vector:getSize(array4)
											do
												n4 = 0
												while n4 < m4 do
													local ho = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.model.ext.NSlingWebApiRequestHandlerObjectDeclaration')
													if ho ~= nil then
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported declaration.", ho, nil))
													end
													do n4 = n4 + 1 end
												end
											end
										end
										do
											local array5 = wac:getNodes()
											if array5 ~= nil then
												local n5 = 0
												local m5 = _g.jk.lang.Vector:getSize(array5)
												do
													n5 = 0
													while n5 < m5 do
														local wh = _vm:to_table_with_key(array5[n5 + 1], '_isType.sling.model.ext.NSlingWebApiRequestHandlerFunctionDeclaration')
														if wh ~= nil then
															local fc = _g.sling.model.FunctionCallExpressionNode:forName("addRoute")
															do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(wh:getMethod())) end
															do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(wh:getPath())) end
															do
																local rq = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
																	"jk",
																	"http",
																	"worker",
																	"HTTPWorkerRequest"
																}), "req", nil)
																local rs = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
																	"jk",
																	"http",
																	"worker",
																	"HTTPWorkerResponse"
																}), "resp", nil)
																local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
																	"jk",
																	"lang",
																	"DynamicMap"
																}), "vars", nil)
																local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
																do fd:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
																do fd:addToParameters(rq) end
																do fd:addToParameters(rs) end
																do fd:addToParameters(vd) end
																do fc:addToParameters(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)) end
																do fd:setBody(wh:exportBody(), false) end
																do _g.sling.util.FunctionUtil:addStatement(ir, fc) end
																do self:processWebApiStatements(fd:getBody(), rq, rs, vd) end
																do _g.jk.lang.Vector:append(toRemove, wh) end
															end
														end
														do n5 = n5 + 1 end
													end
												end
											end
											do
												local array6 = wac:getNodes()
												if array6 ~= nil then
													local n6 = 0
													local m6 = _g.jk.lang.Vector:getSize(array6)
													do
														n6 = 0
														while n6 < m6 do
															local rp = _vm:to_table_with_key(array6[n6 + 1], '_isType.sling.model.FunctionDeclarationNode')
															if rp ~= nil then
																if rp:hasCustomModifier("webrpc") == false then
																	goto _continue74
																end
																if (_vm:to_table_with_key(rp:getOwnReturnType(), '_isType.sling.model.ObjectDataTypeNode') ~= nil) == false then
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Function declarations with #webrpc modifiers should have an object data type.", rp, nil))
																end
																do
																	local fc = _g.sling.model.FunctionCallExpressionNode:forName("addFunction")
																	do fc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(rp:getNodeName())) end
																	do
																		local vd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
																			"jk",
																			"lang",
																			"DynamicMap"
																		}), "parameters", nil)
																		local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
																		do fd:setReturnType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
																		do fd:addToParameters(vd) end
																		do
																			local rc = _g.sling.model.FunctionCallExpressionNode:forName(rp:getNodeName())
																			local array7 = rp:getParameters()
																			if array7 ~= nil then
																				local n7 = 0
																				local m7 = _g.jk.lang.Vector:getSize(array7)
																				do
																					n7 = 0
																					while n7 < m7 do
																						local pr = _vm:to_table_with_key(array7[n7 + 1], '_isType.sling.model.VariableDeclarationNode')
																						if pr ~= nil then
																							local dt = pr:getType()
																							local ts = self:getDynamicMapMethod(dt, false)
																							local nn = pr:getNodeName()
																							local cc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forBinding(vd, nil), ts, false)
																							do cc:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(nn)) end
																							do
																								local pp = _g.sling.model.VariableDeclarationNode:forAutomatic(nn, cc)
																								do _g.sling.util.FunctionUtil:addStatement(fd, pp) end
																								do rc:addToParameters(_g.sling.model.SymbolExpressionNode:forBinding(pp, nil)) end
																							end
																						end
																						do n7 = n7 + 1 end
																					end
																				end
																			end
																			do _g.sling.util.FunctionUtil:addStatement(fd, _g.sling.model.ReturnStatementNode:forExpression(rc)) end
																			do fc:addToParameters(_g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)) end
																			do _g.sling.util.FunctionUtil:addStatement(ir, fc) end
																			do rp:removeCustomModifier("webrpc") end
																		end
																	end
																end
															end
															::_continue74::
															do n6 = n6 + 1 end
														end
													end
												end
												if toRemove ~= nil then
													local n8 = 0
													local m8 = _g.jk.lang.Vector:getSize(toRemove)
													do
														n8 = 0
														while n8 < m8 do
															local node = toRemove[n8 + 1]
															if node ~= nil then
																do node:remove() end
															end
															do n8 = n8 + 1 end
														end
													end
												end
												do wac:addNode(ir) end
												do wac:removeCustomModifier("webapi2") end
												if _g.jk.lang.String:isNotEqual(_g.sling.util.NodeUtil:getQualifiedNameString(wac:getParent(), 46), "jk.http.worker") then
													do wac:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
														"jk",
														"http",
														"worker"
													})) end
												end
												do
													local bts = wac:getBaseTypes()
													if bts == nil or _g.jk.lang.Vector:getSize(bts) < 1 then
														do wac:addBaseTypeExtends(_g.sling.model.ReferenceDataTypeNode:forArrayOfNames({
															"jk",
															"http",
															"worker",
															"HTTPRPCRouter"
														})) end
													end
													if wac:hasCustomModifier("main") then
														if not (mc ~= nil) then
															mc = wac
														end
														do wac:removeCustomModifier("main") end
													end
												end
											end
										end
									end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
			if mc ~= nil then
				do mc:addToImportNamespaces(_g.sling.model.SymbolNode:forArrayOfNames({
					"jk",
					"server",
					"web"
				})) end
				do
					local mf = _g.sling.model.MainFunctionDeclarationNode._construct0(_g.sling.model.MainFunctionDeclarationNode._create())
					do mf:setArgumentArrayName("args") end
					do
						local c1 = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ReferenceDataTypeNode:forName("WebServer")), "setWorker", false)
						do c1:addToParameters(_g.sling.model.GetDatatypeTypeinfoExpressionNode:forDatatype(_g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()))) end
						do
							local c2 = _g.sling.model.FunctionCallExpressionNode:forMethod(c1, "executeMain", false)
							do c2:addToParameters(_g.sling.model.SymbolExpressionNode:forName("args")) end
							do _g.sling.util.FunctionUtil:addStatement(mf, _g.sling.model.ReturnStatementNode:forExpression(c2)) end
							do mc:addNode(mf) end
						end
					end
				end
			end
		end
	end
end

function sling.compiler.WebApi2ExpanderForSympathy:getCtx()
	do return self.ctx end
end

function sling.compiler.WebApi2ExpanderForSympathy:setCtx(v)
	self.ctx = v
	do return self end
end
sling = sling or {}

sling.sushi = sling.sushi or {}

sling.sushi.compiler = sling.sushi.compiler or {}

sling.sushi.compiler.SushiLibraryManager = _g.sling.compiler.LibraryManager._create()
sling.sushi.compiler.SushiLibraryManager.__index = sling.sushi.compiler.SushiLibraryManager
_vm:set_metatable(sling.sushi.compiler.SushiLibraryManager, {
	__index = _g.sling.compiler.LibraryManager
})

function sling.sushi.compiler.SushiLibraryManager._create()
	local v = _vm:set_metatable({}, sling.sushi.compiler.SushiLibraryManager)
	return v
end

function sling.sushi.compiler.SushiLibraryManager:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.sushi.compiler.SushiLibraryManager'
	self['_isType.sling.sushi.compiler.SushiLibraryManager'] = true
end

function sling.sushi.compiler.SushiLibraryManager:_construct0()
	sling.sushi.compiler.SushiLibraryManager._init(self)
	do _g.sling.compiler.LibraryManager._construct0(self) end
	return self
end

function sling.sushi.compiler.SushiLibraryManager:forDefaultDirectory()
	local dd = _g.jk.env.CommonPath:getHomeDirectory()
	if dd ~= nil then
		dd = dd:entry(".sling"):entry("libs")
	end
	do return _g.sling.sushi.compiler.SushiLibraryManager:forDirectory(dd) end
end

function sling.sushi.compiler.SushiLibraryManager:forDirectory(dir)
	local v = _g.sling.sushi.compiler.SushiLibraryManager._construct0(_g.sling.sushi.compiler.SushiLibraryManager._create())
	do v:setDirectory(dir) end
	do return v end
end

function sling.sushi.compiler.SushiLibraryManager:getDefaultRepositoryUrls(urls)
	do _g.sling.compiler.LibraryManager.getDefaultRepositoryUrls(self, urls) end
	do
		local url2 = _g.sling.compiler.LibraryManager.RepositoryUrl._construct0(_g.sling.compiler.LibraryManager.RepositoryUrl._create())
		do url2:setUrl("https://files.eqela.com/sling/libs/%s_%n_%v.slib") end
		do _g.jk.lang.Vector:append(urls, url2) end
	end
end

function sling.sushi.compiler.SushiLibraryManager:getPlatformName()
	do return "sushi" end
end

function sling.sushi.compiler.SushiLibraryManager:getLinkTargetFile(directory, moduleName)
	if not (directory ~= nil) then
		do return nil end
	end
	if not _g.jk.lang.String:isNotEmpty(moduleName) then
		do return nil end
	end
	do return directory:entry(_g.jk.lang.String:safeString(moduleName) .. ".lua") end
end

sling.sushi.compiler.SlingToSushiCompiler = _g.sling.compiler.SlingCompiler._create()
sling.sushi.compiler.SlingToSushiCompiler.__index = sling.sushi.compiler.SlingToSushiCompiler
_vm:set_metatable(sling.sushi.compiler.SlingToSushiCompiler, {
	__index = _g.sling.compiler.SlingCompiler
})

function sling.sushi.compiler.SlingToSushiCompiler._create()
	local v = _vm:set_metatable({}, sling.sushi.compiler.SlingToSushiCompiler)
	return v
end

function sling.sushi.compiler.SlingToSushiCompiler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.sushi.compiler.SlingToSushiCompiler'
	self['_isType.sling.sushi.compiler.SlingToSushiCompiler'] = true
end

function sling.sushi.compiler.SlingToSushiCompiler:_construct0()
	sling.sushi.compiler.SlingToSushiCompiler._init(self)
	do _g.sling.compiler.SlingCompiler._construct0(self) end
	return self
end

sling.sushi.compiler.SlingToSushiCompiler.SushiVM = {}
sling.sushi.compiler.SlingToSushiCompiler.SushiVM.__index = sling.sushi.compiler.SlingToSushiCompiler.SushiVM
_vm:set_metatable(sling.sushi.compiler.SlingToSushiCompiler.SushiVM, {})

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM._create()
	local v = _vm:set_metatable({}, sling.sushi.compiler.SlingToSushiCompiler.SushiVM)
	return v
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.sushi.compiler.SlingToSushiCompiler.SushiVM'
	self['_isType.sling.sushi.compiler.SlingToSushiCompiler.SushiVM'] = true
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:_construct0()
	sling.sushi.compiler.SlingToSushiCompiler.SushiVM._init(self)
	return self
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:getCurrentVMFile()
	local vm = _g.jk.fs.File:forPath(_vm.get_sushi_executable_path())
	if vm:isFile() then
		do return vm end
	end
	do return nil end
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:getVMCodeSizeForFile(file)
	if not (file ~= nil) then
		do return 0 end
	end
	do
		local reader = file:read()
		if not (reader ~= nil) then
			do return 0 end
		end
		do
			local size = reader:getSize()
			if size < 8 then
				do reader:close() end
				do return 0 end
			end
			if not reader:setCurrentPosition(size - 8) then
				do reader:close() end
				do return 0 end
			end
			do
				local buffer = _util:allocate_buffer(4)
				if reader:read(buffer) ~= 4 then
					do reader:close() end
					do return 0 end
				end
				if buffer[0 + 1] ~= 83 or buffer[1 + 1] ~= 117 or buffer[2 + 1] ~= 112 or buffer[3 + 1] ~= 80 then
					do reader:close() end
					do return 0 end
				end
				if reader:read(buffer) ~= 4 then
					do reader:close() end
					do return 0 end
				end
				do reader:close() end
				do return _g.jk.lang.Buffer:getInt32BE(buffer, 0) end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:readSushiVMCodeFromFile(file)
	if not (file ~= nil) then
		do return nil end
	end
	do
		local sz = _g.sling.sushi.compiler.SlingToSushiCompiler.SushiVM:getVMCodeSizeForFile(file)
		if sz < 1 then
			do return file:getContentsBuffer() end
		end
		do
			local reader = file:read()
			local v = _util:allocate_buffer(sz)
			local r = reader:read(v)
			do reader:close() end
			if r < sz then
				do return nil end
			end
			do return v end
		end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:compressIfNecessaryAndPossible(code)
	if not (code ~= nil) then
		do return nil end
	end
	if code[0 + 1] ~= 0 and code[1 + 1] ~= 100 and code[2 + 1] ~= 101 and code[3 + 1] ~= 102 then
		do return _util:deflate(code) end
	end
	do return nil end
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:wrapCodeFileToVMFile(ctx, vm, program, target)
	if not (vm ~= nil and program ~= nil and target ~= nil) then
		do _g.jk.log.Log:error(ctx, "Invalid arguments for SushiVM.wrapCodeFileToVMFile") end
		do return false end
	end
	do
		local code = program:getContentsBuffer()
		if not (code ~= nil) then
			do _g.jk.log.Log:error(ctx, "Failed to read program file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(program:getPath())) .. "'") end
			do return false end
		end
		do
			local sushi = _g.sling.sushi.compiler.SlingToSushiCompiler.SushiVM:readSushiVMCodeFromFile(vm)
			if not (sushi ~= nil) then
				do _g.jk.log.Log:error(ctx, "Failed to read Sushi VM code from file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(vm:getPath())) .. "'") end
				do return false end
			end
			do return self:wrapCodeBufferToVMBuffer(ctx, sushi, code, target) end
		end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler.SushiVM:wrapCodeBufferToVMBuffer(ctx, sushi, code, target)
	if not (sushi ~= nil and code ~= nil and target ~= nil) then
		do _g.jk.log.Log:error(ctx, "Invalid arguments for SushiVM.wrapCodeBufferToVMBuffer") end
		do return false end
	end
	do
		local tdir = target:getParent()
		if not tdir:exists() then
			if not tdir:createDirectoryRecursive() then
				do _g.jk.log.Log:warning(ctx, "Failed to create directory: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(tdir:getPath())) .. "'") end
			end
		end
		do
			local writer = target:write()
			if not (writer ~= nil) then
				do _g.jk.log.Log:error(ctx, "Failed to open file for writing: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(target:getPath())) .. "'") end
				do return false end
			end
			if not (writer:write(sushi, -1) > 0) then
				do _g.jk.log.Log:error(ctx, "Failed while writing to file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(target:getPath())) .. "'") end
				do writer:close() end
				do return false end
			end
			do
				local ccode = self:compressIfNecessaryAndPossible(code)
				if ccode ~= nil then
					local cmagic = _util:allocate_buffer(4)
					do _g.jk.lang.Buffer:setByte(cmagic, 0, 0) end
					do _g.jk.lang.Buffer:setByte(cmagic, 1, 100) end
					do _g.jk.lang.Buffer:setByte(cmagic, 2, 101) end
					do _g.jk.lang.Buffer:setByte(cmagic, 3, 102) end
					if not (writer:write(cmagic, 4) == 4) then
						do _g.jk.log.Log:error(ctx, "Failed while writing to file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(target:getPath())) .. "'") end
						do writer:close() end
						do return false end
					end
					code = ccode
				end
				if not (writer:write(code, -1) > 0) then
					do _g.jk.log.Log:error(ctx, "Failed while writing to file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(target:getPath())) .. "'") end
					do writer:close() end
					do return false end
				end
				do
					local magic = _util:allocate_buffer(4)
					do _g.jk.lang.Buffer:setByte(magic, 0, 83) end
					do _g.jk.lang.Buffer:setByte(magic, 1, 117) end
					do _g.jk.lang.Buffer:setByte(magic, 2, 112) end
					do _g.jk.lang.Buffer:setByte(magic, 3, 80) end
					if not (writer:write(magic, 4) == 4) then
						do _g.jk.log.Log:error(ctx, "Failed while writing to file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(target:getPath())) .. "'") end
						do writer:close() end
						do return false end
					end
					if not (writer:write(_g.jk.lang.Buffer:forInt32BE(#sushi), -1) == 4) then
						do _g.jk.log.Log:error(ctx, "Failed while writing to file: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:safeString(target:getPath())) .. "'") end
						do writer:close() end
						do return false end
					end
					do writer:close() end
					do target:makeExecutable() end
					do return true end
				end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler:_construct1(ctx)
	sling.sushi.compiler.SlingToSushiCompiler._init(self)
	do _g.sling.compiler.SlingCompiler._construct1(self, ctx) end
	return self
end

function sling.sushi.compiler.SlingToSushiCompiler:createLibraryManager()
	do return _g.sling.sushi.compiler.SushiLibraryManager:forDefaultDirectory() end
end

function sling.sushi.compiler.SlingToSushiCompiler:getTargetPlatformId()
	do return "sushi" end
end

function sling.sushi.compiler.SlingToSushiCompiler:getTargetPlatformName()
	do return "Sushi" end
end

function sling.sushi.compiler.SlingToSushiCompiler:getDefines(v)
	do v:setString("target_lua", "true") end
	do v:setString("target_sushi", "true") end
	do v:setString("target_sushi_lua", "true") end
	do v:setString("target_supports_destructor", "true") end
end

function sling.sushi.compiler.SlingToSushiCompiler:getLinkTargetFile(directory, moduleName)
	if not (directory ~= nil) then
		do return nil end
	end
	if not _g.jk.lang.String:isNotEmpty(moduleName) then
		do return nil end
	end
	do return directory:entry(_g.jk.lang.String:safeString(moduleName) .. ".lua") end
end

function sling.sushi.compiler.SlingToSushiCompiler:executePreprocessorFilters(mod)
	do _g.sling.compiler.SlingCompiler.executePreprocessorFilters(self, mod) end
	do _g.sling.compiler.JcoOps:convertTreeDeclarationsToJkDom(self.ctx, mod) end
end

function sling.sushi.compiler.SlingToSushiCompiler:transform(ctx, node, resolver)
	local ph = _g.sling.compiler.ProgressHelper:forSecondHalf(ctx, "Transforming", 30)
	do ph:onUpdate() end
	do _g.sling.compiler.SlingOps:expandPropertyDeclarationsToMethods(ctx, node, resolver) end
	do ph:onUpdate() end
	do _g.sling.compiler.JkopOps:forceJkopVectorOperations(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:flattenOptionalDataTypes(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:flattenUnwrappingExpressions(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:convertSwitchToIf(ctx, node, {
	}) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:renameAmbiguousClassVariables(node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:wrapFunctionReferencesToFunctionDeclarationExpressions(ctx, node, resolver) end
	do ph:onUpdate() end
	do _g.sling.sushi.compiler.SlingToSushiOps:convertTryCatchToPcall(ctx, node, true) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:convertMultipleExpressionsToFunctionExpression(node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandConditionalExpressions(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandAssignmentExpressions(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandDynamicCastExpressions(ctx, node, true) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:surroundLocalVariablesInBlocks(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:changeContinueToGoto(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:expandForStatements(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:wrapAssignmentsInExpressions(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:createDefaultConstructors(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:addExplicitCurrentObjectExpressions(ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:addBaseCallsToConstructors(ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:setMemberAccessExpressionTypes(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:cleanReturnStatementsInFunctions(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:convertToOneBasedIndexing(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:sortEntitiesByDependencies(ctx, resolver, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:addDefaultParameterValuesToFunctionCalls(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:renameOverloadedMethods(ctx, resolver, node, false) end
	do ph:onUpdate() end
	do _g.sling.sushi.compiler.SlingToSushiOps:renameNodesWithReservedWords(ctx, node, false) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:removeIntegerToIntegerCasts(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.sushi.compiler.SlingToSushiOps:addStaticCastsAroundIntegerDivisions(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.op.CommonOps:unresolveSymbols(ctx, node) end
	do ph:onUpdate() end
	do _g.sling.sushi.compiler.SlingToSushiOps:enableSushiBitOps(ctx, node) end
	do ph:_end() end
end

function sling.sushi.compiler.SlingToSushiCompiler:writeModuleSources(ctx, node, output)
	local root = _g.sling.common.CodeUnitNode._construct0(_g.sling.common.CodeUnitNode._create())
	do _g.sling.compiler.SlingOps:transformToOutputModuleCombined(root, node, nil) end
	do _g.sling.op.CommonOps:handleMainFunctionsForAllScripts(ctx, root, false, nil) end
	do
		local mgr = _g.sling.common.DirectoryOutputWriterManager:forDirectory(ctx, output, true)
		local gen = _g.sling.sushi.compiler.SushiLuaGenerator._construct2(_g.sling.sushi.compiler.SushiLuaGenerator._create(), ctx, mgr)
		do gen:dumpModule(root) end
		do _g.sling.util.ProjectUtil:copyTreeResourcesToDirectory(ctx, root, output:entry("resources")) end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler:linkModules(modules, output, projectId, wrapVm, vm)
	local mods = self:toModuleInfos(modules)
	if output:isDirectory() == false then
		do output:createDirectoryRecursive() end
	end
	do
		local links = {}
		local mpid = nil
		if mods ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(mods)
			do
				n = 0
				while n < m do
					local mod = mods[n + 1]
					if mod ~= nil then
						do _g.jk.lang.Vector:append(links, mod:getLinkTarget()) end
						mpid = mod:getModuleId()
					end
					do n = n + 1 end
				end
			end
		end
		do
			local pid = projectId
			if _g.jk.lang.String:isEmpty(pid) then
				pid = mpid
			end
			do
				local modules = links
				local projectId = pid
				local dfn = projectId
				local isWindows = false
				if vm ~= nil and vm:hasExtension("exe") then
					isWindows = true
				elseif _g.jk.os.OS:isWindows() then
					isWindows = true
				end
				if isWindows then
					dfn = _g.jk.lang.String:safeString(dfn) .. ".exe"
				end
				do
					local dst = output:entry(dfn)
					local doLink = false
					local code = output:entry(_g.jk.lang.String:safeString(projectId) .. ".lua")
					local codets = 0
					if wrapVm then
						codets = dst:getLastModifiedTimeStamp()
					else
						codets = code:getLastModifiedTimeStamp()
					end
					do
						local srcfiles = {}
						if modules ~= nil then
							local n2 = 0
							local m2 = _g.jk.lang.Vector:getSize(modules)
							do
								n2 = 0
								while n2 < m2 do
									local module = modules[n2 + 1]
									if module ~= nil then
										local luac = 0
										if module:isFile() and module:hasExtension("lua") then
											do _g.jk.lang.Vector:append(srcfiles, module) end
											if doLink == false and module:getLastModifiedTimeStamp() > codets then
												doLink = true
											end
											do luac = luac + 1 end
										else
											local it = module:entries()
											while it ~= nil do
												local ff = it:next()
												if not (ff ~= nil) then
													do break end
												end
												if ff:hasExtension("lua") then
													do _g.jk.lang.Vector:append(srcfiles, ff) end
													if doLink == false and ff:getLastModifiedTimeStamp() > codets then
														doLink = true
													end
													do luac = luac + 1 end
												end
											end
										end
										if luac < 1 then
											do _g.jk.log.Log:warning(self.ctx, "No Lua files found for module: `" .. _g.jk.lang.String:safeString(module:getPath()) .. "'") end
										end
									end
									do n2 = n2 + 1 end
								end
							end
						end
						if not doLink then
							do _g.jk.log.Log:info(self.ctx, "Already up to date: `" .. _g.jk.lang.String:safeString(code:getPath()) .. "'") end
							do return end
						end
						if wrapVm then
							if not (vm ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Wrapped VM requested, but no VM supplied", nil, nil))
								do return end
							end
							do
								local vmcode = _g.sling.sushi.compiler.SlingToSushiCompiler.SushiVM:readSushiVMCodeFromFile(vm)
								if not (vmcode ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read VM code from file: `" .. _g.jk.lang.String:safeString(vm:getPath()) .. "'", nil, nil))
									do return end
								end
								do _g.jk.log.Log:status(self.ctx, "[Writing] `" .. _g.jk.lang.String:safeString(dst:getPath()) .. "' ..") end
								do
									local databuf = nil
									if srcfiles ~= nil then
										local n3 = 0
										local m3 = _g.jk.lang.Vector:getSize(srcfiles)
										do
											n3 = 0
											while n3 < m3 do
												local file = srcfiles[n3 + 1]
												if file ~= nil then
													do _g.jk.log.Log:debug(self.ctx, "Linking file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "' ..") end
													do
														local data = file:getContentsBuffer()
														if not (data ~= nil) then
															_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, nil))
														end
														databuf = _g.jk.lang.Buffer:append(databuf, data, -1)
													end
												end
												do n3 = n3 + 1 end
											end
										end
									end
									do
										local v = _g.sling.sushi.compiler.SlingToSushiCompiler.SushiVM:wrapCodeBufferToVMBuffer(self.ctx, vmcode, databuf, dst)
										do _g.jk.log.Log:status(self.ctx, nil) end
										if not v then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write output file: `" .. _g.jk.lang.String:safeString(dst:getPath()) .. "'", nil, nil))
											do return end
										end
										do dst:makeExecutable() end
										do _g.jk.log.Log:info(self.ctx, "Wrote: `" .. _g.jk.lang.String:safeString(dst:getPath()) .. "'") end
									end
								end
							end
						else
							do _g.jk.log.Log:status(self.ctx, "[Writing] `" .. _g.jk.lang.String:safeString(code:getPath()) .. "' ..") end
							do
								local writer = code:write()
								if not (writer ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write file: `" .. _g.jk.lang.String:safeString(code:getPath()) .. "'", nil, nil))
								end
								if srcfiles ~= nil then
									local n4 = 0
									local m4 = _g.jk.lang.Vector:getSize(srcfiles)
									do
										n4 = 0
										while n4 < m4 do
											local file = srcfiles[n4 + 1]
											if file ~= nil then
												do _g.jk.log.Log:debug(self.ctx, "Linking file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "' ..") end
												do
													local data = file:getContentsBuffer()
													if not (data ~= nil) then
														do writer:close() end
														_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, nil))
													end
													do
														local sz = #data
														local r = writer:write(data, sz)
														if r < sz then
															do writer:close() end
															_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write data to file: `" .. _g.jk.lang.String:safeString(code:getPath()) .. "'", nil, nil))
														end
													end
												end
											end
											do n4 = n4 + 1 end
										end
									end
								end
								do writer:close() end
								do _g.jk.log.Log:status(self.ctx, nil) end
								do _g.jk.log.Log:info(self.ctx, "Wrote: `" .. _g.jk.lang.String:safeString(code:getPath()) .. "'") end
								if vm ~= nil then
									local sushicode = _g.sling.sushi.compiler.SlingToSushiCompiler.SushiVM:readSushiVMCodeFromFile(vm)
									if not (sushicode ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read Sushi VM code from file: `" .. _g.jk.lang.String:safeString(vm:getPath()) .. "'", nil, nil))
									end
									if not dst:setContentsBuffer(sushicode) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write file: `" .. _g.jk.lang.String:safeString(dst:getPath()) .. "'", nil, nil))
									end
									do dst:makeExecutable() end
									do _g.jk.log.Log:info(self.ctx, "Wrote: `" .. _g.jk.lang.String:safeString(dst:getPath()) .. "'") end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler:getSystemId()
	if _g.jk.os.OS:isWindows() then
		do return "windows" end
	end
	if _g.jk.os.OS:isLinux() then
		do return "linux" end
	end
	if _g.jk.os.OS:isMacOS() then
		do return "macos" end
	end
	do return "native" end
end

function sling.sushi.compiler.SlingToSushiCompiler:buildToNativeApplication(source, output, customName, customVersion)
	if not (output ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No output directory given for native application", nil, nil))
	end
	do
		local version = self:getFinalVersion(customVersion)
		do self:buildApplicationModules(source, customName, version) end
		do
			local sources = {}
			do _g.jk.lang.Vector:append(sources, source) end
			do
				local name = self:getFinalApplicationName(source, customName)
				local appid = _g.jk.lang.String:safeString(name) .. "-" .. _g.jk.lang.String:safeString(version)
				local sid = self:getSystemId()
				local destdir = self:getWorkDirFile(_g.jk.lang.String:safeString(appid) .. "_" .. _g.jk.lang.String:safeString(sid))
				do self:linkModules(sources, destdir, name, true, _g.sling.sushi.compiler.SlingToSushiCompiler.SushiVM:getCurrentVMFile()) end
				do
					local outputdir = output
					local outputfile = outputdir:entry(_g.jk.lang.String:safeString(appid) .. "_" .. _g.jk.lang.String:safeString(sid) .. ".zip")
					do outputfile:remove() end
					do outputdir:createDirectoryRecursive() end
					if not _g.jk.archive.ZipWriter:writeToZipRecursive(self.ctx, outputfile, destdir, true) then
						do _g.jk.lang.Error:throw("failedToWrite", outputfile:getPath()) end
					end
					do _g.jk.log.Log:info(self.ctx, "App: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(outputfile))) end
				end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiCompiler:buildToSushiApplication(source, output, customName, customVersion)
	if not (output ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No output directory given for Sushi application", nil, nil))
	end
	do
		local version = self:getFinalVersion(customVersion)
		do self:buildApplicationModules(source, customName, version) end
		do
			local sources = {}
			do _g.jk.lang.Vector:append(sources, source) end
			do
				local name = self:getFinalApplicationName(source, customName)
				local appid = _g.jk.lang.String:safeString(name) .. "-" .. _g.jk.lang.String:safeString(version)
				local destdir = self:getWorkDirFile(_g.jk.lang.String:safeString(appid) .. "_sushi")
				do self:linkModules(sources, destdir, name, false, nil) end
				do
					local outputdir = output
					local outputfile = outputdir:entry(_g.jk.lang.String:safeString(appid) .. ".sapp")
					do outputfile:remove() end
					do outputdir:createDirectoryRecursive() end
					if not _g.jk.archive.ZipWriter:writeToZipRecursive(self.ctx, outputfile, destdir, true) then
						do _g.jk.lang.Error:throw("failedToWrite", outputfile:getPath()) end
					end
					do _g.jk.log.Log:info(self.ctx, "App: " .. _g.jk.lang.String:safeString(_g.jk.lang.String:asString(outputfile))) end
				end
			end
		end
	end
end

sling.sushi.compiler.SlingToSushiOps = {}
sling.sushi.compiler.SlingToSushiOps.__index = sling.sushi.compiler.SlingToSushiOps
_vm:set_metatable(sling.sushi.compiler.SlingToSushiOps, {})

function sling.sushi.compiler.SlingToSushiOps._create()
	local v = _vm:set_metatable({}, sling.sushi.compiler.SlingToSushiOps)
	return v
end

function sling.sushi.compiler.SlingToSushiOps:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.sushi.compiler.SlingToSushiOps'
	self['_isType.sling.sushi.compiler.SlingToSushiOps'] = true
end

function sling.sushi.compiler.SlingToSushiOps:_construct0()
	sling.sushi.compiler.SlingToSushiOps._init(self)
	return self
end

function sling.sushi.compiler.SlingToSushiOps:renameNodesWithReservedWords(ctx, node, issueWarnings)
	local words = {
		"do",
		"end",
		"function",
		"if",
		"local",
		"then",
		"return",
		"while",
		"else",
		"elseif",
		"for",
		"or",
		"and",
		"goto",
		"repeat",
		"break",
		"not"
	}
	do _g.sling.op.RenamerForReservedWords:execute(ctx, node, words, issueWarnings) end
end

function sling.sushi.compiler.SlingToSushiOps:isDynamicExceptionVariableDeclaration(node)
	local vd = _vm:to_table_with_key(node, '_isType.sling.model.VariableDeclarationNode')
	if not (vd ~= nil) then
		do return false end
	end
	do
		local type = vd:getType()
		if not (type ~= nil) then
			do return true end
		end
		if (_vm:to_table_with_key(type, '_isType.sling.model.DynamicDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) then
			do return true end
		end
		do return false end
	end
end

function sling.sushi.compiler.SlingToSushiOps:convertTryCatchToPcall(ctx, node, isSushi)
	local array = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.TryCatchExpressionNode", false, true, false)
	if array ~= nil then
		local n2 = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n2 = 0
			while n2 < m do
				local tcx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.model.TryCatchExpressionNode')
				if tcx ~= nil then
					local fd = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
					local tcs = _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create())
					local xpr = tcx:exportExpression()
					local blk = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
					if xpr ~= nil then
						do blk:addNode(xpr) end
					end
					do tcs:setTryBlock(blk, false) end
					do
						local cb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
						do cb:addNode(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.SymbolExpressionNode:forName("e"))) end
						do tcs:addToCatchBlocks(_g.sling.model.CatchBlockNode:instance(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "e", nil), cb)) end
						do _g.sling.util.FunctionUtil:addStatement(fd, tcs) end
						do _g.sling.util.FunctionUtil:addStatement(fd, _g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()))) end
						do
							local fdx = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fd)
							local fcx = _g.sling.model.FunctionCallExpressionNode:forExpression(fdx)
							do _g.sling.util.NodeUtil:replaceNode(tcx, fcx) end
						end
					end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	do
		local array2 = _g.sling.common.NodeFinder:findNodesOfType(node, "class:sling.model.TryCatchStatementNode", false, true, false)
		if array2 ~= nil then
			local n3 = 0
			local m2 = _g.jk.lang.Vector:getSize(array2)
			do
				n3 = 0
				while n3 < m2 do
					local tc = _vm:to_table_with_key(array2[n3 + 1], '_isType.sling.model.TryCatchStatementNode')
					if tc ~= nil then
						local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
						local vd = _g.sling.model.MultipleVariableDeclarationNode:forArrayOfVariables(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), {
							"_status",
							"_err"
						})
						local fdecl = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
						do fdecl:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
						do
							local tryblock = tc:exportTryBlock()
							if not (tryblock ~= nil) then
								tryblock = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
							end
							do fdecl:setBody(tryblock, false) end
							do
								local fdx = _g.sling.model.FunctionDeclarationExpressionNode:forDeclaration(fdecl)
								local fcall = nil
								if isSushi then
									fcall = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("_vm"), "execute_protected_call", true)
								else
									fcall = _g.sling.model.FunctionCallExpressionNode:forName("pcall")
								end
								do fcall:addToParameters(fdx) end
								do vd:setInitializer(fcall, false) end
								do
									local hasRval = false
									local array3 = _g.sling.common.NodeFinder:findNodesOfType(tryblock, "class:sling.model.ReturnStatementNode", false, true, false)
									if array3 ~= nil then
										local n4 = 0
										local m3 = _g.jk.lang.Vector:getSize(array3)
										do
											n4 = 0
											while n4 < m3 do
												local rs = _vm:to_table_with_key(array3[n4 + 1], '_isType.sling.model.ReturnStatementNode')
												if rs ~= nil then
													local nf = _g.sling.util.FindUtil:findNearestFunctionBase(rs)
													if nf ~= fdecl then
														goto _continue1
													end
													do
														local xpr = rs:exportExpression()
														if not (xpr ~= nil) then
															xpr = _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())
														end
														do
															local pp = _vm:to_table_with_key(rs:getParent(), '_isType.sling.common.ContainerNode')
															if not (pp ~= nil) then
																_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Return statement parent is not a container", rs, nil))
															end
															do pp:insertAboveNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName("_rval"), _g.sling.model.CreateObjectExpressionNode:forType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()))), rs) end
															do pp:insertAboveNode(_g.sling.model.AssignmentExpressionNode:forNodes(_g.sling.model.MemberAccessExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName("_rval"), _g.sling.model.SymbolExpressionNode:forName("value")), xpr), rs) end
															hasRval = true
														end
													end
												end
												::_continue1::
												do n4 = n4 + 1 end
											end
										end
									end
									if hasRval then
										local rvalDec = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "_rval", nil)
										do rvalDec:setInitializer(_g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()), false) end
										do block:addNode(rvalDec) end
									end
									do block:addNode(vd) end
									do
										local rvalblock = _g.sling.model.BlockNode:forStatement(_g.sling.model.ReturnStatementNode:forExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(_g.sling.model.SymbolExpressionNode:forName("_rval"), _g.sling.model.SymbolExpressionNode:forName("value"))))
										local cifb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
										local pc = nil
										local fallbacks = nil
										local array4 = tc:exportCatchBlocks()
										if array4 ~= nil then
											local n5 = 0
											local m4 = _g.jk.lang.Vector:getSize(array4)
											do
												n5 = 0
												while n5 < m4 do
													local cb = _vm:to_table_with_key(array4[n5 + 1], '_isType.sling.model.CatchBlockNode')
													if cb ~= nil then
														local xprs = cb:getExceptions()
														local cbb = cb:exportBlock()
														if not (cbb ~= nil) then
															cbb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
														end
														if _g.jk.lang.Vector:isEmpty(xprs) then
															if not (fallbacks ~= nil) then
																fallbacks = {}
															end
															do _g.jk.lang.Vector:append(fallbacks, cbb) end
														elseif _g.jk.lang.Vector:getSize(xprs) == 1 and _g.sling.sushi.compiler.SlingToSushiOps:isDynamicExceptionVariableDeclaration(_g.jk.lang.Vector:get(xprs, 0)) then
															local xpr = _vm:to_table_with_key(_g.jk.lang.Vector:get(xprs, 0), '_isType.sling.model.VariableDeclarationNode')
															local lvd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), xpr:getName(), _g.sling.model.SymbolExpressionNode:forName("_err"))
															do cbb:insertNode(lvd, 0) end
															if not (fallbacks ~= nil) then
																fallbacks = {}
															end
															do _g.jk.lang.Vector:append(fallbacks, cbb) end
														else
															local n = 0
															local condition = nil
															if xprs ~= nil then
																local n6 = 0
																local m5 = _g.jk.lang.Vector:getSize(xprs)
																do
																	n6 = 0
																	while n6 < m5 do
																		local xpr = _vm:to_table_with_key(xprs[n6 + 1], '_isType.sling.model.VariableDeclarationNode')
																		if xpr ~= nil then
																			local xc = _g.sling.model.TypeCheckExpressionNode:instance(xpr:getType(), _g.sling.model.SymbolExpressionNode:forName("_err"), false)
																			if condition ~= nil then
																				condition = _g.sling.model.LogicalOrExpressionNode:instance(condition, xc)
																			else
																				condition = xc
																			end
																			do
																				local lvd = _g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), xpr:getName(), _g.sling.model.SymbolExpressionNode:forName("_err"))
																				do cbb:insertNode(lvd, (function() local v = n n = n + 1 return v end)()) end
																			end
																		end
																		do n6 = n6 + 1 end
																	end
																end
															end
															do
																local ifs = _g.sling.model.IfStatementNode:instance(condition, cbb, nil)
																if pc ~= nil then
																	do pc:setElseBlock(_g.sling.model.BlockNode:forStatement(ifs), false) end
																else
																	do cifb:addNode(ifs) end
																end
																pc = ifs
															end
														end
													end
													do n5 = n5 + 1 end
												end
											end
										end
										if _g.jk.lang.Vector:getSize(fallbacks) < 1 then
											fallbacks = {}
											do
												local bb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
												local ts = _g.sling.model.ThrowStatementNode._construct0(_g.sling.model.ThrowStatementNode._create())
												do ts:setExpression(_g.sling.model.SymbolExpressionNode:forName("_err"), false) end
												do bb:addNode(ts) end
												do _g.jk.lang.Vector:append(fallbacks, bb) end
											end
										end
										if fallbacks ~= nil then
											local xb = nil
											if _g.jk.lang.Vector:getSize(fallbacks) == 1 then
												xb = _g.jk.lang.Vector:get(fallbacks, 0)
											else
												xb = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
												if fallbacks ~= nil then
													local n7 = 0
													local m6 = _g.jk.lang.Vector:getSize(fallbacks)
													do
														n7 = 0
														while n7 < m6 do
															local fallback = fallbacks[n7 + 1]
															if fallback ~= nil then
																do xb:addNode(fallback) end
															end
															do n7 = n7 + 1 end
														end
													end
												end
											end
											if pc ~= nil then
												do pc:setElseBlock(xb, false) end
											else
												cifb = xb
											end
										end
										do
											local catchif = _g.sling.model.IfStatementNode:instance(_g.sling.model.SymbolExpressionNode:forName("_err"), cifb, nil)
											do block:addNode(catchif) end
											do
												local finallyblock = tc:exportFinallyBlock()
												if finallyblock ~= nil then
													do block:addNode(finallyblock) end
												end
												if hasRval then
													do block:addNode(_g.sling.model.IfStatementNode:instance(_g.sling.model.SymbolExpressionNode:forName("_rval"), rvalblock, nil)) end
												end
												do _g.sling.util.NodeUtil:replaceNode(tc, block) end
											end
										end
									end
								end
							end
						end
					end
					do n3 = n3 + 1 end
				end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiOps:enableSushiBitOps(ctx, node)
	local types = {
		"class:sling.model.BitwiseAndExpressionNode",
		"class:sling.model.BitwiseOrExpressionNode",
		"class:sling.model.BitwiseNotExpressionNode",
		"class:sling.model.BitwiseXorExpressionNode",
		"class:sling.model.ShiftLeftExpressionNode",
		"class:sling.model.ShiftRightExpressionNode"
	}
	local bitnodes = _g.sling.common.NodeFinder:findNodesOfTypes(node, types, false, true, false)
	if bitnodes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(bitnodes)
		do
			n = 0
			while n < m do
				local node = bitnodes[n + 1]
				if node ~= nil then
					if (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseAndExpressionNode') ~= nil) then
						local left = node:exportLeft()
						local right = node:exportRight()
						local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
							"_vm",
							"bitwise_and"
						})
						do fc:addToParameters(left) end
						do fc:addToParameters(right) end
						do node:replaceWith(fc, false) end
					elseif (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseOrExpressionNode') ~= nil) then
						local left = node:exportLeft()
						local right = node:exportRight()
						local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
							"_vm",
							"bitwise_or"
						})
						do fc:addToParameters(left) end
						do fc:addToParameters(right) end
						do node:replaceWith(fc, false) end
					elseif (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseNotExpressionNode') ~= nil) then
						local xpr = node:exportExpression()
						local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
							"_vm",
							"bitwise_not"
						})
						do fc:addToParameters(xpr) end
						do node:replaceWith(fc, false) end
					elseif (_vm:to_table_with_key(node, '_isType.sling.model.BitwiseXorExpressionNode') ~= nil) then
						local left = node:exportLeft()
						local right = node:exportRight()
						local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
							"_vm",
							"bitwise_xor"
						})
						do fc:addToParameters(left) end
						do fc:addToParameters(right) end
						do node:replaceWith(fc, false) end
					elseif (_vm:to_table_with_key(node, '_isType.sling.model.ShiftLeftExpressionNode') ~= nil) then
						local left = node:exportLeft()
						local right = node:exportRight()
						local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
							"_vm",
							"bitwise_left_shift"
						})
						do fc:addToParameters(left) end
						do fc:addToParameters(right) end
						do node:replaceWith(fc, false) end
					elseif (_vm:to_table_with_key(node, '_isType.sling.model.ShiftRightExpressionNode') ~= nil) then
						local left = node:exportLeft()
						local right = node:exportRight()
						local fc = _g.sling.model.FunctionCallExpressionNode:forNames({
							"_vm",
							"bitwise_right_shift"
						})
						do fc:addToParameters(left) end
						do fc:addToParameters(right) end
						do node:replaceWith(fc, false) end
					else
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Incorrect node type", node, nil))
					end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiOps:convertToSushiSubscripts(root)
	local array = _g.sling.common.NodeFinder:findCompatibleNodes(root, "class:sling.model.SubscriptExpressionNode", false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.SubscriptExpressionNode')
				if node ~= nil then
					local xpr = node:exportChild()
					if not (xpr ~= nil) then
						goto _continue2
					end
					do
						local subscripts = node:exportSubscripts()
						if _g.jk.lang.Vector:getSize(subscripts) ~= 1 then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Only one-dimensional subscripts are supported", node, nil))
						end
						do
							local subscript = _vm:to_table_with_key(_g.jk.lang.Vector:get(subscripts, 0), '_isType.sling.common.ExpressionNode')
							if not (subscript ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null subscript", node, nil))
							end
							do
								local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.AssignmentExpressionNode')
								if pp ~= nil and pp:getLeft() == node then
									local value = pp:exportRight()
									local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("_vm"), "set_subscript_value", true)
									do fc:addToParameters(xpr) end
									do fc:addToParameters(subscript) end
									do fc:addToParameters(value) end
									do _g.sling.util.NodeUtil:replaceNode(pp, fc) end
								else
									local fc = _g.sling.model.FunctionCallExpressionNode:forMethod(_g.sling.model.SymbolExpressionNode:forName("_vm"), "get_subscript_value", true)
									do fc:addToParameters(xpr) end
									do fc:addToParameters(subscript) end
									do _g.sling.util.NodeUtil:replaceNode(node, fc) end
								end
							end
						end
					end
				end
				::_continue2::
				do n = n + 1 end
			end
		end
	end
end

function sling.sushi.compiler.SlingToSushiOps:addStaticCastsAroundIntegerDivisions(ctx, node)
	local array = _g.sling.common.NodeFinder:findCompatibleNodesForTypes(node, {
		"class:sling.model.DivisionExpressionNode",
		"class:sling.model.ModuloExpressionNode"
	}, false, true, false)
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local div = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.ArithmeticExpressionNode')
				if div ~= nil then
					local pp = _vm:to_table_with_key(div:getParent(), '_isType.sling.model.StaticCastExpressionNode')
					if pp ~= nil then
						local type = pp:getType()
						if type ~= nil and (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
							goto _continue3
						end
					end
					do
						local left = div:getLeft()
						local right = div:getRight()
						if left ~= nil and right ~= nil then
							local ldt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(left, nil)
							local rdt = _g.sling.util.ExpressionUtil:tryGetExpressionDataType(right, nil)
							if ldt ~= nil and rdt ~= nil and (_vm:to_table_with_key(ldt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) and (_vm:to_table_with_key(rdt, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
								local nn = _g.sling.model.StaticCastExpressionNode._construct0(_g.sling.model.StaticCastExpressionNode._create())
								do nn:setType(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), false) end
								do _g.sling.util.NodeUtil:replaceAndExport(div, nn) end
								do nn:setExpression(div, false) end
							end
						end
					end
				end
				::_continue3::
				do n = n + 1 end
			end
		end
	end
end

sling.sushi.compiler.SushiLuaGenerator = _g.sling.common.CodeGenerator._create()
sling.sushi.compiler.SushiLuaGenerator.__index = sling.sushi.compiler.SushiLuaGenerator
_vm:set_metatable(sling.sushi.compiler.SushiLuaGenerator, {
	__index = _g.sling.common.CodeGenerator
})

function sling.sushi.compiler.SushiLuaGenerator._create()
	local v = _vm:set_metatable({}, sling.sushi.compiler.SushiLuaGenerator)
	return v
end

function sling.sushi.compiler.SushiLuaGenerator:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.sushi.compiler.SushiLuaGenerator'
	self['_isType.sling.sushi.compiler.SushiLuaGenerator'] = true
	self.excludeComments = false
	self.indent = 0
	self.wasNewline = false
	self.nameStack = _g.jk.lang.Stack._construct0(_g.jk.lang.Stack._create())
end

function sling.sushi.compiler.SushiLuaGenerator:_construct0()
	sling.sushi.compiler.SushiLuaGenerator._init(self)
	do _g.sling.common.CodeGenerator._construct0(self) end
	return self
end

function sling.sushi.compiler.SushiLuaGenerator:_construct2(ctx, output)
	sling.sushi.compiler.SushiLuaGenerator._init(self)
	do _g.sling.common.CodeGenerator._construct2(self, ctx, output) end
	return self
end

function sling.sushi.compiler.SushiLuaGenerator:increaseIndent()
	do self.indent = self.indent + 1 end
end

function sling.sushi.compiler.SushiLuaGenerator:decreaseIndent()
	do self.indent = self.indent - 1 end
end

function sling.sushi.compiler.SushiLuaGenerator:output(str)
	if self.wasNewline then
		do
			local n = 0
			while n < self.indent do
				do self:outputDirect("\t") end
				do n = n + 1 end
			end
		end
		self.wasNewline = false
	end
	do self:outputDirect(str) end
	if _g.jk.lang.String:endsWith(str, "\n") then
		self.wasNewline = true
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpComment(node)
	if not (node ~= nil) then
		do return end
	end
	if not (self.excludeComments == false) then
		do return end
	end
	do
		local substantial = node:getSubstantial()
		local text = node:getText()
		if substantial == false and _g.jk.lang.String:getIndexOfCharacter(text, 10, 0) >= 0 then
			substantial = true
		end
		if substantial then
			do self:output("--\n") end
			do
				local array = _g.jk.lang.String:split(text, 10, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local line = array[n + 1]
							if line ~= nil then
								do self:output("-- " .. _g.jk.lang.String:safeString(line) .. "\n") end
							end
							do n = n + 1 end
						end
					end
				end
				do self:output("--\n") end
			end
		elseif _g.jk.lang.String:startsWith(text, " ", 0) == false then
			do self:output("-- " .. _g.jk.lang.String:safeString(text) .. "\n") end
		else
			do self:output("--" .. _g.jk.lang.String:safeString(text) .. "\n") end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpSymbol(symbol, isFunctionCall)
	local names = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
	local sz = _g.jk.lang.Vector:getSize(names)
	if sz < 1 then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty name for symbol", symbol, _g.jk.lang.StackTrace:generate()))
	end
	do
		local n = 0
		while n < sz do
			local o = names[n + 1]
			if n > 0 then
				if isFunctionCall and n == sz - 1 then
					do self:output(":") end
				else
					do self:output(".") end
				end
			end
			if (_vm:get_variable_type(o) == 'string') then
				if n == 0 and symbol:hasModifier(_g.sling.model.Modifier.GLOBAL) then
					do self:output("_g.") end
				end
				do self:output(o) end
				goto _continue4
			end
			if (_vm:to_table_with_key(o, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
				if n == 0 and symbol:hasModifier(_g.sling.model.Modifier.GLOBAL) then
					do self:output("_g.") end
				end
				do
					local c = o
					do self:output(c:getName()) end
					goto _continue4
				end
			end
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported symbol component", symbol, _g.jk.lang.StackTrace:generate()))
			::_continue4::
			do n = n + 1 end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpImportPackageStatement(node)
	if not (node ~= nil) then
		do return end
	end
	do
		local package = node:getPackage()
		if not (package ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null package", nil, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("local ") end
		do
			local localname = node:getLocalName()
			if _g.jk.lang.String:isNotEmpty(localname) then
				do self:output(localname) end
			else
				do self:dumpSymbol(package, false) end
			end
			do self:output(" = require(\"") end
			do self:dumpSymbol(package, false) end
			do self:output("\")\n") end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpFunctionParameter(param)
	if (_vm:to_table_with_key(param, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
		do self:output(param:getName()) end
	elseif (_vm:to_table_with_key(param, '_isType.sling.model.VariableArgumentsDeclarationNode') ~= nil) then
		local vd = param:getVariableDeclaration()
		if vd ~= nil then
			do self:output(vd:getName()) end
			do self:output(", ...") end
		else
			do self:output("...") end
		end
	else
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. param:getNodeTypeName() .. "' in context `" .. "function parameter" .. "'", param, nil))
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpFunctionDeclaration(node, isExpression)
	if not (node ~= nil) then
		do return end
	end
	do self:output("function") end
	do
		local name = node:getName()
		if _g.jk.lang.String:isNotEmpty(name) then
			do self:output(" ") end
			do
				local pp = node:getParent()
				if pp ~= nil and (_vm:to_table_with_key(pp, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
					do self:output(self:getQualifiedName(name, 58)) end
				else
					do self:output(name) end
				end
			end
		end
		do self:output("(") end
		do
			local params = node:getParameters()
			local first = true
			if params ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(params)
				do
					n = 0
					while n < m do
						local param = _vm:to_table_with_key(params[n + 1], '_isType.sling.common.NodeObject')
						if param ~= nil then
							if not first then
								do self:output(", ") end
							end
							do self:dumpFunctionParameter(param) end
							first = false
						end
						do n = n + 1 end
					end
				end
			end
			do self:output(")\n") end
			do self:increaseIndent() end
			do
				local body = node:getBody()
				if body ~= nil then
					do self:dumpBlock(body) end
				end
				do self:decreaseIndent() end
				do self:output("end") end
				if not isExpression then
					do self:output("\n") end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpLocalVariableDeclaration(vd)
	if not (vd ~= nil) then
		do return end
	end
	do self:output("local ") end
	do self:output(vd:getName()) end
	do self:output(" = ") end
	do
		local init = vd:getInitializer()
		if init ~= nil then
			do self:dumpExpression(init, nil, false) end
		else
			do self:output("nil") end
		end
		do self:output("\n") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpContainer(container, context)
	local prev = nil
	local array = container:getNodes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
				if child ~= nil then
					if (_vm:to_table_with_key(child, '_isType.sling.model.ResourceFileNode') ~= nil) then
						goto _continue5
					end
					do self:separateStatements(child, prev, context) end
					prev = child
					if (_vm:to_table_with_key(child, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
						do self:dumpLocalVariableDeclaration(child) end
						goto _continue5
					end
					do self:dumpStatement(child, context) end
				end
				::_continue5::
				do n = n + 1 end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpBlock(block)
	do self:dumpContainer(block, "block") end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpScript(script)
	do self:dumpContainer(script, "script") end
end

function sling.sushi.compiler.SushiLuaGenerator:escapeStringLiteral(str)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	local it = _g.jk.lang.String:iterate(str)
	while it ~= nil do
		local c = it:getNextChar()
		if _g.jk.lang.Character:isEOF(c) then
			do break end
		end
		if c == 7 then
			do sb:appendString("\\a") end
		elseif c == 8 then
			do sb:appendString("\\b") end
		elseif c == 12 then
			do sb:appendString("\\f") end
		elseif c == 10 then
			do sb:appendString("\\n") end
		elseif c == 13 then
			do sb:appendString("\\r") end
		elseif c == 9 then
			do sb:appendString("\\t") end
		elseif c == 11 then
			do sb:appendString("\\v") end
		elseif c == 92 then
			do sb:appendString("\\\\") end
		elseif c == 34 then
			do sb:appendString("\\\"") end
		else
			do sb:appendCharacter(c) end
		end
	end
	do return sb:toString() end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpExpressionOrTuple(node, parent, isRvalue)
	if (_vm:to_table_with_key(node, '_isType.sling.model.TupleExpressionNode') ~= nil) then
		local first = true
		local array = node:getExpressions()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local value = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.ExpressionNode')
					if value ~= nil then
						if not first then
							do self:output(", ") end
						end
						do self:dumpExpression(value, parent, isRvalue) end
						first = false
					end
					do n = n + 1 end
				end
			end
		end
	else
		do self:dumpExpression(node, parent, isRvalue) end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpDataType(node)
	if not (node ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
		local sym = node:getSymbol()
		if not (sym ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null symbol", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpSymbol(sym, false) end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "data type" .. "'", node, nil))
end

function sling.sushi.compiler.SushiLuaGenerator:getBaseClassType(node)
	if not (node ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null node in getBaseClassType", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local entity = _g.sling.util.FindUtil:findNearestEntity(node)
		if not (entity ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No enclosing entity", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local baseclass = _g.sling.util.EntityUtil:getBaseClassTypeForEntity(entity)
			if not (baseclass ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No base class for enclosing entity", node, _g.jk.lang.StackTrace:generate()))
			end
			do return baseclass end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:getIsTypeVariableName(names)
	local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
	do sb:appendString("_isType") end
	if names ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(names)
		do
			n = 0
			while n < m do
				local name = names[n + 1]
				if name ~= nil then
					do sb:appendCharacter(46) end
					do sb:appendString(name) end
				end
				do n = n + 1 end
			end
		end
	end
	do return sb:toString() end
end

function sling.sushi.compiler.SushiLuaGenerator:getOperatorPrecedence(node)
	if (_vm:to_table_with_key(node, '_isType.sling.model.ExponentExpressionNode') ~= nil) then
		do return 1 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.NegativeNumberExpressionNode') ~= nil) then
		do return 2 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultiplicationExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.DivisionExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.ModuloExpressionNode') ~= nil) then
		do return 3 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AdditionExpressionNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.SubtractionExpressionNode') ~= nil) then
		do return 4 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringConcatenationExpressionNode') ~= nil) then
		do return 5 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ComparisonExpressionNode') ~= nil) then
		do return 6 end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalExpressionNode') ~= nil) then
		do return 7 end
	end
	do return 0 end
end

function sling.sushi.compiler.SushiLuaGenerator:isLowerPriority(node, parent, isRvalue)
	if not (parent ~= nil) then
		do return false end
	end
	if isRvalue then
		if self:getOperatorPrecedence(node) >= self:getOperatorPrecedence(parent) then
			do return true end
		end
	elseif self:getOperatorPrecedence(node) > self:getOperatorPrecedence(parent) then
		do return true end
	end
	do return false end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpExpression(node, parent, isRvalue)
	local lower = self:isLowerPriority(node, parent, isRvalue)
	if lower then
		do self:output("(") end
	end
	do self:doDumpExpression(node, parent) end
	if lower then
		do self:output(")") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:doDumpExpression(node, parent)
	if (_vm:to_table_with_key(node, '_isType.sling.model.SymbolExpressionNode') ~= nil) then
		local symbol = node:getSymbol()
		if not (symbol ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null symbol", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local isFunctionCall = false
			local pfc = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.FunctionCallExpressionNode')
			if pfc ~= nil and pfc:getExpression() == node then
				isFunctionCall = true
			end
			do self:dumpSymbol(symbol, isFunctionCall) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) then
		local fc = node
		local params = fc:getParameters()
		local xpr = fc:getExpression()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", fc, _g.jk.lang.StackTrace:generate()))
		end
		do
			local first = true
			if (_vm:to_table_with_key(xpr, '_isType.sling.model.FunctionDeclarationExpressionNode') ~= nil) then
				do self:output("(") end
				do self:dumpExpression(xpr, fc, false) end
				do self:output(")(") end
			elseif (_vm:to_table_with_key(xpr, '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
				local baseclass = self:getBaseClassType(xpr)
				do self:dumpDataType(baseclass) end
				do self:output(".") end
				do self:output("_construct") end
				do self:output(_g.jk.lang.String:forInteger(_g.jk.lang.Vector:getSize(params))) end
				do self:output("(self") end
				first = false
			elseif (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) and (_vm:to_table_with_key(xpr:getParentExpression(), '_isType.sling.model.BaseClassAccessExpressionNode') ~= nil) then
				local baseclass = self:getBaseClassType(xpr)
				do self:dumpDataType(baseclass) end
				do self:output(".") end
				do
					local child = xpr:getChildExpression()
					if not (child ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("No child expression", xpr, _g.jk.lang.StackTrace:generate()))
					end
					do self:dumpExpression(child, fc, false) end
					do self:output("(self") end
					first = false
				end
			else
				do self:dumpExpression(xpr, fc, false) end
				do self:output("(") end
			end
			if params ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(params)
				do
					n2 = 0
					while n2 < m do
						local param = _vm:to_table_with_key(params[n2 + 1], '_isType.sling.common.ExpressionNode')
						if param ~= nil then
							if not first then
								do self:output(", ") end
							end
							first = false
							do self:dumpExpression(param, nil, false) end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			do self:output(")") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
		local max = node
		local left = max:getParentExpression()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = max:getChildExpression()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do
				local xnode = max
				while true do
					local np = _vm:to_table_with_key(xnode:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
					if np ~= nil then
						xnode = np
					else
						do break end
					end
				end
				do
					local at = max:getAccessType()
					if at == _g.sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_VARIABLE or at == _g.sling.model.MemberAccessExpressionNode.TYPE_STATIC_VARIABLE then
						do self:output(".") end
					elseif _g.sling.util.FunctionUtil:isFunctionCallExpressionChild(xnode) and right == xnode:getLastNode() then
						do self:output(":") end
					else
						do self:output(".") end
					end
					do self:dumpExpression(right, node, false) end
					do return end
				end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringLiteralExpressionNode') ~= nil) then
		do self:output("\"") end
		do self:output(self:escapeStringLiteral(node:getValue())) end
		do self:output("\"") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CharacterLiteralExpressionNode') ~= nil) then
		do self:output(_g.jk.lang.String:forInteger(_util:convert_to_integer(node:getValue()))) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.IntegerLiteralExpressionNode') ~= nil) then
		do self:output(_g.jk.lang.String:forInteger(node:getValue())) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DoubleLiteralExpressionNode') ~= nil) then
		do self:output(_g.jk.lang.String:forDouble(node:getValue())) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FloatLiteralExpressionNode') ~= nil) then
		do self:output(_g.jk.lang.String:forFloat(node:getValue())) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MapLiteralExpressionNode') ~= nil) then
		local maplit = node
		local values = maplit:getValues()
		if _g.jk.lang.Vector:isEmpty(values) then
			do self:output("{}") end
			do return end
		end
		do self:output("{") end
		do self:increaseIndent() end
		do
			local first = true
			if values ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(values)
				do
					n3 = 0
					while n3 < m2 do
						local value = _vm:to_table_with_key(values[n3 + 1], '_isType.sling.model.KeyValueNode')
						if value ~= nil then
							if first then
								do self:output("\n") end
							else
								do self:output(",\n") end
							end
							do self:output("[") end
							do self:dumpExpression(value:getKey(), nil, false) end
							do self:output("] = ") end
							do self:dumpExpression(value:getValue(), nil, false) end
							first = false
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do self:decreaseIndent() end
			do self:output("\n") end
			do self:output("}") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SetLiteralExpressionNode') ~= nil) then
		local setlit = node
		local values = setlit:getValues()
		if _g.jk.lang.Vector:isEmpty(values) then
			do self:output("{}") end
			do return end
		end
		do self:output("{") end
		do self:increaseIndent() end
		do
			local first = true
			if values ~= nil then
				local n4 = 0
				local m3 = _g.jk.lang.Vector:getSize(values)
				do
					n4 = 0
					while n4 < m3 do
						local value = _vm:to_table_with_key(values[n4 + 1], '_isType.sling.common.ExpressionNode')
						if value ~= nil then
							if first then
								do self:output("\n") end
							else
								do self:output(",\n") end
							end
							do self:output("[") end
							do self:dumpExpression(value, nil, false) end
							do self:output("] = true") end
						end
						do n4 = n4 + 1 end
					end
				end
			end
			do self:decreaseIndent() end
			do self:output("\n") end
			do self:output("}") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ArrayLiteralExpressionNode') ~= nil) then
		local alit = node
		do self:output("{") end
		do self:increaseIndent() end
		do
			local first = true
			local array = alit:getExpressions()
			if array ~= nil then
				local n5 = 0
				local m4 = _g.jk.lang.Vector:getSize(array)
				do
					n5 = 0
					while n5 < m4 do
						local value = _vm:to_table_with_key(array[n5 + 1], '_isType.sling.common.ExpressionNode')
						if value ~= nil then
							if first then
								do self:output("\n") end
							else
								do self:output(",\n") end
							end
							first = false
							do self:dumpExpression(value, nil, false) end
						end
						do n5 = n5 + 1 end
					end
				end
			end
			do self:decreaseIndent() end
			do self:output("\n") end
			do self:output("}") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EqualsExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "==") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NotEqualsExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "~=") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GreaterOrEqualExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, ">=") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GreaterThanExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, ">") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LessOrEqualExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "<=") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LessThanExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "<") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringEqualsExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "==") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SubscriptExpressionNode') ~= nil) then
		local se = node
		local xpr = se:getChild()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null child", se, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpExpression(xpr, se, false) end
		do
			local array2 = se:getSubscripts()
			if array2 ~= nil then
				local n6 = 0
				local m5 = _g.jk.lang.Vector:getSize(array2)
				do
					n6 = 0
					while n6 < m5 do
						local subscript = _vm:to_table_with_key(array2[n6 + 1], '_isType.sling.common.ExpressionNode')
						if subscript ~= nil then
							do self:output("[") end
							do self:dumpExpression(subscript, nil, false) end
							do self:output("]") end
						end
						do n6 = n6 + 1 end
					end
				end
			end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalNotExpressionNode') ~= nil) then
		local ln = node
		local xpr = ln:getExpression()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", ln, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("not ") end
		do self:dumpExpression(xpr, ln, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalAndExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "and") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LogicalOrExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "or") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StringConcatenationExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "..") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationExpressionNode') ~= nil) then
		local fd = node:getDeclaration()
		if not (fd ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null declaration", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:dumpFunctionDeclaration(fd, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AdditionExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "+") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.SubtractionExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "-") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DivisionExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "/") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultiplicationExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "*") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ModuloExpressionNode') ~= nil) then
		do self:dumpBinaryOperatorExpression(node, "%") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmptyExpressionNode') ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CreateObjectExpressionNode') ~= nil) then
		local co = node
		local type = co:getType()
		if not (type ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type", co, _g.jk.lang.StackTrace:generate()))
		end
		if (_vm:to_table_with_key(type, '_isType.sling.model.VectorDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.MapDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
			do self:output("{}") end
			do return end
		end
		do
			local params = co:getParameters()
			local nparams = _g.jk.lang.Vector:getSize(params)
			local ctorname = "_construct" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(nparams))
			do self:dumpDataType(type) end
			do self:output(".") end
			do self:output(ctorname) end
			do self:output("(") end
			do self:dumpDataType(type) end
			do self:output("._create()") end
			if params ~= nil then
				local n7 = 0
				local m6 = _g.jk.lang.Vector:getSize(params)
				do
					n7 = 0
					while n7 < m6 do
						local param = _vm:to_table_with_key(params[n7 + 1], '_isType.sling.common.ExpressionNode')
						if param ~= nil then
							do self:output(", ") end
							do self:dumpExpression(param, nil, false) end
						end
						do n7 = n7 + 1 end
					end
				end
			end
			do self:output(")") end
			if co:getInitializers() ~= nil then
				do _g.sling.common.RefLog:warning(self.ctx, "initializers are not supported in Lua", co) end
			end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NullLiteralExpressionNode') ~= nil) then
		do self:output("nil") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NegativeNumberExpressionNode') ~= nil) then
		do self:output("-") end
		do
			local xpr = node:getExpression()
			if not (xpr ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xpr, node, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.CurrentObjectExpressionNode') ~= nil) then
		do self:output("self") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AllocateBufferExpressionNode') ~= nil) then
		do self:output("_util:allocate_buffer(") end
		do
			local xpr = node:getExpression()
			if not (xpr ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(")") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BooleanLiteralExpressionNode') ~= nil) then
		local val = node:getValue()
		if val then
			do self:output("true") end
		else
			do self:output("false") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.TypeCheckExpressionNode') ~= nil) then
		local tcx = node
		local type = tcx:getType()
		if not (type ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null type", tcx, _g.jk.lang.StackTrace:generate()))
		end
		do
			local xpr = tcx:getExpression()
			if not (xpr ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", tcx, _g.jk.lang.StackTrace:generate()))
			end
			do
				local typeFunction = "_vm:get_variable_type"
				if (_vm:to_table_with_key(type, '_isType.sling.model.ObjectDataTypeNode') ~= nil) then
					do self:output("(function(x) return x ~= nil and " .. _g.jk.lang.String:safeString(typeFunction) .. "(x) == 'table' and x._isClassInstance == true end)(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(")") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.ExceptionDataTypeNode') ~= nil) then
					do _g.sling.common.RefLog:warning(self.ctx, "Type checking for exception data types cannot be done reliably. It is recommended to find a different way.", node) end
					do self:output("(function(x) return x ~= nil and " .. _g.jk.lang.String:safeString(typeFunction) .. "(x) == 'table' and x._isClassInstance == true end)(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(")") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.BufferDataTypeNode') ~= nil) then
					do self:output("_util:is_buffer(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(")") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.VectorDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.StaticArrayDataTypeNode') ~= nil) then
					do _g.sling.common.RefLog:warning(self.ctx, "Type checking for vector and array data types cannot be done reliably. It is recommended to find a different way.", node) end
					do self:output("(function(x) return x ~= nil and " .. _g.jk.lang.String:safeString(typeFunction) .. "(x) == 'table' and not x._isClassInstance == true and #x > 0 end)(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(")") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.MapDataTypeNode') ~= nil) then
					do _g.sling.common.RefLog:warning(self.ctx, "Type checking for map data types cannot be done reliably. It is recommended to find a different way.", node) end
					do self:output("(function(x) return x ~= nil and " .. _g.jk.lang.String:safeString(typeFunction) .. "(x) == 'table' and not x._isClassInstance == true and #x < 1 end)(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(")") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.StringDataTypeNode') ~= nil) then
					do self:output("(" .. _g.jk.lang.String:safeString(typeFunction) .. "(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(") == 'string')") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.FunctionDataTypeNode') ~= nil) then
					do self:output("(" .. _g.jk.lang.String:safeString(typeFunction) .. "(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(") == 'function')") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.BooleanDataTypeNode') ~= nil) then
					do self:output("(" .. _g.jk.lang.String:safeString(typeFunction) .. "(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(") == 'boolean')") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.FloatDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.DoubleDataTypeNode') ~= nil) or (_vm:to_table_with_key(type, '_isType.sling.model.CharacterDataTypeNode') ~= nil) then
					do self:output("(" .. _g.jk.lang.String:safeString(typeFunction) .. "(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(") == 'number')") end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) then
					do self:output("(_vm:to_table_with_key(") end
					do self:dumpExpression(xpr, nil, false) end
					do self:output(", '") end
					do
						local names = _g.sling.util.SymbolUtil:getSymbolNames(type:getSymbol())
						if not (names ~= nil) then
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type symbol has no names", type, _g.jk.lang.StackTrace:generate()))
						end
						do self:output(self:getIsTypeVariableName(names)) end
						do self:output("') ~= nil)") end
					end
				elseif (_vm:to_table_with_key(type, '_isType.sling.model.DynamicDataTypeNode') ~= nil) then
					do self:output("true") end
				else
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. type:getNodeTypeName() .. "' in context `" .. "type check expression" .. "'", type, nil))
				end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DynamicCastExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local type = _vm:to_table_with_key(node:getType(), '_isType.sling.model.ReferenceDataTypeNode')
			if not (type ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("only reference data types are supported in dynamic cast expressions", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:output("_vm:to_table_with_key(") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(", '") end
			do
				local names = _g.sling.util.SymbolUtil:getSymbolNames(type:getSymbol())
				if not (names ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type symbol has no names", type, _g.jk.lang.StackTrace:generate()))
				end
				do self:output(self:getIsTypeVariableName(names)) end
				do self:output("')") end
				do return end
			end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.StaticCastExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local type = node:getType()
			if type ~= nil and (_vm:to_table_with_key(type, '_isType.sling.model.IntegerDataTypeNode') ~= nil) then
				do self:output("_util:convert_to_integer(") end
				do self:dumpExpression(xpr, nil, false) end
				do self:output(")") end
			else
				do self:dumpExpression(xpr, parent, false) end
			end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetExpressionTypeinfoExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if not (xpr ~= nil) then
			xpr = _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())
		end
		do self:output("_vm:get_datatype_info(") end
		do self:dumpExpression(xpr, nil, false) end
		do self:output(")") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PostDecrementExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if (_vm:to_table_with_key(node:getParent(), '_isType.sling.model.BlockNode') ~= nil) then
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" - 1") end
		else
			do self:output("(function() local v = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" - 1 return v end)()") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PostIncrementExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if (_vm:to_table_with_key(node:getParent(), '_isType.sling.model.BlockNode') ~= nil) then
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" + 1") end
		else
			do self:output("(function() local v = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" + 1 return v end)()") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreDecrementExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if (_vm:to_table_with_key(node:getParent(), '_isType.sling.model.BlockNode') ~= nil) then
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" - 1") end
		else
			do self:output("(function() ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" - 1 return ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" end)()") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PreIncrementExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if (_vm:to_table_with_key(node:getParent(), '_isType.sling.model.BlockNode') ~= nil) then
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" + 1") end
		else
			do self:output("(function() ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" = ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" + 1 return ") end
			do self:dumpExpression(xpr, nil, false) end
			do self:output(" end)()") end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ArrayCreationExpressionNode') ~= nil) then
		local acx = node
		local lit = acx:getArrayLiteral()
		if lit ~= nil then
			do self:dumpExpression(lit, parent, false) end
		else
			local dims = acx:getDimensionCount()
			if dims < 1 then
				do self:output("{}") end
			elseif dims == 1 then
				local dim = _vm:to_table_with_key(_g.jk.lang.Vector:get(acx:getDimensions(), 0), '_isType.sling.common.ExpressionNode')
				if not (dim ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null dimension 0", acx, _g.jk.lang.StackTrace:generate()))
				end
				do self:output("_vm:allocate_array(") end
				do self:dumpExpression(dim, nil, false) end
				do self:output(")") end
			else
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Multiple dimensions in array creation expressions is not supported.", node, _g.jk.lang.StackTrace:generate()))
			end
		end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetSizeExpressionNode') ~= nil) then
		local xpr = node:getExpression()
		if not (xpr ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
		end
		do self:output("#") end
		do self:dumpExpression(xpr, node, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmbedBlockNode') ~= nil) then
		do self:dumpEmbedBlock(node, true) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AppendToVectorExpressionNode') ~= nil) then
		local avec = node
		local left = avec:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", avec, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = avec:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", avec, _g.jk.lang.StackTrace:generate()))
			end
			if (_vm:to_table_with_key(not (left ~= nil), '_isType.sling.model.SymbolExpressionNode') ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("appending to non-symbol expression vector", avec, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, nil, false) end
			do self:output("[#") end
			do self:dumpExpression(left, nil, false) end
			do self:output(" + 1] = ") end
			do self:dumpExpression(right, nil, false) end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BufferLiteralExpressionNode') ~= nil) then
		do self:output("_util:create_buffer({") end
		do
			local first = true
			local buf = node:getValue()
			if buf ~= nil then
				local sz = #buf
				do
					local n = 0
					while n < sz do
						if first then
							do self:output(" ") end
							first = false
						else
							do self:output(",") end
						end
						do self:output(_g.jk.lang.String:forInteger(buf[n + 1])) end
						do n = n + 1 end
					end
				end
			end
			if not first then
				do self:output(" ") end
			end
			do self:output("})") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GetDatatypeTypeinfoExpressionNode') ~= nil) then
		do self:output("\"" .. _g.jk.lang.String:safeString(_g.sling.util.DataTypeUtil:getDataTypeName(node:getType())) .. "\"") end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "expression" .. "'", node, nil))
end

function sling.sushi.compiler.SushiLuaGenerator:dumpEmbedBlock(node, isExpression)
	if not (node ~= nil) then
		do return end
	end
	do
		local nt = node:getType()
		if not (nt == nil or nt == "lua") then
			do return end
		end
		do
			local cc = node:getCode()
			if not _g.jk.lang.String:isNotEmpty(cc) then
				do return end
			end
			do
				local first = true
				local array = _g.jk.lang.String:split(cc, 10, 0)
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local line = array[n + 1]
							if line ~= nil then
								line = _g.jk.lang.String:strip(line)
								if _g.jk.lang.String:isEmpty(line) == false then
									if isExpression then
										if not first then
											do self:output(" ") end
										end
										do self:output(line) end
									else
										do self:output(_g.jk.lang.String:safeString(line) .. "\n") end
									end
								end
								first = false
							end
							do n = n + 1 end
						end
					end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpBinaryOperatorExpression(node, op)
	if not (node ~= nil) then
		do return end
	end
	do
		local left = node:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = node:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", node, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpression(left, node, false) end
			do self:output(" " .. _g.jk.lang.String:safeString(op) .. " ") end
			do self:dumpExpression(right, node, true) end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:separateStatements(node, prev, context)
	if context == "class" or context == "script" or context == "namespace" then
		if prev == nil then
		elseif (_vm:to_table_with_key(node, '_isType.sling.model.EntityDeclarationNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationBaseNode') ~= nil) or (_vm:to_table_with_key(node, '_isType.sling.model.EntityDeclarationNode') ~= nil) then
			do self:output("\n") end
		elseif _g.jk.lang.String:equals(prev:getNodeTypeName(), node:getNodeTypeName()) == false then
			do self:output("\n") end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:getQualifiedName(name, delim)
	if not (name ~= nil) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		local array = self.nameStack:getData()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local nn = array[n + 1]
					if nn ~= nil then
						if sb:count() > 0 then
							do sb:appendCharacter(46) end
						end
						do sb:appendString(nn) end
					end
					do n = n + 1 end
				end
			end
		end
		if sb:count() > 0 then
			do sb:appendCharacter(delim) end
		end
		do sb:appendString(name) end
		do return sb:toString() end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpNamespace(node)
	local nname = node:getName()
	if _g.jk.lang.String:isEmpty(nname) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("no name", node, _g.jk.lang.StackTrace:generate()))
	end
	do
		local name = self:getQualifiedName(nname, 46)
		do self:output(name) end
		do self:output(" = ") end
		do self:output(name) end
		do self:output(" or {}\n\n") end
		do self.nameStack:push(nname) end
		do self:dumpContainer(node, "namespace") end
		do self.nameStack:pop() end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:getSetMetaTableCallString()
	do return "_vm:set_metatable" end
end

function sling.sushi.compiler.SushiLuaGenerator:hasDestructor(node)
	local array = node:getNodes()
	if array ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(array)
		do
			n = 0
			while n < m do
				local dd = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.DestructorDeclarationNode')
				if dd ~= nil then
					do return true end
				end
				do n = n + 1 end
			end
		end
	end
	do return false end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpClassDeclaration(node)
	local nname = node:getName()
	if _g.jk.lang.String:isEmpty(nname) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("no name", node, _g.jk.lang.StackTrace:generate()))
	end
	do
		local baseclass = _g.sling.util.EntityUtil:getBaseClassTypeForEntity(node)
		local name = self:getQualifiedName(nname, 46)
		do self:output(name) end
		do self:output(" = ") end
		if baseclass ~= nil then
			do self:dumpDataType(baseclass) end
			do self:output("._create()\n") end
		else
			do self:output("{}\n") end
		end
		do self:output(_g.jk.lang.String:safeString(name) .. ".__index = " .. _g.jk.lang.String:safeString(name) .. "\n") end
		if baseclass ~= nil then
			do self:output(_g.jk.lang.String:safeString(self:getSetMetaTableCallString()) .. "(" .. _g.jk.lang.String:safeString(name) .. ", {\n") end
			do self:increaseIndent() end
			do self:output("__index = ") end
			do self:dumpDataType(baseclass) end
			do self:output("\n") end
			do self:decreaseIndent() end
			do self:output("})\n") end
		else
			do self:output(_g.jk.lang.String:safeString(self:getSetMetaTableCallString()) .. "(" .. _g.jk.lang.String:safeString(name) .. ", {})\n") end
		end
		do self:output("\n") end
		do self.nameStack:push(nname) end
		do
			local statics = 0
			local array = node:getNodes()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local child = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
						if child ~= nil then
							if child:hasModifier(_g.sling.model.Modifier.STATIC) then
								local vd = child
								do self:output(self:getQualifiedName(vd:getName(), 46)) end
								do self:output(" = ") end
								do
									local init = vd:getInitializer()
									if init ~= nil then
										do self:dumpExpression(init, nil, false) end
									else
										do self:output("{}") end
									end
									do self:output("\n") end
									do statics = statics + 1 end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
			if statics > 0 then
				do self:output("\n") end
			end
			do self:output("function " .. _g.jk.lang.String:safeString(name) .. "._create()\n") end
			do self:increaseIndent() end
			do self:output("local v = " .. _g.jk.lang.String:safeString(self:getSetMetaTableCallString()) .. "({}, " .. _g.jk.lang.String:safeString(name) .. ")\n") end
			do self:output("return v\n") end
			do self:decreaseIndent() end
			do self:output("end\n") end
			do self:output("\n") end
			do self:output("function " .. _g.jk.lang.String:safeString(name) .. ":_init()\n") end
			do self:increaseIndent() end
			do self:output("self._isClassInstance = true\n") end
			do self:output("self._qualifiedClassName = self._qualifiedClassName or '" .. _g.jk.lang.String:safeString(name) .. "'\n") end
			do self:output("self['" .. _g.jk.lang.String:safeString(self:getIsTypeVariableName(self.nameStack:getData())) .. "'] = true\n") end
			do
				local array2 = node:getBaseTypes()
				if array2 ~= nil then
					local n2 = 0
					local m2 = _g.jk.lang.Vector:getSize(array2)
					do
						n2 = 0
						while n2 < m2 do
							local basetype = _vm:to_table_with_key(array2[n2 + 1], '_isType.sling.model.BaseTypeNode')
							if basetype ~= nil then
								local type = basetype:getInheritType()
								if type ~= _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT then
									goto _continue6
								end
								do
									local reftype = basetype:getReferenceType()
									if not (reftype ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Null reference type", basetype, _g.jk.lang.StackTrace:generate()))
									end
									do
										local names = _g.sling.util.SymbolUtil:getSymbolNames(reftype:getSymbol())
										if not (names ~= nil) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Data type symbol has no names", reftype, _g.jk.lang.StackTrace:generate()))
										end
										do self:output("self['" .. _g.jk.lang.String:safeString(self:getIsTypeVariableName(names)) .. "'] = true\n") end
									end
								end
							end
							::_continue6::
							do n2 = n2 + 1 end
						end
					end
				end
				do
					local array3 = node:getNodes()
					if array3 ~= nil then
						local n3 = 0
						local m3 = _g.jk.lang.Vector:getSize(array3)
						do
							n3 = 0
							while n3 < m3 do
								local child = _vm:to_table_with_key(array3[n3 + 1], '_isType.sling.model.VariableDeclarationNode')
								if child ~= nil then
									if child:hasModifier(_g.sling.model.Modifier.STATIC) == false then
										do self:output("self.") end
										do self:output(child:getName()) end
										do self:output(" = ") end
										do
											local init = child:getInitializer()
											if init ~= nil then
												do self:dumpExpression(init, nil, false) end
											else
												do self:output("{}") end
											end
											do self:output("\n") end
										end
									end
								end
								do n3 = n3 + 1 end
							end
						end
					end
					if self:hasDestructor(node) then
						do self:output("self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)\n") end
					end
					do self:decreaseIndent() end
					do self:output("end\n") end
					do
						local prev = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
						local array4 = node:getNodes()
						if array4 ~= nil then
							local n4 = 0
							local m4 = _g.jk.lang.Vector:getSize(array4)
							do
								n4 = 0
								while n4 < m4 do
									local child = _vm:to_table_with_key(array4[n4 + 1], '_isType.sling.common.NodeObject')
									if child ~= nil then
										if (_vm:to_table_with_key(child, '_isType.sling.model.VariableDeclarationNode') ~= nil) then
											goto _continue7
										end
										do self:separateStatements(child, prev, "class") end
										prev = child
										do self:dumpStatement(child, "class") end
									end
									::_continue7::
									do n4 = n4 + 1 end
								end
							end
						end
						do self.nameStack:pop() end
					end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpIfStatement(node)
	local condition = node:getCondition()
	if not (condition ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("if ") end
	do self:dumpExpression(condition, nil, false) end
	do self:output(" then\n") end
	do self:increaseIndent() end
	do
		local ifblock = node:getIfBlock()
		if ifblock ~= nil then
			do self:dumpBlock(ifblock) end
		end
		do self:decreaseIndent() end
		do
			local elseblock = node:getElseBlock()
			if elseblock ~= nil then
				local elsenodes = elseblock:getNodes()
				local sz = _g.jk.lang.Vector:getSize(elsenodes)
				if sz < 1 then
					do self:output("end\n") end
				elseif sz == 1 and (_vm:to_table_with_key(_g.jk.lang.Vector:get(elsenodes, 0), '_isType.sling.model.IfStatementNode') ~= nil) then
					do self:output("else") end
					do self:dumpIfStatement(_vm:to_table_with_key(_g.jk.lang.Vector:get(elsenodes, 0), '_isType.sling.model.IfStatementNode')) end
				else
					do self:output("else\n") end
					do self:increaseIndent() end
					do self:dumpBlock(elseblock) end
					do self:decreaseIndent() end
					do self:output("end\n") end
				end
			else
				do self:output("end\n") end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpWhileStatement(node)
	local condition = node:getCondition()
	if not (condition ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("while ") end
	do self:dumpExpression(condition, nil, false) end
	do self:output(" do\n") end
	do self:increaseIndent() end
	do
		local block = node:getBlock()
		if block ~= nil then
			do self:dumpBlock(block) end
		end
		do self:decreaseIndent() end
		do self:output("end\n") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpDoWhileStatement(node)
	local condition = node:getCondition()
	if not (condition ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null condition", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("repeat\n") end
	do self:increaseIndent() end
	do
		local block = node:getBlock()
		if block ~= nil then
			do self:dumpBlock(block) end
		end
		do self:decreaseIndent() end
		do self:output("until not ") end
		do self:dumpExpression(condition, _g.sling.model.LogicalNotExpressionNode._construct0(_g.sling.model.LogicalNotExpressionNode._create()), false) end
		do self:output("\n") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpReturnStatement(node)
	do self:output("do return") end
	do
		local xpr = node:getExpression()
		if xpr ~= nil then
			do self:output(" ") end
			do self:dumpExpressionOrTuple(xpr, nil, false) end
		end
		do self:output(" end\n") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpBreakStatement(node)
	do self:output("do break end\n") end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpForEachStatement(node)
	do self:output("for ") end
	do
		local lefts = node:getLefts()
		if _g.jk.lang.Vector:isEmpty(lefts) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("empty lefts", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local first = true
			if lefts ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(lefts)
				do
					n = 0
					while n < m do
						local lefto = lefts[n + 1]
						if lefto ~= nil then
							local left = _vm:to_table_with_key(lefto, '_isType.sling.model.VariableDeclarationNode')
							if not (left ~= nil) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Foreach statement does not have a left variable declaration value", node, _g.jk.lang.StackTrace:generate()))
								do return end
							end
							if not first then
								do self:output(", ") end
							end
							first = false
							do self:output(left:getName()) end
						end
						do n = n + 1 end
					end
				end
			end
			do self:output(" in ") end
			do
				local right = node:getRight()
				if not (right ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", node, _g.jk.lang.StackTrace:generate()))
				end
				do self:dumpExpression(right, nil, false) end
				do self:output(" do\n") end
				do self:increaseIndent() end
				do
					local block = node:getBlock()
					if not (block ~= nil) then
						_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null block", node, _g.jk.lang.StackTrace:generate()))
					end
					do self:dumpBlock(block) end
					do self:decreaseIndent() end
					do self:output("end\n") end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpAssertStatement(node)
	if node:getStyle() == _g.sling.model.AssertStatementNode.STYLE_RETURN then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("`Return' style assert statements are not supported in Lua", node, _g.jk.lang.StackTrace:generate()))
	end
	do
		local child = node:getChild()
		if not (child ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null child", node, _g.jk.lang.StackTrace:generate()))
		end
		do
			local xpr = _vm:to_table_with_key(child, '_isType.sling.common.ExpressionNode')
			if not (xpr ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("child is not an expression", node, _g.jk.lang.StackTrace:generate()))
			end
			do
				local block = node:getErrorBlock()
				if block ~= nil then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Error block in assert is not supported in Lua", node, _g.jk.lang.StackTrace:generate()))
				end
				do self:output("assert(") end
				do self:dumpExpression(xpr, nil, false) end
				do
					local error = node:getErrorMessage()
					if error ~= nil then
						do self:output(", ") end
						do self:dumpExpression(error, nil, false) end
					end
					do self:output(")\n") end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpThrowStatement(node)
	local xpr = node:getExpression()
	if not (xpr ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null expression", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("_vm:throw_error(") end
	do self:dumpExpression(xpr, nil, false) end
	do self:output(")\n") end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpInterfaceDeclaration(node)
	local name = node:getName()
	if _g.jk.lang.String:isEmpty(name) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("empty name", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output(self:getQualifiedName(name, 46)) end
	do self:output(" = {}\n") end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpPrintLineStatement(node)
	do self:output("_io:write_to_stdout(") end
	do
		local xpr = node:getExpression()
		if xpr ~= nil then
			do self:dumpExpression(xpr, nil, false) end
		end
		do self:output(" .. \"\\n\"") end
		do self:output(")\n") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpPrintStatementForSushi(node)
	do self:output("_io:write_to_stdout(") end
	do
		local xpr = node:getExpression()
		if xpr ~= nil then
			do self:dumpExpression(xpr, nil, false) end
		end
		do self:output(")\n") end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpConstructorDeclaration(node)
	local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.EntityDeclarationNode')
	if not (pp ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("constructor's parent is not an entity!", node, _g.jk.lang.StackTrace:generate()))
	end
	do
		local nparams = _g.jk.lang.Vector:getSize(node:getParameters())
		local shortname = "_construct" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forInteger(nparams))
		local name = self:getQualifiedName(shortname, 58)
		do self:output("function " .. _g.jk.lang.String:safeString(name) .. "(") end
		do
			local first = true
			local array = node:getParameters()
			if array ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n = 0
					while n < m do
						local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
						if param ~= nil then
							if not first then
								do self:output(", ") end
							end
							first = false
							do self:dumpFunctionParameter(param) end
						end
						do n = n + 1 end
					end
				end
			end
			do self:output(")\n") end
			do self:increaseIndent() end
			do self:output(self:getQualifiedName("_init", 46)) end
			do self:output("(self)\n") end
			do
				local next = node:getNext()
				if next ~= nil then
					do self:dumpStatement(next, "block") end
				end
				do
					local block = node:getBody()
					if block ~= nil then
						do self:dumpBlock(block) end
					end
					do self:output("return self\n") end
					do self:decreaseIndent() end
					do self:output("end\n") end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpDestructorDeclaration(node)
	local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.EntityDeclarationNode')
	if not (pp ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("destructor's parent is not an entity!", node, _g.jk.lang.StackTrace:generate()))
	end
	do
		local shortname = "_destruct"
		local name = self:getQualifiedName(shortname, 58)
		do self:output("function " .. _g.jk.lang.String:safeString(name) .. "()\n") end
		do self:increaseIndent() end
		do
			local block = node:getBody()
			if block ~= nil then
				do self:dumpBlock(block) end
			end
			do self:decreaseIndent() end
			do self:output("end\n") end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpGoToStatement(node)
	local target = node:getTarget()
	if not (target ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null target", node, _g.jk.lang.StackTrace:generate()))
	end
	do self:output("goto ") end
	do self:dumpExpression(target, nil, false) end
	do self:output("\n") end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpLabeledStatement(node, context)
	local name = node:getName()
	if _g.jk.lang.String:isNotEmpty(name) then
		do self:output("::") end
		do self:output(name) end
		do self:output("::\n") end
	end
	do
		local stmt = node:getStatement()
		if stmt ~= nil then
			do self:dumpStatement(stmt, context) end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpMultipleVariableDeclaration(node)
	local variables = node:getVariables()
	local sz = _g.jk.lang.Vector:getSize(variables)
	if sz < 1 then
		do return end
	end
	do
		local init = node:getInitializer()
		if not (init ~= nil) then
			if variables ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(variables)
				do
					n = 0
					while n < m do
						local variable = _vm:to_table_with_key(variables[n + 1], '_isType.sling.model.VariableDeclarationNode')
						if variable ~= nil then
							do self:dumpLocalVariableDeclaration(variable) end
						end
						do n = n + 1 end
					end
				end
			end
		else
			do self:output("local ") end
			do
				local first = true
				if variables ~= nil then
					local n2 = 0
					local m2 = _g.jk.lang.Vector:getSize(variables)
					do
						n2 = 0
						while n2 < m2 do
							local variable = _vm:to_table_with_key(variables[n2 + 1], '_isType.sling.model.VariableDeclarationNode')
							if variable ~= nil then
								if not first then
									do self:output(", ") end
								end
								first = false
								do self:output(variable:getName()) end
							end
							do n2 = n2 + 1 end
						end
					end
				end
				do self:output(" = ") end
				do self:dumpExpression(init, nil, false) end
				do self:output("\n") end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpStatement(node, context)
	if (_vm:to_table_with_key(node, '_isType.sling.model.CommentNode') ~= nil) then
		do self:dumpComment(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ImportPackageStatementNode') ~= nil) then
		do self:dumpImportPackageStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.FunctionDeclarationNode') ~= nil) then
		do self:dumpFunctionDeclaration(node, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ConstructorDeclarationNode') ~= nil) then
		do self:dumpConstructorDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DestructorDeclarationNode') ~= nil) then
		do self:dumpDestructorDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AssignmentExpressionNode') ~= nil) then
		local assn = node
		local left = assn:getLeft()
		if not (left ~= nil) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null left", assn, _g.jk.lang.StackTrace:generate()))
		end
		do
			local right = assn:getRight()
			if not (right ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null right", assn, _g.jk.lang.StackTrace:generate()))
			end
			do self:dumpExpressionOrTuple(left, nil, false) end
			do self:output(" = ") end
			do self:dumpExpressionOrTuple(right, nil, false) end
			do self:output("\n") end
			do return end
		end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.common.ExpressionNode') ~= nil) then
		do self:output("do ") end
		do self:dumpExpression(node, nil, false) end
		do self:output(" end\n") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ClassDeclarationNode') ~= nil) then
		do self:dumpClassDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.InterfaceDeclarationNode') ~= nil) then
		do self:dumpInterfaceDeclaration(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.IfStatementNode') ~= nil) then
		do self:dumpIfStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.WhileStatementNode') ~= nil) then
		do self:dumpWhileStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.DoWhileStatementNode') ~= nil) then
		do self:dumpDoWhileStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BlockNode') ~= nil) then
		do self:output("do\n") end
		do self:increaseIndent() end
		do self:dumpBlock(node) end
		do self:decreaseIndent() end
		do self:output("end\n") end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ReturnStatementNode') ~= nil) then
		do self:dumpReturnStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.BreakStatementNode') ~= nil) then
		do self:dumpBreakStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmptyStatementNode') ~= nil) then
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ForEachStatementNode') ~= nil) then
		do self:dumpForEachStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.AssertStatementNode') ~= nil) then
		do self:dumpAssertStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.ThrowStatementNode') ~= nil) then
		do self:dumpThrowStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PrintLineStatementNode') ~= nil) then
		do self:dumpPrintLineStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.PrintStatementNode') ~= nil) then
		do self:dumpPrintStatementForSushi(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.GoToLabelStatementNode') ~= nil) then
		do self:dumpGoToStatement(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.LabeledStatementNode') ~= nil) then
		do self:dumpLabeledStatement(node, context) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.NamespaceNode') ~= nil) then
		do self:dumpNamespace(node) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.EmbedBlockNode') ~= nil) then
		do self:dumpEmbedBlock(node, false) end
		do return end
	end
	if (_vm:to_table_with_key(node, '_isType.sling.model.MultipleVariableDeclarationNode') ~= nil) then
		do self:dumpMultipleVariableDeclaration(node) end
		do return end
	end
	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. context .. "'", node, nil))
end

function sling.sushi.compiler.SushiLuaGenerator:dumpModule(module)
	if not (module ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null module", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local array = module:getNodes()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local node = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.NodeObject')
					if node ~= nil then
						if (_vm:to_table_with_key(node, '_isType.sling.common.CodeFileNode') ~= nil) then
							do self:dumpFile(node) end
						else
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported node type `" .. node:getNodeTypeName() .. "' in context `" .. "module" .. "'", node, nil))
						end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:dumpFile(file)
	if not (file ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("null file", nil, _g.jk.lang.StackTrace:generate()))
	end
	do
		local name = file:getNodeName()
		if _g.jk.lang.String:isEmpty(name) then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Code file node has no name!", file, _g.jk.lang.StackTrace:generate()))
		end
		do self:startFile(_g.jk.lang.String:safeString(name) .. ".lua") end
		do self:dumpScript(file) end
		do self:endFile() end
	end
end

function sling.sushi.compiler.SushiLuaGenerator:getExcludeComments()
	do return self.excludeComments end
end

function sling.sushi.compiler.SushiLuaGenerator:setExcludeComments(v)
	self.excludeComments = v
	do return self end
end
sling = sling or {}

sling.ss = sling.ss or {}

sling.ss.compiler = sling.ss.compiler or {}

sling.ss.compiler.SlingScriptToSushiCompiler = {}
sling.ss.compiler.SlingScriptToSushiCompiler.__index = sling.ss.compiler.SlingScriptToSushiCompiler
_vm:set_metatable(sling.ss.compiler.SlingScriptToSushiCompiler, {})

function sling.ss.compiler.SlingScriptToSushiCompiler._create()
	local v = _vm:set_metatable({}, sling.ss.compiler.SlingScriptToSushiCompiler)
	return v
end

function sling.ss.compiler.SlingScriptToSushiCompiler:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.ss.compiler.SlingScriptToSushiCompiler'
	self['_isType.sling.ss.compiler.SlingScriptToSushiCompiler'] = true
	self.workDir = nil
	self.libraryManager = nil
	self.linkUsedLibraries = true
end

function sling.ss.compiler.SlingScriptToSushiCompiler:_construct0()
	sling.ss.compiler.SlingScriptToSushiCompiler._init(self)
	return self
end

function sling.ss.compiler.SlingScriptToSushiCompiler:compileFileToBuffer(ctx, script)
	do return self:processCodeFile(ctx, _g.sling.ss.parser.SlingScriptParser._construct0(_g.sling.ss.parser.SlingScriptParser._create()):parseFile(script)) end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:compileStringToBuffer(ctx, script)
	do return self:processCodeFile(ctx, _g.sling.ss.parser.SlingScriptParser._construct0(_g.sling.ss.parser.SlingScriptParser._create()):parseString(script, "code")) end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:compileFileToFile(ctx, script, output)
	do self:saveOutput(self:compileFileToBuffer(ctx, script), output) end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:compileStringToFile(ctx, script, output)
	do self:saveOutput(self:compileStringToBuffer(ctx, script), output) end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:saveOutput(data, output)
	if output ~= nil then
		if output:setContentsBuffer(data) == false then
			_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to write file: `" .. _g.jk.lang.String:safeString(output:getPath()) .. "'", nil, nil))
		end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:setWorkDir(dir)
	self.workDir = dir
end

function sling.ss.compiler.SlingScriptToSushiCompiler:getWorkDir()
	if not (self.workDir ~= nil) then
		self.workDir = _g.jk.env.TemporaryDirectory:create()
	end
	if not (self.workDir ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unable to create a temporary working directory", nil, nil))
	end
	do return self.workDir end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:simpleSymbolToString(symbol)
	local names = _g.sling.util.SymbolUtil:getSymbolComponents(symbol)
	if _g.jk.lang.Vector:isEmpty(names) then
		do return nil end
	end
	do
		local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
		if names ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(names)
			do
				n = 0
				while n < m do
					local o = names[n + 1]
					if o ~= nil then
						local s = nil
						if (_vm:get_variable_type(o) == 'string') then
							s = o
						elseif (_vm:to_table_with_key(o, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
							s = o:getName()
						end
						if _g.jk.lang.String:isNotEmpty(s) then
							if sb:count() > 0 then
								do sb:appendCharacter(46) end
							end
							do sb:appendString(s) end
						end
					end
					do n = n + 1 end
				end
			end
		end
		do return sb:toString() end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:getModuleInfoFromMap(modname, importNode, moduleMap)
	local modinfo = _g.jk.lang.Map:get(moduleMap, modname)
	if not (modinfo ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to find imported module: `" .. _g.jk.lang.String:safeString(modname) .. "'", importNode, nil))
	end
	do return modinfo end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:getLinkTargetsForModulesRecursive(ctx, modname, importNode, moduleMap, processed, result)
	if not _g.jk.lang.String:isNotEmpty(modname) then
		do _g.jk.log.Log:warning(ctx, "Empty modname for getLinkTargetsForModulesRecursive") end
		do return end
	end
	if not not processed:contains(modname) then
		do return end
	end
	do processed:add(modname) end
	do
		local modinfo = self:getModuleInfoFromMap(modname, importNode, moduleMap)
		local array = modinfo:getDependencies()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local dep = array[n + 1]
					if dep ~= nil then
						do self:getLinkTargetsForModulesRecursive(ctx, dep, importNode, moduleMap, processed, result) end
					end
					do n = n + 1 end
				end
			end
		end
		do
			local modfile = modinfo:getLinkTarget()
			if not (modfile ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Module info has no link target: `" .. _g.jk.lang.String:safeString(modname) .. "'", importNode, nil))
			end
			do _g.jk.lang.Vector:append(result, modfile) end
		end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:getModuleSymbols(ctx, moduleMap, importNode, modname)
	local modinfo = self:getModuleInfoFromMap(modname, importNode, moduleMap)
	local apifile = modinfo:getApifile()
	if not (apifile ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Library has no API file: `" .. _g.jk.lang.String:safeString(modname) .. "'", importNode, nil))
	end
	do
		local str = " name " .. _g.jk.lang.String:safeString(modname) .. "."
		local strlen = _g.jk.lang.String:getLength(str)
		local v = {}
		do _g.jk.log.Log:debug(ctx, "Reading symbols from file: `" .. _g.jk.lang.String:safeString(apifile:getPath()) .. "'") end
		do
			local it = apifile:readLines()
			while it ~= nil do
				local line = it:next()
				if not (line ~= nil) then
					do break end
				end
				do
					local c = _g.jk.lang.String:getChar(line, 0)
					if c == 32 or c == 9 or c == 13 or c == 10 then
						goto _continue1
					end
					do
						local idx = _g.jk.lang.String:getIndexOfString(line, str, 0)
						if idx < 0 then
							goto _continue1
						end
						do
							local s = idx + strlen
							local _end = _g.jk.lang.String:getEndOfString(line, s)
							local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
							local sit = _g.jk.lang.String:iterate(_end)
							while sit ~= nil do
								local c = sit:getNextChar()
								if _g.jk.lang.Character:isEOF(c) then
									do break end
								end
								if c == 32 or c == 60 or c == 13 or c == 10 then
									do break end
								end
								do sb:appendCharacter(c) end
							end
							do
								local name = sb:toString()
								if _g.jk.lang.String:isNotEmpty(name) then
									do _g.jk.lang.Vector:append(v, name) end
								end
							end
						end
					end
				end
				::_continue1::
			end
			do return v end
		end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:createNewSymbol(symbol, append)
	local ss = self:simpleSymbolToString(symbol)
	if not (ss ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to stringify symbol", symbol, nil))
	end
	do
		local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
		local array = _g.jk.lang.String:split(ss, 46, 0)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local comp = array[n + 1]
					if comp ~= nil then
						do v:addNameToComponents(comp) end
					end
					do n = n + 1 end
				end
			end
		end
		if append ~= nil then
			do v:addNameToComponents(append) end
		end
		do return v end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:processAsLocalLibrary(ctx, dir)
	local customPlingOptions = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	local vendor = "local"
	do customPlingOptions:setString("vendorId", vendor) end
	do
		local name = _g.sling.compiler.SlingCompiler:sanitizeModuleId(dir:getBasename())
		if _g.jk.lang.String:isEmpty(name) then
			name = "local"
		end
		name = _g.jk.lang.String:safeString(name) .. "-" .. _g.jk.lang.String:safeString(_g.jk.sha.SHAEncoder:getSha1HashForString(dir:getPath()))
		do customPlingOptions:setString("projectId", name) end
		do
			local version = "local"
			do customPlingOptions:setString("projectVersion", version) end
			do
				local v = _g.jk.lang.String:safeString(vendor) .. ":" .. _g.jk.lang.String:safeString(name) .. ":" .. _g.jk.lang.String:safeString(version)
				local includes = {}
				do _g.jk.lang.Vector:append(includes, dir) end
				do
					local workdir = self:getWorkDir()
					local outputdir = workdir:entry("slib")
					local cc = _g.sling.sushi.compiler.SlingToSushiCompiler._construct1(_g.sling.sushi.compiler.SlingToSushiCompiler._create(), ctx)
					do cc:setModuleInfoForLibraries(self.libraryManager:generateModuleInfosForBuild(ctx, includes, nil)) end
					do cc:setIncludes(includes) end
					do cc:setWorkDir(workdir) end
					do
						local r = cc:compileSlingLibrary(dir, nil, nil, outputdir, customPlingOptions, true)
						local outputfile = r:getFile()
						if outputfile ~= nil then
							if not self.libraryManager:installLibraryFromFile(ctx, outputfile, true) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to install library file: `" .. _g.jk.lang.String:safeString(outputfile:getPath()) .. "'", nil, nil))
							end
						end
						do return v end
					end
				end
			end
		end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:processCodeFile(ctx, ps)
	if not (ps ~= nil) then
		_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process (null code file node)", nil, nil))
	end
	do
		local libnames = {}
		local dependNodes = _g.sling.util.FindUtil:findNodesOfType(ps, "class:sling.model.DependencyDeclarationNode", false, true, false)
		if dependNodes ~= nil then
			local n2 = 0
			local m = _g.jk.lang.Vector:getSize(dependNodes)
			do
				n2 = 0
				while n2 < m do
					local dependNode = _vm:to_table_with_key(dependNodes[n2 + 1], '_isType.sling.model.DependencyDeclarationNode')
					if dependNode ~= nil then
						local val = dependNode:getValue()
						if _g.jk.lang.String:startsWith(val, "libsrc:", 0) then
							val = _g.jk.lang.String:getEndOfString(val, 7)
							do _g.sling.common.RefLog:debug(ctx, "Processing library source: `" .. _g.jk.lang.String:safeString(val) .. "'", dependNode) end
							do
								local file = ps:getFile()
								if not (file ~= nil) then
									_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Code file has no file reference: Cannot proess path-based dependency", dependNode, nil))
								end
								do
									local pp = file:getParent()
									if not (pp ~= nil) then
										_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Directory has no parent: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", dependNode, nil))
									end
									do
										local array = _g.jk.lang.String:split(val, 47, 0)
										if array ~= nil then
											local n3 = 0
											local m2 = _g.jk.lang.Vector:getSize(array)
											do
												n3 = 0
												while n3 < m2 do
													local comp = array[n3 + 1]
													if comp ~= nil then
														pp = pp:entry(comp)
													end
													do n3 = n3 + 1 end
												end
											end
										end
										if not pp:isDirectory() then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Library directory does not exist: `" .. _g.jk.lang.String:safeString(pp:getPath()) .. "'", dependNode, nil))
										end
										val = self:processAsLocalLibrary(ctx, pp)
										if _g.jk.lang.String:isEmpty(val) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty library name", dependNode, nil))
										end
										do _g.jk.lang.Vector:append(libnames, val) end
									end
								end
							end
						elseif _g.jk.lang.String:startsWith(val, "libname:", 0) then
							val = _g.jk.lang.String:getEndOfString(val, 8)
							if _g.jk.lang.String:isEmpty(val) then
								_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Empty library name", dependNode, nil))
							end
							do _g.jk.lang.Vector:append(libnames, val) end
							do _g.sling.common.RefLog:debug(ctx, "Processing library name: `" .. _g.jk.lang.String:safeString(val) .. "'", dependNode) end
						else
							_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Unsupported dependency declaration: `" .. _g.jk.lang.String:safeString(val) .. "'", dependNode, nil))
						end
						do _g.sling.util.NodeUtil:removeNode(dependNode) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do _g.jk.log.Log:debug(ctx, "Requires libraries: " .. _g.jk.lang.String:safeString(_g.jk.json.JSONEncoder:encode(libnames, true, false))) end
		do
			local libdirs = self.libraryManager:processRequiredLibraries(ctx, libnames)
			if not (libdirs ~= nil) then
				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process library dependencies", ps, nil))
			end
			do
				local moduleInfos = self.libraryManager:generateModuleInfosForLibdirs(ctx, libdirs)
				if not (moduleInfos ~= nil) then
					_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to process module infos", ps, nil))
				end
				do
					local moduleMap = {}
					if moduleInfos ~= nil then
						local n4 = 0
						local m3 = _g.jk.lang.Vector:getSize(moduleInfos)
						do
							n4 = 0
							while n4 < m3 do
								local moduleInfo = moduleInfos[n4 + 1]
								if moduleInfo ~= nil then
									local name = moduleInfo:getModuleId()
									if _g.jk.lang.String:isEmpty(name) then
										goto _continue2
									end
									moduleMap[name] = moduleInfo
								end
								::_continue2::
								do n4 = n4 + 1 end
							end
						end
					end
					do
						local importFiles = {}
						local importNodes = _g.sling.util.FindUtil:findNodesOfType(ps, "class:sling.model.ImportPackageStatementNode", false, true, false)
						local processed = _g.jk.lang.StringSet._construct0(_g.jk.lang.StringSet._create())
						if importNodes ~= nil then
							local n5 = 0
							local m4 = _g.jk.lang.Vector:getSize(importNodes)
							do
								n5 = 0
								while n5 < m4 do
									local importNode = _vm:to_table_with_key(importNodes[n5 + 1], '_isType.sling.model.ImportPackageStatementNode')
									if importNode ~= nil then
										local localName = importNode:getLocalName()
										local ip = importNode:getInsertionPoint()
										if not (ip ~= nil) then
											_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get insertion point!", importNode, nil))
										end
										do
											local modname = self:simpleSymbolToString(importNode:getPackage())
											if _g.jk.lang.String:isNotEmpty(localName) then
												local vd = _g.sling.model.VariableDeclarationNode:forDynamic(localName)
												local dups = _vm:to_table_with_key(_g.sling.util.NodeUtil:dupAsNode(importNode:getPackage()), '_isType.sling.model.SymbolNode')
												if not (dups ~= nil) then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to get duplicate symbol node!", importNode, nil))
												end
												do vd:setInitializer(_g.sling.model.SymbolExpressionNode:forSymbol(dups), false) end
												if not ip:insertBefore(vd) then
													_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insertBefore a node!", importNode, nil))
												end
											else
												local symbols = self:getModuleSymbols(ctx, moduleMap, importNode, modname)
												if symbols ~= nil then
													local n6 = 0
													local m5 = _g.jk.lang.Vector:getSize(symbols)
													do
														n6 = 0
														while n6 < m5 do
															local symbol = symbols[n6 + 1]
															if symbol ~= nil then
																local vd = _g.sling.model.VariableDeclarationNode:forDynamic(symbol)
																do vd:setInitializer(_g.sling.model.SymbolExpressionNode:forSymbol(self:createNewSymbol(importNode:getPackage(), symbol)), false) end
																if not ip:insertBefore(vd) then
																	_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to insertBefore a node!", importNode, nil))
																end
															end
															do n6 = n6 + 1 end
														end
													end
												end
											end
											if _g.jk.lang.String:isNotEmpty(modname) then
												do self:getLinkTargetsForModulesRecursive(ctx, modname, importNode, moduleMap, processed, importFiles) end
											end
											do _g.sling.util.NodeUtil:removeNode(importNode) end
										end
									end
									do n5 = n5 + 1 end
								end
							end
						end
						do _g.sling.op.CommonOps:removeComments(ctx, ps) end
						do _g.sling.op.CommonOps:expandAssertStatements(ctx, ps) end
						do
							local array2 = _g.sling.util.FindUtil:findNodesOfType(ps, "class:sling.model.FailureLiteralExpressionNode", false, true, false)
							if array2 ~= nil then
								local n7 = 0
								local m6 = _g.jk.lang.Vector:getSize(array2)
								do
									n7 = 0
									while n7 < m6 do
										local nn = _vm:to_table_with_key(array2[n7 + 1], '_isType.sling.model.FailureLiteralExpressionNode')
										if nn ~= nil then
											do _g.sling.util.NodeUtil:replaceNode(nn, _g.sling.model.BooleanLiteralExpressionNode:forValue(false)) end
										end
										do n7 = n7 + 1 end
									end
								end
							end
							do _g.sling.sushi.compiler.SlingToSushiOps:convertToSushiSubscripts(ps) end
							do _g.sling.compiler.SlingOps:expandForeachStatementsDynamic(ps) end
							do _g.sling.sushi.compiler.SlingToSushiOps:convertTryCatchToPcall(ctx, ps, true) end
							do _g.sling.op.CommonOps:expandConditionalExpressions(ctx, ps) end
							do _g.sling.op.CommonOps:expandAssignmentExpressions(ctx, ps) end
							do _g.sling.op.CommonOps:convertSwitchToIf(ctx, ps, nil) end
							do _g.sling.op.CommonOps:surroundLocalVariablesInBlocks(ctx, ps) end
							do _g.sling.op.CommonOps:changeContinueToGoto(ctx, ps) end
							do _g.sling.op.CommonOps:expandForStatements(ctx, ps) end
							do _g.sling.op.CommonOps:wrapAssignmentsInExpressions(ctx, ps) end
							do _g.sling.sushi.compiler.SlingToSushiOps:enableSushiBitOps(ctx, ps) end
							do
								local fd = _g.sling.model.FunctionDeclarationNode:forName("_main", false)
								do fd:setReturnType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
								do fd:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), "args", nil)) end
								do
									local body = fd:getCreateBody()
									local array3 = ps:exportNodes()
									if array3 ~= nil then
										local n8 = 0
										local m7 = _g.jk.lang.Vector:getSize(array3)
										do
											n8 = 0
											while n8 < m7 do
												local node = _vm:to_table_with_key(array3[n8 + 1], '_isType.sling.common.NodeObject')
												if node ~= nil then
													do body:addNode(node) end
												end
												do n8 = n8 + 1 end
											end
										end
									end
									do ps:addNode(fd) end
									do
										local output = _g.sling.common.StringOutputWriterManager._construct0(_g.sling.common.StringOutputWriterManager._create())
										local gen = _g.sling.sushi.compiler.SushiLuaGenerator._construct2(_g.sling.sushi.compiler.SushiLuaGenerator._create(), nil, output)
										do gen:dumpFile(ps) end
										do
											local result = output:getResult()
											if not (result ~= nil) then
												result = ""
											end
											do
												local v = _g.jk.lang.String:toUTF8Buffer(result)
												if self.linkUsedLibraries then
													local size = 0
													if importFiles ~= nil then
														local n9 = 0
														local m8 = _g.jk.lang.Vector:getSize(importFiles)
														do
															n9 = 0
															while n9 < m8 do
																local file = importFiles[n9 + 1]
																if file ~= nil then
																	size = size + file:getSize()
																end
																do n9 = n9 + 1 end
															end
														end
													end
													do
														local sbuf = v
														if sbuf ~= nil then
															size = size + #sbuf
														end
														do
															local buf = _util:allocate_buffer(size)
															local n = 0
															if importFiles ~= nil then
																local n10 = 0
																local m9 = _g.jk.lang.Vector:getSize(importFiles)
																do
																	n10 = 0
																	while n10 < m9 do
																		local file = importFiles[n10 + 1]
																		if file ~= nil then
																			do _g.jk.log.Log:debug(ctx, "Linking file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'") end
																		end
																		do n10 = n10 + 1 end
																	end
																end
															end
															if importFiles ~= nil then
																local n11 = 0
																local m10 = _g.jk.lang.Vector:getSize(importFiles)
																do
																	n11 = 0
																	while n11 < m10 do
																		local file = importFiles[n11 + 1]
																		if file ~= nil then
																			local data = file:getContentsBuffer()
																			if not (data ~= nil) then
																				_vm:throw_error(_g.sling.common.ReferenceError:forMessage("Failed to read file: `" .. _g.jk.lang.String:safeString(file:getPath()) .. "'", nil, nil))
																			end
																			do
																				local sz = #data
																				do _g.jk.lang.Buffer:copyFrom(buf, data, 0, n, sz) end
																				n = n + sz
																			end
																		end
																		do n11 = n11 + 1 end
																	end
																end
															end
															do _g.jk.lang.Buffer:copyFrom(buf, sbuf, 0, n, #sbuf) end
															v = buf
														end
													end
												end
												do return v end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:getLibraryManager()
	do return self.libraryManager end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:setLibraryManager(v)
	self.libraryManager = v
	do return self end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:getLinkUsedLibraries()
	do return self.linkUsedLibraries end
end

function sling.ss.compiler.SlingScriptToSushiCompiler:setLinkUsedLibraries(v)
	self.linkUsedLibraries = v
	do return self end
end
jk = jk or {}

jk.sushi = jk.sushi or {}

jk.sushi.SushiKit = {}
jk.sushi.SushiKit.__index = jk.sushi.SushiKit
_vm:set_metatable(jk.sushi.SushiKit, {})

function jk.sushi.SushiKit._create()
	local v = _vm:set_metatable({}, jk.sushi.SushiKit)
	return v
end

function jk.sushi.SushiKit:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.sushi.SushiKit'
	self['_isType.jk.sushi.SushiKit'] = true
	self.ctx = nil
end

function jk.sushi.SushiKit:_construct0()
	jk.sushi.SushiKit._init(self)
	return self
end

function jk.sushi.SushiKit:_construct1(ctx)
	jk.sushi.SushiKit._init(self)
	self.ctx = ctx
	return self
end

function jk.sushi.SushiKit:asStringVector(o)
	local it = _g.jk.lang.DynamicObject:iterate(o)
	if not (it ~= nil) then
		do return nil end
	end
	do
		local v = {}
		while true do
			local oo = it:next()
			if not (oo ~= nil) then
				do break end
			end
			do
				local s = _g.jk.lang.String:asString(oo)
				if s ~= nil then
					do _g.jk.lang.Vector:append(v, s) end
				end
			end
		end
		do return v end
	end
end

function jk.sushi.SushiKit:executeBuffer(code, args)
	local cc = _g.jk.sushi.SushiCode:forBuffer(code)
	if not (cc ~= nil) then
		do _g.jk.lang.Error:throw("failedToInitialize", "SushiCode") end
	end
	do return cc:execute(self:asStringVector(args)) end
end

function jk.sushi.SushiKit:executeFile(file, args)
	local ff = _g.jk.fs.FileKit._construct1(_g.jk.fs.FileKit._create(), self.ctx):asFile(file)
	local code = _g.jk.sushi.SushiCode:forFile(ff)
	if not (code ~= nil) then
		do _g.jk.lang.Error:throw("failedToRead", ff:getPath()) end
	end
	do return code:execute(self:asStringVector(args)) end
end

function jk.sushi.SushiKit:executeFileProcess(file, args)
	local ff = _g.jk.fs.FileKit._construct1(_g.jk.fs.FileKit._create(), self.ctx):asFile(file)
	local pl = nil
	pl = _g.jk.process.ProcessLauncher:forSelf()
	if not (pl ~= nil) then
		pl = _g.jk.process.ProcessLauncher:forCommand("eqela", nil)
	end
	if not (pl ~= nil) then
		pl = _g.jk.process.ProcessLauncher:forCommand("sushi", nil)
	end
	if not (pl ~= nil) then
		do _g.jk.lang.Error:throw("failedToFindSushiVm", nil) end
	end
	do pl:addToParams(ff:getPath()) end
	do
		local array = self:asStringVector(args)
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local arg = array[n + 1]
					if arg ~= nil then
						do pl:addToParams(arg) end
					end
					do n = n + 1 end
				end
			end
		end
		do return pl:execute() end
	end
end

jk.sushi.SushiCode = {}
jk.sushi.SushiCode.__index = jk.sushi.SushiCode
_vm:set_metatable(jk.sushi.SushiCode, {})

function jk.sushi.SushiCode._create()
	local v = _vm:set_metatable({}, jk.sushi.SushiCode)
	return v
end

function jk.sushi.SushiCode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'jk.sushi.SushiCode'
	self['_isType.jk.sushi.SushiCode'] = true
	self.code = nil
	self.name = nil
end

function jk.sushi.SushiCode:_construct0()
	jk.sushi.SushiCode._init(self)
	return self
end

function jk.sushi.SushiCode:forBuffer(code)
	local v = _g.jk.sushi.SushiCode._construct0(_g.jk.sushi.SushiCode._create())
	do v:setCode(code) end
	do v:setName("code") end
	do return v end
end

function jk.sushi.SushiCode:forFile(file)
	if not (file ~= nil) then
		do return nil end
	end
	do
		local code = file:getContentsBuffer()
		if not (code ~= nil) then
			do return nil end
		end
		do
			local v = _g.jk.sushi.SushiCode._construct0(_g.jk.sushi.SushiCode._create())
			do v:setCode(code) end
			do v:setName(file:getBasename()) end
			do return v end
		end
	end
end

function jk.sushi.SushiCode:execute(args)
	local buffer = self:getCode()
	local name = self:getName()
	do return _vm:execute_program(buffer, name, args) end
end

function jk.sushi.SushiCode:getCode()
	do return self.code end
end

function jk.sushi.SushiCode:setCode(v)
	self.code = v
	do return self end
end

function jk.sushi.SushiCode:getName()
	do return self.name end
end

function jk.sushi.SushiCode:setName(v)
	self.name = v
	do return self end
end
ss = ss or {}

ss.SlingShellApp = {}
ss.SlingShellApp.__index = ss.SlingShellApp
_vm:set_metatable(ss.SlingShellApp, {})

function ss.SlingShellApp._create()
	local v = _vm:set_metatable({}, ss.SlingShellApp)
	return v
end

function ss.SlingShellApp:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'ss.SlingShellApp'
	self['_isType.ss.SlingShellApp'] = true
	self.ctx = _g.jk.console.ConsoleApplicationContext._construct0(_g.jk.console.ConsoleApplicationContext._create())
	self.jkCoreVersion = "0.10.0"
	self.libraryManager = nil
end

function ss.SlingShellApp:_construct0()
	ss.SlingShellApp._init(self)
	self.libraryManager = _g.sling.sushi.compiler.SushiLibraryManager:forDefaultDirectory()
	return self
end

function ss.SlingShellApp:createContext()
	local context = _g.ss.SlingShellContext._construct0(_g.ss.SlingShellContext._create())
	do context:setCtx(self.ctx) end
	do context:setLibraryManager(self.libraryManager) end
	if _g.jk.lang.String:isNotEmpty(self.jkCoreVersion) then
		do context:executeCommand("lib jk-core:" .. _g.jk.lang.String:safeString(self.jkCoreVersion)) end
	end
	do context:executeCode("\n/*\n * This file is part of Sling Shell\n * Copyright (c) 2020 J42 Pte Ltd\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 3 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\nstr = jk.lang.String\n\nfunc echo(args)\n{\n\tvar aa = jk.lang.Vector.forArray(args)\n\tvar sz = jk.lang.Vector.getSize(aa)\n\tvar n = 0\n\twhile n < sz {\n\t\tif n > 0:\n\t\t\tprint \" \"\n\t\tprint jk.lang.Vector.get(aa, n)\n\t\tn++\n\t}\n\tprint \"\\n\"\n}\n\nfunc ls(args)\n{\n\tvar aa = jk.lang.Vector.forArray(args)\n\tif jk.lang.Vector.isEmpty(aa):\n\t\tjk.lang.Vector.append(aa, \".\")\n\tvar sz = jk.lang.Vector.getSize(aa)\n\tvar n = 0\n\twhile n < sz {\n\t\tvar arg = jk.lang.Vector.get(aa, n++)\n\t\tvar path = jk.fs.File.forPath(arg)\n\t\tif path.exists() == false:\n\t\t\tjk.lang.Error.throw(\"noSuchFileOrDirectory\", path)\n\t\tvar it = path.entries()\n\t\twhile it {\n\t\t\tvar ff = it.next()\n\t\t\tif not ff:\n\t\t\t\tbreak\n\t\t\tprintln ff.getBasename()\n\t\t}\n\t}\n}\n") end
	do
		local dd = _g.jk.env.CommonPath:getHomeDirectory()
		if dd ~= nil then
			local script = dd:entry(".ss")
			if script:isFile() then
				do context:executeCode(script:getContentsUTF8()) end
			end
		end
		do return context end
	end
end

function ss.SlingShellApp:executeInteractiveShell()
	local context = self:createContext()
	local stdin = _g.jk.console.Stdin:instance()
	while true do
		_io:write_to_stdout("sling$ ")
		do
			local line = _g.jk.lang.String:strip(stdin:readLine())
			if line == "exit" then
				do break end
			end
			do
				local _status, _err = _vm:execute_protected_call(function()
					if _g.jk.lang.String:isNotEmpty(line) then
						do context:executeCommand(line) end
					end
				end)
				if _err then
					local e = _err
					_io:write_to_stdout(_g.jk.lang.String:asString(e))
				end
			end
		end
	end
end

function ss.SlingShellApp:compressIfNecessaryAndPossible(code)
	if not (code ~= nil) then
		do return nil end
	end
	if code[0 + 1] ~= 0 and code[1 + 1] ~= 100 and code[2 + 1] ~= 101 and code[3 + 1] ~= 102 then
		local cc = _util:deflate(code)
		local v = _util:allocate_buffer(4)
		do _g.jk.lang.Buffer:setByte(v, 0, 0) end
		do _g.jk.lang.Buffer:setByte(v, 1, 100) end
		do _g.jk.lang.Buffer:setByte(v, 2, 101) end
		do _g.jk.lang.Buffer:setByte(v, 3, 102) end
		v = _g.jk.lang.Buffer:append(v, cc, -1)
		do return v end
	end
	do return code end
end

function ss.SlingShellApp:generateScriptFromMainString(main)
	local comps = _g.jk.lang.String:split(main, 47, 2)
	local lib = _g.jk.lang.Vector:get(comps, 0)
	local fullname = _g.jk.lang.Vector:get(comps, 1)
	if _g.jk.lang.String:isEmpty(lib) or _g.jk.lang.String:isEmpty(fullname) then
		do _g.jk.lang.Error:throw("invalidMainDefinition", main) end
	end
	do
		local lidx = _g.jk.lang.String:getLastIndexOfCharacter(fullname, 46, -1)
		local module = nil
		local cname = nil
		if lidx > 0 then
			module = _g.jk.lang.String:getSubString(fullname, 0, lidx)
			cname = _g.jk.lang.String:getEndOfString(fullname, lidx + 1)
		else
			cname = fullname
		end
		if _g.jk.lang.String:isEmpty(cname) then
			do _g.jk.lang.Error:throw("invalidMainDefinition", main) end
		end
		do
			local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
			do sb:appendString("lib ") end
			do sb:appendString(lib) end
			do sb:appendString("\n") end
			if _g.jk.lang.String:isNotEmpty(module) then
				do sb:appendString("import ") end
				do sb:appendString(module) end
				do sb:appendString("\n") end
			end
			do sb:appendString("return ") end
			do sb:appendString(cname) end
			do sb:appendString("._main(_args)\n") end
			do return sb:toString() end
		end
	end
end

function ss.SlingShellApp:execute(args)
	local workdir = nil
	local scriptFile = nil
	local scriptArgs = nil
	local scriptLiteral = nil
	local compile = false
	local compileOutput = nil
	local writeSource = false
	local executes = {}
	local av = _g.jk.console.ArgumentVector:forArray(args)
	while av:hasMore() do
		if av:acceptFlag("debug") then
			do self.ctx:setEnableDebugMessages(true) end
			goto _continue1
		end
		if av:acceptFlag("c") or av:acceptFlag("compile") then
			compile = true
			goto _continue1
		end
		if av:acceptOption("o") or av:acceptOption("output") then
			compileOutput = _g.jk.fs.File:forPath(av:getOptionValue())
			goto _continue1
		end
		if av:acceptFlag("src") then
			writeSource = true
			goto _continue1
		end
		if av:acceptOption("wd") or av:acceptOption("workdir") then
			workdir = _g.jk.fs.File:forPath(av:getOptionValue())
			goto _continue1
		end
		if av:acceptOption("x") or av:acceptOption("execute") then
			do _g.jk.lang.Vector:append(executes, av:getOptionValue()) end
			goto _continue1
		end
		if av:acceptOption("i") or av:acceptOption("include") then
			do _g.jk.lang.Vector:append(executes, _g.jk.fs.File:forPath(av:getOptionValue())) end
			goto _continue1
		end
		if av:acceptOption("jkcore") then
			self.jkCoreVersion = av:getOptionValue()
			goto _continue1
		end
		if av:acceptOption("flib") then
			local libname = av:getOptionValue()
			local nn = _g.sling.compiler.LibraryName:parse(libname)
			if not (nn ~= nil) then
				do _g.jk.lang.Error:throw("invalidLibraryName", libname) end
			end
			do self.libraryManager:setForcedLibraryVersion(_g.jk.lang.String:safeString(nn:getNamespace()) .. ":" .. _g.jk.lang.String:safeString(nn:getName()), nn:getVersion()) end
			goto _continue1
		end
		if av:acceptOption("s") or av:acceptOption("script") then
			scriptLiteral = av:getOptionValue()
			scriptArgs = av:acceptAllValues()
			goto _continue1
		end
		if av:acceptOption("main") then
			local main = av:getOptionValue()
			scriptLiteral = self:generateScriptFromMainString(main)
			scriptArgs = av:acceptAllValues()
			goto _continue1
		end
		if _g.jk.lang.Vector:isEmpty(executes) and scriptLiteral == nil then
			local value = av:acceptParameter()
			if value ~= nil then
				scriptFile = _g.jk.fs.File:forPath(value)
				scriptArgs = av:acceptAllValues()
				goto _continue1
			end
		end
		do _g.jk.lang.Error:throw("invalidParameter", av:getCurrent()) end
		::_continue1::
	end
	if scriptFile ~= nil or scriptLiteral ~= nil then
		if scriptFile ~= nil and not scriptFile:isFile() then
			do _g.jk.lang.Error:throw("noSuchFile", scriptFile) end
		end
		if compile and _g.jk.lang.Vector:isNotEmpty(scriptArgs) then
			do _g.jk.lang.Error:throw("argumentsNotSupported", "compile") end
		end
		do
			local cc = _g.sling.ss.compiler.SlingScriptToSushiCompiler._construct0(_g.sling.ss.compiler.SlingScriptToSushiCompiler._create())
			do cc:setLibraryManager(self.libraryManager) end
			do cc:setLinkUsedLibraries(true) end
			do cc:setWorkDir(workdir) end
			do
				local scriptName = nil
				local scriptBuffer = nil
				if scriptFile ~= nil then
					scriptBuffer = cc:compileFileToBuffer(self.ctx, scriptFile)
					scriptName = _g.jk.lang.String:safeString(scriptFile:getPath()) .. "@lua"
				else
					scriptBuffer = cc:compileStringToBuffer(self.ctx, scriptLiteral)
					scriptName = "script"
				end
				if not (scriptBuffer ~= nil) then
					do _g.jk.lang.Error:throw("failedToCompileScript", scriptName) end
				end
				if compile then
					if not writeSource then
						scriptBuffer = self:compressIfNecessaryAndPossible(scriptBuffer)
					end
					if compileOutput ~= nil then
						if not compileOutput:setContentsBuffer(scriptBuffer) then
							do _g.jk.lang.Error:throw("failedToWrite", compileOutput) end
						end
					else
						local stdout = _g.jk.console.Stdout:instance()
						if stdout ~= nil then
							do stdout:write(scriptBuffer, -1) end
						end
					end
				else
					local r = _g.jk.sushi.SushiCode:forBuffer(scriptBuffer):setName(scriptName):execute(scriptArgs)
					if r ~= 0 then
						do _g.jk.lang.Error:throw("failedToExecuteScript", _g.jk.lang.String:forInteger(r)) end
					end
				end
				do return end
			end
		end
	end
	if compile then
		do _g.jk.lang.Error:throw("cannotCompileWithoutScript", nil) end
	end
	if _g.jk.lang.Vector:isNotEmpty(executes) then
		local context = self:createContext()
		if executes ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(executes)
			do
				n = 0
				while n < m do
					local execute = executes[n + 1]
					if execute ~= nil then
						if (_vm:get_variable_type(execute) == 'string') then
							do context:executeCommand(execute) end
							goto _continue2
						end
						if (_vm:to_table_with_key(execute, '_isType.jk.fs.File') ~= nil) then
							local ff = execute
							local cc = ff:getContentsUTF8()
							if not (cc ~= nil) then
								do _g.jk.lang.Error:throw("failedToReadFile", ff) end
							end
							do context:executeCode(cc) end
							goto _continue2
						end
						do _g.jk.lang.Error:throw("unsupportedExecute", execute) end
					end
					::_continue2::
					do n = n + 1 end
				end
			end
		end
		do return end
	end
	do self:executeInteractiveShell() end
end

function ss.SlingShellApp:executeMain(args)
	do
		local _status, _err = _vm:execute_protected_call(function()
			do self:execute(args) end
		end)
		if _err then
			local e = _err
			do _g.jk.log.Log:error(self.ctx, _g.jk.lang.String:asString(e)) end
			do return 1 end
		end
	end
	do return 0 end
end

function ss.SlingShellApp:_main(args)
	do return _g.ss.SlingShellApp._construct0(_g.ss.SlingShellApp._create()):executeMain(args) end
end

ss.SlingShellContext = {}
ss.SlingShellContext.__index = ss.SlingShellContext
_vm:set_metatable(ss.SlingShellContext, {})

function ss.SlingShellContext._create()
	local v = _vm:set_metatable({}, ss.SlingShellContext)
	return v
end

function ss.SlingShellContext:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'ss.SlingShellContext'
	self['_isType.ss.SlingShellContext'] = true
	self.interpreter = nil
	self.parser = nil
	self.ctx = nil
	self.libraryManager = nil
end

function ss.SlingShellContext:_construct0()
	ss.SlingShellContext._init(self)
	local basecode = _g.jk.lang.String:toUTF8Buffer("a = {}")
	self.interpreter = _vm:prepare_interpreter(basecode)
	if not (self.interpreter ~= nil) then
		do _g.jk.lang.Error:throw("failedToCreate", "interpreter") end
	end
	self.parser = _g.sling.ss.parser.SlingScriptParser._construct0(_g.sling.ss.parser.SlingScriptParser._create())
	return self
end

function ss.SlingShellContext:processCode(code)
	local cc = code
	if _g.jk.lang.String:endsWith(cc, "\n") == false then
		cc = _g.jk.lang.String:safeString(cc) .. "\n"
	end
	do
		local xprf = self.parser:parseString(cc, "__input__")
		if not (xprf ~= nil) then
			do _g.jk.lang.Error:throw("failedToParse", code) end
		end
		do
			local output = _g.sling.common.StringOutputWriterManager._construct0(_g.sling.common.StringOutputWriterManager._create())
			local generator = _g.sling.sushi.compiler.SushiLuaGenerator._construct2(_g.sling.sushi.compiler.SushiLuaGenerator._create(), nil, output)
			do generator:dumpFile(xprf) end
			do return output:toString() end
		end
	end
end

function ss.SlingShellContext:executeLuaCode(code)
	local interpreter = self.interpreter
	local fd = _os:execute_in_thread(interpreter, code, null, 1, 1)
	if fd < 0 then
		do _g.jk.lang.Error:throw("failedToExecuteLuaCode", code) end
	end
	do
		local reader = _g.jk.io.FileDescriptorReader:forFileDescriptor(fd)
		local buffer = _util:allocate_buffer(1024)
		while true do
			local cc = reader:read(buffer)
			if cc < 1 then
				do break end
			end
			do _g.jk.log.Log:debug(self.ctx, "DATA: `" .. _g.jk.lang.String:safeString(_g.jk.lang.String:forUTF8Buffer(buffer)) .. "'") end
		end
	end
end

function ss.SlingShellContext:processLibrary(libname)
	if not _g.jk.lang.String:isNotEmpty(libname) then
		do return end
	end
	do
		local libnamev = {}
		do _g.jk.lang.Vector:append(libnamev, libname) end
		do
			local libs = self.libraryManager:processRequiredLibraries(self.ctx, libnamev)
			if libs ~= nil then
				local n = 0
				local m = _g.jk.lang.Vector:getSize(libs)
				do
					n = 0
					while n < m do
						local lib = libs[n + 1]
						if lib ~= nil then
							do _g.jk.log.Log:debug(self.ctx, _g.jk.lang.String:asString(lib)) end
							do
								local libv2 = {}
								do _g.jk.lang.Vector:append(libv2, lib) end
								do
									local infos = self.libraryManager:generateModuleInfosForLibdirs(self.ctx, libv2)
									do _g.jk.lang.Vector:sort(infos, function(a, b)
										local aid = a:getModuleId()
										local bid = b:getModuleId()
										local array = a:getDependencies()
										if array ~= nil then
											local n = 0
											local m = _g.jk.lang.Vector:getSize(array)
											do
												n = 0
												while n < m do
													local dep = array[n + 1]
													if dep ~= nil then
														if dep == bid then
															do return 1 end
														end
													end
													do n = n + 1 end
												end
											end
										end
										do
											local array2 = b:getDependencies()
											if array2 ~= nil then
												local n2 = 0
												local m2 = _g.jk.lang.Vector:getSize(array2)
												do
													n2 = 0
													while n2 < m2 do
														local dep = array2[n2 + 1]
														if dep ~= nil then
															if dep == aid then
																do return -1 end
															end
														end
														do n2 = n2 + 1 end
													end
												end
											end
											do return 0 end
										end
									end) end
									if infos ~= nil then
										local n3 = 0
										local m3 = _g.jk.lang.Vector:getSize(infos)
										do
											n3 = 0
											while n3 < m3 do
												local info = infos[n3 + 1]
												if info ~= nil then
													local ff = info:getLinkTarget()
													if not (ff ~= nil) then
														goto _continue3
													end
													do _g.jk.log.Log:debug(self.ctx, _g.jk.lang.String:asString(ff)) end
													do
														local code = ff:getContentsUTF8()
														if not (code ~= nil) then
															do _g.jk.lang.Error:throw("failedToReadFile", ff) end
														end
														do self:executeLuaCode(code) end
													end
												end
												::_continue3::
												do n3 = n3 + 1 end
											end
										end
									end
								end
							end
						end
						do n = n + 1 end
					end
				end
			end
		end
	end
end

function ss.SlingShellContext:processSet(key, value)
	if _g.jk.lang.String:isEmpty(key) then
		do _g.jk.lang.Error:throw("invalidSetKey", key) end
	end
	if key == "debug" then
		local vv = true
		if _g.jk.lang.String:isNotEmpty(value) then
			vv = _g.jk.lang.Boolean:asBoolean(value, false)
		end
		do self.ctx:setEnableDebugMessages(vv) end
	else
		do _g.jk.lang.Error:throw("invalidSetKey", key) end
	end
end

function ss.SlingShellContext:processInclude(file)
	if _g.jk.lang.String:isEmpty(file) then
		do _g.jk.lang.Error:throw("invalidIncludeParameter", file) end
	end
	do
		local ff = _g.jk.fs.File:forPath(file)
		local cc = ff:getContentsUTF8()
		if not (cc ~= nil) then
			do _g.jk.lang.Error:throw("failedToReadFile", ff) end
		end
		do self:executeCode(cc) end
	end
end

function ss.SlingShellContext:executeCode(code)
	if not _g.jk.lang.String:isNotEmpty(code) then
		do return end
	end
	do
		local lua = self:processCode(code)
		if not (lua ~= nil) then
			do _g.jk.lang.Error:throw("failedToProcess", code) end
		end
		do self:executeLuaCode(lua) end
	end
end

function ss.SlingShellContext:escapeQuotesAndBackSlashes(sb, param)
	local it = _g.jk.lang.String:iterate(param)
	while it ~= nil do
		local c = it:getNextChar()
		if _g.jk.lang.Character:isEOF(c) then
			do break end
		end
		if c == 34 or c == 92 then
			do sb:appendCharacter(92) end
		end
		do sb:appendCharacter(c) end
	end
end

function ss.SlingShellContext:executeCommand(command)
	if not _g.jk.lang.String:isNotEmpty(command) then
		do return end
	end
	if _g.jk.lang.String:startsWith(command, ":", 0) then
		do self:executeCode(_g.jk.lang.String:strip(_g.jk.lang.String:getEndOfString(command, 1))) end
		do return end
	end
	do
		local comps = _g.jk.text.StringUtil:quotedStringToVector(command, 32, true, 92)
		local sz = _g.jk.lang.Vector:getSize(comps)
		if not (sz > 0) then
			do return end
		end
		do
			local cmd = comps[0 + 1]
			if not _g.jk.lang.String:isNotEmpty(cmd) then
				do return end
			end
			if cmd == "lib" then
				do self:processLibrary(comps[1 + 1]) end
				do return end
			end
			if cmd == "set" then
				do self:processSet(comps[1 + 1], comps[2 + 1]) end
				do return end
			end
			if cmd == "include" or cmd == "." then
				do self:processInclude(comps[1 + 1]) end
				do return end
			end
			do
				local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
				do sb:appendString(cmd) end
				do sb:appendString("([") end
				do
					local first = true
					do
						local n = 1
						while n < sz do
							if first then
								do sb:appendCharacter(32) end
								first = false
							else
								do sb:appendString(", ") end
							end
							do
								local value = comps[n + 1]
								if _g.jk.lang.String:startsWith(value, ":", 0) then
									do sb:appendString(_g.jk.lang.String:getEndOfString(value, 1)) end
								else
									do sb:appendCharacter(34) end
									do self:escapeQuotesAndBackSlashes(sb, value) end
									do sb:appendCharacter(34) end
								end
							end
							do n = n + 1 end
						end
					end
					do sb:appendString("])") end
					do self:executeCode(sb:toString()) end
				end
			end
		end
	end
end

function ss.SlingShellContext:getCtx()
	do return self.ctx end
end

function ss.SlingShellContext:setCtx(v)
	self.ctx = v
	do return self end
end

function ss.SlingShellContext:getLibraryManager()
	do return self.libraryManager end
end

function ss.SlingShellContext:setLibraryManager(v)
	self.libraryManager = v
	do return self end
end

function _main(args)
	do return ss.SlingShellApp:_main(args) end
end
