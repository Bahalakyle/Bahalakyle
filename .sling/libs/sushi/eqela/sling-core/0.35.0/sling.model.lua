sling = sling or {}

sling.model = sling.model or {}

sling.model.CaseBlockNode = _g.sling.common.NodeObject._create()
sling.model.CaseBlockNode.__index = sling.model.CaseBlockNode
_vm:set_metatable(sling.model.CaseBlockNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CaseBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseBlockNode)
	return v
end

function sling.model.CaseBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseBlockNode'
	self['_isType.sling.model.CaseBlockNode'] = true
	self.block = nil
	self.isRaw = false
end

function sling.model.CaseBlockNode:_construct0()
	sling.model.CaseBlockNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CaseBlockNode:getNodeTypeName()
	do return "CaseBlockNode" end
end

function sling.model.CaseBlockNode:createNew()
	do return _g.sling.model.CaseBlockNode._construct0(_g.sling.model.CaseBlockNode._create()) end
end

function sling.model.CaseBlockNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseBlockNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		n.isRaw = self.isRaw
		do return true end
	end
end

function sling.model.CaseBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseBlockNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseBlockNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.CaseBlockNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.CaseBlockNode:getBlock()
	do return self.block end
end

function sling.model.CaseBlockNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.CaseBlockNode:setIsRaw(v)
	self.isRaw = v
end

function sling.model.CaseBlockNode:getIsRaw()
	do return self.isRaw end
end

sling.model.ExpressionNode = _g.sling.common.NodeObject._create()
sling.model.ExpressionNode.__index = sling.model.ExpressionNode
_vm:set_metatable(sling.model.ExpressionNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ExpressionNode)
	return v
end

function sling.model.ExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExpressionNode'
	self['_isType.sling.model.ExpressionNode'] = true
	self.defaultDataType = nil
	self.resolvedDataType = nil
end

function sling.model.ExpressionNode:_construct0()
	sling.model.ExpressionNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ExpressionNode:getNodeTypeName()
	do return "ExpressionNode" end
end

function sling.model.ExpressionNode:createNew()
	do return _g.sling.model.ExpressionNode._construct0(_g.sling.model.ExpressionNode._create()) end
end

function sling.model.ExpressionNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExpressionNode')
		if n == nil then
			do return true end
		end
		if n.defaultDataType ~= nil then
			do n.defaultDataType:destroy() end
			n.defaultDataType = nil
		end
		if self.defaultDataType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.defaultDataType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.defaultDataType = pcp
			do n.defaultDataType:setParent(n) end
		end
		if n.resolvedDataType ~= nil then
			do n.resolvedDataType:destroy() end
			n.resolvedDataType = nil
		end
		if self.resolvedDataType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.resolvedDataType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.resolvedDataType = pcp
			do n.resolvedDataType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.defaultDataType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.defaultDataType:destroy() end
		end
		self.defaultDataType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.defaultDataType ~= nil then
			do self.defaultDataType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.resolvedDataType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.resolvedDataType:destroy() end
		end
		self.resolvedDataType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.resolvedDataType ~= nil then
			do self.resolvedDataType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExpressionNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.defaultDataType ~= nil then
		if self.defaultDataType:accept(visitor) == false then
			do return false end
		end
	end
	if self.resolvedDataType ~= nil then
		if self.resolvedDataType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ExpressionNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.defaultDataType ~= nil then
		do self.defaultDataType:destroy() end
		self.defaultDataType = nil
	end
	if self.resolvedDataType ~= nil then
		do self.resolvedDataType:destroy() end
		self.resolvedDataType = nil
	end
end

function sling.model.ExpressionNode:setDefaultDataType(v, doExport)
	if self.defaultDataType ~= nil and doExport == false then
		do self.defaultDataType:destroy() end
	end
	self.defaultDataType = v
	if self.defaultDataType ~= nil then
		do self.defaultDataType:setParent(self) end
	end
end

function sling.model.ExpressionNode:getDefaultDataType()
	do return self.defaultDataType end
end

function sling.model.ExpressionNode:exportDefaultDataType()
	local v = self.defaultDataType
	self.defaultDataType = nil
	do return v end
end

function sling.model.ExpressionNode:setResolvedDataType(v, doExport)
	if self.resolvedDataType ~= nil and doExport == false then
		do self.resolvedDataType:destroy() end
	end
	self.resolvedDataType = v
	if self.resolvedDataType ~= nil then
		do self.resolvedDataType:setParent(self) end
	end
end

function sling.model.ExpressionNode:getResolvedDataType()
	do return self.resolvedDataType end
end

function sling.model.ExpressionNode:exportResolvedDataType()
	local v = self.resolvedDataType
	self.resolvedDataType = nil
	do return v end
end

sling.model.StyleSheetExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.StyleSheetExpressionNode.__index = sling.model.StyleSheetExpressionNode
_vm:set_metatable(sling.model.StyleSheetExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.StyleSheetExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StyleSheetExpressionNode)
	return v
end

function sling.model.StyleSheetExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StyleSheetExpressionNode'
	self['_isType.sling.model.StyleSheetExpressionNode'] = true
	self.body = nil
end

function sling.model.StyleSheetExpressionNode:_construct0()
	sling.model.StyleSheetExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.StyleSheetDataTypeNode._construct0(_g.sling.model.StyleSheetDataTypeNode._create()), false) end
	return self
end

function sling.model.StyleSheetExpressionNode:getNodeTypeName()
	do return "StyleSheetExpressionNode" end
end

function sling.model.StyleSheetExpressionNode:createNew()
	do return _g.sling.model.StyleSheetExpressionNode._construct0(_g.sling.model.StyleSheetExpressionNode._create()) end
end

function sling.model.StyleSheetExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StyleSheetExpressionNode')
		if n == nil then
			do return true end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StyleSheetExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StyleSheetExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StyleSheetExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
end

function sling.model.StyleSheetExpressionNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.StyleSheetExpressionNode:getBody()
	do return self.body end
end

function sling.model.StyleSheetExpressionNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

sling.model.CreateObjectExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.CreateObjectExpressionNode.__index = sling.model.CreateObjectExpressionNode
_vm:set_metatable(sling.model.CreateObjectExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.CreateObjectExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.CreateObjectExpressionNode)
	return v
end

function sling.model.CreateObjectExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CreateObjectExpressionNode'
	self['_isType.sling.model.CreateObjectExpressionNode'] = true
	self.parameters = nil
	self.type = nil
	self.typeExpression = nil
	self.initializers = nil
end

function sling.model.CreateObjectExpressionNode:_construct0()
	sling.model.CreateObjectExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.CreateObjectExpressionNode:forType(type)
	local v = _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.CreateObjectExpressionNode:forReferenceTypeName(type)
	local v = _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create())
	do v:setType(_g.sling.model.ReferenceDataTypeNode:forName(type), false) end
	do return v end
end

function sling.model.CreateObjectExpressionNode:getNodeTypeName()
	do return "CreateObjectExpressionNode" end
end

function sling.model.CreateObjectExpressionNode:createNew()
	do return _g.sling.model.CreateObjectExpressionNode._construct0(_g.sling.model.CreateObjectExpressionNode._create()) end
end

function sling.model.CreateObjectExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CreateObjectExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.typeExpression ~= nil then
			do n.typeExpression:destroy() end
			n.typeExpression = nil
		end
		if self.typeExpression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.typeExpression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.typeExpression = pcp
			do n.typeExpression:setParent(n) end
		end
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.initializers
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.initializers = nil
				if self.initializers ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.initializers)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.initializers[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.initializers == nil then
									n.initializers = {}
								end
								do _g.jk.lang.Vector:append(n.initializers, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.CreateObjectExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.typeExpression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.typeExpression:destroy() end
		end
		self.typeExpression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.typeExpression ~= nil then
			do self.typeExpression:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.initializers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CreateObjectExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.typeExpression ~= nil then
		if self.typeExpression:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	if self:visitVector(self.initializers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CreateObjectExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.typeExpression ~= nil then
		do self.typeExpression:destroy() end
		self.typeExpression = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
	if self.initializers ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.initializers)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.initializers[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.initializers = nil
end

function sling.model.CreateObjectExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.CreateObjectExpressionNode:getType()
	do return self.type end
end

function sling.model.CreateObjectExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:setTypeExpression(v, doExport)
	if self.typeExpression ~= nil and doExport == false then
		do self.typeExpression:destroy() end
	end
	self.typeExpression = v
	if self.typeExpression ~= nil then
		do self.typeExpression:setParent(self) end
	end
end

function sling.model.CreateObjectExpressionNode:getTypeExpression()
	do return self.typeExpression end
end

function sling.model.CreateObjectExpressionNode:exportTypeExpression()
	local v = self.typeExpression
	self.typeExpression = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CreateObjectExpressionNode:getParameters()
	do return self.parameters end
end

function sling.model.CreateObjectExpressionNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.CreateObjectExpressionNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.CreateObjectExpressionNode:setInitializers(v, doExport)
	if self.initializers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.initializers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.initializers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.initializers = nil
	else
		self.initializers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.initializers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CreateObjectExpressionNode:getInitializers()
	do return self.initializers end
end

function sling.model.CreateObjectExpressionNode:exportInitializers()
	local v = self.initializers
	self.initializers = nil
	do return v end
end

function sling.model.CreateObjectExpressionNode:addToInitializers(v)
	if v == nil then
		do return end
	end
	if self.initializers == nil then
		self.initializers = {}
	end
	do _g.jk.lang.Vector:append(self.initializers, v) end
	do v:setParent(self) end
end

function sling.model.CreateObjectExpressionNode:clearInitializers()
	if self.initializers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.initializers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.initializers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.initializers = nil
end

sling.model.TryCatchStatementNode = _g.sling.common.NodeObject._create()
sling.model.TryCatchStatementNode.__index = sling.model.TryCatchStatementNode
_vm:set_metatable(sling.model.TryCatchStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TryCatchStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.TryCatchStatementNode)
	return v
end

function sling.model.TryCatchStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TryCatchStatementNode'
	self['_isType.sling.model.TryCatchStatementNode'] = true
	self.initializer = nil
	self.tryBlock = nil
	self.catchBlocks = nil
	self.finallyBlock = nil
	self.elseBlock = nil
end

function sling.model.TryCatchStatementNode:_construct0()
	sling.model.TryCatchStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TryCatchStatementNode:forTryBlock(tryBlock)
	local v = _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create())
	do v:setTryBlock(tryBlock, false) end
	do return v end
end

function sling.model.TryCatchStatementNode:addToInitializer(node)
	if node ~= nil then
		if self.initializer == nil then
			do self:setInitializer(_g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()), false) end
		end
		do self.initializer:addNode(node) end
	end
	do return self end
end

function sling.model.TryCatchStatementNode:getNodeTypeName()
	do return "TryCatchStatementNode" end
end

function sling.model.TryCatchStatementNode:createNew()
	do return _g.sling.model.TryCatchStatementNode._construct0(_g.sling.model.TryCatchStatementNode._create()) end
end

function sling.model.TryCatchStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TryCatchStatementNode')
		if n == nil then
			do return true end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		if n.tryBlock ~= nil then
			do n.tryBlock:destroy() end
			n.tryBlock = nil
		end
		if self.tryBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.tryBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.tryBlock = pcp
			do n.tryBlock:setParent(n) end
		end
		if n.finallyBlock ~= nil then
			do n.finallyBlock:destroy() end
			n.finallyBlock = nil
		end
		if self.finallyBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.finallyBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.finallyBlock = pcp
			do n.finallyBlock:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		do
			local array = n.catchBlocks
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.catchBlocks = nil
			if self.catchBlocks ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.catchBlocks)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.catchBlocks[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.catchBlocks == nil then
								n.catchBlocks = {}
							end
							do _g.jk.lang.Vector:append(n.catchBlocks, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.TryCatchStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.tryBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.tryBlock:destroy() end
		end
		self.tryBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.tryBlock ~= nil then
			do self.tryBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.finallyBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.finallyBlock:destroy() end
		end
		self.finallyBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.finallyBlock ~= nil then
			do self.finallyBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.catchBlocks, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TryCatchStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	if self.tryBlock ~= nil then
		if self.tryBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.finallyBlock ~= nil then
		if self.finallyBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.catchBlocks, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TryCatchStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
	if self.tryBlock ~= nil then
		do self.tryBlock:destroy() end
		self.tryBlock = nil
	end
	if self.finallyBlock ~= nil then
		do self.finallyBlock:destroy() end
		self.finallyBlock = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.catchBlocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.catchBlocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.catchBlocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.catchBlocks = nil
end

function sling.model.TryCatchStatementNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getInitializer()
	do return self.initializer end
end

function sling.model.TryCatchStatementNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setTryBlock(v, doExport)
	if self.tryBlock ~= nil and doExport == false then
		do self.tryBlock:destroy() end
	end
	self.tryBlock = v
	if self.tryBlock ~= nil then
		do self.tryBlock:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getTryBlock()
	do return self.tryBlock end
end

function sling.model.TryCatchStatementNode:exportTryBlock()
	local v = self.tryBlock
	self.tryBlock = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setFinallyBlock(v, doExport)
	if self.finallyBlock ~= nil and doExport == false then
		do self.finallyBlock:destroy() end
	end
	self.finallyBlock = v
	if self.finallyBlock ~= nil then
		do self.finallyBlock:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getFinallyBlock()
	do return self.finallyBlock end
end

function sling.model.TryCatchStatementNode:exportFinallyBlock()
	local v = self.finallyBlock
	self.finallyBlock = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.TryCatchStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.TryCatchStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.TryCatchStatementNode:setCatchBlocks(v, doExport)
	if self.catchBlocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.catchBlocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.catchBlocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.catchBlocks = nil
	else
		self.catchBlocks = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.catchBlocks, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TryCatchStatementNode:getCatchBlocks()
	do return self.catchBlocks end
end

function sling.model.TryCatchStatementNode:exportCatchBlocks()
	local v = self.catchBlocks
	self.catchBlocks = nil
	do return v end
end

function sling.model.TryCatchStatementNode:addToCatchBlocks(v)
	if v == nil then
		do return end
	end
	if self.catchBlocks == nil then
		self.catchBlocks = {}
	end
	do _g.jk.lang.Vector:append(self.catchBlocks, v) end
	do v:setParent(self) end
end

function sling.model.TryCatchStatementNode:clearCatchBlocks()
	if self.catchBlocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.catchBlocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.catchBlocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.catchBlocks = nil
end

sling.model.FileSystemReferenceExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.FileSystemReferenceExpressionNode.__index = sling.model.FileSystemReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemReferenceExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.FileSystemReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemReferenceExpressionNode)
	return v
end

function sling.model.FileSystemReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemReferenceExpressionNode'
	self['_isType.sling.model.FileSystemReferenceExpressionNode'] = true
	self.name = nil
	self.relativeTo = nil
end

function sling.model.FileSystemReferenceExpressionNode:_construct0()
	sling.model.FileSystemReferenceExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemReferenceExpressionNode" end
end

function sling.model.FileSystemReferenceExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		n.relativeTo = self.relativeTo
		do return true end
	end
end

function sling.model.FileSystemReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemReferenceExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

function sling.model.FileSystemReferenceExpressionNode:setName(v)
	self.name = v
end

function sling.model.FileSystemReferenceExpressionNode:getName()
	do return self.name end
end

function sling.model.FileSystemReferenceExpressionNode:setRelativeTo(v)
	self.relativeTo = v
end

function sling.model.FileSystemReferenceExpressionNode:getRelativeTo()
	do return self.relativeTo end
end

sling.model.BreakStatementNode = _g.sling.common.NodeObject._create()
sling.model.BreakStatementNode.__index = sling.model.BreakStatementNode
_vm:set_metatable(sling.model.BreakStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.BreakStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.BreakStatementNode)
	return v
end

function sling.model.BreakStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BreakStatementNode'
	self['_isType.sling.model.BreakStatementNode'] = true
end

function sling.model.BreakStatementNode:_construct0()
	sling.model.BreakStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.BreakStatementNode:getNodeTypeName()
	do return "BreakStatementNode" end
end

function sling.model.BreakStatementNode:createNew()
	do return _g.sling.model.BreakStatementNode._construct0(_g.sling.model.BreakStatementNode._create()) end
end

function sling.model.BreakStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BreakStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BreakStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BreakStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BreakStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

sling.model.NodeWithModifiers = {}

sling.model.AutomaticDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.AutomaticDataTypeNode.__index = sling.model.AutomaticDataTypeNode
_vm:set_metatable(sling.model.AutomaticDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.AutomaticDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.AutomaticDataTypeNode)
	return v
end

function sling.model.AutomaticDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AutomaticDataTypeNode'
	self['_isType.sling.model.AutomaticDataTypeNode'] = true
end

function sling.model.AutomaticDataTypeNode:_construct0()
	sling.model.AutomaticDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.AutomaticDataTypeNode:getNodeTypeName()
	do return "AutomaticDataTypeNode" end
end

function sling.model.AutomaticDataTypeNode:createNew()
	do return _g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()) end
end

function sling.model.AutomaticDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AutomaticDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AutomaticDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AutomaticDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AutomaticDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.GetValueExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.GetValueExpressionNode.__index = sling.model.GetValueExpressionNode
_vm:set_metatable(sling.model.GetValueExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.GetValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetValueExpressionNode)
	return v
end

function sling.model.GetValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetValueExpressionNode'
	self['_isType.sling.model.GetValueExpressionNode'] = true
	self.expression = nil
end

function sling.model.GetValueExpressionNode:_construct0()
	sling.model.GetValueExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.GetValueExpressionNode:getNodeTypeName()
	do return "GetValueExpressionNode" end
end

function sling.model.GetValueExpressionNode:createNew()
	do return _g.sling.model.GetValueExpressionNode._construct0(_g.sling.model.GetValueExpressionNode._create()) end
end

function sling.model.GetValueExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetValueExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetValueExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.GetValueExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.GetValueExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.GetValueExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.EntityDeclarationNode = _g.sling.common.NamedContainerNode._create()
sling.model.EntityDeclarationNode.__index = sling.model.EntityDeclarationNode
_vm:set_metatable(sling.model.EntityDeclarationNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.model.EntityDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EntityDeclarationNode)
	return v
end

function sling.model.EntityDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EntityDeclarationNode'
	self['_isType.sling.model.EntityDeclarationNode'] = true
	self['_isType.sling.model.NodeWithModifiers'] = true
	self.baseTypes = nil
	self.importEntities = nil
	self.importNamespaces = nil
	self.importStaticNamespaces = nil
	self.dependencies = nil
	self.description = nil
	self.metadata = nil
	self.baseTypeMetaParameters = nil
	self.modifiers = nil
end

function sling.model.EntityDeclarationNode:_construct0()
	sling.model.EntityDeclarationNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.model.EntityDeclarationNode:clearImports()
	do self:clearImportNamespaces() end
	do self:clearImportStaticNamespaces() end
	do self:clearImportEntities() end
end

function sling.model.EntityDeclarationNode:addBaseTypeExtends(type)
	do self:addBaseType(type, _g.sling.model.BaseTypeNode.INHERIT_EXTEND) end
end

function sling.model.EntityDeclarationNode:addBaseTypeExtendsAsExpression(expType)
	do self:addBaseTypeForExpression(expType, _g.sling.model.BaseTypeNode.INHERIT_EXTEND) end
end

function sling.model.EntityDeclarationNode:addBaseTypeImplements(type)
	do self:addBaseType(type, _g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT) end
end

function sling.model.EntityDeclarationNode:addBaseTypeAutomatic(type)
	do self:addBaseType(type, _g.sling.model.BaseTypeNode.INHERIT_AUTO) end
end

function sling.model.EntityDeclarationNode:addBaseType(type, inheritType)
	if not (type ~= nil) then
		do return end
	end
	do self:addToBaseTypes(_g.sling.model.BaseTypeNode:forType(type, inheritType)) end
end

function sling.model.EntityDeclarationNode:addBaseTypeForExpression(expression, inheritType)
	if not (expression ~= nil) then
		do return end
	end
	do self:addToBaseTypes(_g.sling.model.BaseTypeNode:forExpression(expression, inheritType)) end
end

function sling.model.EntityDeclarationNode:getNodeTypeName()
	do return "EntityDeclarationNode" end
end

function sling.model.EntityDeclarationNode:createNew()
	do return _g.sling.model.EntityDeclarationNode._construct0(_g.sling.model.EntityDeclarationNode._create()) end
end

function sling.model.EntityDeclarationNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EntityDeclarationNode')
		if n == nil then
			do return true end
		end
		n.description = self.description
		n.metadata = self.metadata
		do
			local array = n.baseTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.baseTypes = nil
			if self.baseTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.baseTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.baseTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.baseTypes == nil then
								n.baseTypes = {}
							end
							do _g.jk.lang.Vector:append(n.baseTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.importEntities
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.importEntities = nil
				if self.importEntities ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.importEntities)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.importEntities[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.importEntities == nil then
									n.importEntities = {}
								end
								do _g.jk.lang.Vector:append(n.importEntities, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do
					local array3 = n.importNamespaces
					if array3 ~= nil then
						local n6 = 0
						local m5 = _g.jk.lang.Vector:getSize(array3)
						do
							n6 = 0
							while n6 < m5 do
								local xx = _vm:to_table_with_key(array3[n6 + 1], '_isType.sling.common.NodeObject')
								if xx ~= nil then
									do xx:destroy() end
								end
								do n6 = n6 + 1 end
							end
						end
					end
					n.importNamespaces = nil
					if self.importNamespaces ~= nil then
						local n7 = 0
						local m6 = _g.jk.lang.Vector:getSize(self.importNamespaces)
						do
							n7 = 0
							while n7 < m6 do
								local nod = _vm:to_table_with_key(self.importNamespaces[n7 + 1], '_isType.sling.common.NodeObject')
								if nod ~= nil then
									local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
									if ndup == nil then
										do return false end
									end
									if n.importNamespaces == nil then
										n.importNamespaces = {}
									end
									do _g.jk.lang.Vector:append(n.importNamespaces, ndup) end
									do ndup:setParent(n) end
								end
								do n7 = n7 + 1 end
							end
						end
					end
					do
						local array4 = n.importStaticNamespaces
						if array4 ~= nil then
							local n8 = 0
							local m7 = _g.jk.lang.Vector:getSize(array4)
							do
								n8 = 0
								while n8 < m7 do
									local xx = _vm:to_table_with_key(array4[n8 + 1], '_isType.sling.common.NodeObject')
									if xx ~= nil then
										do xx:destroy() end
									end
									do n8 = n8 + 1 end
								end
							end
						end
						n.importStaticNamespaces = nil
						if self.importStaticNamespaces ~= nil then
							local n9 = 0
							local m8 = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
							do
								n9 = 0
								while n9 < m8 do
									local nod = _vm:to_table_with_key(self.importStaticNamespaces[n9 + 1], '_isType.sling.common.NodeObject')
									if nod ~= nil then
										local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
										if ndup == nil then
											do return false end
										end
										if n.importStaticNamespaces == nil then
											n.importStaticNamespaces = {}
										end
										do _g.jk.lang.Vector:append(n.importStaticNamespaces, ndup) end
										do ndup:setParent(n) end
									end
									do n9 = n9 + 1 end
								end
							end
						end
						n.dependencies = {}
						if self.dependencies ~= nil then
							local n10 = 0
							local m9 = _g.jk.lang.Vector:getSize(self.dependencies)
							do
								n10 = 0
								while n10 < m9 do
									local value = self.dependencies[n10 + 1]
									if value ~= nil then
										do _g.jk.lang.Vector:append(n.dependencies, value) end
									end
									do n10 = n10 + 1 end
								end
							end
						end
						do
							local array5 = n.baseTypeMetaParameters
							if array5 ~= nil then
								local n11 = 0
								local m10 = _g.jk.lang.Vector:getSize(array5)
								do
									n11 = 0
									while n11 < m10 do
										local xx = _vm:to_table_with_key(array5[n11 + 1], '_isType.sling.common.NodeObject')
										if xx ~= nil then
											do xx:destroy() end
										end
										do n11 = n11 + 1 end
									end
								end
							end
							n.baseTypeMetaParameters = nil
							if self.baseTypeMetaParameters ~= nil then
								local n12 = 0
								local m11 = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
								do
									n12 = 0
									while n12 < m11 do
										local nod = _vm:to_table_with_key(self.baseTypeMetaParameters[n12 + 1], '_isType.sling.common.NodeObject')
										if nod ~= nil then
											local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
											if ndup == nil then
												do return false end
											end
											if n.baseTypeMetaParameters == nil then
												n.baseTypeMetaParameters = {}
											end
											do _g.jk.lang.Vector:append(n.baseTypeMetaParameters, ndup) end
											do ndup:setParent(n) end
										end
										do n12 = n12 + 1 end
									end
								end
							end
							do
								local array6 = n.modifiers
								if array6 ~= nil then
									local n13 = 0
									local m12 = _g.jk.lang.Vector:getSize(array6)
									do
										n13 = 0
										while n13 < m12 do
											local xx = _vm:to_table_with_key(array6[n13 + 1], '_isType.sling.common.NodeObject')
											if xx ~= nil then
												do xx:destroy() end
											end
											do n13 = n13 + 1 end
										end
									end
								end
								n.modifiers = nil
								if self.modifiers ~= nil then
									local n14 = 0
									local m13 = _g.jk.lang.Vector:getSize(self.modifiers)
									do
										n14 = 0
										while n14 < m13 do
											local nod = _vm:to_table_with_key(self.modifiers[n14 + 1], '_isType.sling.common.NodeObject')
											if nod ~= nil then
												local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
												if ndup == nil then
													do return false end
												end
												if n.modifiers == nil then
													n.modifiers = {}
												end
												do _g.jk.lang.Vector:append(n.modifiers, ndup) end
												do ndup:setParent(n) end
											end
											do n14 = n14 + 1 end
										end
									end
								end
								do return true end
							end
						end
					end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.baseTypes, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.importEntities, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.importNamespaces, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.importStaticNamespaces, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.baseTypeMetaParameters, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.modifiers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EntityDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.baseTypes, visitor) == false then
		do return false end
	end
	if self:visitVector(self.importEntities, visitor) == false then
		do return false end
	end
	if self:visitVector(self.importNamespaces, visitor) == false then
		do return false end
	end
	if self:visitVector(self.importStaticNamespaces, visitor) == false then
		do return false end
	end
	if self:visitVector(self.baseTypeMetaParameters, visitor) == false then
		do return false end
	end
	if self:visitVector(self.modifiers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EntityDeclarationNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
	if self.importEntities ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.importEntities)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.importEntities[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.importEntities = nil
	if self.importNamespaces ~= nil then
		local n3 = 0
		local m3 = _g.jk.lang.Vector:getSize(self.importNamespaces)
		do
			n3 = 0
			while n3 < m3 do
				local nx = _vm:to_table_with_key(self.importNamespaces[n3 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n3 = n3 + 1 end
			end
		end
	end
	self.importNamespaces = nil
	if self.importStaticNamespaces ~= nil then
		local n4 = 0
		local m4 = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
		do
			n4 = 0
			while n4 < m4 do
				local nx = _vm:to_table_with_key(self.importStaticNamespaces[n4 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n4 = n4 + 1 end
			end
		end
	end
	self.importStaticNamespaces = nil
	if self.baseTypeMetaParameters ~= nil then
		local n5 = 0
		local m5 = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
		do
			n5 = 0
			while n5 < m5 do
				local nx = _vm:to_table_with_key(self.baseTypeMetaParameters[n5 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n5 = n5 + 1 end
			end
		end
	end
	self.baseTypeMetaParameters = nil
	if self.modifiers ~= nil then
		local n6 = 0
		local m6 = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n6 = 0
			while n6 < m6 do
				local nx = _vm:to_table_with_key(self.modifiers[n6 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n6 = n6 + 1 end
			end
		end
	end
	self.modifiers = nil
end

function sling.model.EntityDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.EntityDeclarationNode:getDescription()
	do return self.description end
end

function sling.model.EntityDeclarationNode:setMetadata(v)
	self.metadata = v
end

function sling.model.EntityDeclarationNode:getMetadata()
	do return self.metadata end
end

function sling.model.EntityDeclarationNode:setBaseTypes(v, doExport)
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.baseTypes = nil
	else
		self.baseTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.baseTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getBaseTypes()
	do return self.baseTypes end
end

function sling.model.EntityDeclarationNode:exportBaseTypes()
	local v = self.baseTypes
	self.baseTypes = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToBaseTypes(v)
	if v == nil then
		do return end
	end
	if self.baseTypes == nil then
		self.baseTypes = {}
	end
	do _g.jk.lang.Vector:append(self.baseTypes, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearBaseTypes()
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
end

function sling.model.EntityDeclarationNode:setImportEntities(v, doExport)
	if self.importEntities ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importEntities)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importEntities[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.importEntities = nil
	else
		self.importEntities = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.importEntities, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getImportEntities()
	do return self.importEntities end
end

function sling.model.EntityDeclarationNode:exportImportEntities()
	local v = self.importEntities
	self.importEntities = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToImportEntities(v)
	if v == nil then
		do return end
	end
	if self.importEntities == nil then
		self.importEntities = {}
	end
	do _g.jk.lang.Vector:append(self.importEntities, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearImportEntities()
	if self.importEntities ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importEntities)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importEntities[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.importEntities = nil
end

function sling.model.EntityDeclarationNode:setImportNamespaces(v, doExport)
	if self.importNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.importNamespaces = nil
	else
		self.importNamespaces = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.importNamespaces, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getImportNamespaces()
	do return self.importNamespaces end
end

function sling.model.EntityDeclarationNode:exportImportNamespaces()
	local v = self.importNamespaces
	self.importNamespaces = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToImportNamespaces(v)
	if v == nil then
		do return end
	end
	if self.importNamespaces == nil then
		self.importNamespaces = {}
	end
	do _g.jk.lang.Vector:append(self.importNamespaces, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearImportNamespaces()
	if self.importNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.importNamespaces = nil
end

function sling.model.EntityDeclarationNode:setImportStaticNamespaces(v, doExport)
	if self.importStaticNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importStaticNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.importStaticNamespaces = nil
	else
		self.importStaticNamespaces = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.importStaticNamespaces, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getImportStaticNamespaces()
	do return self.importStaticNamespaces end
end

function sling.model.EntityDeclarationNode:exportImportStaticNamespaces()
	local v = self.importStaticNamespaces
	self.importStaticNamespaces = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToImportStaticNamespaces(v)
	if v == nil then
		do return end
	end
	if self.importStaticNamespaces == nil then
		self.importStaticNamespaces = {}
	end
	do _g.jk.lang.Vector:append(self.importStaticNamespaces, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearImportStaticNamespaces()
	if self.importStaticNamespaces ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.importStaticNamespaces)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.importStaticNamespaces[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.importStaticNamespaces = nil
end

function sling.model.EntityDeclarationNode:setDependencies(v)
	self.dependencies = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.dependencies, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getDependencies()
	do return self.dependencies end
end

function sling.model.EntityDeclarationNode:addToDependencies(v)
	if v == nil then
		do return end
	end
	if self.dependencies == nil then
		self.dependencies = {}
	end
	do _g.jk.lang.Vector:append(self.dependencies, v) end
end

function sling.model.EntityDeclarationNode:clearDependencies()
	self.dependencies = nil
end

function sling.model.EntityDeclarationNode:setBaseTypeMetaParameters(v, doExport)
	if self.baseTypeMetaParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypeMetaParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.baseTypeMetaParameters = nil
	else
		self.baseTypeMetaParameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.baseTypeMetaParameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getBaseTypeMetaParameters()
	do return self.baseTypeMetaParameters end
end

function sling.model.EntityDeclarationNode:exportBaseTypeMetaParameters()
	local v = self.baseTypeMetaParameters
	self.baseTypeMetaParameters = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToBaseTypeMetaParameters(v)
	if v == nil then
		do return end
	end
	if self.baseTypeMetaParameters == nil then
		self.baseTypeMetaParameters = {}
	end
	do _g.jk.lang.Vector:append(self.baseTypeMetaParameters, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearBaseTypeMetaParameters()
	if self.baseTypeMetaParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypeMetaParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypeMetaParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypeMetaParameters = nil
end

function sling.model.EntityDeclarationNode:setModifiers(v, doExport)
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.modifiers = nil
	else
		self.modifiers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.modifiers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.EntityDeclarationNode:getModifiers()
	do return self.modifiers end
end

function sling.model.EntityDeclarationNode:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do return v end
end

function sling.model.EntityDeclarationNode:addToModifiers(v)
	if v == nil then
		do return end
	end
	if self.modifiers == nil then
		self.modifiers = {}
	end
	do _g.jk.lang.Vector:append(self.modifiers, v) end
	do v:setParent(self) end
end

function sling.model.EntityDeclarationNode:clearModifiers()
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

sling.model.CatchBlockNode = _g.sling.common.NodeObject._create()
sling.model.CatchBlockNode.__index = sling.model.CatchBlockNode
_vm:set_metatable(sling.model.CatchBlockNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CatchBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CatchBlockNode)
	return v
end

function sling.model.CatchBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CatchBlockNode'
	self['_isType.sling.model.CatchBlockNode'] = true
	self.exceptions = nil
	self.block = nil
	self.when = nil
end

function sling.model.CatchBlockNode:_construct0()
	sling.model.CatchBlockNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CatchBlockNode:instance(xc, nn)
	local v = _g.sling.model.CatchBlockNode._construct0(_g.sling.model.CatchBlockNode._create())
	if xc ~= nil then
		do v:addToExceptions(xc) end
	end
	do v:setBlock(nn, false) end
	do return v end
end

function sling.model.CatchBlockNode:getNodeTypeName()
	do return "CatchBlockNode" end
end

function sling.model.CatchBlockNode:createNew()
	do return _g.sling.model.CatchBlockNode._construct0(_g.sling.model.CatchBlockNode._create()) end
end

function sling.model.CatchBlockNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CatchBlockNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		if n.when ~= nil then
			do n.when:destroy() end
			n.when = nil
		end
		if self.when ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.when), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.when = pcp
			do n.when:setParent(n) end
		end
		do
			local array = n.exceptions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.exceptions = nil
			if self.exceptions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.exceptions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.exceptions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.exceptions == nil then
								n.exceptions = {}
							end
							do _g.jk.lang.Vector:append(n.exceptions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.CatchBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.when then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.when:destroy() end
		end
		self.when = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.when ~= nil then
			do self.when:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.exceptions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CatchBlockNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	if self.when ~= nil then
		if self.when:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.exceptions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CatchBlockNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
	if self.when ~= nil then
		do self.when:destroy() end
		self.when = nil
	end
	if self.exceptions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.exceptions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.exceptions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.exceptions = nil
end

function sling.model.CatchBlockNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.CatchBlockNode:getBlock()
	do return self.block end
end

function sling.model.CatchBlockNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.CatchBlockNode:setWhen(v, doExport)
	if self.when ~= nil and doExport == false then
		do self.when:destroy() end
	end
	self.when = v
	if self.when ~= nil then
		do self.when:setParent(self) end
	end
end

function sling.model.CatchBlockNode:getWhen()
	do return self.when end
end

function sling.model.CatchBlockNode:exportWhen()
	local v = self.when
	self.when = nil
	do return v end
end

function sling.model.CatchBlockNode:setExceptions(v, doExport)
	if self.exceptions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.exceptions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.exceptions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.exceptions = nil
	else
		self.exceptions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.exceptions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CatchBlockNode:getExceptions()
	do return self.exceptions end
end

function sling.model.CatchBlockNode:exportExceptions()
	local v = self.exceptions
	self.exceptions = nil
	do return v end
end

function sling.model.CatchBlockNode:addToExceptions(v)
	if v == nil then
		do return end
	end
	if self.exceptions == nil then
		self.exceptions = {}
	end
	do _g.jk.lang.Vector:append(self.exceptions, v) end
	do v:setParent(self) end
end

function sling.model.CatchBlockNode:clearExceptions()
	if self.exceptions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.exceptions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.exceptions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.exceptions = nil
end

sling.model.UnaryExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.UnaryExpressionNode.__index = sling.model.UnaryExpressionNode
_vm:set_metatable(sling.model.UnaryExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.UnaryExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.UnaryExpressionNode)
	return v
end

function sling.model.UnaryExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.UnaryExpressionNode'
	self['_isType.sling.model.UnaryExpressionNode'] = true
	self.expression = nil
end

function sling.model.UnaryExpressionNode:_construct0()
	sling.model.UnaryExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.UnaryExpressionNode:getNodeTypeName()
	do return "UnaryExpressionNode" end
end

function sling.model.UnaryExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.UnaryExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.UnaryExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.UnaryExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.UnaryExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.UnaryExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.UnaryExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.UnaryExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.CommentNode = _g.sling.common.NodeObject._create()
sling.model.CommentNode.__index = sling.model.CommentNode
_vm:set_metatable(sling.model.CommentNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CommentNode._create()
	local v = _vm:set_metatable({}, sling.model.CommentNode)
	return v
end

function sling.model.CommentNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CommentNode'
	self['_isType.sling.model.CommentNode'] = true
	self.text = nil
	self.substantial = false
end

function sling.model.CommentNode:_construct0()
	sling.model.CommentNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CommentNode:forText(text, substantial)
	local v = _g.sling.model.CommentNode._construct0(_g.sling.model.CommentNode._create())
	do v:setText(text) end
	do v:setSubstantial(substantial) end
	do return v end
end

function sling.model.CommentNode:getNodeTypeName()
	do return "CommentNode" end
end

function sling.model.CommentNode:createNew()
	do return _g.sling.model.CommentNode._construct0(_g.sling.model.CommentNode._create()) end
end

function sling.model.CommentNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CommentNode')
		if n == nil then
			do return true end
		end
		n.text = self.text
		n.substantial = self.substantial
		do return true end
	end
end

function sling.model.CommentNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CommentNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CommentNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.CommentNode:setText(v)
	self.text = v
end

function sling.model.CommentNode:getText()
	do return self.text end
end

function sling.model.CommentNode:setSubstantial(v)
	self.substantial = v
end

function sling.model.CommentNode:getSubstantial()
	do return self.substantial end
end

sling.model.DateTimeDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.DateTimeDataTypeNode.__index = sling.model.DateTimeDataTypeNode
_vm:set_metatable(sling.model.DateTimeDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DateTimeDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DateTimeDataTypeNode)
	return v
end

function sling.model.DateTimeDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DateTimeDataTypeNode'
	self['_isType.sling.model.DateTimeDataTypeNode'] = true
end

function sling.model.DateTimeDataTypeNode:_construct0()
	sling.model.DateTimeDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DateTimeDataTypeNode:getNodeTypeName()
	do return "DateTimeDataTypeNode" end
end

function sling.model.DateTimeDataTypeNode:createNew()
	do return _g.sling.model.DateTimeDataTypeNode._construct0(_g.sling.model.DateTimeDataTypeNode._create()) end
end

function sling.model.DateTimeDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DateTimeDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DateTimeDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DateTimeDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DateTimeDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.NodeObjectWithModifiers = _g.sling.common.NodeObject._create()
sling.model.NodeObjectWithModifiers.__index = sling.model.NodeObjectWithModifiers
_vm:set_metatable(sling.model.NodeObjectWithModifiers, {
	__index = _g.sling.common.NodeObject
})

function sling.model.NodeObjectWithModifiers._create()
	local v = _vm:set_metatable({}, sling.model.NodeObjectWithModifiers)
	return v
end

function sling.model.NodeObjectWithModifiers:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NodeObjectWithModifiers'
	self['_isType.sling.model.NodeObjectWithModifiers'] = true
	self['_isType.sling.model.NodeWithModifiers'] = true
	self.modifiers = nil
end

function sling.model.NodeObjectWithModifiers:_construct0()
	sling.model.NodeObjectWithModifiers._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.NodeObjectWithModifiers:getNodeTypeName()
	do return "NodeObjectWithModifiers" end
end

function sling.model.NodeObjectWithModifiers:createNew()
	do return _g.sling.model.NodeObjectWithModifiers._construct0(_g.sling.model.NodeObjectWithModifiers._create()) end
end

function sling.model.NodeObjectWithModifiers:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NodeObjectWithModifiers')
		if n == nil then
			do return true end
		end
		do
			local array = n.modifiers
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.modifiers = nil
			if self.modifiers ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.modifiers)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.modifiers[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.modifiers == nil then
								n.modifiers = {}
							end
							do _g.jk.lang.Vector:append(n.modifiers, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.NodeObjectWithModifiers:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.modifiers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NodeObjectWithModifiers:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.modifiers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NodeObjectWithModifiers:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

function sling.model.NodeObjectWithModifiers:setModifiers(v, doExport)
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.modifiers = nil
	else
		self.modifiers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.modifiers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.NodeObjectWithModifiers:getModifiers()
	do return self.modifiers end
end

function sling.model.NodeObjectWithModifiers:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do return v end
end

function sling.model.NodeObjectWithModifiers:addToModifiers(v)
	if v == nil then
		do return end
	end
	if self.modifiers == nil then
		self.modifiers = {}
	end
	do _g.jk.lang.Vector:append(self.modifiers, v) end
	do v:setParent(self) end
end

function sling.model.NodeObjectWithModifiers:clearModifiers()
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

sling.model.GetTypeinfoExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.GetTypeinfoExpressionNode.__index = sling.model.GetTypeinfoExpressionNode
_vm:set_metatable(sling.model.GetTypeinfoExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.GetTypeinfoExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetTypeinfoExpressionNode)
	return v
end

function sling.model.GetTypeinfoExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetTypeinfoExpressionNode'
	self['_isType.sling.model.GetTypeinfoExpressionNode'] = true
end

function sling.model.GetTypeinfoExpressionNode:_construct0()
	sling.model.GetTypeinfoExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.GetTypeinfoExpressionNode:getNodeTypeName()
	do return "GetTypeinfoExpressionNode" end
end

function sling.model.GetTypeinfoExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetTypeinfoExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GetTypeinfoExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetTypeinfoExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GetTypeinfoExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.BinaryExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.BinaryExpressionNode.__index = sling.model.BinaryExpressionNode
_vm:set_metatable(sling.model.BinaryExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.BinaryExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BinaryExpressionNode)
	return v
end

function sling.model.BinaryExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BinaryExpressionNode'
	self['_isType.sling.model.BinaryExpressionNode'] = true
	self.left = nil
	self.right = nil
end

function sling.model.BinaryExpressionNode:_construct0()
	sling.model.BinaryExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.BinaryExpressionNode:getNodeTypeName()
	do return "BinaryExpressionNode" end
end

function sling.model.BinaryExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BinaryExpressionNode')
		if n == nil then
			do return true end
		end
		if n.left ~= nil then
			do n.left:destroy() end
			n.left = nil
		end
		if self.left ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.left), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.left = pcp
			do n.left:setParent(n) end
		end
		if n.right ~= nil then
			do n.right:destroy() end
			n.right = nil
		end
		if self.right ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.right), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.right = pcp
			do n.right:setParent(n) end
		end
		do return true end
	end
end

function sling.model.BinaryExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.left then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.left:destroy() end
		end
		self.left = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.left ~= nil then
			do self.left:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.right then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.right:destroy() end
		end
		self.right = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.right ~= nil then
			do self.right:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BinaryExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.left ~= nil then
		if self.left:accept(visitor) == false then
			do return false end
		end
	end
	if self.right ~= nil then
		if self.right:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.BinaryExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.left ~= nil then
		do self.left:destroy() end
		self.left = nil
	end
	if self.right ~= nil then
		do self.right:destroy() end
		self.right = nil
	end
end

function sling.model.BinaryExpressionNode:setLeft(v, doExport)
	if self.left ~= nil and doExport == false then
		do self.left:destroy() end
	end
	self.left = v
	if self.left ~= nil then
		do self.left:setParent(self) end
	end
end

function sling.model.BinaryExpressionNode:getLeft()
	do return self.left end
end

function sling.model.BinaryExpressionNode:exportLeft()
	local v = self.left
	self.left = nil
	do return v end
end

function sling.model.BinaryExpressionNode:setRight(v, doExport)
	if self.right ~= nil and doExport == false then
		do self.right:destroy() end
	end
	self.right = v
	if self.right ~= nil then
		do self.right:setParent(self) end
	end
end

function sling.model.BinaryExpressionNode:getRight()
	do return self.right end
end

function sling.model.BinaryExpressionNode:exportRight()
	local v = self.right
	self.right = nil
	do return v end
end

sling.model.VariableArgumentsDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.VariableArgumentsDeclarationNode.__index = sling.model.VariableArgumentsDeclarationNode
_vm:set_metatable(sling.model.VariableArgumentsDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.VariableArgumentsDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableArgumentsDeclarationNode)
	return v
end

function sling.model.VariableArgumentsDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableArgumentsDeclarationNode'
	self['_isType.sling.model.VariableArgumentsDeclarationNode'] = true
	self.variableDeclaration = nil
end

function sling.model.VariableArgumentsDeclarationNode:_construct0()
	sling.model.VariableArgumentsDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.VariableArgumentsDeclarationNode:forDeclaration(decl)
	local v = _g.sling.model.VariableArgumentsDeclarationNode._construct0(_g.sling.model.VariableArgumentsDeclarationNode._create())
	do v:setVariableDeclaration(decl, false) end
	do return v end
end

function sling.model.VariableArgumentsDeclarationNode:getType()
	if not (self.variableDeclaration ~= nil) then
		do return nil end
	end
	do return self.variableDeclaration:getType() end
end

function sling.model.VariableArgumentsDeclarationNode:getNodeTypeName()
	do return "VariableArgumentsDeclarationNode" end
end

function sling.model.VariableArgumentsDeclarationNode:createNew()
	do return _g.sling.model.VariableArgumentsDeclarationNode._construct0(_g.sling.model.VariableArgumentsDeclarationNode._create()) end
end

function sling.model.VariableArgumentsDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableArgumentsDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.variableDeclaration ~= nil then
			do n.variableDeclaration:destroy() end
			n.variableDeclaration = nil
		end
		if self.variableDeclaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.variableDeclaration), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.variableDeclaration = pcp
			do n.variableDeclaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.VariableArgumentsDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.variableDeclaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.variableDeclaration:destroy() end
		end
		self.variableDeclaration = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.variableDeclaration ~= nil then
			do self.variableDeclaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableArgumentsDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.variableDeclaration ~= nil then
		if self.variableDeclaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.VariableArgumentsDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.variableDeclaration ~= nil then
		do self.variableDeclaration:destroy() end
		self.variableDeclaration = nil
	end
end

function sling.model.VariableArgumentsDeclarationNode:setVariableDeclaration(v, doExport)
	if self.variableDeclaration ~= nil and doExport == false then
		do self.variableDeclaration:destroy() end
	end
	self.variableDeclaration = v
	if self.variableDeclaration ~= nil then
		do self.variableDeclaration:setParent(self) end
	end
end

function sling.model.VariableArgumentsDeclarationNode:getVariableDeclaration()
	do return self.variableDeclaration end
end

function sling.model.VariableArgumentsDeclarationNode:exportVariableDeclaration()
	local v = self.variableDeclaration
	self.variableDeclaration = nil
	do return v end
end

sling.model.FunctionDeclarationBaseNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.FunctionDeclarationBaseNode.__index = sling.model.FunctionDeclarationBaseNode
_vm:set_metatable(sling.model.FunctionDeclarationBaseNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.FunctionDeclarationBaseNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDeclarationBaseNode)
	return v
end

function sling.model.FunctionDeclarationBaseNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDeclarationBaseNode'
	self['_isType.sling.model.FunctionDeclarationBaseNode'] = true
	self.genericTypes = nil
	self.parameters = nil
	self.throwables = nil
	self.body = nil
	self.description = nil
end

function sling.model.FunctionDeclarationBaseNode:_construct0()
	sling.model.FunctionDeclarationBaseNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.FunctionDeclarationBaseNode:getCreateBody()
	if self.body == nil then
		do self:setBody(_g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()), false) end
	end
	do return self.body end
end

function sling.model.FunctionDeclarationBaseNode:prependParameter(param)
	if not (param ~= nil) then
		do return end
	end
	if self.parameters == nil then
		do self:addToParameters(param) end
		do return end
	end
	do _g.jk.lang.Vector:prepend(self.parameters, param) end
	do param:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:getParameterCount()
	if not (self.parameters ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.parameters) end
end

function sling.model.FunctionDeclarationBaseNode:removeFirstParameter()
	if not (self.parameters ~= nil) then
		do return nil end
	end
	do
		local psz = _g.jk.lang.Vector:getSize(self.parameters)
		if not (psz > 0) then
			do return nil end
		end
		do
			local fp = _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, 0), '_isType.sling.common.NodeObject')
			if not (fp ~= nil) then
				do return nil end
			end
			do fp:destroy() end
			if psz == 1 then
				self.parameters = nil
			else
				do _g.jk.lang.Vector:removeFirst(self.parameters) end
			end
			do return fp end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getParameter(n)
	if not (self.parameters ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, n), '_isType.sling.common.NodeObject') end
end

function sling.model.FunctionDeclarationBaseNode:getNodeTypeName()
	do return "FunctionDeclarationBaseNode" end
end

function sling.model.FunctionDeclarationBaseNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDeclarationBaseNode')
		if n == nil then
			do return true end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		n.description = self.description
		do
			local array = n.genericTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.genericTypes = nil
			if self.genericTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.genericTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.genericTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.genericTypes == nil then
								n.genericTypes = {}
							end
							do _g.jk.lang.Vector:append(n.genericTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.parameters
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.parameters = nil
				if self.parameters ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.parameters)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.parameters[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.parameters == nil then
									n.parameters = {}
								end
								do _g.jk.lang.Vector:append(n.parameters, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do
					local array3 = n.throwables
					if array3 ~= nil then
						local n6 = 0
						local m5 = _g.jk.lang.Vector:getSize(array3)
						do
							n6 = 0
							while n6 < m5 do
								local xx = _vm:to_table_with_key(array3[n6 + 1], '_isType.sling.common.NodeObject')
								if xx ~= nil then
									do xx:destroy() end
								end
								do n6 = n6 + 1 end
							end
						end
					end
					n.throwables = nil
					if self.throwables ~= nil then
						local n7 = 0
						local m6 = _g.jk.lang.Vector:getSize(self.throwables)
						do
							n7 = 0
							while n7 < m6 do
								local nod = _vm:to_table_with_key(self.throwables[n7 + 1], '_isType.sling.common.NodeObject')
								if nod ~= nil then
									local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
									if ndup == nil then
										do return false end
									end
									if n.throwables == nil then
										n.throwables = {}
									end
									do _g.jk.lang.Vector:append(n.throwables, ndup) end
									do ndup:setParent(n) end
								end
								do n7 = n7 + 1 end
							end
						end
					end
					do return true end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.genericTypes, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.throwables, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDeclarationBaseNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.genericTypes, visitor) == false then
		do return false end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	if self:visitVector(self.throwables, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FunctionDeclarationBaseNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
	if self.parameters ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.parameters[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.parameters = nil
	if self.throwables ~= nil then
		local n3 = 0
		local m3 = _g.jk.lang.Vector:getSize(self.throwables)
		do
			n3 = 0
			while n3 < m3 do
				local nx = _vm:to_table_with_key(self.throwables[n3 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n3 = n3 + 1 end
			end
		end
	end
	self.throwables = nil
end

function sling.model.FunctionDeclarationBaseNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.FunctionDeclarationBaseNode:getBody()
	do return self.body end
end

function sling.model.FunctionDeclarationBaseNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:setDescription(v)
	self.description = v
end

function sling.model.FunctionDeclarationBaseNode:getDescription()
	do return self.description end
end

function sling.model.FunctionDeclarationBaseNode:setGenericTypes(v, doExport)
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.genericTypes = nil
	else
		self.genericTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.genericTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getGenericTypes()
	do return self.genericTypes end
end

function sling.model.FunctionDeclarationBaseNode:exportGenericTypes()
	local v = self.genericTypes
	self.genericTypes = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToGenericTypes(v)
	if v == nil then
		do return end
	end
	if self.genericTypes == nil then
		self.genericTypes = {}
	end
	do _g.jk.lang.Vector:append(self.genericTypes, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearGenericTypes()
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
end

function sling.model.FunctionDeclarationBaseNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getParameters()
	do return self.parameters end
end

function sling.model.FunctionDeclarationBaseNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.FunctionDeclarationBaseNode:setThrowables(v, doExport)
	if self.throwables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.throwables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.throwables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.throwables = nil
	else
		self.throwables = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.throwables, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationBaseNode:getThrowables()
	do return self.throwables end
end

function sling.model.FunctionDeclarationBaseNode:exportThrowables()
	local v = self.throwables
	self.throwables = nil
	do return v end
end

function sling.model.FunctionDeclarationBaseNode:addToThrowables(v)
	if v == nil then
		do return end
	end
	if self.throwables == nil then
		self.throwables = {}
	end
	do _g.jk.lang.Vector:append(self.throwables, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationBaseNode:clearThrowables()
	if self.throwables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.throwables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.throwables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.throwables = nil
end

sling.model.LoopStatementNode = {}

sling.model.TypeCastExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.TypeCastExpressionNode.__index = sling.model.TypeCastExpressionNode
_vm:set_metatable(sling.model.TypeCastExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.TypeCastExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeCastExpressionNode)
	return v
end

function sling.model.TypeCastExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeCastExpressionNode'
	self['_isType.sling.model.TypeCastExpressionNode'] = true
	self.expression = nil
	self.type = nil
end

function sling.model.TypeCastExpressionNode:_construct0()
	sling.model.TypeCastExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TypeCastExpressionNode:getNodeTypeName()
	do return "TypeCastExpressionNode" end
end

function sling.model.TypeCastExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeCastExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TypeCastExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeCastExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TypeCastExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.TypeCastExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.TypeCastExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.TypeCastExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.TypeCastExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.TypeCastExpressionNode:getType()
	do return self.type end
end

function sling.model.TypeCastExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.EventRemoveFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.EventRemoveFunctionDeclarationNode.__index = sling.model.EventRemoveFunctionDeclarationNode
_vm:set_metatable(sling.model.EventRemoveFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.EventRemoveFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EventRemoveFunctionDeclarationNode)
	return v
end

function sling.model.EventRemoveFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EventRemoveFunctionDeclarationNode'
	self['_isType.sling.model.EventRemoveFunctionDeclarationNode'] = true
end

function sling.model.EventRemoveFunctionDeclarationNode:_construct0()
	sling.model.EventRemoveFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.EventRemoveFunctionDeclarationNode:setParameter(dt, name)
	do self:clearParameters() end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, name, nil)) end
end

function sling.model.EventRemoveFunctionDeclarationNode:getNodeTypeName()
	do return "EventRemoveFunctionDeclarationNode" end
end

function sling.model.EventRemoveFunctionDeclarationNode:createNew()
	do return _g.sling.model.EventRemoveFunctionDeclarationNode._construct0(_g.sling.model.EventRemoveFunctionDeclarationNode._create()) end
end

function sling.model.EventRemoveFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EventRemoveFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EventRemoveFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EventRemoveFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EventRemoveFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.LiteralExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.LiteralExpressionNode.__index = sling.model.LiteralExpressionNode
_vm:set_metatable(sling.model.LiteralExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.LiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LiteralExpressionNode)
	return v
end

function sling.model.LiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LiteralExpressionNode'
	self['_isType.sling.model.LiteralExpressionNode'] = true
end

function sling.model.LiteralExpressionNode:_construct0()
	sling.model.LiteralExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.LiteralExpressionNode:getNodeTypeName()
	do return "LiteralExpressionNode" end
end

function sling.model.LiteralExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LiteralExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.ImportStatementNode = _g.sling.common.NodeObject._create()
sling.model.ImportStatementNode.__index = sling.model.ImportStatementNode
_vm:set_metatable(sling.model.ImportStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ImportStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportStatementNode)
	return v
end

function sling.model.ImportStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportStatementNode'
	self['_isType.sling.model.ImportStatementNode'] = true
	self.localName = nil
end

function sling.model.ImportStatementNode:_construct0()
	sling.model.ImportStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ImportStatementNode:getNodeTypeName()
	do return "ImportStatementNode" end
end

function sling.model.ImportStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportStatementNode')
		if n == nil then
			do return true end
		end
		n.localName = self.localName
		do return true end
	end
end

function sling.model.ImportStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ImportStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ImportStatementNode:setLocalName(v)
	self.localName = v
end

function sling.model.ImportStatementNode:getLocalName()
	do return self.localName end
end

sling.model.DataTypeDefaultValueExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.DataTypeDefaultValueExpressionNode.__index = sling.model.DataTypeDefaultValueExpressionNode
_vm:set_metatable(sling.model.DataTypeDefaultValueExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.DataTypeDefaultValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DataTypeDefaultValueExpressionNode)
	return v
end

function sling.model.DataTypeDefaultValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DataTypeDefaultValueExpressionNode'
	self['_isType.sling.model.DataTypeDefaultValueExpressionNode'] = true
	self.type = nil
end

function sling.model.DataTypeDefaultValueExpressionNode:_construct0()
	sling.model.DataTypeDefaultValueExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.DataTypeDefaultValueExpressionNode:forType(dt)
	local v = _g.sling.model.DataTypeDefaultValueExpressionNode._construct0(_g.sling.model.DataTypeDefaultValueExpressionNode._create())
	do v:setType(dt, false) end
	do return v end
end

function sling.model.DataTypeDefaultValueExpressionNode:getNodeTypeName()
	do return "DataTypeDefaultValueExpressionNode" end
end

function sling.model.DataTypeDefaultValueExpressionNode:createNew()
	do return _g.sling.model.DataTypeDefaultValueExpressionNode._construct0(_g.sling.model.DataTypeDefaultValueExpressionNode._create()) end
end

function sling.model.DataTypeDefaultValueExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DataTypeDefaultValueExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DataTypeDefaultValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DataTypeDefaultValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DataTypeDefaultValueExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.DataTypeDefaultValueExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.DataTypeDefaultValueExpressionNode:getType()
	do return self.type end
end

function sling.model.DataTypeDefaultValueExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.FileSystemDirectoryReferenceExpressionNode = _g.sling.model.FileSystemReferenceExpressionNode._create()
sling.model.FileSystemDirectoryReferenceExpressionNode.__index = sling.model.FileSystemDirectoryReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemDirectoryReferenceExpressionNode, {
	__index = _g.sling.model.FileSystemReferenceExpressionNode
})

function sling.model.FileSystemDirectoryReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemDirectoryReferenceExpressionNode)
	return v
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemDirectoryReferenceExpressionNode'
	self['_isType.sling.model.FileSystemDirectoryReferenceExpressionNode'] = true
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:_construct0()
	sling.model.FileSystemDirectoryReferenceExpressionNode._init(self)
	do _g.sling.model.FileSystemReferenceExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemDirectoryReferenceExpressionNode" end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:createNew()
	do return _g.sling.model.FileSystemDirectoryReferenceExpressionNode._construct0(_g.sling.model.FileSystemDirectoryReferenceExpressionNode._create()) end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:copyTo(o)
	if _g.sling.model.FileSystemReferenceExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemDirectoryReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FileSystemReferenceExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.FileSystemReferenceExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemDirectoryReferenceExpressionNode:destroy()
	do _g.sling.model.FileSystemReferenceExpressionNode.destroy(self) end
end

sling.model.StaticCastExpressionNode = _g.sling.model.TypeCastExpressionNode._create()
sling.model.StaticCastExpressionNode.__index = sling.model.StaticCastExpressionNode
_vm:set_metatable(sling.model.StaticCastExpressionNode, {
	__index = _g.sling.model.TypeCastExpressionNode
})

sling.model.StaticCastExpressionNode.TYPE_REFERENCE = 0
sling.model.StaticCastExpressionNode.TYPE_PRIMITIVE = 1

function sling.model.StaticCastExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StaticCastExpressionNode)
	return v
end

function sling.model.StaticCastExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StaticCastExpressionNode'
	self['_isType.sling.model.StaticCastExpressionNode'] = true
	self.castType = 0
end

function sling.model.StaticCastExpressionNode:_construct0()
	sling.model.StaticCastExpressionNode._init(self)
	do _g.sling.model.TypeCastExpressionNode._construct0(self) end
	return self
end

function sling.model.StaticCastExpressionNode:instance(type, expression)
	local v = _g.sling.model.StaticCastExpressionNode._construct0(_g.sling.model.StaticCastExpressionNode._create())
	do v:setType(type, false) end
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.StaticCastExpressionNode:getNodeTypeName()
	do return "StaticCastExpressionNode" end
end

function sling.model.StaticCastExpressionNode:createNew()
	do return _g.sling.model.StaticCastExpressionNode._construct0(_g.sling.model.StaticCastExpressionNode._create()) end
end

function sling.model.StaticCastExpressionNode:copyTo(o)
	if _g.sling.model.TypeCastExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StaticCastExpressionNode')
		if n == nil then
			do return true end
		end
		n.castType = self.castType
		do return true end
	end
end

function sling.model.StaticCastExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.TypeCastExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StaticCastExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.TypeCastExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StaticCastExpressionNode:destroy()
	do _g.sling.model.TypeCastExpressionNode.destroy(self) end
end

function sling.model.StaticCastExpressionNode:setCastType(v)
	self.castType = v
end

function sling.model.StaticCastExpressionNode:getCastType()
	do return self.castType end
end

sling.model.StringConcatenationExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.StringConcatenationExpressionNode.__index = sling.model.StringConcatenationExpressionNode
_vm:set_metatable(sling.model.StringConcatenationExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.StringConcatenationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringConcatenationExpressionNode)
	return v
end

function sling.model.StringConcatenationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringConcatenationExpressionNode'
	self['_isType.sling.model.StringConcatenationExpressionNode'] = true
end

function sling.model.StringConcatenationExpressionNode:_construct0()
	sling.model.StringConcatenationExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.StringConcatenationExpressionNode:instance(left, right)
	local v = _g.sling.model.StringConcatenationExpressionNode._construct0(_g.sling.model.StringConcatenationExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StringConcatenationExpressionNode:forExpressions(xprs)
	if not (xprs ~= nil) then
		do return nil end
	end
	do
		local sz = _g.jk.lang.Vector:getSize(xprs)
		if not (sz >= 2) then
			do return nil end
		end
		do
			local v = _g.sling.model.StringConcatenationExpressionNode:instance(_g.jk.lang.Vector:get(xprs, 0), _g.jk.lang.Vector:get(xprs, 1))
			do
				local n = 2
				while n < sz do
					v = _g.sling.model.StringConcatenationExpressionNode:instance(v, _g.jk.lang.Vector:get(xprs, n))
					do n = n + 1 end
				end
			end
			do return v end
		end
	end
end

function sling.model.StringConcatenationExpressionNode:getNodeTypeName()
	do return "StringConcatenationExpressionNode" end
end

function sling.model.StringConcatenationExpressionNode:createNew()
	do return _g.sling.model.StringConcatenationExpressionNode._construct0(_g.sling.model.StringConcatenationExpressionNode._create()) end
end

function sling.model.StringConcatenationExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringConcatenationExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StringConcatenationExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringConcatenationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringConcatenationExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.TreeElementNode = _g.sling.common.NodeObject._create()
sling.model.TreeElementNode.__index = sling.model.TreeElementNode
_vm:set_metatable(sling.model.TreeElementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TreeElementNode._create()
	local v = _vm:set_metatable({}, sling.model.TreeElementNode)
	return v
end

function sling.model.TreeElementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TreeElementNode'
	self['_isType.sling.model.TreeElementNode'] = true
	self.name = nil
	self.reference = nil
	self.attributes = nil
	self.children = nil
end

function sling.model.TreeElementNode:_construct0()
	sling.model.TreeElementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TreeElementNode:getNodeTypeName()
	do return "TreeElementNode" end
end

function sling.model.TreeElementNode:createNew()
	do return _g.sling.model.TreeElementNode._construct0(_g.sling.model.TreeElementNode._create()) end
end

function sling.model.TreeElementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TreeElementNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		n.reference = self.reference
		do
			local array = n.attributes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.attributes = nil
			if self.attributes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.attributes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.attributes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.attributes == nil then
								n.attributes = {}
							end
							do _g.jk.lang.Vector:append(n.attributes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.children
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.children = nil
				if self.children ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.children)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.children[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.children == nil then
									n.children = {}
								end
								do _g.jk.lang.Vector:append(n.children, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.TreeElementNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.attributes, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.children, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TreeElementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.attributes, visitor) == false then
		do return false end
	end
	if self:visitVector(self.children, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TreeElementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.attributes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.attributes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.attributes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.attributes = nil
	if self.children ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.children)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.children[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.children = nil
end

function sling.model.TreeElementNode:setName(v)
	self.name = v
end

function sling.model.TreeElementNode:getName()
	do return self.name end
end

function sling.model.TreeElementNode:setReference(v)
	self.reference = v
end

function sling.model.TreeElementNode:getReference()
	do return self.reference end
end

function sling.model.TreeElementNode:setAttributes(v, doExport)
	if self.attributes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.attributes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.attributes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.attributes = nil
	else
		self.attributes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.attributes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TreeElementNode:getAttributes()
	do return self.attributes end
end

function sling.model.TreeElementNode:exportAttributes()
	local v = self.attributes
	self.attributes = nil
	do return v end
end

function sling.model.TreeElementNode:addToAttributes(v)
	if v == nil then
		do return end
	end
	if self.attributes == nil then
		self.attributes = {}
	end
	do _g.jk.lang.Vector:append(self.attributes, v) end
	do v:setParent(self) end
end

function sling.model.TreeElementNode:clearAttributes()
	if self.attributes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.attributes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.attributes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.attributes = nil
end

function sling.model.TreeElementNode:setChildren(v, doExport)
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.children = nil
	else
		self.children = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.children, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TreeElementNode:getChildren()
	do return self.children end
end

function sling.model.TreeElementNode:exportChildren()
	local v = self.children
	self.children = nil
	do return v end
end

function sling.model.TreeElementNode:addToChildren(v)
	if v == nil then
		do return end
	end
	if self.children == nil then
		self.children = {}
	end
	do _g.jk.lang.Vector:append(self.children, v) end
	do v:setParent(self) end
end

function sling.model.TreeElementNode:clearChildren()
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.children = nil
end

sling.model.PropertyDidSetFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.PropertyDidSetFunctionDeclarationNode.__index = sling.model.PropertyDidSetFunctionDeclarationNode
_vm:set_metatable(sling.model.PropertyDidSetFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.PropertyDidSetFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyDidSetFunctionDeclarationNode)
	return v
end

function sling.model.PropertyDidSetFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyDidSetFunctionDeclarationNode'
	self['_isType.sling.model.PropertyDidSetFunctionDeclarationNode'] = true
end

function sling.model.PropertyDidSetFunctionDeclarationNode:_construct0()
	sling.model.PropertyDidSetFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.PropertyDidSetFunctionDeclarationNode:setParameter(dt, name)
	do self:clearParameters() end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, name, nil)) end
end

function sling.model.PropertyDidSetFunctionDeclarationNode:getNodeTypeName()
	do return "PropertyDidSetFunctionDeclarationNode" end
end

function sling.model.PropertyDidSetFunctionDeclarationNode:createNew()
	do return _g.sling.model.PropertyDidSetFunctionDeclarationNode._construct0(_g.sling.model.PropertyDidSetFunctionDeclarationNode._create()) end
end

function sling.model.PropertyDidSetFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyDidSetFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PropertyDidSetFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyDidSetFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertyDidSetFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.CaseTypePatternBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseTypePatternBlockNode.__index = sling.model.CaseTypePatternBlockNode
_vm:set_metatable(sling.model.CaseTypePatternBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseTypePatternBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseTypePatternBlockNode)
	return v
end

function sling.model.CaseTypePatternBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseTypePatternBlockNode'
	self['_isType.sling.model.CaseTypePatternBlockNode'] = true
	self.type = nil
	self.name = nil
end

function sling.model.CaseTypePatternBlockNode:_construct0()
	sling.model.CaseTypePatternBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseTypePatternBlockNode:instance(type, name, bb)
	local v = _g.sling.model.CaseTypePatternBlockNode._construct0(_g.sling.model.CaseTypePatternBlockNode._create())
	do v:setType(type, false) end
	do v:setName(name) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseTypePatternBlockNode:getNodeTypeName()
	do return "CaseTypePatternBlockNode" end
end

function sling.model.CaseTypePatternBlockNode:createNew()
	do return _g.sling.model.CaseTypePatternBlockNode._construct0(_g.sling.model.CaseTypePatternBlockNode._create()) end
end

function sling.model.CaseTypePatternBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseTypePatternBlockNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.CaseTypePatternBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseTypePatternBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseTypePatternBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.CaseTypePatternBlockNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.CaseTypePatternBlockNode:getType()
	do return self.type end
end

function sling.model.CaseTypePatternBlockNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.CaseTypePatternBlockNode:setName(v)
	self.name = v
end

function sling.model.CaseTypePatternBlockNode:getName()
	do return self.name end
end

sling.model.TreeElementAttributeNode = _g.sling.common.NodeObject._create()
sling.model.TreeElementAttributeNode.__index = sling.model.TreeElementAttributeNode
_vm:set_metatable(sling.model.TreeElementAttributeNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TreeElementAttributeNode._create()
	local v = _vm:set_metatable({}, sling.model.TreeElementAttributeNode)
	return v
end

function sling.model.TreeElementAttributeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TreeElementAttributeNode'
	self['_isType.sling.model.TreeElementAttributeNode'] = true
	self.name = nil
	self.value = nil
end

function sling.model.TreeElementAttributeNode:_construct0()
	sling.model.TreeElementAttributeNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TreeElementAttributeNode:getNodeTypeName()
	do return "TreeElementAttributeNode" end
end

function sling.model.TreeElementAttributeNode:createNew()
	do return _g.sling.model.TreeElementAttributeNode._construct0(_g.sling.model.TreeElementAttributeNode._create()) end
end

function sling.model.TreeElementAttributeNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TreeElementAttributeNode')
		if n == nil then
			do return true end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.TreeElementAttributeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TreeElementAttributeNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TreeElementAttributeNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.TreeElementAttributeNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.TreeElementAttributeNode:getValue()
	do return self.value end
end

function sling.model.TreeElementAttributeNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.TreeElementAttributeNode:setName(v)
	self.name = v
end

function sling.model.TreeElementAttributeNode:getName()
	do return self.name end
end

sling.model.DataTypeExtenderNode = _g.sling.common.DataTypeNode._create()
sling.model.DataTypeExtenderNode.__index = sling.model.DataTypeExtenderNode
_vm:set_metatable(sling.model.DataTypeExtenderNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DataTypeExtenderNode._create()
	local v = _vm:set_metatable({}, sling.model.DataTypeExtenderNode)
	return v
end

function sling.model.DataTypeExtenderNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DataTypeExtenderNode'
	self['_isType.sling.model.DataTypeExtenderNode'] = true
	self.primaryType = nil
end

function sling.model.DataTypeExtenderNode:_construct0()
	sling.model.DataTypeExtenderNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DataTypeExtenderNode:getNodeTypeName()
	do return "DataTypeExtenderNode" end
end

function sling.model.DataTypeExtenderNode:createNew()
	do return _g.sling.model.DataTypeExtenderNode._construct0(_g.sling.model.DataTypeExtenderNode._create()) end
end

function sling.model.DataTypeExtenderNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DataTypeExtenderNode')
		if n == nil then
			do return true end
		end
		if n.primaryType ~= nil then
			do n.primaryType:destroy() end
			n.primaryType = nil
		end
		if self.primaryType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.primaryType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.primaryType = pcp
			do n.primaryType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DataTypeExtenderNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.primaryType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.primaryType:destroy() end
		end
		self.primaryType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.primaryType ~= nil then
			do self.primaryType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DataTypeExtenderNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.primaryType ~= nil then
		if self.primaryType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DataTypeExtenderNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.primaryType ~= nil then
		do self.primaryType:destroy() end
		self.primaryType = nil
	end
end

function sling.model.DataTypeExtenderNode:setPrimaryType(v, doExport)
	if self.primaryType ~= nil and doExport == false then
		do self.primaryType:destroy() end
	end
	self.primaryType = v
	if self.primaryType ~= nil then
		do self.primaryType:setParent(self) end
	end
end

function sling.model.DataTypeExtenderNode:getPrimaryType()
	do return self.primaryType end
end

function sling.model.DataTypeExtenderNode:exportPrimaryType()
	local v = self.primaryType
	self.primaryType = nil
	do return v end
end

sling.model.AssignmentExpressionBaseNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.AssignmentExpressionBaseNode.__index = sling.model.AssignmentExpressionBaseNode
_vm:set_metatable(sling.model.AssignmentExpressionBaseNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.AssignmentExpressionBaseNode._create()
	local v = _vm:set_metatable({}, sling.model.AssignmentExpressionBaseNode)
	return v
end

function sling.model.AssignmentExpressionBaseNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AssignmentExpressionBaseNode'
	self['_isType.sling.model.AssignmentExpressionBaseNode'] = true
end

function sling.model.AssignmentExpressionBaseNode:_construct0()
	sling.model.AssignmentExpressionBaseNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.AssignmentExpressionBaseNode:getNodeTypeName()
	do return "AssignmentExpressionBaseNode" end
end

function sling.model.AssignmentExpressionBaseNode:createNew()
	do return _g.sling.model.AssignmentExpressionBaseNode._construct0(_g.sling.model.AssignmentExpressionBaseNode._create()) end
end

function sling.model.AssignmentExpressionBaseNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AssignmentExpressionBaseNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AssignmentExpressionBaseNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AssignmentExpressionBaseNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AssignmentExpressionBaseNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.SwitchStatementNode = _g.sling.common.NodeObject._create()
sling.model.SwitchStatementNode.__index = sling.model.SwitchStatementNode
_vm:set_metatable(sling.model.SwitchStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.SwitchStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.SwitchStatementNode)
	return v
end

function sling.model.SwitchStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SwitchStatementNode'
	self['_isType.sling.model.SwitchStatementNode'] = true
	self.expression = nil
	self.blocks = nil
end

function sling.model.SwitchStatementNode:_construct0()
	sling.model.SwitchStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.SwitchStatementNode:forExpression(xp)
	local v = _g.sling.model.SwitchStatementNode._construct0(_g.sling.model.SwitchStatementNode._create())
	do v:setExpression(xp, false) end
	do return v end
end

function sling.model.SwitchStatementNode:getNodeTypeName()
	do return "SwitchStatementNode" end
end

function sling.model.SwitchStatementNode:createNew()
	do return _g.sling.model.SwitchStatementNode._construct0(_g.sling.model.SwitchStatementNode._create()) end
end

function sling.model.SwitchStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SwitchStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do
			local array = n.blocks
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.blocks = nil
			if self.blocks ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.blocks)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.blocks[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.blocks == nil then
								n.blocks = {}
							end
							do _g.jk.lang.Vector:append(n.blocks, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SwitchStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.blocks, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SwitchStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.blocks, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SwitchStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.blocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.blocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.blocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.blocks = nil
end

function sling.model.SwitchStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.SwitchStatementNode:getExpression()
	do return self.expression end
end

function sling.model.SwitchStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.SwitchStatementNode:setBlocks(v, doExport)
	if self.blocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.blocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.blocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.blocks = nil
	else
		self.blocks = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.blocks, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SwitchStatementNode:getBlocks()
	do return self.blocks end
end

function sling.model.SwitchStatementNode:exportBlocks()
	local v = self.blocks
	self.blocks = nil
	do return v end
end

function sling.model.SwitchStatementNode:addToBlocks(v)
	if v == nil then
		do return end
	end
	if self.blocks == nil then
		self.blocks = {}
	end
	do _g.jk.lang.Vector:append(self.blocks, v) end
	do v:setParent(self) end
end

function sling.model.SwitchStatementNode:clearBlocks()
	if self.blocks ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.blocks)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.blocks[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.blocks = nil
end

sling.model.ArithmeticExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ArithmeticExpressionNode.__index = sling.model.ArithmeticExpressionNode
_vm:set_metatable(sling.model.ArithmeticExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ArithmeticExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ArithmeticExpressionNode)
	return v
end

function sling.model.ArithmeticExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ArithmeticExpressionNode'
	self['_isType.sling.model.ArithmeticExpressionNode'] = true
end

function sling.model.ArithmeticExpressionNode:_construct0()
	sling.model.ArithmeticExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ArithmeticExpressionNode:getNodeTypeName()
	do return "ArithmeticExpressionNode" end
end

function sling.model.ArithmeticExpressionNode:createNew()
	do return _g.sling.model.ArithmeticExpressionNode._construct0(_g.sling.model.ArithmeticExpressionNode._create()) end
end

function sling.model.ArithmeticExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ArithmeticExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ArithmeticExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ArithmeticExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ArithmeticExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.VariableDeclarationNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.VariableDeclarationNode.__index = sling.model.VariableDeclarationNode
_vm:set_metatable(sling.model.VariableDeclarationNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.VariableDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableDeclarationNode)
	return v
end

function sling.model.VariableDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableDeclarationNode'
	self['_isType.sling.model.VariableDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.fundamentalType = nil
	self.type = nil
	self.name = nil
	self.paramName = nil
	self.initializer = nil
	self.description = nil
end

function sling.model.VariableDeclarationNode:_construct0()
	sling.model.VariableDeclarationNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.VariableDeclarationNode:forAutomatic(name, initializer)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setType(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), false) end
	do v:setName(name) end
	do v:setInitializer(initializer, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:instance(type, name, initializer)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setType(type, false) end
	do v:setName(name) end
	do v:setInitializer(initializer, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:forInitializer(initializer)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setInitializer(initializer, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:forDynamic(name)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setName(name) end
	do v:setType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	do return v end
end

function sling.model.VariableDeclarationNode:forName(name)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.VariableDeclarationNode:forType(type)
	local v = _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.VariableDeclarationNode:getNodeName()
	do return self.name end
end

function sling.model.VariableDeclarationNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.VariableDeclarationNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.VariableDeclarationNode:getNodeTypeName()
	do return "VariableDeclarationNode" end
end

function sling.model.VariableDeclarationNode:createNew()
	do return _g.sling.model.VariableDeclarationNode._construct0(_g.sling.model.VariableDeclarationNode._create()) end
end

function sling.model.VariableDeclarationNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.fundamentalType ~= nil then
			do n.fundamentalType:destroy() end
			n.fundamentalType = nil
		end
		if self.fundamentalType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.fundamentalType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.fundamentalType = pcp
			do n.fundamentalType:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		n.name = self.name
		n.paramName = self.paramName
		n.description = self.description
		do return true end
	end
end

function sling.model.VariableDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.fundamentalType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.fundamentalType:destroy() end
		end
		self.fundamentalType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.fundamentalType ~= nil then
			do self.fundamentalType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.fundamentalType ~= nil then
		if self.fundamentalType:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.VariableDeclarationNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.fundamentalType ~= nil then
		do self.fundamentalType:destroy() end
		self.fundamentalType = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
end

function sling.model.VariableDeclarationNode:setFundamentalType(v, doExport)
	if self.fundamentalType ~= nil and doExport == false then
		do self.fundamentalType:destroy() end
	end
	self.fundamentalType = v
	if self.fundamentalType ~= nil then
		do self.fundamentalType:setParent(self) end
	end
end

function sling.model.VariableDeclarationNode:getFundamentalType()
	do return self.fundamentalType end
end

function sling.model.VariableDeclarationNode:exportFundamentalType()
	local v = self.fundamentalType
	self.fundamentalType = nil
	do return v end
end

function sling.model.VariableDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.VariableDeclarationNode:getType()
	do return self.type end
end

function sling.model.VariableDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.VariableDeclarationNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.VariableDeclarationNode:getInitializer()
	do return self.initializer end
end

function sling.model.VariableDeclarationNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.VariableDeclarationNode:getName()
	do return self.name end
end

function sling.model.VariableDeclarationNode:setParamName(v)
	self.paramName = v
end

function sling.model.VariableDeclarationNode:getParamName()
	do return self.paramName end
end

function sling.model.VariableDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.VariableDeclarationNode:getDescription()
	do return self.description end
end

sling.model.RegionDeclarationNode = _g.sling.common.NamedContainerNode._create()
sling.model.RegionDeclarationNode.__index = sling.model.RegionDeclarationNode
_vm:set_metatable(sling.model.RegionDeclarationNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.model.RegionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.RegionDeclarationNode)
	return v
end

function sling.model.RegionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.RegionDeclarationNode'
	self['_isType.sling.model.RegionDeclarationNode'] = true
	self.description = nil
end

function sling.model.RegionDeclarationNode:_construct0()
	sling.model.RegionDeclarationNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.model.RegionDeclarationNode:getNodeTypeName()
	do return "RegionDeclarationNode" end
end

function sling.model.RegionDeclarationNode:createNew()
	do return _g.sling.model.RegionDeclarationNode._construct0(_g.sling.model.RegionDeclarationNode._create()) end
end

function sling.model.RegionDeclarationNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.RegionDeclarationNode')
		if n == nil then
			do return true end
		end
		n.description = self.description
		do return true end
	end
end

function sling.model.RegionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.RegionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.RegionDeclarationNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
end

function sling.model.RegionDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.RegionDeclarationNode:getDescription()
	do return self.description end
end

sling.model.TypeMap = {}
sling.model.TypeMap.__index = sling.model.TypeMap
_vm:set_metatable(sling.model.TypeMap, {})

function sling.model.TypeMap._create()
	local v = _vm:set_metatable({}, sling.model.TypeMap)
	return v
end

function sling.model.TypeMap:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeMap'
	self['_isType.sling.model.TypeMap'] = true
	self.map = nil
	self._destructWrapper = _vm:create_destructor(function() self:_destruct() end)
end

function sling.model.TypeMap:_construct0()
	sling.model.TypeMap._init(self)
	return self
end

function sling.model.TypeMap:merge(from, ato)
	local to = ato
	if not (to ~= nil) then
		to = _g.sling.model.TypeMap._construct0(_g.sling.model.TypeMap._create())
	end
	if from ~= nil then
		do from:copyTo(to) end
	end
	do return to end
end

function sling.model.TypeMap:forDynamicMap(v)
	local r = _g.sling.model.TypeMap._construct0(_g.sling.model.TypeMap._create())
	if v ~= nil then
		local array = v:getKeys()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local key = array[n + 1]
					if key ~= nil then
						do r:set(key, _vm:to_table_with_key(v:get(key), '_isType.sling.common.DataTypeNode')) end
					end
					do n = n + 1 end
				end
			end
		end
	end
	do return r end
end

function sling.model.TypeMap:_destruct()
	do self:clear() end
end

function sling.model.TypeMap:asDynamicMap()
	do return self.map end
end

function sling.model.TypeMap:get(name)
	if not (name ~= nil) then
		do return nil end
	end
	if not (self.map ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(self.map:get(name), '_isType.sling.common.DataTypeNode') end
end

function sling.model.TypeMap:dup()
	local v = _g.sling.model.TypeMap._construct0(_g.sling.model.TypeMap._create())
	do self:copyTo(v) end
	do return v end
end

function sling.model.TypeMap:clear()
	if self.map ~= nil then
		local array = self.map:getValues()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local value = _vm:to_table_with_key(array[n + 1], '_isType.sling.common.DataTypeNode')
					if value ~= nil then
						do value:destroy() end
					end
					do n = n + 1 end
				end
			end
		end
		self.map = nil
	end
end

function sling.model.TypeMap:copyTo(r)
	if not (r ~= nil) then
		do return end
	end
	if self.map ~= nil then
		local array = self.map:getKeys()
		if array ~= nil then
			local n = 0
			local m = _g.jk.lang.Vector:getSize(array)
			do
				n = 0
				while n < m do
					local key = array[n + 1]
					if key ~= nil then
						do r:set(key, _vm:to_table_with_key(self.map:get(key), '_isType.sling.common.DataTypeNode')) end
					end
					do n = n + 1 end
				end
			end
		end
	end
end

function sling.model.TypeMap:copyFrom(r)
	if r ~= nil then
		do r:copyTo(self) end
	end
end

function sling.model.TypeMap:set(name, dt)
	if not (name ~= nil) then
		do return end
	end
	if not (self.map ~= nil) then
		self.map = _g.jk.lang.DynamicMap._construct0(_g.jk.lang.DynamicMap._create())
	end
	do
		local sdt = dt
		if sdt ~= nil then
			sdt = _vm:to_table_with_key(sdt:dup(), '_isType.sling.common.DataTypeNode')
		end
		do self.map:setObject(name, sdt) end
	end
end

function sling.model.TypeMap:contains(name)
	if not (name ~= nil) then
		do return false end
	end
	if not (self.map ~= nil) then
		do return false end
	end
	if self.map:get(name) ~= nil then
		do return true end
	end
	do return false end
end

sling.model.SymbolNameComponentNode = _g.sling.common.NodeObject._create()
sling.model.SymbolNameComponentNode.__index = sling.model.SymbolNameComponentNode
_vm:set_metatable(sling.model.SymbolNameComponentNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.SymbolNameComponentNode._create()
	local v = _vm:set_metatable({}, sling.model.SymbolNameComponentNode)
	return v
end

function sling.model.SymbolNameComponentNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SymbolNameComponentNode'
	self['_isType.sling.model.SymbolNameComponentNode'] = true
	self.name = nil
	self.typeParameters = nil
end

function sling.model.SymbolNameComponentNode:_construct0()
	sling.model.SymbolNameComponentNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.SymbolNameComponentNode:forObject(obj)
	if not (obj ~= nil) then
		do return nil end
	end
	if (_vm:to_table_with_key(obj, '_isType.sling.model.SymbolNameComponentNode') ~= nil) then
		do return obj end
	end
	if (_vm:get_variable_type(obj) == 'string') then
		do return _g.sling.model.SymbolNameComponentNode:forName(obj) end
	end
	do return nil end
end

function sling.model.SymbolNameComponentNode:forName(name)
	local v = _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.SymbolNameComponentNode:instance(name, params)
	local v = _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create())
	do v:setName(name) end
	do v:setTypeParameters(params, false) end
	do return v end
end

function sling.model.SymbolNameComponentNode:getNodeTypeName()
	do return "SymbolNameComponentNode" end
end

function sling.model.SymbolNameComponentNode:createNew()
	do return _g.sling.model.SymbolNameComponentNode._construct0(_g.sling.model.SymbolNameComponentNode._create()) end
end

function sling.model.SymbolNameComponentNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SymbolNameComponentNode')
		if n == nil then
			do return true end
		end
		n.name = self.name
		do
			local array = n.typeParameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.typeParameters = nil
			if self.typeParameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.typeParameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.typeParameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.typeParameters == nil then
								n.typeParameters = {}
							end
							do _g.jk.lang.Vector:append(n.typeParameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SymbolNameComponentNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.typeParameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SymbolNameComponentNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.typeParameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SymbolNameComponentNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.typeParameters = nil
end

function sling.model.SymbolNameComponentNode:setName(v)
	self.name = v
end

function sling.model.SymbolNameComponentNode:getName()
	do return self.name end
end

function sling.model.SymbolNameComponentNode:setTypeParameters(v, doExport)
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.typeParameters = nil
	else
		self.typeParameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.typeParameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SymbolNameComponentNode:getTypeParameters()
	do return self.typeParameters end
end

function sling.model.SymbolNameComponentNode:exportTypeParameters()
	local v = self.typeParameters
	self.typeParameters = nil
	do return v end
end

function sling.model.SymbolNameComponentNode:addToTypeParameters(v)
	if v == nil then
		do return end
	end
	if self.typeParameters == nil then
		self.typeParameters = {}
	end
	do _g.jk.lang.Vector:append(self.typeParameters, v) end
	do v:setParent(self) end
end

function sling.model.SymbolNameComponentNode:clearTypeParameters()
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.typeParameters = nil
end

sling.model.DecimalLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.DecimalLiteralExpressionNode.__index = sling.model.DecimalLiteralExpressionNode
_vm:set_metatable(sling.model.DecimalLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.DecimalLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DecimalLiteralExpressionNode)
	return v
end

function sling.model.DecimalLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DecimalLiteralExpressionNode'
	self['_isType.sling.model.DecimalLiteralExpressionNode'] = true
	self.value = nil
end

function sling.model.DecimalLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.DecimalLiteralExpressionNode._construct0(_g.sling.model.DecimalLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.DecimalLiteralExpressionNode:_construct0()
	sling.model.DecimalLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DecimalDataTypeNode._construct0(_g.sling.model.DecimalDataTypeNode._create()), false) end
	return self
end

function sling.model.DecimalLiteralExpressionNode:getNodeTypeName()
	do return "DecimalLiteralExpressionNode" end
end

function sling.model.DecimalLiteralExpressionNode:createNew()
	do return _g.sling.model.DecimalLiteralExpressionNode._construct0(_g.sling.model.DecimalLiteralExpressionNode._create()) end
end

function sling.model.DecimalLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DecimalLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.DecimalLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DecimalLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DecimalLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.DecimalLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.DecimalLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.BaseTypeNode = _g.sling.common.NodeObject._create()
sling.model.BaseTypeNode.__index = sling.model.BaseTypeNode
_vm:set_metatable(sling.model.BaseTypeNode, {
	__index = _g.sling.common.NodeObject
})

sling.model.BaseTypeNode.INHERIT_AUTO = 0
sling.model.BaseTypeNode.INHERIT_EXTEND = 1
sling.model.BaseTypeNode.INHERIT_IMPLEMENT = 2
sling.model.BaseTypeNode.INHERIT_INFORMATIVE = 3
sling.model.BaseTypeNode.INHERIT_UNKNOWN = 4

function sling.model.BaseTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.BaseTypeNode)
	return v
end

function sling.model.BaseTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BaseTypeNode'
	self['_isType.sling.model.BaseTypeNode'] = true
	self.referenceType = nil
	self.inheritType = 0
	self.expression = nil
end

function sling.model.BaseTypeNode:_construct0()
	sling.model.BaseTypeNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.BaseTypeNode:forType(type, inheritType)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setReferenceType(type, false) end
	do v:setInheritType(inheritType) end
	do return v end
end

function sling.model.BaseTypeNode:forExpression(expression, inheritType)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setExpression(expression, false) end
	do v:setInheritType(inheritType) end
	do return v end
end

function sling.model.BaseTypeNode:forExtends(type)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setReferenceType(type, false) end
	do v:setInheritType(_g.sling.model.BaseTypeNode.INHERIT_EXTEND) end
	do return v end
end

function sling.model.BaseTypeNode:forImplements(type)
	local v = _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create())
	do v:setReferenceType(type, false) end
	do v:setInheritType(_g.sling.model.BaseTypeNode.INHERIT_IMPLEMENT) end
	do return v end
end

function sling.model.BaseTypeNode:getNodeTypeName()
	do return "BaseTypeNode" end
end

function sling.model.BaseTypeNode:createNew()
	do return _g.sling.model.BaseTypeNode._construct0(_g.sling.model.BaseTypeNode._create()) end
end

function sling.model.BaseTypeNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BaseTypeNode')
		if n == nil then
			do return true end
		end
		if n.referenceType ~= nil then
			do n.referenceType:destroy() end
			n.referenceType = nil
		end
		if self.referenceType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.referenceType), '_isType.sling.model.ReferenceDataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.referenceType = pcp
			do n.referenceType:setParent(n) end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.inheritType = self.inheritType
		do return true end
	end
end

function sling.model.BaseTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.referenceType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ReferenceDataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.referenceType:destroy() end
		end
		self.referenceType = _vm:to_table_with_key(newnode, '_isType.sling.model.ReferenceDataTypeNode')
		if self.referenceType ~= nil then
			do self.referenceType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BaseTypeNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.referenceType ~= nil then
		if self.referenceType:accept(visitor) == false then
			do return false end
		end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.BaseTypeNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.referenceType ~= nil then
		do self.referenceType:destroy() end
		self.referenceType = nil
	end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.BaseTypeNode:setReferenceType(v, doExport)
	if self.referenceType ~= nil and doExport == false then
		do self.referenceType:destroy() end
	end
	self.referenceType = v
	if self.referenceType ~= nil then
		do self.referenceType:setParent(self) end
	end
end

function sling.model.BaseTypeNode:getReferenceType()
	do return self.referenceType end
end

function sling.model.BaseTypeNode:exportReferenceType()
	local v = self.referenceType
	self.referenceType = nil
	do return v end
end

function sling.model.BaseTypeNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.BaseTypeNode:getExpression()
	do return self.expression end
end

function sling.model.BaseTypeNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.BaseTypeNode:setInheritType(v)
	self.inheritType = v
end

function sling.model.BaseTypeNode:getInheritType()
	do return self.inheritType end
end

sling.model.StringDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.StringDataTypeNode.__index = sling.model.StringDataTypeNode
_vm:set_metatable(sling.model.StringDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.StringDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.StringDataTypeNode)
	return v
end

function sling.model.StringDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringDataTypeNode'
	self['_isType.sling.model.StringDataTypeNode'] = true
	self.fixedLength = nil
end

function sling.model.StringDataTypeNode:_construct0()
	sling.model.StringDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.StringDataTypeNode:getNodeTypeName()
	do return "StringDataTypeNode" end
end

function sling.model.StringDataTypeNode:createNew()
	do return _g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()) end
end

function sling.model.StringDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.fixedLength ~= nil then
			do n.fixedLength:destroy() end
			n.fixedLength = nil
		end
		if self.fixedLength ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.fixedLength), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.fixedLength = pcp
			do n.fixedLength:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StringDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.fixedLength then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.fixedLength:destroy() end
		end
		self.fixedLength = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.fixedLength ~= nil then
			do self.fixedLength:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.fixedLength ~= nil then
		if self.fixedLength:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StringDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.fixedLength ~= nil then
		do self.fixedLength:destroy() end
		self.fixedLength = nil
	end
end

function sling.model.StringDataTypeNode:setFixedLength(v, doExport)
	if self.fixedLength ~= nil and doExport == false then
		do self.fixedLength:destroy() end
	end
	self.fixedLength = v
	if self.fixedLength ~= nil then
		do self.fixedLength:setParent(self) end
	end
end

function sling.model.StringDataTypeNode:getFixedLength()
	do return self.fixedLength end
end

function sling.model.StringDataTypeNode:exportFixedLength()
	local v = self.fixedLength
	self.fixedLength = nil
	do return v end
end

sling.model.SetDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.SetDataTypeNode.__index = sling.model.SetDataTypeNode
_vm:set_metatable(sling.model.SetDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.SetDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.SetDataTypeNode)
	return v
end

function sling.model.SetDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SetDataTypeNode'
	self['_isType.sling.model.SetDataTypeNode'] = true
end

function sling.model.SetDataTypeNode:_construct0()
	sling.model.SetDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.SetDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.SetDataTypeNode._construct0(_g.sling.model.SetDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.SetDataTypeNode:getNodeTypeName()
	do return "SetDataTypeNode" end
end

function sling.model.SetDataTypeNode:createNew()
	do return _g.sling.model.SetDataTypeNode._construct0(_g.sling.model.SetDataTypeNode._create()) end
end

function sling.model.SetDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SetDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SetDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SetDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SetDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.BitwiseAndAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.BitwiseAndAssignmentExpressionNode.__index = sling.model.BitwiseAndAssignmentExpressionNode
_vm:set_metatable(sling.model.BitwiseAndAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.BitwiseAndAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseAndAssignmentExpressionNode)
	return v
end

function sling.model.BitwiseAndAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseAndAssignmentExpressionNode'
	self['_isType.sling.model.BitwiseAndAssignmentExpressionNode'] = true
end

function sling.model.BitwiseAndAssignmentExpressionNode:_construct0()
	sling.model.BitwiseAndAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.BitwiseAndAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseAndAssignmentExpressionNode._construct0(_g.sling.model.BitwiseAndAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseAndAssignmentExpressionNode:getNodeTypeName()
	do return "BitwiseAndAssignmentExpressionNode" end
end

function sling.model.BitwiseAndAssignmentExpressionNode:createNew()
	do return _g.sling.model.BitwiseAndAssignmentExpressionNode._construct0(_g.sling.model.BitwiseAndAssignmentExpressionNode._create()) end
end

function sling.model.BitwiseAndAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseAndAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseAndAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseAndAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseAndAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.IndexerDeclarationNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.IndexerDeclarationNode.__index = sling.model.IndexerDeclarationNode
_vm:set_metatable(sling.model.IndexerDeclarationNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.IndexerDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.IndexerDeclarationNode)
	return v
end

function sling.model.IndexerDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IndexerDeclarationNode'
	self['_isType.sling.model.IndexerDeclarationNode'] = true
	self.type = nil
	self.getter = nil
	self.setter = nil
	self.parameters = nil
	self.description = nil
end

function sling.model.IndexerDeclarationNode:_construct0()
	sling.model.IndexerDeclarationNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.IndexerDeclarationNode:forParameters(params)
	local v = _g.sling.model.IndexerDeclarationNode._construct0(_g.sling.model.IndexerDeclarationNode._create())
	do v:setParameters(params, false) end
	do return v end
end

function sling.model.IndexerDeclarationNode:setSetterAsBlock(block, varName)
	if not (block ~= nil and varName ~= nil) then
		do return end
	end
	do
		local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do v:setBody(block, false) end
		do
			local tt = nil
			if self.type ~= nil then
				tt = _g.sling.common.DataTypeNode:duplicate(self.type)
			else
				tt = _g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create())
			end
			do v:addToParameters(_g.sling.model.VariableDeclarationNode:instance(tt, varName, nil)) end
			do self:setSetter(v, false) end
		end
	end
end

function sling.model.IndexerDeclarationNode:setGetterAsBlock(block)
	if not (block ~= nil) then
		do return end
	end
	do
		local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
		do v:setBody(block, false) end
		do
			local tt = nil
			if self.type ~= nil then
				tt = _g.sling.common.DataTypeNode:duplicate(self.type)
			else
				tt = _g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create())
			end
			do v:setReturnType(tt, false) end
			do self:setGetter(v, false) end
		end
	end
end

function sling.model.IndexerDeclarationNode:getNodeTypeName()
	do return "IndexerDeclarationNode" end
end

function sling.model.IndexerDeclarationNode:createNew()
	do return _g.sling.model.IndexerDeclarationNode._construct0(_g.sling.model.IndexerDeclarationNode._create()) end
end

function sling.model.IndexerDeclarationNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IndexerDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.getter ~= nil then
			do n.getter:destroy() end
			n.getter = nil
		end
		if self.getter ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.getter), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.getter = pcp
			do n.getter:setParent(n) end
		end
		if n.setter ~= nil then
			do n.setter:destroy() end
			n.setter = nil
		end
		if self.setter ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.setter), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.setter = pcp
			do n.setter:setParent(n) end
		end
		n.description = self.description
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.IndexerDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.getter then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.getter:destroy() end
		end
		self.getter = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.getter ~= nil then
			do self.getter:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.setter then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.setter:destroy() end
		end
		self.setter = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.setter ~= nil then
			do self.setter:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IndexerDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.getter ~= nil then
		if self.getter:accept(visitor) == false then
			do return false end
		end
	end
	if self.setter ~= nil then
		if self.setter:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.IndexerDeclarationNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.getter ~= nil then
		do self.getter:destroy() end
		self.getter = nil
	end
	if self.setter ~= nil then
		do self.setter:destroy() end
		self.setter = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.IndexerDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.IndexerDeclarationNode:getType()
	do return self.type end
end

function sling.model.IndexerDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.IndexerDeclarationNode:setGetter(v, doExport)
	if self.getter ~= nil and doExport == false then
		do self.getter:destroy() end
	end
	self.getter = v
	if self.getter ~= nil then
		do self.getter:setParent(self) end
	end
end

function sling.model.IndexerDeclarationNode:getGetter()
	do return self.getter end
end

function sling.model.IndexerDeclarationNode:exportGetter()
	local v = self.getter
	self.getter = nil
	do return v end
end

function sling.model.IndexerDeclarationNode:setSetter(v, doExport)
	if self.setter ~= nil and doExport == false then
		do self.setter:destroy() end
	end
	self.setter = v
	if self.setter ~= nil then
		do self.setter:setParent(self) end
	end
end

function sling.model.IndexerDeclarationNode:getSetter()
	do return self.setter end
end

function sling.model.IndexerDeclarationNode:exportSetter()
	local v = self.setter
	self.setter = nil
	do return v end
end

function sling.model.IndexerDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.IndexerDeclarationNode:getDescription()
	do return self.description end
end

function sling.model.IndexerDeclarationNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.IndexerDeclarationNode:getParameters()
	do return self.parameters end
end

function sling.model.IndexerDeclarationNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.IndexerDeclarationNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.IndexerDeclarationNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

sling.model.CaseGreaterThanBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseGreaterThanBlockNode.__index = sling.model.CaseGreaterThanBlockNode
_vm:set_metatable(sling.model.CaseGreaterThanBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseGreaterThanBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseGreaterThanBlockNode)
	return v
end

function sling.model.CaseGreaterThanBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseGreaterThanBlockNode'
	self['_isType.sling.model.CaseGreaterThanBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseGreaterThanBlockNode:_construct0()
	sling.model.CaseGreaterThanBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseGreaterThanBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseGreaterThanBlockNode._construct0(_g.sling.model.CaseGreaterThanBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseGreaterThanBlockNode:getNodeTypeName()
	do return "CaseGreaterThanBlockNode" end
end

function sling.model.CaseGreaterThanBlockNode:createNew()
	do return _g.sling.model.CaseGreaterThanBlockNode._construct0(_g.sling.model.CaseGreaterThanBlockNode._create()) end
end

function sling.model.CaseGreaterThanBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseGreaterThanBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseGreaterThanBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseGreaterThanBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseGreaterThanBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseGreaterThanBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseGreaterThanBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseGreaterThanBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.FloorDivisionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.FloorDivisionExpressionNode.__index = sling.model.FloorDivisionExpressionNode
_vm:set_metatable(sling.model.FloorDivisionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.FloorDivisionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FloorDivisionExpressionNode)
	return v
end

function sling.model.FloorDivisionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloorDivisionExpressionNode'
	self['_isType.sling.model.FloorDivisionExpressionNode'] = true
end

function sling.model.FloorDivisionExpressionNode:instance(left, right)
	local v = _g.sling.model.FloorDivisionExpressionNode._construct0(_g.sling.model.FloorDivisionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.FloorDivisionExpressionNode:_construct0()
	sling.model.FloorDivisionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()), false) end
	return self
end

function sling.model.FloorDivisionExpressionNode:getNodeTypeName()
	do return "FloorDivisionExpressionNode" end
end

function sling.model.FloorDivisionExpressionNode:createNew()
	do return _g.sling.model.FloorDivisionExpressionNode._construct0(_g.sling.model.FloorDivisionExpressionNode._create()) end
end

function sling.model.FloorDivisionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloorDivisionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FloorDivisionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloorDivisionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloorDivisionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.StringConcatenationAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.StringConcatenationAssignmentExpressionNode.__index = sling.model.StringConcatenationAssignmentExpressionNode
_vm:set_metatable(sling.model.StringConcatenationAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.StringConcatenationAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringConcatenationAssignmentExpressionNode)
	return v
end

function sling.model.StringConcatenationAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringConcatenationAssignmentExpressionNode'
	self['_isType.sling.model.StringConcatenationAssignmentExpressionNode'] = true
end

function sling.model.StringConcatenationAssignmentExpressionNode:_construct0()
	sling.model.StringConcatenationAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.StringConcatenationAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.StringConcatenationAssignmentExpressionNode._construct0(_g.sling.model.StringConcatenationAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StringConcatenationAssignmentExpressionNode:getNodeTypeName()
	do return "StringConcatenationAssignmentExpressionNode" end
end

function sling.model.StringConcatenationAssignmentExpressionNode:createNew()
	do return _g.sling.model.StringConcatenationAssignmentExpressionNode._construct0(_g.sling.model.StringConcatenationAssignmentExpressionNode._create()) end
end

function sling.model.StringConcatenationAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringConcatenationAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StringConcatenationAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringConcatenationAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringConcatenationAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.PreIncrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PreIncrementExpressionNode.__index = sling.model.PreIncrementExpressionNode
_vm:set_metatable(sling.model.PreIncrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PreIncrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreIncrementExpressionNode)
	return v
end

function sling.model.PreIncrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreIncrementExpressionNode'
	self['_isType.sling.model.PreIncrementExpressionNode'] = true
end

function sling.model.PreIncrementExpressionNode:_construct0()
	sling.model.PreIncrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PreIncrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PreIncrementExpressionNode._construct0(_g.sling.model.PreIncrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PreIncrementExpressionNode:getNodeTypeName()
	do return "PreIncrementExpressionNode" end
end

function sling.model.PreIncrementExpressionNode:createNew()
	do return _g.sling.model.PreIncrementExpressionNode._construct0(_g.sling.model.PreIncrementExpressionNode._create()) end
end

function sling.model.PreIncrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreIncrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PreIncrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreIncrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreIncrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.NullDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.NullDataTypeNode.__index = sling.model.NullDataTypeNode
_vm:set_metatable(sling.model.NullDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.NullDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.NullDataTypeNode)
	return v
end

function sling.model.NullDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NullDataTypeNode'
	self['_isType.sling.model.NullDataTypeNode'] = true
end

function sling.model.NullDataTypeNode:_construct0()
	sling.model.NullDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.NullDataTypeNode:getNodeTypeName()
	do return "NullDataTypeNode" end
end

function sling.model.NullDataTypeNode:createNew()
	do return _g.sling.model.NullDataTypeNode._construct0(_g.sling.model.NullDataTypeNode._create()) end
end

function sling.model.NullDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NullDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NullDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NullDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NullDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.ShiftRightExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ShiftRightExpressionNode.__index = sling.model.ShiftRightExpressionNode
_vm:set_metatable(sling.model.ShiftRightExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ShiftRightExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftRightExpressionNode)
	return v
end

function sling.model.ShiftRightExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftRightExpressionNode'
	self['_isType.sling.model.ShiftRightExpressionNode'] = true
	self.zeroLeftmostBit = false
end

function sling.model.ShiftRightExpressionNode:_construct0()
	sling.model.ShiftRightExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ShiftRightExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftRightExpressionNode._construct0(_g.sling.model.ShiftRightExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftRightExpressionNode:getNodeTypeName()
	do return "ShiftRightExpressionNode" end
end

function sling.model.ShiftRightExpressionNode:createNew()
	do return _g.sling.model.ShiftRightExpressionNode._construct0(_g.sling.model.ShiftRightExpressionNode._create()) end
end

function sling.model.ShiftRightExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftRightExpressionNode')
		if n == nil then
			do return true end
		end
		n.zeroLeftmostBit = self.zeroLeftmostBit
		do return true end
	end
end

function sling.model.ShiftRightExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftRightExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftRightExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

function sling.model.ShiftRightExpressionNode:setZeroLeftmostBit(v)
	self.zeroLeftmostBit = v
end

function sling.model.ShiftRightExpressionNode:getZeroLeftmostBit()
	do return self.zeroLeftmostBit end
end

sling.model.GenericCapableEntityDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.GenericCapableEntityDeclarationNode.__index = sling.model.GenericCapableEntityDeclarationNode
_vm:set_metatable(sling.model.GenericCapableEntityDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.GenericCapableEntityDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.GenericCapableEntityDeclarationNode)
	return v
end

function sling.model.GenericCapableEntityDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GenericCapableEntityDeclarationNode'
	self['_isType.sling.model.GenericCapableEntityDeclarationNode'] = true
	self.genericTypes = nil
end

function sling.model.GenericCapableEntityDeclarationNode:_construct0()
	sling.model.GenericCapableEntityDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.GenericCapableEntityDeclarationNode:getNodeTypeName()
	do return "GenericCapableEntityDeclarationNode" end
end

function sling.model.GenericCapableEntityDeclarationNode:createNew()
	do return _g.sling.model.GenericCapableEntityDeclarationNode._construct0(_g.sling.model.GenericCapableEntityDeclarationNode._create()) end
end

function sling.model.GenericCapableEntityDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GenericCapableEntityDeclarationNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.genericTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.genericTypes = nil
			if self.genericTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.genericTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.genericTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.genericTypes == nil then
								n.genericTypes = {}
							end
							do _g.jk.lang.Vector:append(n.genericTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.GenericCapableEntityDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.genericTypes, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GenericCapableEntityDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.genericTypes, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GenericCapableEntityDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
end

function sling.model.GenericCapableEntityDeclarationNode:setGenericTypes(v, doExport)
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.genericTypes = nil
	else
		self.genericTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.genericTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.GenericCapableEntityDeclarationNode:getGenericTypes()
	do return self.genericTypes end
end

function sling.model.GenericCapableEntityDeclarationNode:exportGenericTypes()
	local v = self.genericTypes
	self.genericTypes = nil
	do return v end
end

function sling.model.GenericCapableEntityDeclarationNode:addToGenericTypes(v)
	if v == nil then
		do return end
	end
	if self.genericTypes == nil then
		self.genericTypes = {}
	end
	do _g.jk.lang.Vector:append(self.genericTypes, v) end
	do v:setParent(self) end
end

function sling.model.GenericCapableEntityDeclarationNode:clearGenericTypes()
	if self.genericTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.genericTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.genericTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.genericTypes = nil
end

sling.model.VariableDeclarationExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.VariableDeclarationExpressionNode.__index = sling.model.VariableDeclarationExpressionNode
_vm:set_metatable(sling.model.VariableDeclarationExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.VariableDeclarationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableDeclarationExpressionNode)
	return v
end

function sling.model.VariableDeclarationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableDeclarationExpressionNode'
	self['_isType.sling.model.VariableDeclarationExpressionNode'] = true
	self.declaration = nil
end

function sling.model.VariableDeclarationExpressionNode:_construct0()
	sling.model.VariableDeclarationExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.VariableDeclarationExpressionNode:getNodeTypeName()
	do return "VariableDeclarationExpressionNode" end
end

function sling.model.VariableDeclarationExpressionNode:createNew()
	do return _g.sling.model.VariableDeclarationExpressionNode._construct0(_g.sling.model.VariableDeclarationExpressionNode._create()) end
end

function sling.model.VariableDeclarationExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableDeclarationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.VariableDeclarationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableDeclarationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.VariableDeclarationExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
end

function sling.model.VariableDeclarationExpressionNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.VariableDeclarationExpressionNode:getDeclaration()
	do return self.declaration end
end

function sling.model.VariableDeclarationExpressionNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

sling.model.DecimalDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.DecimalDataTypeNode.__index = sling.model.DecimalDataTypeNode
_vm:set_metatable(sling.model.DecimalDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DecimalDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DecimalDataTypeNode)
	return v
end

function sling.model.DecimalDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DecimalDataTypeNode'
	self['_isType.sling.model.DecimalDataTypeNode'] = true
end

function sling.model.DecimalDataTypeNode:_construct0()
	sling.model.DecimalDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DecimalDataTypeNode:getNodeTypeName()
	do return "DecimalDataTypeNode" end
end

function sling.model.DecimalDataTypeNode:createNew()
	do return _g.sling.model.DecimalDataTypeNode._construct0(_g.sling.model.DecimalDataTypeNode._create()) end
end

function sling.model.DecimalDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DecimalDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DecimalDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DecimalDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DecimalDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.ExternalImplementationReferenceNode = _g.sling.common.NodeObject._create()
sling.model.ExternalImplementationReferenceNode.__index = sling.model.ExternalImplementationReferenceNode
_vm:set_metatable(sling.model.ExternalImplementationReferenceNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ExternalImplementationReferenceNode._create()
	local v = _vm:set_metatable({}, sling.model.ExternalImplementationReferenceNode)
	return v
end

function sling.model.ExternalImplementationReferenceNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExternalImplementationReferenceNode'
	self['_isType.sling.model.ExternalImplementationReferenceNode'] = true
	self.data = nil
end

function sling.model.ExternalImplementationReferenceNode:_construct0()
	sling.model.ExternalImplementationReferenceNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ExternalImplementationReferenceNode:getNodeTypeName()
	do return "ExternalImplementationReferenceNode" end
end

function sling.model.ExternalImplementationReferenceNode:createNew()
	do return _g.sling.model.ExternalImplementationReferenceNode._construct0(_g.sling.model.ExternalImplementationReferenceNode._create()) end
end

function sling.model.ExternalImplementationReferenceNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExternalImplementationReferenceNode')
		if n == nil then
			do return true end
		end
		n.data = self.data
		do return true end
	end
end

function sling.model.ExternalImplementationReferenceNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExternalImplementationReferenceNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExternalImplementationReferenceNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ExternalImplementationReferenceNode:setData(v)
	self.data = v
end

function sling.model.ExternalImplementationReferenceNode:getData()
	do return self.data end
end

sling.model.WhileStatementNode = _g.sling.common.NodeObject._create()
sling.model.WhileStatementNode.__index = sling.model.WhileStatementNode
_vm:set_metatable(sling.model.WhileStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.WhileStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.WhileStatementNode)
	return v
end

function sling.model.WhileStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.WhileStatementNode'
	self['_isType.sling.model.WhileStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.condition = nil
	self.block = nil
	self.elseBlock = nil
end

function sling.model.WhileStatementNode:_construct0()
	sling.model.WhileStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.WhileStatementNode:instance(condition, block, elseBlock)
	local v = _g.sling.model.WhileStatementNode._construct0(_g.sling.model.WhileStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setBlock(block, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.WhileStatementNode:forSingleStatement(condition, statement)
	local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	do v:addNode(statement) end
	do return _g.sling.model.WhileStatementNode:instance(condition, v, nil) end
end

function sling.model.WhileStatementNode:getNodeTypeName()
	do return "WhileStatementNode" end
end

function sling.model.WhileStatementNode:createNew()
	do return _g.sling.model.WhileStatementNode._construct0(_g.sling.model.WhileStatementNode._create()) end
end

function sling.model.WhileStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.WhileStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		do return true end
	end
end

function sling.model.WhileStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.WhileStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.WhileStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
end

function sling.model.WhileStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.WhileStatementNode:getCondition()
	do return self.condition end
end

function sling.model.WhileStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.WhileStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.WhileStatementNode:getBlock()
	do return self.block end
end

function sling.model.WhileStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.WhileStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.WhileStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.WhileStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

sling.model.KeyValueNode = _g.sling.common.NodeObject._create()
sling.model.KeyValueNode.__index = sling.model.KeyValueNode
_vm:set_metatable(sling.model.KeyValueNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.KeyValueNode._create()
	local v = _vm:set_metatable({}, sling.model.KeyValueNode)
	return v
end

function sling.model.KeyValueNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.KeyValueNode'
	self['_isType.sling.model.KeyValueNode'] = true
	self.key = nil
	self.value = nil
	self.comment = nil
end

function sling.model.KeyValueNode:_construct0()
	sling.model.KeyValueNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.KeyValueNode:forValues(key, value)
	local v = _g.sling.model.KeyValueNode._construct0(_g.sling.model.KeyValueNode._create())
	do v:setKey(key, false) end
	do v:setValue(value, false) end
	do return v end
end

function sling.model.KeyValueNode:getNodeTypeName()
	do return "KeyValueNode" end
end

function sling.model.KeyValueNode:createNew()
	do return _g.sling.model.KeyValueNode._construct0(_g.sling.model.KeyValueNode._create()) end
end

function sling.model.KeyValueNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.KeyValueNode')
		if n == nil then
			do return true end
		end
		if n.key ~= nil then
			do n.key:destroy() end
			n.key = nil
		end
		if self.key ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.key), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.key = pcp
			do n.key:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.comment = self.comment
		do return true end
	end
end

function sling.model.KeyValueNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.key then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.key:destroy() end
		end
		self.key = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.key ~= nil then
			do self.key:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.KeyValueNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.key ~= nil then
		if self.key:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.KeyValueNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.key ~= nil then
		do self.key:destroy() end
		self.key = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.KeyValueNode:setKey(v, doExport)
	if self.key ~= nil and doExport == false then
		do self.key:destroy() end
	end
	self.key = v
	if self.key ~= nil then
		do self.key:setParent(self) end
	end
end

function sling.model.KeyValueNode:getKey()
	do return self.key end
end

function sling.model.KeyValueNode:exportKey()
	local v = self.key
	self.key = nil
	do return v end
end

function sling.model.KeyValueNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.KeyValueNode:getValue()
	do return self.value end
end

function sling.model.KeyValueNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.KeyValueNode:setComment(v)
	self.comment = v
end

function sling.model.KeyValueNode:getComment()
	do return self.comment end
end

sling.model.TypeAliasDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.TypeAliasDeclarationNode.__index = sling.model.TypeAliasDeclarationNode
_vm:set_metatable(sling.model.TypeAliasDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.TypeAliasDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeAliasDeclarationNode)
	return v
end

function sling.model.TypeAliasDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeAliasDeclarationNode'
	self['_isType.sling.model.TypeAliasDeclarationNode'] = true
	self.type = nil
end

function sling.model.TypeAliasDeclarationNode:_construct0()
	sling.model.TypeAliasDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.TypeAliasDeclarationNode:instance(name, type)
	local v = _g.sling.model.TypeAliasDeclarationNode._construct0(_g.sling.model.TypeAliasDeclarationNode._create())
	do v:setName(name) end
	do v:setType(type, false) end
	do return v end
end

function sling.model.TypeAliasDeclarationNode:getNodeTypeName()
	do return "TypeAliasDeclarationNode" end
end

function sling.model.TypeAliasDeclarationNode:createNew()
	do return _g.sling.model.TypeAliasDeclarationNode._construct0(_g.sling.model.TypeAliasDeclarationNode._create()) end
end

function sling.model.TypeAliasDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeAliasDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TypeAliasDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeAliasDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TypeAliasDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.TypeAliasDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.TypeAliasDeclarationNode:getType()
	do return self.type end
end

function sling.model.TypeAliasDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.AdditionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.AdditionAssignmentExpressionNode.__index = sling.model.AdditionAssignmentExpressionNode
_vm:set_metatable(sling.model.AdditionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.AdditionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AdditionAssignmentExpressionNode)
	return v
end

function sling.model.AdditionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AdditionAssignmentExpressionNode'
	self['_isType.sling.model.AdditionAssignmentExpressionNode'] = true
end

function sling.model.AdditionAssignmentExpressionNode:_construct0()
	sling.model.AdditionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.AdditionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.AdditionAssignmentExpressionNode._construct0(_g.sling.model.AdditionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.AdditionAssignmentExpressionNode:getNodeTypeName()
	do return "AdditionAssignmentExpressionNode" end
end

function sling.model.AdditionAssignmentExpressionNode:createNew()
	do return _g.sling.model.AdditionAssignmentExpressionNode._construct0(_g.sling.model.AdditionAssignmentExpressionNode._create()) end
end

function sling.model.AdditionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AdditionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AdditionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AdditionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AdditionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.MultiplicationAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.MultiplicationAssignmentExpressionNode.__index = sling.model.MultiplicationAssignmentExpressionNode
_vm:set_metatable(sling.model.MultiplicationAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.MultiplicationAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MultiplicationAssignmentExpressionNode)
	return v
end

function sling.model.MultiplicationAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultiplicationAssignmentExpressionNode'
	self['_isType.sling.model.MultiplicationAssignmentExpressionNode'] = true
end

function sling.model.MultiplicationAssignmentExpressionNode:_construct0()
	sling.model.MultiplicationAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.MultiplicationAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.MultiplicationAssignmentExpressionNode._construct0(_g.sling.model.MultiplicationAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.MultiplicationAssignmentExpressionNode:getNodeTypeName()
	do return "MultiplicationAssignmentExpressionNode" end
end

function sling.model.MultiplicationAssignmentExpressionNode:createNew()
	do return _g.sling.model.MultiplicationAssignmentExpressionNode._construct0(_g.sling.model.MultiplicationAssignmentExpressionNode._create()) end
end

function sling.model.MultiplicationAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultiplicationAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MultiplicationAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultiplicationAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultiplicationAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.DynamicDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.DynamicDataTypeNode.__index = sling.model.DynamicDataTypeNode
_vm:set_metatable(sling.model.DynamicDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.DynamicDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicDataTypeNode)
	return v
end

function sling.model.DynamicDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicDataTypeNode'
	self['_isType.sling.model.DynamicDataTypeNode'] = true
end

function sling.model.DynamicDataTypeNode:_construct0()
	sling.model.DynamicDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.DynamicDataTypeNode:getNodeTypeName()
	do return "DynamicDataTypeNode" end
end

function sling.model.DynamicDataTypeNode:createNew()
	do return _g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()) end
end

function sling.model.DynamicDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.StatementNode = _g.sling.common.NodeObject._create()
sling.model.StatementNode.__index = sling.model.StatementNode
_vm:set_metatable(sling.model.StatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.StatementNode._create()
	local v = _vm:set_metatable({}, sling.model.StatementNode)
	return v
end

function sling.model.StatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StatementNode'
	self['_isType.sling.model.StatementNode'] = true
	self['_isType.sling.model.NodeWithModifiers'] = true
	self.modifiers = nil
end

function sling.model.StatementNode:_construct0()
	sling.model.StatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.StatementNode:getNodeTypeName()
	do return "StatementNode" end
end

function sling.model.StatementNode:createNew()
	do return _g.sling.model.StatementNode._construct0(_g.sling.model.StatementNode._create()) end
end

function sling.model.StatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StatementNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.modifiers
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.modifiers = nil
			if self.modifiers ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.modifiers)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.modifiers[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.modifiers == nil then
								n.modifiers = {}
							end
							do _g.jk.lang.Vector:append(n.modifiers, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.StatementNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.modifiers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.modifiers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

function sling.model.StatementNode:setModifiers(v, doExport)
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.modifiers = nil
	else
		self.modifiers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.modifiers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.StatementNode:getModifiers()
	do return self.modifiers end
end

function sling.model.StatementNode:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do return v end
end

function sling.model.StatementNode:addToModifiers(v)
	if v == nil then
		do return end
	end
	if self.modifiers == nil then
		self.modifiers = {}
	end
	do _g.jk.lang.Vector:append(self.modifiers, v) end
	do v:setParent(self) end
end

function sling.model.StatementNode:clearModifiers()
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

sling.model.MultipleVariableDeclarationNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.MultipleVariableDeclarationNode.__index = sling.model.MultipleVariableDeclarationNode
_vm:set_metatable(sling.model.MultipleVariableDeclarationNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.MultipleVariableDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.MultipleVariableDeclarationNode)
	return v
end

function sling.model.MultipleVariableDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultipleVariableDeclarationNode'
	self['_isType.sling.model.MultipleVariableDeclarationNode'] = true
	self.type = nil
	self.variables = nil
	self.initializer = nil
end

function sling.model.MultipleVariableDeclarationNode:_construct0()
	sling.model.MultipleVariableDeclarationNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.MultipleVariableDeclarationNode:forType(type)
	local v = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:forArrayOfVariables(type, variables)
	local v = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
	do v:setType(type, false) end
	if variables ~= nil then
		local n = 0
		local m = #variables
		do
			n = 0
			while n < m do
				local variable = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(variables[n + 1])
				if variable ~= nil then
					do v:addToVariables(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), variable, nil)) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:forVectorOfVariables(type, variables)
	local v = _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create())
	do v:setType(type, false) end
	if variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(variables)
		do
			n = 0
			while n < m do
				local variable = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(variables[n + 1])
				if variable ~= nil then
					do v:addToVariables(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.AutomaticDataTypeNode._construct0(_g.sling.model.AutomaticDataTypeNode._create()), variable, nil)) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:getNodeTypeName()
	do return "MultipleVariableDeclarationNode" end
end

function sling.model.MultipleVariableDeclarationNode:createNew()
	do return _g.sling.model.MultipleVariableDeclarationNode._construct0(_g.sling.model.MultipleVariableDeclarationNode._create()) end
end

function sling.model.MultipleVariableDeclarationNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultipleVariableDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		do
			local array = n.variables
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.variables = nil
			if self.variables ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.variables)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.variables[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.variables == nil then
								n.variables = {}
							end
							do _g.jk.lang.Vector:append(n.variables, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MultipleVariableDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.variables, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultipleVariableDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.variables, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultipleVariableDeclarationNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
	if self.variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.variables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.variables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.variables = nil
end

function sling.model.MultipleVariableDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.MultipleVariableDeclarationNode:getType()
	do return self.type end
end

function sling.model.MultipleVariableDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.MultipleVariableDeclarationNode:getInitializer()
	do return self.initializer end
end

function sling.model.MultipleVariableDeclarationNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:setVariables(v, doExport)
	if self.variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.variables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.variables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.variables = nil
	else
		self.variables = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.variables, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MultipleVariableDeclarationNode:getVariables()
	do return self.variables end
end

function sling.model.MultipleVariableDeclarationNode:exportVariables()
	local v = self.variables
	self.variables = nil
	do return v end
end

function sling.model.MultipleVariableDeclarationNode:addToVariables(v)
	if v == nil then
		do return end
	end
	if self.variables == nil then
		self.variables = {}
	end
	do _g.jk.lang.Vector:append(self.variables, v) end
	do v:setParent(self) end
end

function sling.model.MultipleVariableDeclarationNode:clearVariables()
	if self.variables ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.variables)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.variables[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.variables = nil
end

sling.model.InitializerFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.InitializerFunctionDeclarationNode.__index = sling.model.InitializerFunctionDeclarationNode
_vm:set_metatable(sling.model.InitializerFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.InitializerFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.InitializerFunctionDeclarationNode)
	return v
end

function sling.model.InitializerFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.InitializerFunctionDeclarationNode'
	self['_isType.sling.model.InitializerFunctionDeclarationNode'] = true
end

function sling.model.InitializerFunctionDeclarationNode:_construct0()
	sling.model.InitializerFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.InitializerFunctionDeclarationNode:getNodeTypeName()
	do return "InitializerFunctionDeclarationNode" end
end

function sling.model.InitializerFunctionDeclarationNode:createNew()
	do return _g.sling.model.InitializerFunctionDeclarationNode._construct0(_g.sling.model.InitializerFunctionDeclarationNode._create()) end
end

function sling.model.InitializerFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.InitializerFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.InitializerFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.InitializerFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.InitializerFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.FloorDivisionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.FloorDivisionAssignmentExpressionNode.__index = sling.model.FloorDivisionAssignmentExpressionNode
_vm:set_metatable(sling.model.FloorDivisionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.FloorDivisionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FloorDivisionAssignmentExpressionNode)
	return v
end

function sling.model.FloorDivisionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloorDivisionAssignmentExpressionNode'
	self['_isType.sling.model.FloorDivisionAssignmentExpressionNode'] = true
end

function sling.model.FloorDivisionAssignmentExpressionNode:_construct0()
	sling.model.FloorDivisionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.FloorDivisionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.FloorDivisionAssignmentExpressionNode._construct0(_g.sling.model.FloorDivisionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.FloorDivisionAssignmentExpressionNode:getNodeTypeName()
	do return "FloorDivisionAssignmentExpressionNode" end
end

function sling.model.FloorDivisionAssignmentExpressionNode:createNew()
	do return _g.sling.model.FloorDivisionAssignmentExpressionNode._construct0(_g.sling.model.FloorDivisionAssignmentExpressionNode._create()) end
end

function sling.model.FloorDivisionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloorDivisionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FloorDivisionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloorDivisionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloorDivisionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.MemberAccessExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.MemberAccessExpressionNode.__index = sling.model.MemberAccessExpressionNode
_vm:set_metatable(sling.model.MemberAccessExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

sling.model.MemberAccessExpressionNode.TYPE_AUTO = 0
sling.model.MemberAccessExpressionNode.TYPE_INSTANCE = 1
sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_VARIABLE = 2
sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_FUNCTION = 3
sling.model.MemberAccessExpressionNode.TYPE_STATIC = 4
sling.model.MemberAccessExpressionNode.TYPE_STATIC_VARIABLE = 5
sling.model.MemberAccessExpressionNode.TYPE_STATIC_FUNCTION = 6
sling.model.MemberAccessExpressionNode.TYPE_POINTER = 7
sling.model.MemberAccessExpressionNode.TYPE_PROPERTY = 8
sling.model.MemberAccessExpressionNode.TYPE_NAMESPACE_ALIAS = 9

function sling.model.MemberAccessExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MemberAccessExpressionNode)
	return v
end

function sling.model.MemberAccessExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MemberAccessExpressionNode'
	self['_isType.sling.model.MemberAccessExpressionNode'] = true
	self.parentExpression = nil
	self.childExpression = nil
	self.accessType = 0
end

function sling.model.MemberAccessExpressionNode:_construct0()
	sling.model.MemberAccessExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.MemberAccessExpressionNode:forExpressions(expressions)
	local v = nil
	if expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(expressions)
		do
			n = 0
			while n < m do
				local expression = expressions[n + 1]
				if expression ~= nil then
					v = _g.sling.model.MemberAccessExpressionNode:append(expression, v)
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.MemberAccessExpressionNode:forNodes(parent, child)
	local v = _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create())
	do v:setParentExpression(parent, false) end
	do v:setChildExpression(child, false) end
	do return v end
end

function sling.model.MemberAccessExpressionNode:forSymbolNames(parent, child)
	local v = _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create())
	do v:setParentExpression(_g.sling.model.SymbolExpressionNode:forName(parent), false) end
	do v:setChildExpression(_g.sling.model.SymbolExpressionNode:forName(child), false) end
	do return v end
end

function sling.model.MemberAccessExpressionNode:forSymbols(names)
	if not (names ~= nil) then
		do return nil end
	end
	do
		local v = nil
		if names ~= nil then
			local n = 0
			local m = #names
			do
				n = 0
				while n < m do
					local str = (function(o)
						if (_vm:get_variable_type(o) == 'string') then
							do return o end
						end
						do return nil end
					end)(names[n + 1])
					if str ~= nil then
						v = _g.sling.model.MemberAccessExpressionNode:append(_g.sling.model.SymbolExpressionNode:forName(str), v)
					end
					do n = n + 1 end
				end
			end
		end
		do return v end
	end
end

function sling.model.MemberAccessExpressionNode:getPreviousNode(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return nil end
		end
		if pp:getChildExpression() == node then
			do return pp:getParentExpression() end
		end
		do
			local pe = pp:getParentExpression()
			if pe ~= node then
				do return nil end
			end
			do
				local pp2 = _vm:to_table_with_key(pp:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
				if not (pp2 ~= nil) then
					do return nil end
				end
				if pp2:getChildExpression() ~= pp then
					do return nil end
				end
				do return pp2:getParentExpression() end
			end
		end
	end
end

function sling.model.MemberAccessExpressionNode:isChildOf(xpr)
	if not (xpr ~= nil) then
		do return false end
	end
	do
		local pp = _vm:to_table_with_key(xpr:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return false end
		end
		if pp:getChildExpression() ~= xpr then
			do return false end
		end
		do return true end
	end
end

function sling.model.MemberAccessExpressionNode:append(toappend, original)
	if not (toappend ~= nil) then
		do return original end
	end
	if not (original ~= nil) then
		do return toappend end
	end
	do
		local ip = _vm:to_table_with_key(original, '_isType.sling.model.MemberAccessExpressionNode')
		if not (ip ~= nil) then
			do return _g.sling.model.MemberAccessExpressionNode:forNodes(original, toappend) end
		end
		while true do
			local nn = ip:getChildExpression()
			if not (nn ~= nil) then
				do ip:setChildExpression(toappend, false) end
				do break end
			end
			if (_vm:to_table_with_key(nn, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
				ip = nn
				goto _continue1
			end
			do ip:exportChildExpression() end
			do ip:setChildExpression(_g.sling.model.MemberAccessExpressionNode:forNodes(nn, toappend), false) end
			do break end
			::_continue1::
		end
		do return original end
	end
end

function sling.model.MemberAccessExpressionNode:isChild(node)
	if not (node ~= nil) then
		do return false end
	end
	do
		local pp = _vm:to_table_with_key(node:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
		if not (pp ~= nil) then
			do return false end
		end
		if pp:getParentExpression() == node and (_vm:to_table_with_key(pp:getParent(), '_isType.sling.model.MemberAccessExpressionNode') ~= nil) == false then
			do return false end
		end
		do return true end
	end
end

function sling.model.MemberAccessExpressionNode:findFromChild(node)
	local v = node
	if not (v ~= nil) then
		do return nil end
	end
	while true do
		local p = _g.sling.model.MemberAccessExpressionNode:getPreviousNode(v)
		if not (p ~= nil) then
			do break end
		end
		v = p
	end
	do return _vm:to_table_with_key(v:getParent(), '_isType.sling.model.MemberAccessExpressionNode') end
end

function sling.model.MemberAccessExpressionNode:getLastNode()
	local v = self.childExpression
	while true do
		if not (v ~= nil) then
			do break end
		elseif (_vm:to_table_with_key(v, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			v = v.childExpression
		else
			do break end
		end
	end
	do return v end
end

function sling.model.MemberAccessExpressionNode:removeLastNode()
	local p = self
	while true do
		local n = _vm:to_table_with_key(p.childExpression, '_isType.sling.model.MemberAccessExpressionNode')
		if n ~= nil then
			p = n
			goto _continue2
		end
		if p == self then
			do return p:exportParentExpression() end
		end
		do
			local pp = _vm:to_table_with_key(p:getParent(), '_isType.sling.model.MemberAccessExpressionNode')
			if not (pp ~= nil) then
				do return nil end
			end
			do
				local oc = p:exportParentExpression()
				if not (oc ~= nil) then
					do return nil end
				end
				do pp:setChildExpression(oc, false) end
				do return self end
			end
		end
		::_continue2::
	end
	do return nil end
end

function sling.model.MemberAccessExpressionNode:getAllExpressionsTo(results)
	if self.parentExpression ~= nil then
		if (_vm:to_table_with_key(self.parentExpression, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			do self.parentExpression:getAllExpressionsTo(results) end
		else
			do _g.jk.lang.Vector:append(results, self.parentExpression) end
		end
	end
	if self.childExpression ~= nil then
		if (_vm:to_table_with_key(self.childExpression, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			do self.childExpression:getAllExpressionsTo(results) end
		else
			do _g.jk.lang.Vector:append(results, self.childExpression) end
		end
	end
end

function sling.model.MemberAccessExpressionNode:getAllExpressions()
	local v = {}
	do self:getAllExpressionsTo(v) end
	do return v end
end

function sling.model.MemberAccessExpressionNode:getNodeTypeName()
	do return "MemberAccessExpressionNode" end
end

function sling.model.MemberAccessExpressionNode:createNew()
	do return _g.sling.model.MemberAccessExpressionNode._construct0(_g.sling.model.MemberAccessExpressionNode._create()) end
end

function sling.model.MemberAccessExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MemberAccessExpressionNode')
		if n == nil then
			do return true end
		end
		if n.parentExpression ~= nil then
			do n.parentExpression:destroy() end
			n.parentExpression = nil
		end
		if self.parentExpression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.parentExpression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.parentExpression = pcp
			do n.parentExpression:setParent(n) end
		end
		if n.childExpression ~= nil then
			do n.childExpression:destroy() end
			n.childExpression = nil
		end
		if self.childExpression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.childExpression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.childExpression = pcp
			do n.childExpression:setParent(n) end
		end
		n.accessType = self.accessType
		do return true end
	end
end

function sling.model.MemberAccessExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.parentExpression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.parentExpression:destroy() end
		end
		self.parentExpression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.parentExpression ~= nil then
			do self.parentExpression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.childExpression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.childExpression:destroy() end
		end
		self.childExpression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.childExpression ~= nil then
			do self.childExpression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MemberAccessExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.parentExpression ~= nil then
		if self.parentExpression:accept(visitor) == false then
			do return false end
		end
	end
	if self.childExpression ~= nil then
		if self.childExpression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.MemberAccessExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.parentExpression ~= nil then
		do self.parentExpression:destroy() end
		self.parentExpression = nil
	end
	if self.childExpression ~= nil then
		do self.childExpression:destroy() end
		self.childExpression = nil
	end
end

function sling.model.MemberAccessExpressionNode:setParentExpression(v, doExport)
	if self.parentExpression ~= nil and doExport == false then
		do self.parentExpression:destroy() end
	end
	self.parentExpression = v
	if self.parentExpression ~= nil then
		do self.parentExpression:setParent(self) end
	end
end

function sling.model.MemberAccessExpressionNode:getParentExpression()
	do return self.parentExpression end
end

function sling.model.MemberAccessExpressionNode:exportParentExpression()
	local v = self.parentExpression
	self.parentExpression = nil
	do return v end
end

function sling.model.MemberAccessExpressionNode:setChildExpression(v, doExport)
	if self.childExpression ~= nil and doExport == false then
		do self.childExpression:destroy() end
	end
	self.childExpression = v
	if self.childExpression ~= nil then
		do self.childExpression:setParent(self) end
	end
end

function sling.model.MemberAccessExpressionNode:getChildExpression()
	do return self.childExpression end
end

function sling.model.MemberAccessExpressionNode:exportChildExpression()
	local v = self.childExpression
	self.childExpression = nil
	do return v end
end

function sling.model.MemberAccessExpressionNode:setAccessType(v)
	self.accessType = v
end

function sling.model.MemberAccessExpressionNode:getAccessType()
	do return self.accessType end
end

sling.model.Modifier = {}
sling.model.Modifier.__index = sling.model.Modifier
_vm:set_metatable(sling.model.Modifier, {})

sling.model.Modifier.PUBLIC = "public"
sling.model.Modifier.PRIVATE = "private"
sling.model.Modifier.PROTECTED = "protected"
sling.model.Modifier.NAMESPACEPRIVATE = "namespaceprivate"
sling.model.Modifier.STATIC = "static"
sling.model.Modifier.ABSTRACT = "abstract"
sling.model.Modifier.EXTERNAL = "external"
sling.model.Modifier.IMPLEMENT = "implement"
sling.model.Modifier.OVERRIDE = "override"
sling.model.Modifier.VIRTUAL = "virtual"
sling.model.Modifier.FUNDAMENTAL = "fundamental"
sling.model.Modifier.PARTIAL = "partial"
sling.model.Modifier.CONSTANT = "constant"
sling.model.Modifier.NEW = "new"
sling.model.Modifier.STUB = "stub"
sling.model.Modifier.WEAK = "weak"
sling.model.Modifier.FINAL = "final"
sling.model.Modifier.GLOBAL = "global"
sling.model.Modifier.HEADER = "header"
sling.model.Modifier.PROPERTY = "property"
sling.model.Modifier.READONLY = "readonly"
sling.model.Modifier.WRITEONLY = "writeonly"
sling.model.Modifier.READWRITE = "readwrite"
sling.model.Modifier.VOLATILE = "volatile"
sling.model.Modifier.THROWABLE = "throwable"
sling.model.Modifier.TRANSIENT = "transient"
sling.model.Modifier.DEPRECATED = "deprecated"
sling.model.Modifier.ASYNCHRONOUS = "asynchronous"
sling.model.Modifier.SYNCHRONIZED = "synchronized"
sling.model.Modifier.IMPLEMENTATION = "implementation"
sling.model.Modifier.REFERENCE = "reference"

function sling.model.Modifier._create()
	local v = _vm:set_metatable({}, sling.model.Modifier)
	return v
end

function sling.model.Modifier:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.Modifier'
	self['_isType.sling.model.Modifier'] = true
end

function sling.model.Modifier:_construct0()
	sling.model.Modifier._init(self)
	return self
end

function sling.model.Modifier:isVisibilityModifier(mod)
	if not (mod ~= nil) then
		do return false end
	end
	if mod == _g.sling.model.Modifier.PUBLIC then
		do return true end
	end
	if mod == _g.sling.model.Modifier.PRIVATE then
		do return true end
	end
	if mod == _g.sling.model.Modifier.NAMESPACEPRIVATE then
		do return true end
	end
	if mod == _g.sling.model.Modifier.PROTECTED then
		do return true end
	end
	do return false end
end

sling.model.DynamicOrExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.DynamicOrExpressionNode.__index = sling.model.DynamicOrExpressionNode
_vm:set_metatable(sling.model.DynamicOrExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.DynamicOrExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicOrExpressionNode)
	return v
end

function sling.model.DynamicOrExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicOrExpressionNode'
	self['_isType.sling.model.DynamicOrExpressionNode'] = true
end

function sling.model.DynamicOrExpressionNode:_construct0()
	sling.model.DynamicOrExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.DynamicOrExpressionNode:instance(left, right)
	local v = _g.sling.model.DynamicOrExpressionNode._construct0(_g.sling.model.DynamicOrExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DynamicOrExpressionNode:getNodeTypeName()
	do return "DynamicOrExpressionNode" end
end

function sling.model.DynamicOrExpressionNode:createNew()
	do return _g.sling.model.DynamicOrExpressionNode._construct0(_g.sling.model.DynamicOrExpressionNode._create()) end
end

function sling.model.DynamicOrExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicOrExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicOrExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicOrExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicOrExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.ThrowStatementNode = _g.sling.common.NodeObject._create()
sling.model.ThrowStatementNode.__index = sling.model.ThrowStatementNode
_vm:set_metatable(sling.model.ThrowStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ThrowStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ThrowStatementNode)
	return v
end

function sling.model.ThrowStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ThrowStatementNode'
	self['_isType.sling.model.ThrowStatementNode'] = true
	self.expression = nil
end

function sling.model.ThrowStatementNode:_construct0()
	sling.model.ThrowStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ThrowStatementNode:forExpression(expression)
	local v = _g.sling.model.ThrowStatementNode._construct0(_g.sling.model.ThrowStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.ThrowStatementNode:getNodeTypeName()
	do return "ThrowStatementNode" end
end

function sling.model.ThrowStatementNode:createNew()
	do return _g.sling.model.ThrowStatementNode._construct0(_g.sling.model.ThrowStatementNode._create()) end
end

function sling.model.ThrowStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ThrowStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ThrowStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ThrowStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ThrowStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ThrowStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ThrowStatementNode:getExpression()
	do return self.expression end
end

function sling.model.ThrowStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.AdditionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.AdditionExpressionNode.__index = sling.model.AdditionExpressionNode
_vm:set_metatable(sling.model.AdditionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.AdditionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AdditionExpressionNode)
	return v
end

function sling.model.AdditionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AdditionExpressionNode'
	self['_isType.sling.model.AdditionExpressionNode'] = true
end

function sling.model.AdditionExpressionNode:_construct0()
	sling.model.AdditionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.AdditionExpressionNode:instance(left, right)
	local v = _g.sling.model.AdditionExpressionNode._construct0(_g.sling.model.AdditionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.AdditionExpressionNode:getNodeTypeName()
	do return "AdditionExpressionNode" end
end

function sling.model.AdditionExpressionNode:createNew()
	do return _g.sling.model.AdditionExpressionNode._construct0(_g.sling.model.AdditionExpressionNode._create()) end
end

function sling.model.AdditionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AdditionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AdditionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AdditionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AdditionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.LabeledStatementNode = _g.sling.common.NodeObject._create()
sling.model.LabeledStatementNode.__index = sling.model.LabeledStatementNode
_vm:set_metatable(sling.model.LabeledStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.LabeledStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.LabeledStatementNode)
	return v
end

function sling.model.LabeledStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LabeledStatementNode'
	self['_isType.sling.model.LabeledStatementNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.statement = nil
	self.name = nil
end

function sling.model.LabeledStatementNode:_construct0()
	sling.model.LabeledStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.LabeledStatementNode:forLabel(label)
	local v = _g.sling.model.LabeledStatementNode._construct0(_g.sling.model.LabeledStatementNode._create())
	do v:setName(label) end
	do return v end
end

function sling.model.LabeledStatementNode:getNodeName()
	do return self.name end
end

function sling.model.LabeledStatementNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.LabeledStatementNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.LabeledStatementNode:getNodeTypeName()
	do return "LabeledStatementNode" end
end

function sling.model.LabeledStatementNode:createNew()
	do return _g.sling.model.LabeledStatementNode._construct0(_g.sling.model.LabeledStatementNode._create()) end
end

function sling.model.LabeledStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LabeledStatementNode')
		if n == nil then
			do return true end
		end
		if n.statement ~= nil then
			do n.statement:destroy() end
			n.statement = nil
		end
		if self.statement ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.statement), '_isType.sling.common.NodeObject')
			if pcp == nil then
				do return false end
			end
			n.statement = pcp
			do n.statement:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.LabeledStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.statement then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.statement:destroy() end
		end
		self.statement = _vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject')
		if self.statement ~= nil then
			do self.statement:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LabeledStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.statement ~= nil then
		if self.statement:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.LabeledStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.statement ~= nil then
		do self.statement:destroy() end
		self.statement = nil
	end
end

function sling.model.LabeledStatementNode:setStatement(v, doExport)
	if self.statement ~= nil and doExport == false then
		do self.statement:destroy() end
	end
	self.statement = v
	if self.statement ~= nil then
		do self.statement:setParent(self) end
	end
end

function sling.model.LabeledStatementNode:getStatement()
	do return self.statement end
end

function sling.model.LabeledStatementNode:exportStatement()
	local v = self.statement
	self.statement = nil
	do return v end
end

function sling.model.LabeledStatementNode:getName()
	do return self.name end
end

sling.model.ObjectDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ObjectDataTypeNode.__index = sling.model.ObjectDataTypeNode
_vm:set_metatable(sling.model.ObjectDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ObjectDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ObjectDataTypeNode)
	return v
end

function sling.model.ObjectDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ObjectDataTypeNode'
	self['_isType.sling.model.ObjectDataTypeNode'] = true
end

function sling.model.ObjectDataTypeNode:_construct0()
	sling.model.ObjectDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ObjectDataTypeNode:getNodeTypeName()
	do return "ObjectDataTypeNode" end
end

function sling.model.ObjectDataTypeNode:createNew()
	do return _g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()) end
end

function sling.model.ObjectDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ObjectDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ObjectDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ObjectDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ObjectDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.StringLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.StringLiteralExpressionNode.__index = sling.model.StringLiteralExpressionNode
_vm:set_metatable(sling.model.StringLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.StringLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringLiteralExpressionNode)
	return v
end

function sling.model.StringLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringLiteralExpressionNode'
	self['_isType.sling.model.StringLiteralExpressionNode'] = true
	self['_isType.sling.model.NodeWithModifiers'] = true
	self.value = nil
	self.type = nil
	self.isLongString = false
	self.isRawString = false
	self.identifier = nil
	self.modifiers = nil
end

function sling.model.StringLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.StringLiteralExpressionNode._construct0(_g.sling.model.StringLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.StringLiteralExpressionNode:_construct0()
	sling.model.StringLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), false) end
	return self
end

function sling.model.StringLiteralExpressionNode:getNodeTypeName()
	do return "StringLiteralExpressionNode" end
end

function sling.model.StringLiteralExpressionNode:createNew()
	do return _g.sling.model.StringLiteralExpressionNode._construct0(_g.sling.model.StringLiteralExpressionNode._create()) end
end

function sling.model.StringLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.value = self.value
		n.isLongString = self.isLongString
		n.isRawString = self.isRawString
		n.identifier = self.identifier
		do
			local array = n.modifiers
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.modifiers = nil
			if self.modifiers ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.modifiers)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.modifiers[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.modifiers == nil then
								n.modifiers = {}
							end
							do _g.jk.lang.Vector:append(n.modifiers, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.StringLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.modifiers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.modifiers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

function sling.model.StringLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.StringLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.StringLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.StringLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.StringLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.StringLiteralExpressionNode:setIsLongString(v)
	self.isLongString = v
end

function sling.model.StringLiteralExpressionNode:getIsLongString()
	do return self.isLongString end
end

function sling.model.StringLiteralExpressionNode:setIsRawString(v)
	self.isRawString = v
end

function sling.model.StringLiteralExpressionNode:getIsRawString()
	do return self.isRawString end
end

function sling.model.StringLiteralExpressionNode:setIdentifier(v)
	self.identifier = v
end

function sling.model.StringLiteralExpressionNode:getIdentifier()
	do return self.identifier end
end

function sling.model.StringLiteralExpressionNode:setModifiers(v, doExport)
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.modifiers = nil
	else
		self.modifiers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.modifiers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.StringLiteralExpressionNode:getModifiers()
	do return self.modifiers end
end

function sling.model.StringLiteralExpressionNode:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do return v end
end

function sling.model.StringLiteralExpressionNode:addToModifiers(v)
	if v == nil then
		do return end
	end
	if self.modifiers == nil then
		self.modifiers = {}
	end
	do _g.jk.lang.Vector:append(self.modifiers, v) end
	do v:setParent(self) end
end

function sling.model.StringLiteralExpressionNode:clearModifiers()
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

sling.model.LabeledControlStatementNode = _g.sling.common.NodeObject._create()
sling.model.LabeledControlStatementNode.__index = sling.model.LabeledControlStatementNode
_vm:set_metatable(sling.model.LabeledControlStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.LabeledControlStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.LabeledControlStatementNode)
	return v
end

function sling.model.LabeledControlStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LabeledControlStatementNode'
	self['_isType.sling.model.LabeledControlStatementNode'] = true
	self.label = nil
end

function sling.model.LabeledControlStatementNode:_construct0()
	sling.model.LabeledControlStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.LabeledControlStatementNode:getNodeTypeName()
	do return "LabeledControlStatementNode" end
end

function sling.model.LabeledControlStatementNode:createNew()
	do return _g.sling.model.LabeledControlStatementNode._construct0(_g.sling.model.LabeledControlStatementNode._create()) end
end

function sling.model.LabeledControlStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LabeledControlStatementNode')
		if n == nil then
			do return true end
		end
		n.label = self.label
		do return true end
	end
end

function sling.model.LabeledControlStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LabeledControlStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LabeledControlStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.LabeledControlStatementNode:setLabel(v)
	self.label = v
end

function sling.model.LabeledControlStatementNode:getLabel()
	do return self.label end
end

sling.model.DestructorDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.DestructorDeclarationNode.__index = sling.model.DestructorDeclarationNode
_vm:set_metatable(sling.model.DestructorDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.DestructorDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.DestructorDeclarationNode)
	return v
end

function sling.model.DestructorDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DestructorDeclarationNode'
	self['_isType.sling.model.DestructorDeclarationNode'] = true
end

function sling.model.DestructorDeclarationNode:_construct0()
	sling.model.DestructorDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.DestructorDeclarationNode:getNodeTypeName()
	do return "DestructorDeclarationNode" end
end

function sling.model.DestructorDeclarationNode:createNew()
	do return _g.sling.model.DestructorDeclarationNode._construct0(_g.sling.model.DestructorDeclarationNode._create()) end
end

function sling.model.DestructorDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DestructorDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DestructorDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DestructorDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DestructorDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.ShiftLeftAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ShiftLeftAssignmentExpressionNode.__index = sling.model.ShiftLeftAssignmentExpressionNode
_vm:set_metatable(sling.model.ShiftLeftAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ShiftLeftAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftLeftAssignmentExpressionNode)
	return v
end

function sling.model.ShiftLeftAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftLeftAssignmentExpressionNode'
	self['_isType.sling.model.ShiftLeftAssignmentExpressionNode'] = true
end

function sling.model.ShiftLeftAssignmentExpressionNode:_construct0()
	sling.model.ShiftLeftAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ShiftLeftAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftLeftAssignmentExpressionNode._construct0(_g.sling.model.ShiftLeftAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftLeftAssignmentExpressionNode:getNodeTypeName()
	do return "ShiftLeftAssignmentExpressionNode" end
end

function sling.model.ShiftLeftAssignmentExpressionNode:createNew()
	do return _g.sling.model.ShiftLeftAssignmentExpressionNode._construct0(_g.sling.model.ShiftLeftAssignmentExpressionNode._create()) end
end

function sling.model.ShiftLeftAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftLeftAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ShiftLeftAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftLeftAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftLeftAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.DivisionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.DivisionExpressionNode.__index = sling.model.DivisionExpressionNode
_vm:set_metatable(sling.model.DivisionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.DivisionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DivisionExpressionNode)
	return v
end

function sling.model.DivisionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DivisionExpressionNode'
	self['_isType.sling.model.DivisionExpressionNode'] = true
end

function sling.model.DivisionExpressionNode:_construct0()
	sling.model.DivisionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.DivisionExpressionNode:instance(left, right)
	local v = _g.sling.model.DivisionExpressionNode._construct0(_g.sling.model.DivisionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DivisionExpressionNode:getNodeTypeName()
	do return "DivisionExpressionNode" end
end

function sling.model.DivisionExpressionNode:createNew()
	do return _g.sling.model.DivisionExpressionNode._construct0(_g.sling.model.DivisionExpressionNode._create()) end
end

function sling.model.DivisionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DivisionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DivisionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DivisionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DivisionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.ArrayLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.ArrayLiteralExpressionNode.__index = sling.model.ArrayLiteralExpressionNode
_vm:set_metatable(sling.model.ArrayLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.ArrayLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ArrayLiteralExpressionNode)
	return v
end

function sling.model.ArrayLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ArrayLiteralExpressionNode'
	self['_isType.sling.model.ArrayLiteralExpressionNode'] = true
	self.expressions = nil
	self.type = nil
end

function sling.model.ArrayLiteralExpressionNode:_construct0()
	sling.model.ArrayLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	return self
end

function sling.model.ArrayLiteralExpressionNode:forExpressions(xprs)
	local v = _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create())
	do v:setExpressions(xprs, false) end
	do return v end
end

function sling.model.ArrayLiteralExpressionNode:getNodeTypeName()
	do return "ArrayLiteralExpressionNode" end
end

function sling.model.ArrayLiteralExpressionNode:createNew()
	do return _g.sling.model.ArrayLiteralExpressionNode._construct0(_g.sling.model.ArrayLiteralExpressionNode._create()) end
end

function sling.model.ArrayLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ArrayLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ArrayLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ArrayLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ArrayLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.ArrayLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.ArrayLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.ArrayLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.ArrayLiteralExpressionNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ArrayLiteralExpressionNode:getExpressions()
	do return self.expressions end
end

function sling.model.ArrayLiteralExpressionNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.ArrayLiteralExpressionNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.ArrayLiteralExpressionNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.NullCoalescingExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.NullCoalescingExpressionNode.__index = sling.model.NullCoalescingExpressionNode
_vm:set_metatable(sling.model.NullCoalescingExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.NullCoalescingExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NullCoalescingExpressionNode)
	return v
end

function sling.model.NullCoalescingExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NullCoalescingExpressionNode'
	self['_isType.sling.model.NullCoalescingExpressionNode'] = true
end

function sling.model.NullCoalescingExpressionNode:_construct0()
	sling.model.NullCoalescingExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.NullCoalescingExpressionNode:forExpressions(left, right)
	local v = _g.sling.model.NullCoalescingExpressionNode._construct0(_g.sling.model.NullCoalescingExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.NullCoalescingExpressionNode:getNodeTypeName()
	do return "NullCoalescingExpressionNode" end
end

function sling.model.NullCoalescingExpressionNode:createNew()
	do return _g.sling.model.NullCoalescingExpressionNode._construct0(_g.sling.model.NullCoalescingExpressionNode._create()) end
end

function sling.model.NullCoalescingExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NullCoalescingExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NullCoalescingExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NullCoalescingExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NullCoalescingExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.CaseLessThanBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseLessThanBlockNode.__index = sling.model.CaseLessThanBlockNode
_vm:set_metatable(sling.model.CaseLessThanBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseLessThanBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseLessThanBlockNode)
	return v
end

function sling.model.CaseLessThanBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseLessThanBlockNode'
	self['_isType.sling.model.CaseLessThanBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseLessThanBlockNode:_construct0()
	sling.model.CaseLessThanBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseLessThanBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseLessThanBlockNode._construct0(_g.sling.model.CaseLessThanBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseLessThanBlockNode:getNodeTypeName()
	do return "CaseLessThanBlockNode" end
end

function sling.model.CaseLessThanBlockNode:createNew()
	do return _g.sling.model.CaseLessThanBlockNode._construct0(_g.sling.model.CaseLessThanBlockNode._create()) end
end

function sling.model.CaseLessThanBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseLessThanBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseLessThanBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseLessThanBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseLessThanBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseLessThanBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseLessThanBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseLessThanBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.GetAddressExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.GetAddressExpressionNode.__index = sling.model.GetAddressExpressionNode
_vm:set_metatable(sling.model.GetAddressExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.GetAddressExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetAddressExpressionNode)
	return v
end

function sling.model.GetAddressExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetAddressExpressionNode'
	self['_isType.sling.model.GetAddressExpressionNode'] = true
	self.expression = nil
end

function sling.model.GetAddressExpressionNode:_construct0()
	sling.model.GetAddressExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.GetAddressExpressionNode:getNodeTypeName()
	do return "GetAddressExpressionNode" end
end

function sling.model.GetAddressExpressionNode:createNew()
	do return _g.sling.model.GetAddressExpressionNode._construct0(_g.sling.model.GetAddressExpressionNode._create()) end
end

function sling.model.GetAddressExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetAddressExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetAddressExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetAddressExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetAddressExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.GetAddressExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.GetAddressExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.GetAddressExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.PreprocessorIfStatementNode = _g.sling.common.NodeObject._create()
sling.model.PreprocessorIfStatementNode.__index = sling.model.PreprocessorIfStatementNode
_vm:set_metatable(sling.model.PreprocessorIfStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PreprocessorIfStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.PreprocessorIfStatementNode)
	return v
end

function sling.model.PreprocessorIfStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreprocessorIfStatementNode'
	self['_isType.sling.model.PreprocessorIfStatementNode'] = true
	self.condition = nil
	self.ifBlock = nil
	self.elseBlock = nil
	self.elseBlockComment = nil
end

function sling.model.PreprocessorIfStatementNode:_construct0()
	sling.model.PreprocessorIfStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PreprocessorIfStatementNode:instance(condition, ifBlock, elseBlock)
	local v = _g.sling.model.PreprocessorIfStatementNode._construct0(_g.sling.model.PreprocessorIfStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setIfBlock(ifBlock, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.PreprocessorIfStatementNode:getNodeTypeName()
	do return "PreprocessorIfStatementNode" end
end

function sling.model.PreprocessorIfStatementNode:createNew()
	do return _g.sling.model.PreprocessorIfStatementNode._construct0(_g.sling.model.PreprocessorIfStatementNode._create()) end
end

function sling.model.PreprocessorIfStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreprocessorIfStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.ifBlock ~= nil then
			do n.ifBlock:destroy() end
			n.ifBlock = nil
		end
		if self.ifBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.ifBlock), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.ifBlock = pcp
			do n.ifBlock:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		if n.elseBlockComment ~= nil then
			do n.elseBlockComment:destroy() end
			n.elseBlockComment = nil
		end
		if self.elseBlockComment ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlockComment), '_isType.sling.model.CommentNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlockComment = pcp
			do n.elseBlockComment:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PreprocessorIfStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.ifBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.ifBlock:destroy() end
		end
		self.ifBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.ifBlock ~= nil then
			do self.ifBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlockComment then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlockComment:destroy() end
		end
		self.elseBlockComment = _vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode')
		if self.elseBlockComment ~= nil then
			do self.elseBlockComment:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreprocessorIfStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.ifBlock ~= nil then
		if self.ifBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlockComment ~= nil then
		if self.elseBlockComment:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PreprocessorIfStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.ifBlock ~= nil then
		do self.ifBlock:destroy() end
		self.ifBlock = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:destroy() end
		self.elseBlockComment = nil
	end
end

function sling.model.PreprocessorIfStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getCondition()
	do return self.condition end
end

function sling.model.PreprocessorIfStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.PreprocessorIfStatementNode:setIfBlock(v, doExport)
	if self.ifBlock ~= nil and doExport == false then
		do self.ifBlock:destroy() end
	end
	self.ifBlock = v
	if self.ifBlock ~= nil then
		do self.ifBlock:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getIfBlock()
	do return self.ifBlock end
end

function sling.model.PreprocessorIfStatementNode:exportIfBlock()
	local v = self.ifBlock
	self.ifBlock = nil
	do return v end
end

function sling.model.PreprocessorIfStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.PreprocessorIfStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.PreprocessorIfStatementNode:setElseBlockComment(v, doExport)
	if self.elseBlockComment ~= nil and doExport == false then
		do self.elseBlockComment:destroy() end
	end
	self.elseBlockComment = v
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:setParent(self) end
	end
end

function sling.model.PreprocessorIfStatementNode:getElseBlockComment()
	do return self.elseBlockComment end
end

function sling.model.PreprocessorIfStatementNode:exportElseBlockComment()
	local v = self.elseBlockComment
	self.elseBlockComment = nil
	do return v end
end

sling.model.PostDecrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PostDecrementExpressionNode.__index = sling.model.PostDecrementExpressionNode
_vm:set_metatable(sling.model.PostDecrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PostDecrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PostDecrementExpressionNode)
	return v
end

function sling.model.PostDecrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PostDecrementExpressionNode'
	self['_isType.sling.model.PostDecrementExpressionNode'] = true
end

function sling.model.PostDecrementExpressionNode:_construct0()
	sling.model.PostDecrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PostDecrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PostDecrementExpressionNode._construct0(_g.sling.model.PostDecrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PostDecrementExpressionNode:getNodeTypeName()
	do return "PostDecrementExpressionNode" end
end

function sling.model.PostDecrementExpressionNode:createNew()
	do return _g.sling.model.PostDecrementExpressionNode._construct0(_g.sling.model.PostDecrementExpressionNode._create()) end
end

function sling.model.PostDecrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PostDecrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PostDecrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PostDecrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PostDecrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ForceUnwrapOptionalExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.ForceUnwrapOptionalExpressionNode.__index = sling.model.ForceUnwrapOptionalExpressionNode
_vm:set_metatable(sling.model.ForceUnwrapOptionalExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.ForceUnwrapOptionalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ForceUnwrapOptionalExpressionNode)
	return v
end

function sling.model.ForceUnwrapOptionalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ForceUnwrapOptionalExpressionNode'
	self['_isType.sling.model.ForceUnwrapOptionalExpressionNode'] = true
end

function sling.model.ForceUnwrapOptionalExpressionNode:_construct0()
	sling.model.ForceUnwrapOptionalExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ForceUnwrapOptionalExpressionNode:forExpression(expression)
	local v = _g.sling.model.ForceUnwrapOptionalExpressionNode._construct0(_g.sling.model.ForceUnwrapOptionalExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.ForceUnwrapOptionalExpressionNode:getNodeTypeName()
	do return "ForceUnwrapOptionalExpressionNode" end
end

function sling.model.ForceUnwrapOptionalExpressionNode:createNew()
	do return _g.sling.model.ForceUnwrapOptionalExpressionNode._construct0(_g.sling.model.ForceUnwrapOptionalExpressionNode._create()) end
end

function sling.model.ForceUnwrapOptionalExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ForceUnwrapOptionalExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ForceUnwrapOptionalExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ForceUnwrapOptionalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ForceUnwrapOptionalExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.BufferDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.BufferDataTypeNode.__index = sling.model.BufferDataTypeNode
_vm:set_metatable(sling.model.BufferDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.BufferDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.BufferDataTypeNode)
	return v
end

function sling.model.BufferDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BufferDataTypeNode'
	self['_isType.sling.model.BufferDataTypeNode'] = true
end

function sling.model.BufferDataTypeNode:_construct0()
	sling.model.BufferDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.BufferDataTypeNode:getNodeTypeName()
	do return "BufferDataTypeNode" end
end

function sling.model.BufferDataTypeNode:createNew()
	do return _g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()) end
end

function sling.model.BufferDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BufferDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BufferDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BufferDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BufferDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.ExceptionDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ExceptionDataTypeNode.__index = sling.model.ExceptionDataTypeNode
_vm:set_metatable(sling.model.ExceptionDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ExceptionDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ExceptionDataTypeNode)
	return v
end

function sling.model.ExceptionDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExceptionDataTypeNode'
	self['_isType.sling.model.ExceptionDataTypeNode'] = true
end

function sling.model.ExceptionDataTypeNode:_construct0()
	sling.model.ExceptionDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ExceptionDataTypeNode:getNodeTypeName()
	do return "ExceptionDataTypeNode" end
end

function sling.model.ExceptionDataTypeNode:createNew()
	do return _g.sling.model.ExceptionDataTypeNode._construct0(_g.sling.model.ExceptionDataTypeNode._create()) end
end

function sling.model.ExceptionDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExceptionDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ExceptionDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExceptionDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExceptionDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.VoidDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.VoidDataTypeNode.__index = sling.model.VoidDataTypeNode
_vm:set_metatable(sling.model.VoidDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.VoidDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.VoidDataTypeNode)
	return v
end

function sling.model.VoidDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VoidDataTypeNode'
	self['_isType.sling.model.VoidDataTypeNode'] = true
end

function sling.model.VoidDataTypeNode:_construct0()
	sling.model.VoidDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	do self:setIsNullable(false) end
	return self
end

function sling.model.VoidDataTypeNode:getNodeTypeName()
	do return "VoidDataTypeNode" end
end

function sling.model.VoidDataTypeNode:createNew()
	do return _g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()) end
end

function sling.model.VoidDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VoidDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.VoidDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VoidDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.VoidDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.TryCatchExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.TryCatchExpressionNode.__index = sling.model.TryCatchExpressionNode
_vm:set_metatable(sling.model.TryCatchExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.TryCatchExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TryCatchExpressionNode)
	return v
end

function sling.model.TryCatchExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TryCatchExpressionNode'
	self['_isType.sling.model.TryCatchExpressionNode'] = true
	self.expression = nil
end

function sling.model.TryCatchExpressionNode:_construct0()
	sling.model.TryCatchExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TryCatchExpressionNode:forExpression(xpr)
	local v = _g.sling.model.TryCatchExpressionNode._construct0(_g.sling.model.TryCatchExpressionNode._create())
	do v:setExpression(xpr, false) end
	do return v end
end

function sling.model.TryCatchExpressionNode:getNodeTypeName()
	do return "TryCatchExpressionNode" end
end

function sling.model.TryCatchExpressionNode:createNew()
	do return _g.sling.model.TryCatchExpressionNode._construct0(_g.sling.model.TryCatchExpressionNode._create()) end
end

function sling.model.TryCatchExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TryCatchExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TryCatchExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TryCatchExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TryCatchExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.TryCatchExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.TryCatchExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.TryCatchExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.CaseMultipleEqualsBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseMultipleEqualsBlockNode.__index = sling.model.CaseMultipleEqualsBlockNode
_vm:set_metatable(sling.model.CaseMultipleEqualsBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseMultipleEqualsBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseMultipleEqualsBlockNode)
	return v
end

function sling.model.CaseMultipleEqualsBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseMultipleEqualsBlockNode'
	self['_isType.sling.model.CaseMultipleEqualsBlockNode'] = true
	self.expressions = nil
end

function sling.model.CaseMultipleEqualsBlockNode:_construct0()
	sling.model.CaseMultipleEqualsBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseMultipleEqualsBlockNode:forVectorOfExpessions(expressions, bb)
	local v = _g.sling.model.CaseMultipleEqualsBlockNode._construct0(_g.sling.model.CaseMultipleEqualsBlockNode._create())
	if expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(expressions)
		do
			n = 0
			while n < m do
				local expression = expressions[n + 1]
				if expression ~= nil then
					do v:addToExpressions(expression) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseMultipleEqualsBlockNode:forVectorOfObjects(expressions, bb)
	local v = _g.sling.model.CaseMultipleEqualsBlockNode._construct0(_g.sling.model.CaseMultipleEqualsBlockNode._create())
	if expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(expressions)
		do
			n = 0
			while n < m do
				local expression = _vm:to_table_with_key(expressions[n + 1], '_isType.sling.model.ExpressionNode')
				if expression ~= nil then
					do v:addToExpressions(expression) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseMultipleEqualsBlockNode:getNodeTypeName()
	do return "CaseMultipleEqualsBlockNode" end
end

function sling.model.CaseMultipleEqualsBlockNode:createNew()
	do return _g.sling.model.CaseMultipleEqualsBlockNode._construct0(_g.sling.model.CaseMultipleEqualsBlockNode._create()) end
end

function sling.model.CaseMultipleEqualsBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseMultipleEqualsBlockNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.CaseMultipleEqualsBlockNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseMultipleEqualsBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CaseMultipleEqualsBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.CaseMultipleEqualsBlockNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.CaseMultipleEqualsBlockNode:getExpressions()
	do return self.expressions end
end

function sling.model.CaseMultipleEqualsBlockNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.CaseMultipleEqualsBlockNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.CaseMultipleEqualsBlockNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.RangeExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.RangeExpressionNode.__index = sling.model.RangeExpressionNode
_vm:set_metatable(sling.model.RangeExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

sling.model.RangeExpressionNode.TYPE_NONE = 0
sling.model.RangeExpressionNode.TYPE_EXCLUDE_UPPER_BOUND = 1
sling.model.RangeExpressionNode.TYPE_EXCLUDE_LOWER_BOUND = 2
sling.model.RangeExpressionNode.TYPE_EXCLUDE_BOTH_BOUNDS = 3

function sling.model.RangeExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.RangeExpressionNode)
	return v
end

function sling.model.RangeExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.RangeExpressionNode'
	self['_isType.sling.model.RangeExpressionNode'] = true
	self.lowerBound = nil
	self.upperBound = nil
	self.step = nil
	self.type = nil
	self.exclusionType = 0
end

function sling.model.RangeExpressionNode:instance(from, to)
	local v = _g.sling.model.RangeExpressionNode._construct0(_g.sling.model.RangeExpressionNode._create())
	do v:setLowerBound(from, false) end
	do v:setUpperBound(to, false) end
	do return v end
end

function sling.model.RangeExpressionNode:_construct0()
	sling.model.RangeExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.RangeDataTypeNode._construct0(_g.sling.model.RangeDataTypeNode._create()), false) end
	return self
end

function sling.model.RangeExpressionNode:getNodeTypeName()
	do return "RangeExpressionNode" end
end

function sling.model.RangeExpressionNode:createNew()
	do return _g.sling.model.RangeExpressionNode._construct0(_g.sling.model.RangeExpressionNode._create()) end
end

function sling.model.RangeExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.RangeExpressionNode')
		if n == nil then
			do return true end
		end
		if n.lowerBound ~= nil then
			do n.lowerBound:destroy() end
			n.lowerBound = nil
		end
		if self.lowerBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.lowerBound), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.lowerBound = pcp
			do n.lowerBound:setParent(n) end
		end
		if n.upperBound ~= nil then
			do n.upperBound:destroy() end
			n.upperBound = nil
		end
		if self.upperBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.upperBound), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.upperBound = pcp
			do n.upperBound:setParent(n) end
		end
		if n.step ~= nil then
			do n.step:destroy() end
			n.step = nil
		end
		if self.step ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.step), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.step = pcp
			do n.step:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.exclusionType = self.exclusionType
		do return true end
	end
end

function sling.model.RangeExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.lowerBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.lowerBound:destroy() end
		end
		self.lowerBound = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.lowerBound ~= nil then
			do self.lowerBound:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.upperBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.upperBound:destroy() end
		end
		self.upperBound = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.upperBound ~= nil then
			do self.upperBound:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.step then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.step:destroy() end
		end
		self.step = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.step ~= nil then
			do self.step:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.RangeExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.lowerBound ~= nil then
		if self.lowerBound:accept(visitor) == false then
			do return false end
		end
	end
	if self.upperBound ~= nil then
		if self.upperBound:accept(visitor) == false then
			do return false end
		end
	end
	if self.step ~= nil then
		if self.step:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.RangeExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.lowerBound ~= nil then
		do self.lowerBound:destroy() end
		self.lowerBound = nil
	end
	if self.upperBound ~= nil then
		do self.upperBound:destroy() end
		self.upperBound = nil
	end
	if self.step ~= nil then
		do self.step:destroy() end
		self.step = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.RangeExpressionNode:setLowerBound(v, doExport)
	if self.lowerBound ~= nil and doExport == false then
		do self.lowerBound:destroy() end
	end
	self.lowerBound = v
	if self.lowerBound ~= nil then
		do self.lowerBound:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getLowerBound()
	do return self.lowerBound end
end

function sling.model.RangeExpressionNode:exportLowerBound()
	local v = self.lowerBound
	self.lowerBound = nil
	do return v end
end

function sling.model.RangeExpressionNode:setUpperBound(v, doExport)
	if self.upperBound ~= nil and doExport == false then
		do self.upperBound:destroy() end
	end
	self.upperBound = v
	if self.upperBound ~= nil then
		do self.upperBound:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getUpperBound()
	do return self.upperBound end
end

function sling.model.RangeExpressionNode:exportUpperBound()
	local v = self.upperBound
	self.upperBound = nil
	do return v end
end

function sling.model.RangeExpressionNode:setStep(v, doExport)
	if self.step ~= nil and doExport == false then
		do self.step:destroy() end
	end
	self.step = v
	if self.step ~= nil then
		do self.step:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getStep()
	do return self.step end
end

function sling.model.RangeExpressionNode:exportStep()
	local v = self.step
	self.step = nil
	do return v end
end

function sling.model.RangeExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.RangeExpressionNode:getType()
	do return self.type end
end

function sling.model.RangeExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.RangeExpressionNode:setExclusionType(v)
	self.exclusionType = v
end

function sling.model.RangeExpressionNode:getExclusionType()
	do return self.exclusionType end
end

sling.model.FileSystemTextFileReferenceExpressionNode = _g.sling.model.FileSystemReferenceExpressionNode._create()
sling.model.FileSystemTextFileReferenceExpressionNode.__index = sling.model.FileSystemTextFileReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemTextFileReferenceExpressionNode, {
	__index = _g.sling.model.FileSystemReferenceExpressionNode
})

function sling.model.FileSystemTextFileReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemTextFileReferenceExpressionNode)
	return v
end

function sling.model.FileSystemTextFileReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemTextFileReferenceExpressionNode'
	self['_isType.sling.model.FileSystemTextFileReferenceExpressionNode'] = true
end

function sling.model.FileSystemTextFileReferenceExpressionNode:_construct0()
	sling.model.FileSystemTextFileReferenceExpressionNode._init(self)
	do _g.sling.model.FileSystemReferenceExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemTextFileReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemTextFileReferenceExpressionNode" end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:createNew()
	do return _g.sling.model.FileSystemTextFileReferenceExpressionNode._construct0(_g.sling.model.FileSystemTextFileReferenceExpressionNode._create()) end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:copyTo(o)
	if _g.sling.model.FileSystemReferenceExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemTextFileReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FileSystemReferenceExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.FileSystemReferenceExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemTextFileReferenceExpressionNode:destroy()
	do _g.sling.model.FileSystemReferenceExpressionNode.destroy(self) end
end

sling.model.ComparisonExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ComparisonExpressionNode.__index = sling.model.ComparisonExpressionNode
_vm:set_metatable(sling.model.ComparisonExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ComparisonExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ComparisonExpressionNode)
	return v
end

function sling.model.ComparisonExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ComparisonExpressionNode'
	self['_isType.sling.model.ComparisonExpressionNode'] = true
end

function sling.model.ComparisonExpressionNode:_construct0()
	sling.model.ComparisonExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
	return self
end

function sling.model.ComparisonExpressionNode:getNodeTypeName()
	do return "ComparisonExpressionNode" end
end

function sling.model.ComparisonExpressionNode:createNew()
	do return _g.sling.model.ComparisonExpressionNode._construct0(_g.sling.model.ComparisonExpressionNode._create()) end
end

function sling.model.ComparisonExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ComparisonExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ComparisonExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ComparisonExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ComparisonExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.EqualityComparisonExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.EqualityComparisonExpressionNode.__index = sling.model.EqualityComparisonExpressionNode
_vm:set_metatable(sling.model.EqualityComparisonExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

sling.model.EqualityComparisonExpressionNode.SEMANTICS_CLASSIC = 0
sling.model.EqualityComparisonExpressionNode.SEMANTICS_COERCED = 1
sling.model.EqualityComparisonExpressionNode.SEMANTICS_IDENTITY = 2
sling.model.EqualityComparisonExpressionNode.SEMANTICS_VALUE = 3
sling.model.EqualityComparisonExpressionNode.SEMANTICS_OBJECT = 4

function sling.model.EqualityComparisonExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.EqualityComparisonExpressionNode)
	return v
end

function sling.model.EqualityComparisonExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EqualityComparisonExpressionNode'
	self['_isType.sling.model.EqualityComparisonExpressionNode'] = true
	self.semantics = 0
end

function sling.model.EqualityComparisonExpressionNode:_construct0()
	sling.model.EqualityComparisonExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.EqualityComparisonExpressionNode:getNodeTypeName()
	do return "EqualityComparisonExpressionNode" end
end

function sling.model.EqualityComparisonExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EqualityComparisonExpressionNode')
		if n == nil then
			do return true end
		end
		n.semantics = self.semantics
		do return true end
	end
end

function sling.model.EqualityComparisonExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EqualityComparisonExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EqualityComparisonExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

function sling.model.EqualityComparisonExpressionNode:setSemantics(v)
	self.semantics = v
end

function sling.model.EqualityComparisonExpressionNode:getSemantics()
	do return self.semantics end
end

sling.model.EqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.EqualsExpressionNode.__index = sling.model.EqualsExpressionNode
_vm:set_metatable(sling.model.EqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.EqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.EqualsExpressionNode)
	return v
end

function sling.model.EqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EqualsExpressionNode'
	self['_isType.sling.model.EqualsExpressionNode'] = true
end

function sling.model.EqualsExpressionNode:_construct0()
	sling.model.EqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.EqualsExpressionNode:forNull(expr)
	do return _g.sling.model.EqualsExpressionNode:instance(expr, _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())) end
end

function sling.model.EqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.EqualsExpressionNode._construct0(_g.sling.model.EqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.EqualsExpressionNode:getNodeTypeName()
	do return "EqualsExpressionNode" end
end

function sling.model.EqualsExpressionNode:createNew()
	do return _g.sling.model.EqualsExpressionNode._construct0(_g.sling.model.EqualsExpressionNode._create()) end
end

function sling.model.EqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.TemplateStatementNode = _g.sling.common.NodeObject._create()
sling.model.TemplateStatementNode.__index = sling.model.TemplateStatementNode
_vm:set_metatable(sling.model.TemplateStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TemplateStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.TemplateStatementNode)
	return v
end

function sling.model.TemplateStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TemplateStatementNode'
	self['_isType.sling.model.TemplateStatementNode'] = true
	self.name = nil
	self.relativeTo = nil
	self.symbol = nil
end

function sling.model.TemplateStatementNode:_construct0()
	sling.model.TemplateStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TemplateStatementNode:getNodeTypeName()
	do return "TemplateStatementNode" end
end

function sling.model.TemplateStatementNode:createNew()
	do return _g.sling.model.TemplateStatementNode._construct0(_g.sling.model.TemplateStatementNode._create()) end
end

function sling.model.TemplateStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TemplateStatementNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		n.name = self.name
		n.relativeTo = self.relativeTo
		do return true end
	end
end

function sling.model.TemplateStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TemplateStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TemplateStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.TemplateStatementNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.TemplateStatementNode:getSymbol()
	do return self.symbol end
end

function sling.model.TemplateStatementNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

function sling.model.TemplateStatementNode:setName(v)
	self.name = v
end

function sling.model.TemplateStatementNode:getName()
	do return self.name end
end

function sling.model.TemplateStatementNode:setRelativeTo(v)
	self.relativeTo = v
end

function sling.model.TemplateStatementNode:getRelativeTo()
	do return self.relativeTo end
end

sling.model.StyleSheetDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.StyleSheetDeclarationNode.__index = sling.model.StyleSheetDeclarationNode
_vm:set_metatable(sling.model.StyleSheetDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.StyleSheetDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.StyleSheetDeclarationNode)
	return v
end

function sling.model.StyleSheetDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StyleSheetDeclarationNode'
	self['_isType.sling.model.StyleSheetDeclarationNode'] = true
	self.name = nil
	self.body = nil
end

function sling.model.StyleSheetDeclarationNode:_construct0()
	sling.model.StyleSheetDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.StyleSheetDeclarationNode:getNodeTypeName()
	do return "StyleSheetDeclarationNode" end
end

function sling.model.StyleSheetDeclarationNode:createNew()
	do return _g.sling.model.StyleSheetDeclarationNode._construct0(_g.sling.model.StyleSheetDeclarationNode._create()) end
end

function sling.model.StyleSheetDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StyleSheetDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.StyleSheetDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StyleSheetDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StyleSheetDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
end

function sling.model.StyleSheetDeclarationNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.StyleSheetDeclarationNode:getBody()
	do return self.body end
end

function sling.model.StyleSheetDeclarationNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

function sling.model.StyleSheetDeclarationNode:setName(v)
	self.name = v
end

function sling.model.StyleSheetDeclarationNode:getName()
	do return self.name end
end

sling.model.DoWhileStatementNode = _g.sling.common.NodeObject._create()
sling.model.DoWhileStatementNode.__index = sling.model.DoWhileStatementNode
_vm:set_metatable(sling.model.DoWhileStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.DoWhileStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.DoWhileStatementNode)
	return v
end

function sling.model.DoWhileStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DoWhileStatementNode'
	self['_isType.sling.model.DoWhileStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.condition = nil
	self.block = nil
end

function sling.model.DoWhileStatementNode:_construct0()
	sling.model.DoWhileStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.DoWhileStatementNode:instance(condition, block)
	local v = _g.sling.model.DoWhileStatementNode._construct0(_g.sling.model.DoWhileStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.DoWhileStatementNode:getNodeTypeName()
	do return "DoWhileStatementNode" end
end

function sling.model.DoWhileStatementNode:createNew()
	do return _g.sling.model.DoWhileStatementNode._construct0(_g.sling.model.DoWhileStatementNode._create()) end
end

function sling.model.DoWhileStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DoWhileStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DoWhileStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DoWhileStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DoWhileStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.DoWhileStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.DoWhileStatementNode:getCondition()
	do return self.condition end
end

function sling.model.DoWhileStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.DoWhileStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.DoWhileStatementNode:getBlock()
	do return self.block end
end

function sling.model.DoWhileStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.ImportEntityStatementNode = _g.sling.model.ImportStatementNode._create()
sling.model.ImportEntityStatementNode.__index = sling.model.ImportEntityStatementNode
_vm:set_metatable(sling.model.ImportEntityStatementNode, {
	__index = _g.sling.model.ImportStatementNode
})

function sling.model.ImportEntityStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportEntityStatementNode)
	return v
end

function sling.model.ImportEntityStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportEntityStatementNode'
	self['_isType.sling.model.ImportEntityStatementNode'] = true
	self.entity = nil
	self.container = nil
	self.allMembers = false
end

function sling.model.ImportEntityStatementNode:_construct0()
	sling.model.ImportEntityStatementNode._init(self)
	do _g.sling.model.ImportStatementNode._construct0(self) end
	return self
end

function sling.model.ImportEntityStatementNode:getNodeTypeName()
	do return "ImportEntityStatementNode" end
end

function sling.model.ImportEntityStatementNode:createNew()
	do return _g.sling.model.ImportEntityStatementNode._construct0(_g.sling.model.ImportEntityStatementNode._create()) end
end

function sling.model.ImportEntityStatementNode:copyTo(o)
	if _g.sling.model.ImportStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportEntityStatementNode')
		if n == nil then
			do return true end
		end
		if n.entity ~= nil then
			do n.entity:destroy() end
			n.entity = nil
		end
		if self.entity ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.entity), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.entity = pcp
			do n.entity:setParent(n) end
		end
		if n.container ~= nil then
			do n.container:destroy() end
			n.container = nil
		end
		if self.container ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.container), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.container = pcp
			do n.container:setParent(n) end
		end
		n.allMembers = self.allMembers
		do return true end
	end
end

function sling.model.ImportEntityStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.entity then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.entity:destroy() end
		end
		self.entity = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.entity ~= nil then
			do self.entity:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.container then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.container:destroy() end
		end
		self.container = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.container ~= nil then
			do self.container:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ImportStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportEntityStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ImportStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.entity ~= nil then
		if self.entity:accept(visitor) == false then
			do return false end
		end
	end
	if self.container ~= nil then
		if self.container:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImportEntityStatementNode:destroy()
	do _g.sling.model.ImportStatementNode.destroy(self) end
	if self.entity ~= nil then
		do self.entity:destroy() end
		self.entity = nil
	end
	if self.container ~= nil then
		do self.container:destroy() end
		self.container = nil
	end
end

function sling.model.ImportEntityStatementNode:setEntity(v, doExport)
	if self.entity ~= nil and doExport == false then
		do self.entity:destroy() end
	end
	self.entity = v
	if self.entity ~= nil then
		do self.entity:setParent(self) end
	end
end

function sling.model.ImportEntityStatementNode:getEntity()
	do return self.entity end
end

function sling.model.ImportEntityStatementNode:exportEntity()
	local v = self.entity
	self.entity = nil
	do return v end
end

function sling.model.ImportEntityStatementNode:setContainer(v, doExport)
	if self.container ~= nil and doExport == false then
		do self.container:destroy() end
	end
	self.container = v
	if self.container ~= nil then
		do self.container:setParent(self) end
	end
end

function sling.model.ImportEntityStatementNode:getContainer()
	do return self.container end
end

function sling.model.ImportEntityStatementNode:exportContainer()
	local v = self.container
	self.container = nil
	do return v end
end

function sling.model.ImportEntityStatementNode:setAllMembers(v)
	self.allMembers = v
end

function sling.model.ImportEntityStatementNode:getAllMembers()
	do return self.allMembers end
end

sling.model.ModuloAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ModuloAssignmentExpressionNode.__index = sling.model.ModuloAssignmentExpressionNode
_vm:set_metatable(sling.model.ModuloAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ModuloAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ModuloAssignmentExpressionNode)
	return v
end

function sling.model.ModuloAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ModuloAssignmentExpressionNode'
	self['_isType.sling.model.ModuloAssignmentExpressionNode'] = true
end

function sling.model.ModuloAssignmentExpressionNode:_construct0()
	sling.model.ModuloAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ModuloAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ModuloAssignmentExpressionNode._construct0(_g.sling.model.ModuloAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ModuloAssignmentExpressionNode:getNodeTypeName()
	do return "ModuloAssignmentExpressionNode" end
end

function sling.model.ModuloAssignmentExpressionNode:createNew()
	do return _g.sling.model.ModuloAssignmentExpressionNode._construct0(_g.sling.model.ModuloAssignmentExpressionNode._create()) end
end

function sling.model.ModuloAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ModuloAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ModuloAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ModuloAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ModuloAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.IntegerLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.IntegerLiteralExpressionNode.__index = sling.model.IntegerLiteralExpressionNode
_vm:set_metatable(sling.model.IntegerLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

sling.model.IntegerLiteralExpressionNode.FORMAT_DECIMAL = 0
sling.model.IntegerLiteralExpressionNode.FORMAT_HEXADECIMAL = 1
sling.model.IntegerLiteralExpressionNode.FORMAT_BINARY = 2
sling.model.IntegerLiteralExpressionNode.FORMAT_OCTAL = 3

function sling.model.IntegerLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.IntegerLiteralExpressionNode)
	return v
end

function sling.model.IntegerLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IntegerLiteralExpressionNode'
	self['_isType.sling.model.IntegerLiteralExpressionNode'] = true
	self.value = 0
	self.type = 0
	self.format = 0
end

function sling.model.IntegerLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.IntegerLiteralExpressionNode._construct0(_g.sling.model.IntegerLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.IntegerLiteralExpressionNode:_construct0()
	sling.model.IntegerLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setType(_g.sling.model.IntegerDataTypeNode.TYPE_INT32) end
	return self
end

function sling.model.IntegerLiteralExpressionNode:setType(type)
	self.type = type
	do self:setDefaultDataType(_g.sling.model.IntegerDataTypeNode:forType(type), false) end
end

function sling.model.IntegerLiteralExpressionNode:getNodeTypeName()
	do return "IntegerLiteralExpressionNode" end
end

function sling.model.IntegerLiteralExpressionNode:createNew()
	do return _g.sling.model.IntegerLiteralExpressionNode._construct0(_g.sling.model.IntegerLiteralExpressionNode._create()) end
end

function sling.model.IntegerLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IntegerLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		n.type = self.type
		n.format = self.format
		do return true end
	end
end

function sling.model.IntegerLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IntegerLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.IntegerLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.IntegerLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.IntegerLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.IntegerLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.IntegerLiteralExpressionNode:setFormat(v)
	self.format = v
end

function sling.model.IntegerLiteralExpressionNode:getFormat()
	do return self.format end
end

sling.model.DelegateDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.DelegateDeclarationNode.__index = sling.model.DelegateDeclarationNode
_vm:set_metatable(sling.model.DelegateDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.DelegateDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.DelegateDeclarationNode)
	return v
end

function sling.model.DelegateDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DelegateDeclarationNode'
	self['_isType.sling.model.DelegateDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.declaration = nil
end

function sling.model.DelegateDeclarationNode:_construct0()
	sling.model.DelegateDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.DelegateDeclarationNode:forDeclaration(declaration)
	local v = _g.sling.model.DelegateDeclarationNode._construct0(_g.sling.model.DelegateDeclarationNode._create())
	do v:setDeclaration(declaration, false) end
	do return v end
end

function sling.model.DelegateDeclarationNode:getNodeName()
	local v = _g.sling.model.EntityDeclarationNode.getNodeName(self)
	if v ~= nil then
		do return v end
	end
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getNodeName() end
end

function sling.model.DelegateDeclarationNode:renameNode(name)
	do _g.sling.model.EntityDeclarationNode.renameNode(self, name) end
	if self.declaration ~= nil then
		do self.declaration:renameNode(name) end
	end
end

function sling.model.DelegateDeclarationNode:getReturnType()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getReturnType() end
end

function sling.model.DelegateDeclarationNode:getParameters()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getParameters() end
end

function sling.model.DelegateDeclarationNode:setReturnType(type)
	if self.declaration == nil then
		do self:setDeclaration(_g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create()), false) end
	end
	do self.declaration:setReturnType(type, false) end
	do return self end
end

function sling.model.DelegateDeclarationNode:setParameters(params)
	if self.declaration == nil then
		do self:setDeclaration(_g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create()), false) end
	end
	do self.declaration:setParameters(params, false) end
	do return self end
end

function sling.model.DelegateDeclarationNode:getNodeTypeName()
	do return "DelegateDeclarationNode" end
end

function sling.model.DelegateDeclarationNode:createNew()
	do return _g.sling.model.DelegateDeclarationNode._construct0(_g.sling.model.DelegateDeclarationNode._create()) end
end

function sling.model.DelegateDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DelegateDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.DelegateDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DelegateDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.DelegateDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
end

function sling.model.DelegateDeclarationNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.DelegateDeclarationNode:getDeclaration()
	do return self.declaration end
end

function sling.model.DelegateDeclarationNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

sling.model.ImplementsModifierNode = _g.sling.common.NodeObject._create()
sling.model.ImplementsModifierNode.__index = sling.model.ImplementsModifierNode
_vm:set_metatable(sling.model.ImplementsModifierNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ImplementsModifierNode._create()
	local v = _vm:set_metatable({}, sling.model.ImplementsModifierNode)
	return v
end

function sling.model.ImplementsModifierNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImplementsModifierNode'
	self['_isType.sling.model.ImplementsModifierNode'] = true
	self.symbol = nil
end

function sling.model.ImplementsModifierNode:_construct0()
	sling.model.ImplementsModifierNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ImplementsModifierNode:getNodeTypeName()
	do return "ImplementsModifierNode" end
end

function sling.model.ImplementsModifierNode:createNew()
	do return _g.sling.model.ImplementsModifierNode._construct0(_g.sling.model.ImplementsModifierNode._create()) end
end

function sling.model.ImplementsModifierNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImplementsModifierNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ImplementsModifierNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImplementsModifierNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImplementsModifierNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.ImplementsModifierNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.ImplementsModifierNode:getSymbol()
	do return self.symbol end
end

function sling.model.ImplementsModifierNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.ShiftRightAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ShiftRightAssignmentExpressionNode.__index = sling.model.ShiftRightAssignmentExpressionNode
_vm:set_metatable(sling.model.ShiftRightAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ShiftRightAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftRightAssignmentExpressionNode)
	return v
end

function sling.model.ShiftRightAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftRightAssignmentExpressionNode'
	self['_isType.sling.model.ShiftRightAssignmentExpressionNode'] = true
	self.zeroLeftmostBit = false
end

function sling.model.ShiftRightAssignmentExpressionNode:_construct0()
	sling.model.ShiftRightAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ShiftRightAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftRightAssignmentExpressionNode._construct0(_g.sling.model.ShiftRightAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftRightAssignmentExpressionNode:getNodeTypeName()
	do return "ShiftRightAssignmentExpressionNode" end
end

function sling.model.ShiftRightAssignmentExpressionNode:createNew()
	do return _g.sling.model.ShiftRightAssignmentExpressionNode._construct0(_g.sling.model.ShiftRightAssignmentExpressionNode._create()) end
end

function sling.model.ShiftRightAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftRightAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		n.zeroLeftmostBit = self.zeroLeftmostBit
		do return true end
	end
end

function sling.model.ShiftRightAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftRightAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftRightAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

function sling.model.ShiftRightAssignmentExpressionNode:setZeroLeftmostBit(v)
	self.zeroLeftmostBit = v
end

function sling.model.ShiftRightAssignmentExpressionNode:getZeroLeftmostBit()
	do return self.zeroLeftmostBit end
end

sling.model.EmptyStatementNode = _g.sling.common.NodeObject._create()
sling.model.EmptyStatementNode.__index = sling.model.EmptyStatementNode
_vm:set_metatable(sling.model.EmptyStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.EmptyStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.EmptyStatementNode)
	return v
end

function sling.model.EmptyStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EmptyStatementNode'
	self['_isType.sling.model.EmptyStatementNode'] = true
	self.comment = nil
end

function sling.model.EmptyStatementNode:_construct0()
	sling.model.EmptyStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.EmptyStatementNode:getNodeTypeName()
	do return "EmptyStatementNode" end
end

function sling.model.EmptyStatementNode:createNew()
	do return _g.sling.model.EmptyStatementNode._construct0(_g.sling.model.EmptyStatementNode._create()) end
end

function sling.model.EmptyStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EmptyStatementNode')
		if n == nil then
			do return true end
		end
		n.comment = self.comment
		do return true end
	end
end

function sling.model.EmptyStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EmptyStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EmptyStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.EmptyStatementNode:setComment(v)
	self.comment = v
end

function sling.model.EmptyStatementNode:getComment()
	do return self.comment end
end

sling.model.BitwiseOrExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.BitwiseOrExpressionNode.__index = sling.model.BitwiseOrExpressionNode
_vm:set_metatable(sling.model.BitwiseOrExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.BitwiseOrExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseOrExpressionNode)
	return v
end

function sling.model.BitwiseOrExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseOrExpressionNode'
	self['_isType.sling.model.BitwiseOrExpressionNode'] = true
end

function sling.model.BitwiseOrExpressionNode:_construct0()
	sling.model.BitwiseOrExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseOrExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseOrExpressionNode._construct0(_g.sling.model.BitwiseOrExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseOrExpressionNode:getNodeTypeName()
	do return "BitwiseOrExpressionNode" end
end

function sling.model.BitwiseOrExpressionNode:createNew()
	do return _g.sling.model.BitwiseOrExpressionNode._construct0(_g.sling.model.BitwiseOrExpressionNode._create()) end
end

function sling.model.BitwiseOrExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseOrExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseOrExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseOrExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseOrExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.ConstrainedDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.ConstrainedDataTypeNode.__index = sling.model.ConstrainedDataTypeNode
_vm:set_metatable(sling.model.ConstrainedDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.ConstrainedDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ConstrainedDataTypeNode)
	return v
end

function sling.model.ConstrainedDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ConstrainedDataTypeNode'
	self['_isType.sling.model.ConstrainedDataTypeNode'] = true
	self.baseTypes = nil
end

function sling.model.ConstrainedDataTypeNode:_construct0()
	sling.model.ConstrainedDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.ConstrainedDataTypeNode:forPrimaryType(pt)
	local v = _g.sling.model.ConstrainedDataTypeNode._construct0(_g.sling.model.ConstrainedDataTypeNode._create())
	do v:setPrimaryType(pt, false) end
	do return v end
end

function sling.model.ConstrainedDataTypeNode:getNodeTypeName()
	do return "ConstrainedDataTypeNode" end
end

function sling.model.ConstrainedDataTypeNode:createNew()
	do return _g.sling.model.ConstrainedDataTypeNode._construct0(_g.sling.model.ConstrainedDataTypeNode._create()) end
end

function sling.model.ConstrainedDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ConstrainedDataTypeNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.baseTypes
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.baseTypes = nil
			if self.baseTypes ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.baseTypes)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.baseTypes[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.baseTypes == nil then
								n.baseTypes = {}
							end
							do _g.jk.lang.Vector:append(n.baseTypes, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ConstrainedDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.baseTypes, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ConstrainedDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.baseTypes, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ConstrainedDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
end

function sling.model.ConstrainedDataTypeNode:setBaseTypes(v, doExport)
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.baseTypes = nil
	else
		self.baseTypes = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.baseTypes, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ConstrainedDataTypeNode:getBaseTypes()
	do return self.baseTypes end
end

function sling.model.ConstrainedDataTypeNode:exportBaseTypes()
	local v = self.baseTypes
	self.baseTypes = nil
	do return v end
end

function sling.model.ConstrainedDataTypeNode:addToBaseTypes(v)
	if v == nil then
		do return end
	end
	if self.baseTypes == nil then
		self.baseTypes = {}
	end
	do _g.jk.lang.Vector:append(self.baseTypes, v) end
	do v:setParent(self) end
end

function sling.model.ConstrainedDataTypeNode:clearBaseTypes()
	if self.baseTypes ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.baseTypes)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.baseTypes[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.baseTypes = nil
end

sling.model.PreprocessorIsDefinedExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.PreprocessorIsDefinedExpressionNode.__index = sling.model.PreprocessorIsDefinedExpressionNode
_vm:set_metatable(sling.model.PreprocessorIsDefinedExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.PreprocessorIsDefinedExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreprocessorIsDefinedExpressionNode)
	return v
end

function sling.model.PreprocessorIsDefinedExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreprocessorIsDefinedExpressionNode'
	self['_isType.sling.model.PreprocessorIsDefinedExpressionNode'] = true
	self.variable = nil
end

function sling.model.PreprocessorIsDefinedExpressionNode:_construct0()
	sling.model.PreprocessorIsDefinedExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.PreprocessorIsDefinedExpressionNode:instance(variable)
	local v = _g.sling.model.PreprocessorIsDefinedExpressionNode._construct0(_g.sling.model.PreprocessorIsDefinedExpressionNode._create())
	do v:setVariable(variable) end
	do return v end
end

function sling.model.PreprocessorIsDefinedExpressionNode:forVariable(variable)
	local v = _g.sling.model.PreprocessorIsDefinedExpressionNode._construct0(_g.sling.model.PreprocessorIsDefinedExpressionNode._create())
	do v:setVariable(variable) end
	do return v end
end

function sling.model.PreprocessorIsDefinedExpressionNode:getNodeTypeName()
	do return "PreprocessorIsDefinedExpressionNode" end
end

function sling.model.PreprocessorIsDefinedExpressionNode:createNew()
	do return _g.sling.model.PreprocessorIsDefinedExpressionNode._construct0(_g.sling.model.PreprocessorIsDefinedExpressionNode._create()) end
end

function sling.model.PreprocessorIsDefinedExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreprocessorIsDefinedExpressionNode')
		if n == nil then
			do return true end
		end
		n.variable = self.variable
		do return true end
	end
end

function sling.model.PreprocessorIsDefinedExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreprocessorIsDefinedExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreprocessorIsDefinedExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

function sling.model.PreprocessorIsDefinedExpressionNode:setVariable(v)
	self.variable = v
end

function sling.model.PreprocessorIsDefinedExpressionNode:getVariable()
	do return self.variable end
end

sling.model.TypeCheckExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.TypeCheckExpressionNode.__index = sling.model.TypeCheckExpressionNode
_vm:set_metatable(sling.model.TypeCheckExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.TypeCheckExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeCheckExpressionNode)
	return v
end

function sling.model.TypeCheckExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeCheckExpressionNode'
	self['_isType.sling.model.TypeCheckExpressionNode'] = true
	self.type = nil
	self.expression = nil
	self.negate = false
end

function sling.model.TypeCheckExpressionNode:_construct0()
	sling.model.TypeCheckExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TypeCheckExpressionNode:instance(type, expression, negate)
	local v = _g.sling.model.TypeCheckExpressionNode._construct0(_g.sling.model.TypeCheckExpressionNode._create())
	do v:setType(type, false) end
	do v:setExpression(expression, false) end
	do v:setNegate(negate) end
	do return v end
end

function sling.model.TypeCheckExpressionNode:getNodeTypeName()
	do return "TypeCheckExpressionNode" end
end

function sling.model.TypeCheckExpressionNode:createNew()
	do return _g.sling.model.TypeCheckExpressionNode._construct0(_g.sling.model.TypeCheckExpressionNode._create()) end
end

function sling.model.TypeCheckExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeCheckExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.negate = self.negate
		do return true end
	end
end

function sling.model.TypeCheckExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeCheckExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TypeCheckExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.TypeCheckExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.TypeCheckExpressionNode:getType()
	do return self.type end
end

function sling.model.TypeCheckExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.TypeCheckExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.TypeCheckExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.TypeCheckExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.TypeCheckExpressionNode:setNegate(v)
	self.negate = v
end

function sling.model.TypeCheckExpressionNode:getNegate()
	do return self.negate end
end

sling.model.MultipleExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.MultipleExpressionNode.__index = sling.model.MultipleExpressionNode
_vm:set_metatable(sling.model.MultipleExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.MultipleExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MultipleExpressionNode)
	return v
end

function sling.model.MultipleExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultipleExpressionNode'
	self['_isType.sling.model.MultipleExpressionNode'] = true
	self.expressions = nil
end

function sling.model.MultipleExpressionNode:_construct0()
	sling.model.MultipleExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.MultipleExpressionNode:getNodeTypeName()
	do return "MultipleExpressionNode" end
end

function sling.model.MultipleExpressionNode:createNew()
	do return _g.sling.model.MultipleExpressionNode._construct0(_g.sling.model.MultipleExpressionNode._create()) end
end

function sling.model.MultipleExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultipleExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MultipleExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultipleExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultipleExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.MultipleExpressionNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MultipleExpressionNode:getExpressions()
	do return self.expressions end
end

function sling.model.MultipleExpressionNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.MultipleExpressionNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.MultipleExpressionNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.UIExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.UIExpressionNode.__index = sling.model.UIExpressionNode
_vm:set_metatable(sling.model.UIExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.UIExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.UIExpressionNode)
	return v
end

function sling.model.UIExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.UIExpressionNode'
	self['_isType.sling.model.UIExpressionNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
	self.expression = nil
	self.layoutParams = nil
	self.children = nil
end

function sling.model.UIExpressionNode:_construct0()
	sling.model.UIExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.UIExpressionNode:getNodeName()
	do return self.name end
end

function sling.model.UIExpressionNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.UIExpressionNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.UIExpressionNode:getNodeTypeName()
	do return "UIExpressionNode" end
end

function sling.model.UIExpressionNode:createNew()
	do return _g.sling.model.UIExpressionNode._construct0(_g.sling.model.UIExpressionNode._create()) end
end

function sling.model.UIExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.UIExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		n.name = self.name
		do
			local array = n.layoutParams
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.layoutParams = nil
			if self.layoutParams ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.layoutParams)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.layoutParams[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.layoutParams == nil then
								n.layoutParams = {}
							end
							do _g.jk.lang.Vector:append(n.layoutParams, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.children
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.children = nil
				if self.children ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.children)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.children[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.children == nil then
									n.children = {}
								end
								do _g.jk.lang.Vector:append(n.children, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.UIExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.layoutParams, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.children, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.UIExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.layoutParams, visitor) == false then
		do return false end
	end
	if self:visitVector(self.children, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.UIExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.layoutParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.layoutParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.layoutParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.layoutParams = nil
	if self.children ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.children)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.children[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.children = nil
end

function sling.model.UIExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.UIExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.UIExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.UIExpressionNode:getName()
	do return self.name end
end

function sling.model.UIExpressionNode:setLayoutParams(v, doExport)
	if self.layoutParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.layoutParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.layoutParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.layoutParams = nil
	else
		self.layoutParams = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.layoutParams, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.UIExpressionNode:getLayoutParams()
	do return self.layoutParams end
end

function sling.model.UIExpressionNode:exportLayoutParams()
	local v = self.layoutParams
	self.layoutParams = nil
	do return v end
end

function sling.model.UIExpressionNode:addToLayoutParams(v)
	if v == nil then
		do return end
	end
	if self.layoutParams == nil then
		self.layoutParams = {}
	end
	do _g.jk.lang.Vector:append(self.layoutParams, v) end
	do v:setParent(self) end
end

function sling.model.UIExpressionNode:clearLayoutParams()
	if self.layoutParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.layoutParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.layoutParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.layoutParams = nil
end

function sling.model.UIExpressionNode:setChildren(v, doExport)
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.children = nil
	else
		self.children = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.children, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.UIExpressionNode:getChildren()
	do return self.children end
end

function sling.model.UIExpressionNode:exportChildren()
	local v = self.children
	self.children = nil
	do return v end
end

function sling.model.UIExpressionNode:addToChildren(v)
	if v == nil then
		do return end
	end
	if self.children == nil then
		self.children = {}
	end
	do _g.jk.lang.Vector:append(self.children, v) end
	do v:setParent(self) end
end

function sling.model.UIExpressionNode:clearChildren()
	if self.children ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.children)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.children[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.children = nil
end

sling.model.CaseDefaultBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseDefaultBlockNode.__index = sling.model.CaseDefaultBlockNode
_vm:set_metatable(sling.model.CaseDefaultBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseDefaultBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseDefaultBlockNode)
	return v
end

function sling.model.CaseDefaultBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseDefaultBlockNode'
	self['_isType.sling.model.CaseDefaultBlockNode'] = true
end

function sling.model.CaseDefaultBlockNode:_construct0()
	sling.model.CaseDefaultBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseDefaultBlockNode:instance(bb)
	local v = _g.sling.model.CaseDefaultBlockNode._construct0(_g.sling.model.CaseDefaultBlockNode._create())
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseDefaultBlockNode:getNodeTypeName()
	do return "CaseDefaultBlockNode" end
end

function sling.model.CaseDefaultBlockNode:createNew()
	do return _g.sling.model.CaseDefaultBlockNode._construct0(_g.sling.model.CaseDefaultBlockNode._create()) end
end

function sling.model.CaseDefaultBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseDefaultBlockNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.CaseDefaultBlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseDefaultBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CaseDefaultBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
end

sling.model.StyleSheetRuleNode = _g.sling.common.NodeObject._create()
sling.model.StyleSheetRuleNode.__index = sling.model.StyleSheetRuleNode
_vm:set_metatable(sling.model.StyleSheetRuleNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.StyleSheetRuleNode._create()
	local v = _vm:set_metatable({}, sling.model.StyleSheetRuleNode)
	return v
end

function sling.model.StyleSheetRuleNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StyleSheetRuleNode'
	self['_isType.sling.model.StyleSheetRuleNode'] = true
	self.selectors = nil
	self.body = nil
end

function sling.model.StyleSheetRuleNode:_construct0()
	sling.model.StyleSheetRuleNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.StyleSheetRuleNode:getNodeTypeName()
	do return "StyleSheetRuleNode" end
end

function sling.model.StyleSheetRuleNode:createNew()
	do return _g.sling.model.StyleSheetRuleNode._construct0(_g.sling.model.StyleSheetRuleNode._create()) end
end

function sling.model.StyleSheetRuleNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StyleSheetRuleNode')
		if n == nil then
			do return true end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		n.selectors = {}
		if self.selectors ~= nil then
			local n2 = 0
			local m = _g.jk.lang.Vector:getSize(self.selectors)
			do
				n2 = 0
				while n2 < m do
					local value = self.selectors[n2 + 1]
					if value ~= nil then
						do _g.jk.lang.Vector:append(n.selectors, value) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
		do return true end
	end
end

function sling.model.StyleSheetRuleNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StyleSheetRuleNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StyleSheetRuleNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
end

function sling.model.StyleSheetRuleNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.StyleSheetRuleNode:getBody()
	do return self.body end
end

function sling.model.StyleSheetRuleNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

function sling.model.StyleSheetRuleNode:setSelectors(v)
	self.selectors = {}
	if v ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(v)
		do
			n = 0
			while n < m do
				local value = v[n + 1]
				if value ~= nil then
					do _g.jk.lang.Vector:append(self.selectors, value) end
				end
				do n = n + 1 end
			end
		end
	end
end

function sling.model.StyleSheetRuleNode:getSelectors()
	do return self.selectors end
end

function sling.model.StyleSheetRuleNode:addToSelectors(v)
	if v == nil then
		do return end
	end
	if self.selectors == nil then
		self.selectors = {}
	end
	do _g.jk.lang.Vector:append(self.selectors, v) end
end

function sling.model.StyleSheetRuleNode:clearSelectors()
	self.selectors = nil
end

sling.model.PrintLineStatementNode = _g.sling.common.NodeObject._create()
sling.model.PrintLineStatementNode.__index = sling.model.PrintLineStatementNode
_vm:set_metatable(sling.model.PrintLineStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PrintLineStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.PrintLineStatementNode)
	return v
end

function sling.model.PrintLineStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PrintLineStatementNode'
	self['_isType.sling.model.PrintLineStatementNode'] = true
	self.expression = nil
end

function sling.model.PrintLineStatementNode:_construct0()
	sling.model.PrintLineStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PrintLineStatementNode:forExpression(expression)
	local v = _g.sling.model.PrintLineStatementNode._construct0(_g.sling.model.PrintLineStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PrintLineStatementNode:getNodeTypeName()
	do return "PrintLineStatementNode" end
end

function sling.model.PrintLineStatementNode:createNew()
	do return _g.sling.model.PrintLineStatementNode._construct0(_g.sling.model.PrintLineStatementNode._create()) end
end

function sling.model.PrintLineStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PrintLineStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PrintLineStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PrintLineStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PrintLineStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.PrintLineStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.PrintLineStatementNode:getExpression()
	do return self.expression end
end

function sling.model.PrintLineStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.CaseEqualsBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseEqualsBlockNode.__index = sling.model.CaseEqualsBlockNode
_vm:set_metatable(sling.model.CaseEqualsBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseEqualsBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseEqualsBlockNode)
	return v
end

function sling.model.CaseEqualsBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseEqualsBlockNode'
	self['_isType.sling.model.CaseEqualsBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseEqualsBlockNode:_construct0()
	sling.model.CaseEqualsBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseEqualsBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseEqualsBlockNode._construct0(_g.sling.model.CaseEqualsBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseEqualsBlockNode:getNodeTypeName()
	do return "CaseEqualsBlockNode" end
end

function sling.model.CaseEqualsBlockNode:createNew()
	do return _g.sling.model.CaseEqualsBlockNode._construct0(_g.sling.model.CaseEqualsBlockNode._create()) end
end

function sling.model.CaseEqualsBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseEqualsBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseEqualsBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseEqualsBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseEqualsBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseEqualsBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseEqualsBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseEqualsBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.CaseRangeBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseRangeBlockNode.__index = sling.model.CaseRangeBlockNode
_vm:set_metatable(sling.model.CaseRangeBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseRangeBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseRangeBlockNode)
	return v
end

function sling.model.CaseRangeBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseRangeBlockNode'
	self['_isType.sling.model.CaseRangeBlockNode'] = true
	self.lowerBound = nil
	self.upperBound = nil
	self.exclusionType = 0
end

function sling.model.CaseRangeBlockNode:_construct0()
	sling.model.CaseRangeBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseRangeBlockNode:instance(from, to, bb, type)
	local v = _g.sling.model.CaseRangeBlockNode._construct0(_g.sling.model.CaseRangeBlockNode._create())
	do v:setLowerBound(from, false) end
	do v:setUpperBound(to, false) end
	do v:setBlock(bb, false) end
	do v:setExclusionType(type) end
	do return v end
end

function sling.model.CaseRangeBlockNode:getNodeTypeName()
	do return "CaseRangeBlockNode" end
end

function sling.model.CaseRangeBlockNode:createNew()
	do return _g.sling.model.CaseRangeBlockNode._construct0(_g.sling.model.CaseRangeBlockNode._create()) end
end

function sling.model.CaseRangeBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseRangeBlockNode')
		if n == nil then
			do return true end
		end
		if n.lowerBound ~= nil then
			do n.lowerBound:destroy() end
			n.lowerBound = nil
		end
		if self.lowerBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.lowerBound), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.lowerBound = pcp
			do n.lowerBound:setParent(n) end
		end
		if n.upperBound ~= nil then
			do n.upperBound:destroy() end
			n.upperBound = nil
		end
		if self.upperBound ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.upperBound), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.upperBound = pcp
			do n.upperBound:setParent(n) end
		end
		n.exclusionType = self.exclusionType
		do return true end
	end
end

function sling.model.CaseRangeBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.lowerBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.lowerBound:destroy() end
		end
		self.lowerBound = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.lowerBound ~= nil then
			do self.lowerBound:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.upperBound then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.upperBound:destroy() end
		end
		self.upperBound = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.upperBound ~= nil then
			do self.upperBound:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseRangeBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.lowerBound ~= nil then
		if self.lowerBound:accept(visitor) == false then
			do return false end
		end
	end
	if self.upperBound ~= nil then
		if self.upperBound:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseRangeBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.lowerBound ~= nil then
		do self.lowerBound:destroy() end
		self.lowerBound = nil
	end
	if self.upperBound ~= nil then
		do self.upperBound:destroy() end
		self.upperBound = nil
	end
end

function sling.model.CaseRangeBlockNode:setLowerBound(v, doExport)
	if self.lowerBound ~= nil and doExport == false then
		do self.lowerBound:destroy() end
	end
	self.lowerBound = v
	if self.lowerBound ~= nil then
		do self.lowerBound:setParent(self) end
	end
end

function sling.model.CaseRangeBlockNode:getLowerBound()
	do return self.lowerBound end
end

function sling.model.CaseRangeBlockNode:exportLowerBound()
	local v = self.lowerBound
	self.lowerBound = nil
	do return v end
end

function sling.model.CaseRangeBlockNode:setUpperBound(v, doExport)
	if self.upperBound ~= nil and doExport == false then
		do self.upperBound:destroy() end
	end
	self.upperBound = v
	if self.upperBound ~= nil then
		do self.upperBound:setParent(self) end
	end
end

function sling.model.CaseRangeBlockNode:getUpperBound()
	do return self.upperBound end
end

function sling.model.CaseRangeBlockNode:exportUpperBound()
	local v = self.upperBound
	self.upperBound = nil
	do return v end
end

function sling.model.CaseRangeBlockNode:setExclusionType(v)
	self.exclusionType = v
end

function sling.model.CaseRangeBlockNode:getExclusionType()
	do return self.exclusionType end
end

sling.model.BitwiseAndExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.BitwiseAndExpressionNode.__index = sling.model.BitwiseAndExpressionNode
_vm:set_metatable(sling.model.BitwiseAndExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.BitwiseAndExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseAndExpressionNode)
	return v
end

function sling.model.BitwiseAndExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseAndExpressionNode'
	self['_isType.sling.model.BitwiseAndExpressionNode'] = true
end

function sling.model.BitwiseAndExpressionNode:_construct0()
	sling.model.BitwiseAndExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseAndExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseAndExpressionNode._construct0(_g.sling.model.BitwiseAndExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseAndExpressionNode:getNodeTypeName()
	do return "BitwiseAndExpressionNode" end
end

function sling.model.BitwiseAndExpressionNode:createNew()
	do return _g.sling.model.BitwiseAndExpressionNode._construct0(_g.sling.model.BitwiseAndExpressionNode._create()) end
end

function sling.model.BitwiseAndExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseAndExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseAndExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseAndExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseAndExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.ExponentExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.ExponentExpressionNode.__index = sling.model.ExponentExpressionNode
_vm:set_metatable(sling.model.ExponentExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.ExponentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ExponentExpressionNode)
	return v
end

function sling.model.ExponentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExponentExpressionNode'
	self['_isType.sling.model.ExponentExpressionNode'] = true
end

function sling.model.ExponentExpressionNode:instance(left, right)
	local v = _g.sling.model.ExponentExpressionNode._construct0(_g.sling.model.ExponentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ExponentExpressionNode:_construct0()
	sling.model.ExponentExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()), false) end
	return self
end

function sling.model.ExponentExpressionNode:getNodeTypeName()
	do return "ExponentExpressionNode" end
end

function sling.model.ExponentExpressionNode:createNew()
	do return _g.sling.model.ExponentExpressionNode._construct0(_g.sling.model.ExponentExpressionNode._create()) end
end

function sling.model.ExponentExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExponentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ExponentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExponentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExponentExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.LessOrEqualExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.LessOrEqualExpressionNode.__index = sling.model.LessOrEqualExpressionNode
_vm:set_metatable(sling.model.LessOrEqualExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.LessOrEqualExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LessOrEqualExpressionNode)
	return v
end

function sling.model.LessOrEqualExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LessOrEqualExpressionNode'
	self['_isType.sling.model.LessOrEqualExpressionNode'] = true
end

function sling.model.LessOrEqualExpressionNode:_construct0()
	sling.model.LessOrEqualExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.LessOrEqualExpressionNode:instance(left, right)
	local v = _g.sling.model.LessOrEqualExpressionNode._construct0(_g.sling.model.LessOrEqualExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LessOrEqualExpressionNode:getNodeTypeName()
	do return "LessOrEqualExpressionNode" end
end

function sling.model.LessOrEqualExpressionNode:createNew()
	do return _g.sling.model.LessOrEqualExpressionNode._construct0(_g.sling.model.LessOrEqualExpressionNode._create()) end
end

function sling.model.LessOrEqualExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LessOrEqualExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LessOrEqualExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LessOrEqualExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LessOrEqualExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.ShiftLeftExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.ShiftLeftExpressionNode.__index = sling.model.ShiftLeftExpressionNode
_vm:set_metatable(sling.model.ShiftLeftExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.ShiftLeftExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ShiftLeftExpressionNode)
	return v
end

function sling.model.ShiftLeftExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ShiftLeftExpressionNode'
	self['_isType.sling.model.ShiftLeftExpressionNode'] = true
end

function sling.model.ShiftLeftExpressionNode:_construct0()
	sling.model.ShiftLeftExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.ShiftLeftExpressionNode:instance(left, right)
	local v = _g.sling.model.ShiftLeftExpressionNode._construct0(_g.sling.model.ShiftLeftExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ShiftLeftExpressionNode:getNodeTypeName()
	do return "ShiftLeftExpressionNode" end
end

function sling.model.ShiftLeftExpressionNode:createNew()
	do return _g.sling.model.ShiftLeftExpressionNode._construct0(_g.sling.model.ShiftLeftExpressionNode._create()) end
end

function sling.model.ShiftLeftExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ShiftLeftExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ShiftLeftExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ShiftLeftExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ShiftLeftExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.ClassDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.ClassDeclarationNode.__index = sling.model.ClassDeclarationNode
_vm:set_metatable(sling.model.ClassDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.ClassDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ClassDeclarationNode)
	return v
end

function sling.model.ClassDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ClassDeclarationNode'
	self['_isType.sling.model.ClassDeclarationNode'] = true
end

function sling.model.ClassDeclarationNode:_construct0()
	sling.model.ClassDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.ClassDeclarationNode:forName(name)
	local v = _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.ClassDeclarationNode:getNodeTypeName()
	do return "ClassDeclarationNode" end
end

function sling.model.ClassDeclarationNode:createNew()
	do return _g.sling.model.ClassDeclarationNode._construct0(_g.sling.model.ClassDeclarationNode._create()) end
end

function sling.model.ClassDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ClassDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ClassDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ClassDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ClassDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
end

sling.model.LogicalExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.LogicalExpressionNode.__index = sling.model.LogicalExpressionNode
_vm:set_metatable(sling.model.LogicalExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.LogicalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalExpressionNode)
	return v
end

function sling.model.LogicalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalExpressionNode'
	self['_isType.sling.model.LogicalExpressionNode'] = true
end

function sling.model.LogicalExpressionNode:_construct0()
	sling.model.LogicalExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalExpressionNode:getNodeTypeName()
	do return "LogicalExpressionNode" end
end

function sling.model.LogicalExpressionNode:createNew()
	do return _g.sling.model.LogicalExpressionNode._construct0(_g.sling.model.LogicalExpressionNode._create()) end
end

function sling.model.LogicalExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.PrimitiveDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.PrimitiveDataTypeNode.__index = sling.model.PrimitiveDataTypeNode
_vm:set_metatable(sling.model.PrimitiveDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.PrimitiveDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.PrimitiveDataTypeNode)
	return v
end

function sling.model.PrimitiveDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PrimitiveDataTypeNode'
	self['_isType.sling.model.PrimitiveDataTypeNode'] = true
end

function sling.model.PrimitiveDataTypeNode:_construct0()
	sling.model.PrimitiveDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	do self:setIsNullable(false) end
	return self
end

function sling.model.PrimitiveDataTypeNode:getNodeTypeName()
	do return "PrimitiveDataTypeNode" end
end

function sling.model.PrimitiveDataTypeNode:createNew()
	do return _g.sling.model.PrimitiveDataTypeNode._construct0(_g.sling.model.PrimitiveDataTypeNode._create()) end
end

function sling.model.PrimitiveDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PrimitiveDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PrimitiveDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PrimitiveDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PrimitiveDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.BlockNode = _g.sling.common.ContainerNode._create()
sling.model.BlockNode.__index = sling.model.BlockNode
_vm:set_metatable(sling.model.BlockNode, {
	__index = _g.sling.common.ContainerNode
})

function sling.model.BlockNode._create()
	local v = _vm:set_metatable({}, sling.model.BlockNode)
	return v
end

function sling.model.BlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BlockNode'
	self['_isType.sling.model.BlockNode'] = true
	self['_isType.sling.model.NodeWithModifiers'] = true
	self.modifiers = nil
end

function sling.model.BlockNode:_construct0()
	sling.model.BlockNode._init(self)
	do _g.sling.common.ContainerNode._construct0(self) end
	return self
end

function sling.model.BlockNode:forStatement(statement)
	local v = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	if statement ~= nil then
		do v:addNode(statement) end
	end
	do return v end
end

function sling.model.BlockNode:getNodeTypeName()
	do return "BlockNode" end
end

function sling.model.BlockNode:createNew()
	do return _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create()) end
end

function sling.model.BlockNode:copyTo(o)
	if _g.sling.common.ContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BlockNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.modifiers
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.modifiers = nil
			if self.modifiers ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.modifiers)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.modifiers[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.modifiers == nil then
								n.modifiers = {}
							end
							do _g.jk.lang.Vector:append(n.modifiers, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.BlockNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.modifiers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.ContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BlockNode:acceptVisitor(visitor)
	if _g.sling.common.ContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.modifiers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BlockNode:destroy()
	do _g.sling.common.ContainerNode.destroy(self) end
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

function sling.model.BlockNode:setModifiers(v, doExport)
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.modifiers = nil
	else
		self.modifiers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.modifiers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.BlockNode:getModifiers()
	do return self.modifiers end
end

function sling.model.BlockNode:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do return v end
end

function sling.model.BlockNode:addToModifiers(v)
	if v == nil then
		do return end
	end
	if self.modifiers == nil then
		self.modifiers = {}
	end
	do _g.jk.lang.Vector:append(self.modifiers, v) end
	do v:setParent(self) end
end

function sling.model.BlockNode:clearModifiers()
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

sling.model.ConstructorDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.ConstructorDeclarationNode.__index = sling.model.ConstructorDeclarationNode
_vm:set_metatable(sling.model.ConstructorDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.ConstructorDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ConstructorDeclarationNode)
	return v
end

function sling.model.ConstructorDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ConstructorDeclarationNode'
	self['_isType.sling.model.ConstructorDeclarationNode'] = true
	self.next = nil
end

function sling.model.ConstructorDeclarationNode:_construct0()
	sling.model.ConstructorDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.ConstructorDeclarationNode:getNodeTypeName()
	do return "ConstructorDeclarationNode" end
end

function sling.model.ConstructorDeclarationNode:createNew()
	do return _g.sling.model.ConstructorDeclarationNode._construct0(_g.sling.model.ConstructorDeclarationNode._create()) end
end

function sling.model.ConstructorDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ConstructorDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.next ~= nil then
			do n.next:destroy() end
			n.next = nil
		end
		if self.next ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.next), '_isType.sling.model.FunctionCallExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.next = pcp
			do n.next:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ConstructorDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.next then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionCallExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.next:destroy() end
		end
		self.next = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionCallExpressionNode')
		if self.next ~= nil then
			do self.next:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ConstructorDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.next ~= nil then
		if self.next:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ConstructorDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
	if self.next ~= nil then
		do self.next:destroy() end
		self.next = nil
	end
end

function sling.model.ConstructorDeclarationNode:setNext(v, doExport)
	if self.next ~= nil and doExport == false then
		do self.next:destroy() end
	end
	self.next = v
	if self.next ~= nil then
		do self.next:setParent(self) end
	end
end

function sling.model.ConstructorDeclarationNode:getNext()
	do return self.next end
end

function sling.model.ConstructorDeclarationNode:exportNext()
	local v = self.next
	self.next = nil
	do return v end
end

sling.model.BitwiseXorExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.BitwiseXorExpressionNode.__index = sling.model.BitwiseXorExpressionNode
_vm:set_metatable(sling.model.BitwiseXorExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.BitwiseXorExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseXorExpressionNode)
	return v
end

function sling.model.BitwiseXorExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseXorExpressionNode'
	self['_isType.sling.model.BitwiseXorExpressionNode'] = true
end

function sling.model.BitwiseXorExpressionNode:_construct0()
	sling.model.BitwiseXorExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseXorExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseXorExpressionNode._construct0(_g.sling.model.BitwiseXorExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseXorExpressionNode:getNodeTypeName()
	do return "BitwiseXorExpressionNode" end
end

function sling.model.BitwiseXorExpressionNode:createNew()
	do return _g.sling.model.BitwiseXorExpressionNode._construct0(_g.sling.model.BitwiseXorExpressionNode._create()) end
end

function sling.model.BitwiseXorExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseXorExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseXorExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseXorExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseXorExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.WithStatementNode = _g.sling.common.NodeObject._create()
sling.model.WithStatementNode.__index = sling.model.WithStatementNode
_vm:set_metatable(sling.model.WithStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.WithStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.WithStatementNode)
	return v
end

function sling.model.WithStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.WithStatementNode'
	self['_isType.sling.model.WithStatementNode'] = true
	self.expression = nil
	self.block = nil
end

function sling.model.WithStatementNode:_construct0()
	sling.model.WithStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.WithStatementNode:getNodeTypeName()
	do return "WithStatementNode" end
end

function sling.model.WithStatementNode:createNew()
	do return _g.sling.model.WithStatementNode._construct0(_g.sling.model.WithStatementNode._create()) end
end

function sling.model.WithStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.WithStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.WithStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.WithStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.WithStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.WithStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.WithStatementNode:getExpression()
	do return self.expression end
end

function sling.model.WithStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.WithStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.WithStatementNode:getBlock()
	do return self.block end
end

function sling.model.WithStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.SubscriptExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.SubscriptExpressionNode.__index = sling.model.SubscriptExpressionNode
_vm:set_metatable(sling.model.SubscriptExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.SubscriptExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SubscriptExpressionNode)
	return v
end

function sling.model.SubscriptExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SubscriptExpressionNode'
	self['_isType.sling.model.SubscriptExpressionNode'] = true
	self.child = nil
	self.subscripts = nil
end

function sling.model.SubscriptExpressionNode:_construct0()
	sling.model.SubscriptExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.SubscriptExpressionNode:forExpression(child)
	local v = _g.sling.model.SubscriptExpressionNode._construct0(_g.sling.model.SubscriptExpressionNode._create())
	do v:setChild(child, false) end
	do return v end
end

function sling.model.SubscriptExpressionNode:instance(child, subscript)
	local v = _g.sling.model.SubscriptExpressionNode._construct0(_g.sling.model.SubscriptExpressionNode._create())
	do v:setChild(child, false) end
	do v:addToSubscripts(subscript) end
	do return v end
end

function sling.model.SubscriptExpressionNode:getSubscript()
	local ss = self:getSubscripts()
	if not (ss ~= nil) then
		do return nil end
	end
	if not (_g.jk.lang.Vector:getSize(ss) == 1) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(ss, 0), '_isType.sling.model.ExpressionNode') end
end

function sling.model.SubscriptExpressionNode:getNodeTypeName()
	do return "SubscriptExpressionNode" end
end

function sling.model.SubscriptExpressionNode:createNew()
	do return _g.sling.model.SubscriptExpressionNode._construct0(_g.sling.model.SubscriptExpressionNode._create()) end
end

function sling.model.SubscriptExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SubscriptExpressionNode')
		if n == nil then
			do return true end
		end
		if n.child ~= nil then
			do n.child:destroy() end
			n.child = nil
		end
		if self.child ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.child), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.child = pcp
			do n.child:setParent(n) end
		end
		do
			local array = n.subscripts
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.subscripts = nil
			if self.subscripts ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.subscripts)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.subscripts[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.subscripts == nil then
								n.subscripts = {}
							end
							do _g.jk.lang.Vector:append(n.subscripts, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SubscriptExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.child then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.child:destroy() end
		end
		self.child = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.child ~= nil then
			do self.child:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.subscripts, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SubscriptExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.child ~= nil then
		if self.child:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.subscripts, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SubscriptExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.child ~= nil then
		do self.child:destroy() end
		self.child = nil
	end
	if self.subscripts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.subscripts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.subscripts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.subscripts = nil
end

function sling.model.SubscriptExpressionNode:setChild(v, doExport)
	if self.child ~= nil and doExport == false then
		do self.child:destroy() end
	end
	self.child = v
	if self.child ~= nil then
		do self.child:setParent(self) end
	end
end

function sling.model.SubscriptExpressionNode:getChild()
	do return self.child end
end

function sling.model.SubscriptExpressionNode:exportChild()
	local v = self.child
	self.child = nil
	do return v end
end

function sling.model.SubscriptExpressionNode:setSubscripts(v, doExport)
	if self.subscripts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.subscripts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.subscripts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.subscripts = nil
	else
		self.subscripts = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.subscripts, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SubscriptExpressionNode:getSubscripts()
	do return self.subscripts end
end

function sling.model.SubscriptExpressionNode:exportSubscripts()
	local v = self.subscripts
	self.subscripts = nil
	do return v end
end

function sling.model.SubscriptExpressionNode:addToSubscripts(v)
	if v == nil then
		do return end
	end
	if self.subscripts == nil then
		self.subscripts = {}
	end
	do _g.jk.lang.Vector:append(self.subscripts, v) end
	do v:setParent(self) end
end

function sling.model.SubscriptExpressionNode:clearSubscripts()
	if self.subscripts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.subscripts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.subscripts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.subscripts = nil
end

sling.model.VariableReferenceDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.VariableReferenceDataTypeNode.__index = sling.model.VariableReferenceDataTypeNode
_vm:set_metatable(sling.model.VariableReferenceDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.VariableReferenceDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.VariableReferenceDataTypeNode)
	return v
end

function sling.model.VariableReferenceDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VariableReferenceDataTypeNode'
	self['_isType.sling.model.VariableReferenceDataTypeNode'] = true
end

function sling.model.VariableReferenceDataTypeNode:_construct0()
	sling.model.VariableReferenceDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.VariableReferenceDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.VariableReferenceDataTypeNode._construct0(_g.sling.model.VariableReferenceDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.VariableReferenceDataTypeNode:getNodeTypeName()
	do return "VariableReferenceDataTypeNode" end
end

function sling.model.VariableReferenceDataTypeNode:createNew()
	do return _g.sling.model.VariableReferenceDataTypeNode._construct0(_g.sling.model.VariableReferenceDataTypeNode._create()) end
end

function sling.model.VariableReferenceDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VariableReferenceDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.VariableReferenceDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VariableReferenceDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.VariableReferenceDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.LogicalXorExpressionNode = _g.sling.model.LogicalExpressionNode._create()
sling.model.LogicalXorExpressionNode.__index = sling.model.LogicalXorExpressionNode
_vm:set_metatable(sling.model.LogicalXorExpressionNode, {
	__index = _g.sling.model.LogicalExpressionNode
})

function sling.model.LogicalXorExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalXorExpressionNode)
	return v
end

function sling.model.LogicalXorExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalXorExpressionNode'
	self['_isType.sling.model.LogicalXorExpressionNode'] = true
end

function sling.model.LogicalXorExpressionNode:_construct0()
	sling.model.LogicalXorExpressionNode._init(self)
	do _g.sling.model.LogicalExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalXorExpressionNode:instance(left, right)
	local v = _g.sling.model.LogicalXorExpressionNode._construct0(_g.sling.model.LogicalXorExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LogicalXorExpressionNode:getNodeTypeName()
	do return "LogicalXorExpressionNode" end
end

function sling.model.LogicalXorExpressionNode:createNew()
	do return _g.sling.model.LogicalXorExpressionNode._construct0(_g.sling.model.LogicalXorExpressionNode._create()) end
end

function sling.model.LogicalXorExpressionNode:copyTo(o)
	if _g.sling.model.LogicalExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalXorExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalXorExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LogicalExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalXorExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LogicalExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalXorExpressionNode:destroy()
	do _g.sling.model.LogicalExpressionNode.destroy(self) end
end

sling.model.CaseLessOrEqualBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseLessOrEqualBlockNode.__index = sling.model.CaseLessOrEqualBlockNode
_vm:set_metatable(sling.model.CaseLessOrEqualBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseLessOrEqualBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseLessOrEqualBlockNode)
	return v
end

function sling.model.CaseLessOrEqualBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseLessOrEqualBlockNode'
	self['_isType.sling.model.CaseLessOrEqualBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseLessOrEqualBlockNode:_construct0()
	sling.model.CaseLessOrEqualBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseLessOrEqualBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseLessOrEqualBlockNode._construct0(_g.sling.model.CaseLessOrEqualBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseLessOrEqualBlockNode:getNodeTypeName()
	do return "CaseLessOrEqualBlockNode" end
end

function sling.model.CaseLessOrEqualBlockNode:createNew()
	do return _g.sling.model.CaseLessOrEqualBlockNode._construct0(_g.sling.model.CaseLessOrEqualBlockNode._create()) end
end

function sling.model.CaseLessOrEqualBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseLessOrEqualBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseLessOrEqualBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseLessOrEqualBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseLessOrEqualBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseLessOrEqualBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseLessOrEqualBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseLessOrEqualBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.LogicalNotExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.LogicalNotExpressionNode.__index = sling.model.LogicalNotExpressionNode
_vm:set_metatable(sling.model.LogicalNotExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.LogicalNotExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalNotExpressionNode)
	return v
end

function sling.model.LogicalNotExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalNotExpressionNode'
	self['_isType.sling.model.LogicalNotExpressionNode'] = true
end

function sling.model.LogicalNotExpressionNode:_construct0()
	sling.model.LogicalNotExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalNotExpressionNode:forExpression(expression)
	local v = _g.sling.model.LogicalNotExpressionNode._construct0(_g.sling.model.LogicalNotExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.LogicalNotExpressionNode:getNodeTypeName()
	do return "LogicalNotExpressionNode" end
end

function sling.model.LogicalNotExpressionNode:createNew()
	do return _g.sling.model.LogicalNotExpressionNode._construct0(_g.sling.model.LogicalNotExpressionNode._create()) end
end

function sling.model.LogicalNotExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalNotExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalNotExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalNotExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalNotExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.GoToLabelStatementNode = _g.sling.common.NodeObject._create()
sling.model.GoToLabelStatementNode.__index = sling.model.GoToLabelStatementNode
_vm:set_metatable(sling.model.GoToLabelStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.GoToLabelStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.GoToLabelStatementNode)
	return v
end

function sling.model.GoToLabelStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GoToLabelStatementNode'
	self['_isType.sling.model.GoToLabelStatementNode'] = true
	self.target = nil
end

function sling.model.GoToLabelStatementNode:_construct0()
	sling.model.GoToLabelStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.GoToLabelStatementNode:getNodeTypeName()
	do return "GoToLabelStatementNode" end
end

function sling.model.GoToLabelStatementNode:createNew()
	do return _g.sling.model.GoToLabelStatementNode._construct0(_g.sling.model.GoToLabelStatementNode._create()) end
end

function sling.model.GoToLabelStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GoToLabelStatementNode')
		if n == nil then
			do return true end
		end
		if n.target ~= nil then
			do n.target:destroy() end
			n.target = nil
		end
		if self.target ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.target), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.target = pcp
			do n.target:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GoToLabelStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.target then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.target:destroy() end
		end
		self.target = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.target ~= nil then
			do self.target:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GoToLabelStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.target ~= nil then
		if self.target:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GoToLabelStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.target ~= nil then
		do self.target:destroy() end
		self.target = nil
	end
end

function sling.model.GoToLabelStatementNode:setTarget(v, doExport)
	if self.target ~= nil and doExport == false then
		do self.target:destroy() end
	end
	self.target = v
	if self.target ~= nil then
		do self.target:setParent(self) end
	end
end

function sling.model.GoToLabelStatementNode:getTarget()
	do return self.target end
end

function sling.model.GoToLabelStatementNode:exportTarget()
	local v = self.target
	self.target = nil
	do return v end
end

sling.model.StaticBlockDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.StaticBlockDeclarationNode.__index = sling.model.StaticBlockDeclarationNode
_vm:set_metatable(sling.model.StaticBlockDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.StaticBlockDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.StaticBlockDeclarationNode)
	return v
end

function sling.model.StaticBlockDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StaticBlockDeclarationNode'
	self['_isType.sling.model.StaticBlockDeclarationNode'] = true
	self.block = nil
end

function sling.model.StaticBlockDeclarationNode:_construct0()
	sling.model.StaticBlockDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.StaticBlockDeclarationNode:forBlock(block)
	local v = _g.sling.model.StaticBlockDeclarationNode._construct0(_g.sling.model.StaticBlockDeclarationNode._create())
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.StaticBlockDeclarationNode:getNodeTypeName()
	do return "StaticBlockDeclarationNode" end
end

function sling.model.StaticBlockDeclarationNode:createNew()
	do return _g.sling.model.StaticBlockDeclarationNode._construct0(_g.sling.model.StaticBlockDeclarationNode._create()) end
end

function sling.model.StaticBlockDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StaticBlockDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StaticBlockDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StaticBlockDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StaticBlockDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.StaticBlockDeclarationNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.StaticBlockDeclarationNode:getBlock()
	do return self.block end
end

function sling.model.StaticBlockDeclarationNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.GreaterThanExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.GreaterThanExpressionNode.__index = sling.model.GreaterThanExpressionNode
_vm:set_metatable(sling.model.GreaterThanExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.GreaterThanExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GreaterThanExpressionNode)
	return v
end

function sling.model.GreaterThanExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GreaterThanExpressionNode'
	self['_isType.sling.model.GreaterThanExpressionNode'] = true
end

function sling.model.GreaterThanExpressionNode:_construct0()
	sling.model.GreaterThanExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.GreaterThanExpressionNode:instance(left, right)
	local v = _g.sling.model.GreaterThanExpressionNode._construct0(_g.sling.model.GreaterThanExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.GreaterThanExpressionNode:getNodeTypeName()
	do return "GreaterThanExpressionNode" end
end

function sling.model.GreaterThanExpressionNode:createNew()
	do return _g.sling.model.GreaterThanExpressionNode._construct0(_g.sling.model.GreaterThanExpressionNode._create()) end
end

function sling.model.GreaterThanExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GreaterThanExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GreaterThanExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GreaterThanExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GreaterThanExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.EnumDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.EnumDeclarationNode.__index = sling.model.EnumDeclarationNode
_vm:set_metatable(sling.model.EnumDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.EnumDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EnumDeclarationNode)
	return v
end

function sling.model.EnumDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EnumDeclarationNode'
	self['_isType.sling.model.EnumDeclarationNode'] = true
end

function sling.model.EnumDeclarationNode:_construct0()
	sling.model.EnumDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.EnumDeclarationNode:forName(name)
	local v = _g.sling.model.EnumDeclarationNode._construct0(_g.sling.model.EnumDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.EnumDeclarationNode:getNodeTypeName()
	do return "EnumDeclarationNode" end
end

function sling.model.EnumDeclarationNode:createNew()
	do return _g.sling.model.EnumDeclarationNode._construct0(_g.sling.model.EnumDeclarationNode._create()) end
end

function sling.model.EnumDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EnumDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EnumDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EnumDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EnumDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
end

sling.model.FlatBlockNode = _g.sling.common.ContainerNode._create()
sling.model.FlatBlockNode.__index = sling.model.FlatBlockNode
_vm:set_metatable(sling.model.FlatBlockNode, {
	__index = _g.sling.common.ContainerNode
})

function sling.model.FlatBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.FlatBlockNode)
	return v
end

function sling.model.FlatBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FlatBlockNode'
	self['_isType.sling.model.FlatBlockNode'] = true
end

function sling.model.FlatBlockNode:_construct0()
	sling.model.FlatBlockNode._init(self)
	do _g.sling.common.ContainerNode._construct0(self) end
	return self
end

function sling.model.FlatBlockNode:forStatement(node)
	if not (node ~= nil) then
		do return nil end
	end
	do
		local v = _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create())
		do v:addNode(node) end
		do return v end
	end
end

function sling.model.FlatBlockNode:getNodeTypeName()
	do return "FlatBlockNode" end
end

function sling.model.FlatBlockNode:createNew()
	do return _g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()) end
end

function sling.model.FlatBlockNode:copyTo(o)
	if _g.sling.common.ContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FlatBlockNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FlatBlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.ContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FlatBlockNode:acceptVisitor(visitor)
	if _g.sling.common.ContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FlatBlockNode:destroy()
	do _g.sling.common.ContainerNode.destroy(self) end
end

sling.model.EmptyExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.EmptyExpressionNode.__index = sling.model.EmptyExpressionNode
_vm:set_metatable(sling.model.EmptyExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.EmptyExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.EmptyExpressionNode)
	return v
end

function sling.model.EmptyExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EmptyExpressionNode'
	self['_isType.sling.model.EmptyExpressionNode'] = true
end

function sling.model.EmptyExpressionNode:_construct0()
	sling.model.EmptyExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.EmptyExpressionNode:getNodeTypeName()
	do return "EmptyExpressionNode" end
end

function sling.model.EmptyExpressionNode:createNew()
	do return _g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create()) end
end

function sling.model.EmptyExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EmptyExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EmptyExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EmptyExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EmptyExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.InterfaceDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.InterfaceDeclarationNode.__index = sling.model.InterfaceDeclarationNode
_vm:set_metatable(sling.model.InterfaceDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.InterfaceDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.InterfaceDeclarationNode)
	return v
end

function sling.model.InterfaceDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.InterfaceDeclarationNode'
	self['_isType.sling.model.InterfaceDeclarationNode'] = true
end

function sling.model.InterfaceDeclarationNode:_construct0()
	sling.model.InterfaceDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.InterfaceDeclarationNode:forName(name)
	local v = _g.sling.model.InterfaceDeclarationNode._construct0(_g.sling.model.InterfaceDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.InterfaceDeclarationNode:getNodeTypeName()
	do return "InterfaceDeclarationNode" end
end

function sling.model.InterfaceDeclarationNode:createNew()
	do return _g.sling.model.InterfaceDeclarationNode._construct0(_g.sling.model.InterfaceDeclarationNode._create()) end
end

function sling.model.InterfaceDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.InterfaceDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.InterfaceDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.InterfaceDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.InterfaceDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
end

sling.model.StrictNotEqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.StrictNotEqualsExpressionNode.__index = sling.model.StrictNotEqualsExpressionNode
_vm:set_metatable(sling.model.StrictNotEqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.StrictNotEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StrictNotEqualsExpressionNode)
	return v
end

function sling.model.StrictNotEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StrictNotEqualsExpressionNode'
	self['_isType.sling.model.StrictNotEqualsExpressionNode'] = true
end

function sling.model.StrictNotEqualsExpressionNode:_construct0()
	sling.model.StrictNotEqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.StrictNotEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.StrictNotEqualsExpressionNode._construct0(_g.sling.model.StrictNotEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StrictNotEqualsExpressionNode:getNodeTypeName()
	do return "StrictNotEqualsExpressionNode" end
end

function sling.model.StrictNotEqualsExpressionNode:createNew()
	do return _g.sling.model.StrictNotEqualsExpressionNode._construct0(_g.sling.model.StrictNotEqualsExpressionNode._create()) end
end

function sling.model.StrictNotEqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StrictNotEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StrictNotEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StrictNotEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StrictNotEqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.GetReferenceExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.GetReferenceExpressionNode.__index = sling.model.GetReferenceExpressionNode
_vm:set_metatable(sling.model.GetReferenceExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.GetReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetReferenceExpressionNode)
	return v
end

function sling.model.GetReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetReferenceExpressionNode'
	self['_isType.sling.model.GetReferenceExpressionNode'] = true
end

function sling.model.GetReferenceExpressionNode:_construct0()
	sling.model.GetReferenceExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.GetReferenceExpressionNode:forExpression(expression)
	local v = _g.sling.model.GetReferenceExpressionNode._construct0(_g.sling.model.GetReferenceExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.GetReferenceExpressionNode:getNodeTypeName()
	do return "GetReferenceExpressionNode" end
end

function sling.model.GetReferenceExpressionNode:createNew()
	do return _g.sling.model.GetReferenceExpressionNode._construct0(_g.sling.model.GetReferenceExpressionNode._create()) end
end

function sling.model.GetReferenceExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GetReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GetReferenceExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.DoubleDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.DoubleDataTypeNode.__index = sling.model.DoubleDataTypeNode
_vm:set_metatable(sling.model.DoubleDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.DoubleDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.DoubleDataTypeNode)
	return v
end

function sling.model.DoubleDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DoubleDataTypeNode'
	self['_isType.sling.model.DoubleDataTypeNode'] = true
end

function sling.model.DoubleDataTypeNode:_construct0()
	sling.model.DoubleDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.DoubleDataTypeNode:getNodeTypeName()
	do return "DoubleDataTypeNode" end
end

function sling.model.DoubleDataTypeNode:createNew()
	do return _g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()) end
end

function sling.model.DoubleDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DoubleDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DoubleDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DoubleDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DoubleDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.CaseNotEqualsBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseNotEqualsBlockNode.__index = sling.model.CaseNotEqualsBlockNode
_vm:set_metatable(sling.model.CaseNotEqualsBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseNotEqualsBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseNotEqualsBlockNode)
	return v
end

function sling.model.CaseNotEqualsBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseNotEqualsBlockNode'
	self['_isType.sling.model.CaseNotEqualsBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseNotEqualsBlockNode:_construct0()
	sling.model.CaseNotEqualsBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseNotEqualsBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseNotEqualsBlockNode._construct0(_g.sling.model.CaseNotEqualsBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseNotEqualsBlockNode:getNodeTypeName()
	do return "CaseNotEqualsBlockNode" end
end

function sling.model.CaseNotEqualsBlockNode:createNew()
	do return _g.sling.model.CaseNotEqualsBlockNode._construct0(_g.sling.model.CaseNotEqualsBlockNode._create()) end
end

function sling.model.CaseNotEqualsBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseNotEqualsBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseNotEqualsBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseNotEqualsBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseNotEqualsBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseNotEqualsBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseNotEqualsBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseNotEqualsBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.TemplateDeclarationNode = _g.sling.model.ClassDeclarationNode._create()
sling.model.TemplateDeclarationNode.__index = sling.model.TemplateDeclarationNode
_vm:set_metatable(sling.model.TemplateDeclarationNode, {
	__index = _g.sling.model.ClassDeclarationNode
})

sling.model.TemplateDeclarationNode.TYPE_ANY = 0
sling.model.TemplateDeclarationNode.TYPE_VALUE = 1
sling.model.TemplateDeclarationNode.TYPE_CLASS = 2

function sling.model.TemplateDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.TemplateDeclarationNode)
	return v
end

function sling.model.TemplateDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TemplateDeclarationNode'
	self['_isType.sling.model.TemplateDeclarationNode'] = true
	self.type = 0
end

function sling.model.TemplateDeclarationNode:_construct0()
	sling.model.TemplateDeclarationNode._init(self)
	do _g.sling.model.ClassDeclarationNode._construct0(self) end
	return self
end

function sling.model.TemplateDeclarationNode:forName1(name)
	local v = _g.sling.model.TemplateDeclarationNode._construct0(_g.sling.model.TemplateDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.TemplateDeclarationNode:getNodeTypeName()
	do return "TemplateDeclarationNode" end
end

function sling.model.TemplateDeclarationNode:createNew()
	do return _g.sling.model.TemplateDeclarationNode._construct0(_g.sling.model.TemplateDeclarationNode._create()) end
end

function sling.model.TemplateDeclarationNode:copyTo(o)
	if _g.sling.model.ClassDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TemplateDeclarationNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.TemplateDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ClassDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TemplateDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.ClassDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TemplateDeclarationNode:destroy()
	do _g.sling.model.ClassDeclarationNode.destroy(self) end
end

function sling.model.TemplateDeclarationNode:setType(v)
	self.type = v
end

function sling.model.TemplateDeclarationNode:getType()
	do return self.type end
end

sling.model.IfStatementNode = _g.sling.common.NodeObject._create()
sling.model.IfStatementNode.__index = sling.model.IfStatementNode
_vm:set_metatable(sling.model.IfStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.IfStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.IfStatementNode)
	return v
end

function sling.model.IfStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IfStatementNode'
	self['_isType.sling.model.IfStatementNode'] = true
	self.condition = nil
	self.ifBlock = nil
	self.elseBlock = nil
	self.elseBlockComment = nil
end

function sling.model.IfStatementNode:_construct0()
	sling.model.IfStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.IfStatementNode:instance(condition, ifBlock, elseBlock)
	local v = _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create())
	do v:setCondition(condition, false) end
	do v:setIfBlock(ifBlock, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.IfStatementNode:forStatement(condition, statement)
	if not (condition ~= nil and statement ~= nil) then
		do return nil end
	end
	do
		local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
		do block:addNode(statement) end
		do return _g.sling.model.IfStatementNode:instance(condition, block, nil) end
	end
end

function sling.model.IfStatementNode:getNodeTypeName()
	do return "IfStatementNode" end
end

function sling.model.IfStatementNode:createNew()
	do return _g.sling.model.IfStatementNode._construct0(_g.sling.model.IfStatementNode._create()) end
end

function sling.model.IfStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IfStatementNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.ifBlock ~= nil then
			do n.ifBlock:destroy() end
			n.ifBlock = nil
		end
		if self.ifBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.ifBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.ifBlock = pcp
			do n.ifBlock:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		if n.elseBlockComment ~= nil then
			do n.elseBlockComment:destroy() end
			n.elseBlockComment = nil
		end
		if self.elseBlockComment ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlockComment), '_isType.sling.model.CommentNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlockComment = pcp
			do n.elseBlockComment:setParent(n) end
		end
		do return true end
	end
end

function sling.model.IfStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.ifBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.ifBlock:destroy() end
		end
		self.ifBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.ifBlock ~= nil then
			do self.ifBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlockComment then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlockComment:destroy() end
		end
		self.elseBlockComment = _vm:to_table_with_key(newnode, '_isType.sling.model.CommentNode')
		if self.elseBlockComment ~= nil then
			do self.elseBlockComment:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IfStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.ifBlock ~= nil then
		if self.ifBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlockComment ~= nil then
		if self.elseBlockComment:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.IfStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.ifBlock ~= nil then
		do self.ifBlock:destroy() end
		self.ifBlock = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:destroy() end
		self.elseBlockComment = nil
	end
end

function sling.model.IfStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.IfStatementNode:getCondition()
	do return self.condition end
end

function sling.model.IfStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.IfStatementNode:setIfBlock(v, doExport)
	if self.ifBlock ~= nil and doExport == false then
		do self.ifBlock:destroy() end
	end
	self.ifBlock = v
	if self.ifBlock ~= nil then
		do self.ifBlock:setParent(self) end
	end
end

function sling.model.IfStatementNode:getIfBlock()
	do return self.ifBlock end
end

function sling.model.IfStatementNode:exportIfBlock()
	local v = self.ifBlock
	self.ifBlock = nil
	do return v end
end

function sling.model.IfStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.IfStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.IfStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.IfStatementNode:setElseBlockComment(v, doExport)
	if self.elseBlockComment ~= nil and doExport == false then
		do self.elseBlockComment:destroy() end
	end
	self.elseBlockComment = v
	if self.elseBlockComment ~= nil then
		do self.elseBlockComment:setParent(self) end
	end
end

function sling.model.IfStatementNode:getElseBlockComment()
	do return self.elseBlockComment end
end

function sling.model.IfStatementNode:exportElseBlockComment()
	local v = self.elseBlockComment
	self.elseBlockComment = nil
	do return v end
end

sling.model.SubtractionExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.SubtractionExpressionNode.__index = sling.model.SubtractionExpressionNode
_vm:set_metatable(sling.model.SubtractionExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.SubtractionExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SubtractionExpressionNode)
	return v
end

function sling.model.SubtractionExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SubtractionExpressionNode'
	self['_isType.sling.model.SubtractionExpressionNode'] = true
end

function sling.model.SubtractionExpressionNode:_construct0()
	sling.model.SubtractionExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.SubtractionExpressionNode:instance(left, right)
	local v = _g.sling.model.SubtractionExpressionNode._construct0(_g.sling.model.SubtractionExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.SubtractionExpressionNode:getNodeTypeName()
	do return "SubtractionExpressionNode" end
end

function sling.model.SubtractionExpressionNode:createNew()
	do return _g.sling.model.SubtractionExpressionNode._construct0(_g.sling.model.SubtractionExpressionNode._create()) end
end

function sling.model.SubtractionExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SubtractionExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SubtractionExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SubtractionExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SubtractionExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.DynamicXorExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.DynamicXorExpressionNode.__index = sling.model.DynamicXorExpressionNode
_vm:set_metatable(sling.model.DynamicXorExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.DynamicXorExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicXorExpressionNode)
	return v
end

function sling.model.DynamicXorExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicXorExpressionNode'
	self['_isType.sling.model.DynamicXorExpressionNode'] = true
end

function sling.model.DynamicXorExpressionNode:_construct0()
	sling.model.DynamicXorExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.DynamicXorExpressionNode:instance(left, right)
	local v = _g.sling.model.DynamicXorExpressionNode._construct0(_g.sling.model.DynamicXorExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DynamicXorExpressionNode:getNodeTypeName()
	do return "DynamicXorExpressionNode" end
end

function sling.model.DynamicXorExpressionNode:createNew()
	do return _g.sling.model.DynamicXorExpressionNode._construct0(_g.sling.model.DynamicXorExpressionNode._create()) end
end

function sling.model.DynamicXorExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicXorExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicXorExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicXorExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicXorExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.PreDecrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PreDecrementExpressionNode.__index = sling.model.PreDecrementExpressionNode
_vm:set_metatable(sling.model.PreDecrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PreDecrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreDecrementExpressionNode)
	return v
end

function sling.model.PreDecrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreDecrementExpressionNode'
	self['_isType.sling.model.PreDecrementExpressionNode'] = true
end

function sling.model.PreDecrementExpressionNode:_construct0()
	sling.model.PreDecrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PreDecrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PreDecrementExpressionNode._construct0(_g.sling.model.PreDecrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PreDecrementExpressionNode:getNodeTypeName()
	do return "PreDecrementExpressionNode" end
end

function sling.model.PreDecrementExpressionNode:createNew()
	do return _g.sling.model.PreDecrementExpressionNode._construct0(_g.sling.model.PreDecrementExpressionNode._create()) end
end

function sling.model.PreDecrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreDecrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PreDecrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreDecrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreDecrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.EmbedBlockNode = _g.sling.model.ExpressionNode._create()
sling.model.EmbedBlockNode.__index = sling.model.EmbedBlockNode
_vm:set_metatable(sling.model.EmbedBlockNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.EmbedBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.EmbedBlockNode)
	return v
end

function sling.model.EmbedBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EmbedBlockNode'
	self['_isType.sling.model.EmbedBlockNode'] = true
	self.type = nil
	self.code = nil
end

function sling.model.EmbedBlockNode:_construct0()
	sling.model.EmbedBlockNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.EmbedBlockNode:instance(type, code)
	local v = _g.sling.model.EmbedBlockNode._construct0(_g.sling.model.EmbedBlockNode._create())
	do v:setType(type) end
	do v:setCode(code) end
	do return v end
end

function sling.model.EmbedBlockNode:getNodeTypeName()
	do return "EmbedBlockNode" end
end

function sling.model.EmbedBlockNode:createNew()
	do return _g.sling.model.EmbedBlockNode._construct0(_g.sling.model.EmbedBlockNode._create()) end
end

function sling.model.EmbedBlockNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EmbedBlockNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		n.code = self.code
		do return true end
	end
end

function sling.model.EmbedBlockNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EmbedBlockNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EmbedBlockNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

function sling.model.EmbedBlockNode:setType(v)
	self.type = v
end

function sling.model.EmbedBlockNode:getType()
	do return self.type end
end

function sling.model.EmbedBlockNode:setCode(v)
	self.code = v
end

function sling.model.EmbedBlockNode:getCode()
	do return self.code end
end

sling.model.SubtractionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.SubtractionAssignmentExpressionNode.__index = sling.model.SubtractionAssignmentExpressionNode
_vm:set_metatable(sling.model.SubtractionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.SubtractionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SubtractionAssignmentExpressionNode)
	return v
end

function sling.model.SubtractionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SubtractionAssignmentExpressionNode'
	self['_isType.sling.model.SubtractionAssignmentExpressionNode'] = true
end

function sling.model.SubtractionAssignmentExpressionNode:_construct0()
	sling.model.SubtractionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.SubtractionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.SubtractionAssignmentExpressionNode._construct0(_g.sling.model.SubtractionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.SubtractionAssignmentExpressionNode:getNodeTypeName()
	do return "SubtractionAssignmentExpressionNode" end
end

function sling.model.SubtractionAssignmentExpressionNode:createNew()
	do return _g.sling.model.SubtractionAssignmentExpressionNode._construct0(_g.sling.model.SubtractionAssignmentExpressionNode._create()) end
end

function sling.model.SubtractionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SubtractionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SubtractionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SubtractionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SubtractionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.StringEqualsExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.StringEqualsExpressionNode.__index = sling.model.StringEqualsExpressionNode
_vm:set_metatable(sling.model.StringEqualsExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.StringEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StringEqualsExpressionNode)
	return v
end

function sling.model.StringEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StringEqualsExpressionNode'
	self['_isType.sling.model.StringEqualsExpressionNode'] = true
end

function sling.model.StringEqualsExpressionNode:_construct0()
	sling.model.StringEqualsExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.StringEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.StringEqualsExpressionNode._construct0(_g.sling.model.StringEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StringEqualsExpressionNode:getNodeTypeName()
	do return "StringEqualsExpressionNode" end
end

function sling.model.StringEqualsExpressionNode:createNew()
	do return _g.sling.model.StringEqualsExpressionNode._construct0(_g.sling.model.StringEqualsExpressionNode._create()) end
end

function sling.model.StringEqualsExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StringEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StringEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StringEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StringEqualsExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.ModelDeclarationNode = _g.sling.model.GenericCapableEntityDeclarationNode._create()
sling.model.ModelDeclarationNode.__index = sling.model.ModelDeclarationNode
_vm:set_metatable(sling.model.ModelDeclarationNode, {
	__index = _g.sling.model.GenericCapableEntityDeclarationNode
})

function sling.model.ModelDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ModelDeclarationNode)
	return v
end

function sling.model.ModelDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ModelDeclarationNode'
	self['_isType.sling.model.ModelDeclarationNode'] = true
end

function sling.model.ModelDeclarationNode:_construct0()
	sling.model.ModelDeclarationNode._init(self)
	do _g.sling.model.GenericCapableEntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.ModelDeclarationNode:forName(name)
	local v = _g.sling.model.ModelDeclarationNode._construct0(_g.sling.model.ModelDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.ModelDeclarationNode:getNodeTypeName()
	do return "ModelDeclarationNode" end
end

function sling.model.ModelDeclarationNode:createNew()
	do return _g.sling.model.ModelDeclarationNode._construct0(_g.sling.model.ModelDeclarationNode._create()) end
end

function sling.model.ModelDeclarationNode:copyTo(o)
	if _g.sling.model.GenericCapableEntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ModelDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ModelDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.GenericCapableEntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ModelDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.GenericCapableEntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ModelDeclarationNode:destroy()
	do _g.sling.model.GenericCapableEntityDeclarationNode.destroy(self) end
end

sling.model.ReferenceDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ReferenceDataTypeNode.__index = sling.model.ReferenceDataTypeNode
_vm:set_metatable(sling.model.ReferenceDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ReferenceDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ReferenceDataTypeNode)
	return v
end

function sling.model.ReferenceDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ReferenceDataTypeNode'
	self['_isType.sling.model.ReferenceDataTypeNode'] = true
	self.magical = false
	self.symbol = nil
end

function sling.model.ReferenceDataTypeNode:_construct0()
	sling.model.ReferenceDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ReferenceDataTypeNode:forNode(node, typemap)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forBinding(node, typemap), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forName(vv)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forName(vv), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forVectorOfNames(nn)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forVectorOfNames(nn), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forArrayOfNames(nn)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	local nna = {}
	if nn ~= nil then
		local n = 0
		local m = #nn
		do
			n = 0
			while n < m do
				local s = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(nn[n + 1])
				if s ~= nil then
					do _g.jk.lang.Vector:append(nna, s) end
				end
				do n = n + 1 end
			end
		end
	end
	do v:setSymbol(_g.sling.model.SymbolNode:forVectorOfNames(nna), false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:forSymbol(sym)
	local v = _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create())
	do v:setSymbol(sym, false) end
	do return v end
end

function sling.model.ReferenceDataTypeNode:setName(name)
	do self:setSymbol(_g.sling.model.SymbolNode:forName(name), false) end
end

function sling.model.ReferenceDataTypeNode:setNames(nss)
	do self:setSymbol(_g.sling.model.SymbolNode:forVectorOfNames(nss), false) end
end

function sling.model.ReferenceDataTypeNode:getNodeTypeName()
	do return "ReferenceDataTypeNode" end
end

function sling.model.ReferenceDataTypeNode:createNew()
	do return _g.sling.model.ReferenceDataTypeNode._construct0(_g.sling.model.ReferenceDataTypeNode._create()) end
end

function sling.model.ReferenceDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ReferenceDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		n.magical = self.magical
		do return true end
	end
end

function sling.model.ReferenceDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ReferenceDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ReferenceDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.ReferenceDataTypeNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.ReferenceDataTypeNode:getSymbol()
	do return self.symbol end
end

function sling.model.ReferenceDataTypeNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

function sling.model.ReferenceDataTypeNode:setMagical(v)
	self.magical = v
end

function sling.model.ReferenceDataTypeNode:getMagical()
	do return self.magical end
end

sling.model.CharacterLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.CharacterLiteralExpressionNode.__index = sling.model.CharacterLiteralExpressionNode
_vm:set_metatable(sling.model.CharacterLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.CharacterLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.CharacterLiteralExpressionNode)
	return v
end

function sling.model.CharacterLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CharacterLiteralExpressionNode'
	self['_isType.sling.model.CharacterLiteralExpressionNode'] = true
	self.value = 0
end

function sling.model.CharacterLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.CharacterLiteralExpressionNode._construct0(_g.sling.model.CharacterLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.CharacterLiteralExpressionNode:_construct0()
	sling.model.CharacterLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()), false) end
	return self
end

function sling.model.CharacterLiteralExpressionNode:getNodeTypeName()
	do return "CharacterLiteralExpressionNode" end
end

function sling.model.CharacterLiteralExpressionNode:createNew()
	do return _g.sling.model.CharacterLiteralExpressionNode._construct0(_g.sling.model.CharacterLiteralExpressionNode._create()) end
end

function sling.model.CharacterLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CharacterLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.CharacterLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CharacterLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CharacterLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.CharacterLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.CharacterLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.LogicalOrExpressionNode = _g.sling.model.LogicalExpressionNode._create()
sling.model.LogicalOrExpressionNode.__index = sling.model.LogicalOrExpressionNode
_vm:set_metatable(sling.model.LogicalOrExpressionNode, {
	__index = _g.sling.model.LogicalExpressionNode
})

function sling.model.LogicalOrExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalOrExpressionNode)
	return v
end

function sling.model.LogicalOrExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalOrExpressionNode'
	self['_isType.sling.model.LogicalOrExpressionNode'] = true
end

function sling.model.LogicalOrExpressionNode:_construct0()
	sling.model.LogicalOrExpressionNode._init(self)
	do _g.sling.model.LogicalExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalOrExpressionNode:instance(left, right)
	local v = _g.sling.model.LogicalOrExpressionNode._construct0(_g.sling.model.LogicalOrExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LogicalOrExpressionNode:getNodeTypeName()
	do return "LogicalOrExpressionNode" end
end

function sling.model.LogicalOrExpressionNode:createNew()
	do return _g.sling.model.LogicalOrExpressionNode._construct0(_g.sling.model.LogicalOrExpressionNode._create()) end
end

function sling.model.LogicalOrExpressionNode:copyTo(o)
	if _g.sling.model.LogicalExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalOrExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalOrExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LogicalExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalOrExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LogicalExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalOrExpressionNode:destroy()
	do _g.sling.model.LogicalExpressionNode.destroy(self) end
end

sling.model.DivisionAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.DivisionAssignmentExpressionNode.__index = sling.model.DivisionAssignmentExpressionNode
_vm:set_metatable(sling.model.DivisionAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.DivisionAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DivisionAssignmentExpressionNode)
	return v
end

function sling.model.DivisionAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DivisionAssignmentExpressionNode'
	self['_isType.sling.model.DivisionAssignmentExpressionNode'] = true
end

function sling.model.DivisionAssignmentExpressionNode:_construct0()
	sling.model.DivisionAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.DivisionAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.DivisionAssignmentExpressionNode._construct0(_g.sling.model.DivisionAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DivisionAssignmentExpressionNode:getNodeTypeName()
	do return "DivisionAssignmentExpressionNode" end
end

function sling.model.DivisionAssignmentExpressionNode:createNew()
	do return _g.sling.model.DivisionAssignmentExpressionNode._construct0(_g.sling.model.DivisionAssignmentExpressionNode._create()) end
end

function sling.model.DivisionAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DivisionAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DivisionAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DivisionAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DivisionAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.PositiveNumberExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PositiveNumberExpressionNode.__index = sling.model.PositiveNumberExpressionNode
_vm:set_metatable(sling.model.PositiveNumberExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PositiveNumberExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PositiveNumberExpressionNode)
	return v
end

function sling.model.PositiveNumberExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PositiveNumberExpressionNode'
	self['_isType.sling.model.PositiveNumberExpressionNode'] = true
end

function sling.model.PositiveNumberExpressionNode:_construct0()
	sling.model.PositiveNumberExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PositiveNumberExpressionNode:forExpression(expression)
	local v = _g.sling.model.PositiveNumberExpressionNode._construct0(_g.sling.model.PositiveNumberExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PositiveNumberExpressionNode:getNodeTypeName()
	do return "PositiveNumberExpressionNode" end
end

function sling.model.PositiveNumberExpressionNode:createNew()
	do return _g.sling.model.PositiveNumberExpressionNode._construct0(_g.sling.model.PositiveNumberExpressionNode._create()) end
end

function sling.model.PositiveNumberExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PositiveNumberExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PositiveNumberExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PositiveNumberExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PositiveNumberExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.PrintStatementNode = _g.sling.common.NodeObject._create()
sling.model.PrintStatementNode.__index = sling.model.PrintStatementNode
_vm:set_metatable(sling.model.PrintStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.PrintStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.PrintStatementNode)
	return v
end

function sling.model.PrintStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PrintStatementNode'
	self['_isType.sling.model.PrintStatementNode'] = true
	self.expression = nil
end

function sling.model.PrintStatementNode:_construct0()
	sling.model.PrintStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.PrintStatementNode:forExpression(expression)
	local v = _g.sling.model.PrintStatementNode._construct0(_g.sling.model.PrintStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PrintStatementNode:getNodeTypeName()
	do return "PrintStatementNode" end
end

function sling.model.PrintStatementNode:createNew()
	do return _g.sling.model.PrintStatementNode._construct0(_g.sling.model.PrintStatementNode._create()) end
end

function sling.model.PrintStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PrintStatementNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PrintStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PrintStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PrintStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.PrintStatementNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.PrintStatementNode:getExpression()
	do return self.expression end
end

function sling.model.PrintStatementNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.GetSizeExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.GetSizeExpressionNode.__index = sling.model.GetSizeExpressionNode
_vm:set_metatable(sling.model.GetSizeExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.GetSizeExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetSizeExpressionNode)
	return v
end

function sling.model.GetSizeExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetSizeExpressionNode'
	self['_isType.sling.model.GetSizeExpressionNode'] = true
end

function sling.model.GetSizeExpressionNode:_construct0()
	sling.model.GetSizeExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.GetSizeExpressionNode:forExpression(expression)
	local v = _g.sling.model.GetSizeExpressionNode._construct0(_g.sling.model.GetSizeExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.GetSizeExpressionNode:getNodeTypeName()
	do return "GetSizeExpressionNode" end
end

function sling.model.GetSizeExpressionNode:createNew()
	do return _g.sling.model.GetSizeExpressionNode._construct0(_g.sling.model.GetSizeExpressionNode._create()) end
end

function sling.model.GetSizeExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetSizeExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GetSizeExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetSizeExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GetSizeExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.NotEqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.NotEqualsExpressionNode.__index = sling.model.NotEqualsExpressionNode
_vm:set_metatable(sling.model.NotEqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.NotEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NotEqualsExpressionNode)
	return v
end

function sling.model.NotEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NotEqualsExpressionNode'
	self['_isType.sling.model.NotEqualsExpressionNode'] = true
end

function sling.model.NotEqualsExpressionNode:_construct0()
	sling.model.NotEqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.NotEqualsExpressionNode:forNull(expr)
	do return _g.sling.model.NotEqualsExpressionNode:instance(expr, _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create())) end
end

function sling.model.NotEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.NotEqualsExpressionNode._construct0(_g.sling.model.NotEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.NotEqualsExpressionNode:getNodeTypeName()
	do return "NotEqualsExpressionNode" end
end

function sling.model.NotEqualsExpressionNode:createNew()
	do return _g.sling.model.NotEqualsExpressionNode._construct0(_g.sling.model.NotEqualsExpressionNode._create()) end
end

function sling.model.NotEqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NotEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NotEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NotEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NotEqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.StaticArrayDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.StaticArrayDataTypeNode.__index = sling.model.StaticArrayDataTypeNode
_vm:set_metatable(sling.model.StaticArrayDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.StaticArrayDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.StaticArrayDataTypeNode)
	return v
end

function sling.model.StaticArrayDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StaticArrayDataTypeNode'
	self['_isType.sling.model.StaticArrayDataTypeNode'] = true
	self.size = nil
end

function sling.model.StaticArrayDataTypeNode:_construct0()
	sling.model.StaticArrayDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.StaticArrayDataTypeNode:forPrimaryType(type, size)
	local v = _g.sling.model.StaticArrayDataTypeNode._construct0(_g.sling.model.StaticArrayDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do v:setSize(size, false) end
	do return v end
end

function sling.model.StaticArrayDataTypeNode:getNodeTypeName()
	do return "StaticArrayDataTypeNode" end
end

function sling.model.StaticArrayDataTypeNode:createNew()
	do return _g.sling.model.StaticArrayDataTypeNode._construct0(_g.sling.model.StaticArrayDataTypeNode._create()) end
end

function sling.model.StaticArrayDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StaticArrayDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.size ~= nil then
			do n.size:destroy() end
			n.size = nil
		end
		if self.size ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.size), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.size = pcp
			do n.size:setParent(n) end
		end
		do return true end
	end
end

function sling.model.StaticArrayDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.size then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.size:destroy() end
		end
		self.size = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.size ~= nil then
			do self.size:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StaticArrayDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.size ~= nil then
		if self.size:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StaticArrayDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
	if self.size ~= nil then
		do self.size:destroy() end
		self.size = nil
	end
end

function sling.model.StaticArrayDataTypeNode:setSize(v, doExport)
	if self.size ~= nil and doExport == false then
		do self.size:destroy() end
	end
	self.size = v
	if self.size ~= nil then
		do self.size:setParent(self) end
	end
end

function sling.model.StaticArrayDataTypeNode:getSize()
	do return self.size end
end

function sling.model.StaticArrayDataTypeNode:exportSize()
	local v = self.size
	self.size = nil
	do return v end
end

sling.model.AssertStatementNode = _g.sling.common.NodeObject._create()
sling.model.AssertStatementNode.__index = sling.model.AssertStatementNode
_vm:set_metatable(sling.model.AssertStatementNode, {
	__index = _g.sling.common.NodeObject
})

sling.model.AssertStatementNode.STYLE_RETURN = 0
sling.model.AssertStatementNode.STYLE_THROW = 1

function sling.model.AssertStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.AssertStatementNode)
	return v
end

function sling.model.AssertStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AssertStatementNode'
	self['_isType.sling.model.AssertStatementNode'] = true
	self.child = nil
	self.errorBlock = nil
	self.errorMessage = nil
	self.style = 0
end

function sling.model.AssertStatementNode:_construct0()
	sling.model.AssertStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.AssertStatementNode:forChild(xpr)
	local v = _g.sling.model.AssertStatementNode._construct0(_g.sling.model.AssertStatementNode._create())
	do v:setChild(xpr, false) end
	do return v end
end

function sling.model.AssertStatementNode:getNodeTypeName()
	do return "AssertStatementNode" end
end

function sling.model.AssertStatementNode:createNew()
	do return _g.sling.model.AssertStatementNode._construct0(_g.sling.model.AssertStatementNode._create()) end
end

function sling.model.AssertStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AssertStatementNode')
		if n == nil then
			do return true end
		end
		if n.child ~= nil then
			do n.child:destroy() end
			n.child = nil
		end
		if self.child ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.child), '_isType.sling.common.NodeObject')
			if pcp == nil then
				do return false end
			end
			n.child = pcp
			do n.child:setParent(n) end
		end
		if n.errorBlock ~= nil then
			do n.errorBlock:destroy() end
			n.errorBlock = nil
		end
		if self.errorBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.errorBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.errorBlock = pcp
			do n.errorBlock:setParent(n) end
		end
		if n.errorMessage ~= nil then
			do n.errorMessage:destroy() end
			n.errorMessage = nil
		end
		if self.errorMessage ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.errorMessage), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.errorMessage = pcp
			do n.errorMessage:setParent(n) end
		end
		n.style = self.style
		do return true end
	end
end

function sling.model.AssertStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.child then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.child:destroy() end
		end
		self.child = _vm:to_table_with_key(newnode, '_isType.sling.common.NodeObject')
		if self.child ~= nil then
			do self.child:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.errorBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.errorBlock:destroy() end
		end
		self.errorBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.errorBlock ~= nil then
			do self.errorBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.errorMessage then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.errorMessage:destroy() end
		end
		self.errorMessage = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.errorMessage ~= nil then
			do self.errorMessage:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AssertStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.child ~= nil then
		if self.child:accept(visitor) == false then
			do return false end
		end
	end
	if self.errorBlock ~= nil then
		if self.errorBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.errorMessage ~= nil then
		if self.errorMessage:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.AssertStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.child ~= nil then
		do self.child:destroy() end
		self.child = nil
	end
	if self.errorBlock ~= nil then
		do self.errorBlock:destroy() end
		self.errorBlock = nil
	end
	if self.errorMessage ~= nil then
		do self.errorMessage:destroy() end
		self.errorMessage = nil
	end
end

function sling.model.AssertStatementNode:setChild(v, doExport)
	if self.child ~= nil and doExport == false then
		do self.child:destroy() end
	end
	self.child = v
	if self.child ~= nil then
		do self.child:setParent(self) end
	end
end

function sling.model.AssertStatementNode:getChild()
	do return self.child end
end

function sling.model.AssertStatementNode:exportChild()
	local v = self.child
	self.child = nil
	do return v end
end

function sling.model.AssertStatementNode:setErrorBlock(v, doExport)
	if self.errorBlock ~= nil and doExport == false then
		do self.errorBlock:destroy() end
	end
	self.errorBlock = v
	if self.errorBlock ~= nil then
		do self.errorBlock:setParent(self) end
	end
end

function sling.model.AssertStatementNode:getErrorBlock()
	do return self.errorBlock end
end

function sling.model.AssertStatementNode:exportErrorBlock()
	local v = self.errorBlock
	self.errorBlock = nil
	do return v end
end

function sling.model.AssertStatementNode:setErrorMessage(v, doExport)
	if self.errorMessage ~= nil and doExport == false then
		do self.errorMessage:destroy() end
	end
	self.errorMessage = v
	if self.errorMessage ~= nil then
		do self.errorMessage:setParent(self) end
	end
end

function sling.model.AssertStatementNode:getErrorMessage()
	do return self.errorMessage end
end

function sling.model.AssertStatementNode:exportErrorMessage()
	local v = self.errorMessage
	self.errorMessage = nil
	do return v end
end

function sling.model.AssertStatementNode:setStyle(v)
	self.style = v
end

function sling.model.AssertStatementNode:getStyle()
	do return self.style end
end

sling.model.EnumValueNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.EnumValueNode.__index = sling.model.EnumValueNode
_vm:set_metatable(sling.model.EnumValueNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.EnumValueNode._create()
	local v = _vm:set_metatable({}, sling.model.EnumValueNode)
	return v
end

function sling.model.EnumValueNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EnumValueNode'
	self['_isType.sling.model.EnumValueNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
	self.type = nil
	self.value = nil
end

function sling.model.EnumValueNode:_construct0()
	sling.model.EnumValueNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.EnumValueNode:getNodeName()
	do return self.name end
end

function sling.model.EnumValueNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.EnumValueNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.EnumValueNode:getNodeTypeName()
	do return "EnumValueNode" end
end

function sling.model.EnumValueNode:createNew()
	do return _g.sling.model.EnumValueNode._construct0(_g.sling.model.EnumValueNode._create()) end
end

function sling.model.EnumValueNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EnumValueNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.EnumValueNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EnumValueNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.EnumValueNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.EnumValueNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.EnumValueNode:getType()
	do return self.type end
end

function sling.model.EnumValueNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.EnumValueNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.EnumValueNode:getValue()
	do return self.value end
end

function sling.model.EnumValueNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.EnumValueNode:getName()
	do return self.name end
end

sling.model.NamedParameterExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.NamedParameterExpressionNode.__index = sling.model.NamedParameterExpressionNode
_vm:set_metatable(sling.model.NamedParameterExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.NamedParameterExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NamedParameterExpressionNode)
	return v
end

function sling.model.NamedParameterExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NamedParameterExpressionNode'
	self['_isType.sling.model.NamedParameterExpressionNode'] = true
	self.name = nil
	self.value = nil
end

function sling.model.NamedParameterExpressionNode:_construct0()
	sling.model.NamedParameterExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.NamedParameterExpressionNode:getNodeTypeName()
	do return "NamedParameterExpressionNode" end
end

function sling.model.NamedParameterExpressionNode:createNew()
	do return _g.sling.model.NamedParameterExpressionNode._construct0(_g.sling.model.NamedParameterExpressionNode._create()) end
end

function sling.model.NamedParameterExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NamedParameterExpressionNode')
		if n == nil then
			do return true end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.NamedParameterExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NamedParameterExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.NamedParameterExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.NamedParameterExpressionNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.NamedParameterExpressionNode:getValue()
	do return self.value end
end

function sling.model.NamedParameterExpressionNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.NamedParameterExpressionNode:setName(v)
	self.name = v
end

function sling.model.NamedParameterExpressionNode:getName()
	do return self.name end
end

sling.model.TupleExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.TupleExpressionNode.__index = sling.model.TupleExpressionNode
_vm:set_metatable(sling.model.TupleExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.TupleExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TupleExpressionNode)
	return v
end

function sling.model.TupleExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TupleExpressionNode'
	self['_isType.sling.model.TupleExpressionNode'] = true
	self.expressions = nil
end

function sling.model.TupleExpressionNode:_construct0()
	sling.model.TupleExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.TupleExpressionNode:getNodeTypeName()
	do return "TupleExpressionNode" end
end

function sling.model.TupleExpressionNode:createNew()
	do return _g.sling.model.TupleExpressionNode._construct0(_g.sling.model.TupleExpressionNode._create()) end
end

function sling.model.TupleExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TupleExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.TupleExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TupleExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TupleExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.TupleExpressionNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TupleExpressionNode:getExpressions()
	do return self.expressions end
end

function sling.model.TupleExpressionNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.TupleExpressionNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.TupleExpressionNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.SymbolExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.SymbolExpressionNode.__index = sling.model.SymbolExpressionNode
_vm:set_metatable(sling.model.SymbolExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.SymbolExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SymbolExpressionNode)
	return v
end

function sling.model.SymbolExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SymbolExpressionNode'
	self['_isType.sling.model.SymbolExpressionNode'] = true
	self.symbol = nil
end

function sling.model.SymbolExpressionNode:_construct0()
	sling.model.SymbolExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.SymbolExpressionNode:forSymbol(symbol)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	do v:setSymbol(symbol, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forBinding(binding, typemap)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	do v:setSymbol(_g.sling.model.SymbolNode:forBinding(binding, typemap), false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forNameWithTypeParameters(name, typeParameters)
	if typeParameters == nil then
		do return _g.sling.model.SymbolExpressionNode:forName(name) end
	end
	do
		local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
		local nn = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
		local cc = _g.sling.model.SymbolNameComponentNode:forName(name)
		do cc:setTypeParameters(typeParameters, false) end
		do nn:addToComponents(cc) end
		do v:setSymbol(nn, false) end
		do return v end
	end
end

function sling.model.SymbolExpressionNode:forName(name)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nn = _g.sling.model.SymbolNode:forName(name)
	do v:setSymbol(nn, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forBoundName(name, binding, typemap)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nn = _g.sling.model.SymbolNode:forName(name)
	do nn:setBinding(binding, typemap) end
	do v:setSymbol(nn, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:forArrayOfNames(names)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nna = {}
	if names ~= nil then
		local n = 0
		local m = #names
		do
			n = 0
			while n < m do
				local s = (function(o)
					if (_vm:get_variable_type(o) == 'string') then
						do return o end
					end
					do return nil end
				end)(names[n + 1])
				if s ~= nil then
					do _g.jk.lang.Vector:append(nna, s) end
				end
				do n = n + 1 end
			end
		end
	end
	do
		local nn = _g.sling.model.SymbolNode:forVectorOfNames(nna)
		do v:setSymbol(nn, false) end
		do return v end
	end
end

function sling.model.SymbolExpressionNode:forVectorOfNames(names)
	local v = _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create())
	local nn = _g.sling.model.SymbolNode:forVectorOfNames(names)
	do v:setSymbol(nn, false) end
	do return v end
end

function sling.model.SymbolExpressionNode:getNodeTypeName()
	do return "SymbolExpressionNode" end
end

function sling.model.SymbolExpressionNode:createNew()
	do return _g.sling.model.SymbolExpressionNode._construct0(_g.sling.model.SymbolExpressionNode._create()) end
end

function sling.model.SymbolExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SymbolExpressionNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.SymbolExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SymbolExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.SymbolExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.SymbolExpressionNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.SymbolExpressionNode:getSymbol()
	do return self.symbol end
end

function sling.model.SymbolExpressionNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.PropertySetFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.PropertySetFunctionDeclarationNode.__index = sling.model.PropertySetFunctionDeclarationNode
_vm:set_metatable(sling.model.PropertySetFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.PropertySetFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertySetFunctionDeclarationNode)
	return v
end

function sling.model.PropertySetFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertySetFunctionDeclarationNode'
	self['_isType.sling.model.PropertySetFunctionDeclarationNode'] = true
end

function sling.model.PropertySetFunctionDeclarationNode:_construct0()
	sling.model.PropertySetFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.PropertySetFunctionDeclarationNode:setParameter(dt, name)
	do self:clearParameters() end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, name, nil)) end
end

function sling.model.PropertySetFunctionDeclarationNode:getNodeTypeName()
	do return "PropertySetFunctionDeclarationNode" end
end

function sling.model.PropertySetFunctionDeclarationNode:createNew()
	do return _g.sling.model.PropertySetFunctionDeclarationNode._construct0(_g.sling.model.PropertySetFunctionDeclarationNode._create()) end
end

function sling.model.PropertySetFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertySetFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PropertySetFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertySetFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertySetFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.CharacterDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.CharacterDataTypeNode.__index = sling.model.CharacterDataTypeNode
_vm:set_metatable(sling.model.CharacterDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.CharacterDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.CharacterDataTypeNode)
	return v
end

function sling.model.CharacterDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CharacterDataTypeNode'
	self['_isType.sling.model.CharacterDataTypeNode'] = true
end

function sling.model.CharacterDataTypeNode:_construct0()
	sling.model.CharacterDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.CharacterDataTypeNode:getNodeTypeName()
	do return "CharacterDataTypeNode" end
end

function sling.model.CharacterDataTypeNode:createNew()
	do return _g.sling.model.CharacterDataTypeNode._construct0(_g.sling.model.CharacterDataTypeNode._create()) end
end

function sling.model.CharacterDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CharacterDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.CharacterDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CharacterDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CharacterDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.ScriptDeclarationNode = _g.sling.model.EntityDeclarationNode._create()
sling.model.ScriptDeclarationNode.__index = sling.model.ScriptDeclarationNode
_vm:set_metatable(sling.model.ScriptDeclarationNode, {
	__index = _g.sling.model.EntityDeclarationNode
})

function sling.model.ScriptDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.ScriptDeclarationNode)
	return v
end

function sling.model.ScriptDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ScriptDeclarationNode'
	self['_isType.sling.model.ScriptDeclarationNode'] = true
end

function sling.model.ScriptDeclarationNode:_construct0()
	sling.model.ScriptDeclarationNode._init(self)
	do _g.sling.model.EntityDeclarationNode._construct0(self) end
	return self
end

function sling.model.ScriptDeclarationNode:forName(name)
	local v = _g.sling.model.ScriptDeclarationNode._construct0(_g.sling.model.ScriptDeclarationNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.ScriptDeclarationNode:getNodeTypeName()
	do return "ScriptDeclarationNode" end
end

function sling.model.ScriptDeclarationNode:createNew()
	do return _g.sling.model.ScriptDeclarationNode._construct0(_g.sling.model.ScriptDeclarationNode._create()) end
end

function sling.model.ScriptDeclarationNode:copyTo(o)
	if _g.sling.model.EntityDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ScriptDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ScriptDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EntityDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ScriptDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.EntityDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ScriptDeclarationNode:destroy()
	do _g.sling.model.EntityDeclarationNode.destroy(self) end
end

sling.model.CriticalSectionBlockNode = _g.sling.common.NodeObject._create()
sling.model.CriticalSectionBlockNode.__index = sling.model.CriticalSectionBlockNode
_vm:set_metatable(sling.model.CriticalSectionBlockNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CriticalSectionBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CriticalSectionBlockNode)
	return v
end

function sling.model.CriticalSectionBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CriticalSectionBlockNode'
	self['_isType.sling.model.CriticalSectionBlockNode'] = true
	self.object = nil
	self.block = nil
end

function sling.model.CriticalSectionBlockNode:_construct0()
	sling.model.CriticalSectionBlockNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CriticalSectionBlockNode:instance(object, block)
	local v = _g.sling.model.CriticalSectionBlockNode._construct0(_g.sling.model.CriticalSectionBlockNode._create())
	do v:setObject(object, false) end
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.CriticalSectionBlockNode:getNodeTypeName()
	do return "CriticalSectionBlockNode" end
end

function sling.model.CriticalSectionBlockNode:createNew()
	do return _g.sling.model.CriticalSectionBlockNode._construct0(_g.sling.model.CriticalSectionBlockNode._create()) end
end

function sling.model.CriticalSectionBlockNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CriticalSectionBlockNode')
		if n == nil then
			do return true end
		end
		if n.object ~= nil then
			do n.object:destroy() end
			n.object = nil
		end
		if self.object ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.object), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.object = pcp
			do n.object:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CriticalSectionBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.object then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.object:destroy() end
		end
		self.object = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.object ~= nil then
			do self.object:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CriticalSectionBlockNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.object ~= nil then
		if self.object:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CriticalSectionBlockNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.object ~= nil then
		do self.object:destroy() end
		self.object = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.CriticalSectionBlockNode:setObject(v, doExport)
	if self.object ~= nil and doExport == false then
		do self.object:destroy() end
	end
	self.object = v
	if self.object ~= nil then
		do self.object:setParent(self) end
	end
end

function sling.model.CriticalSectionBlockNode:getObject()
	do return self.object end
end

function sling.model.CriticalSectionBlockNode:exportObject()
	local v = self.object
	self.object = nil
	do return v end
end

function sling.model.CriticalSectionBlockNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.CriticalSectionBlockNode:getBlock()
	do return self.block end
end

function sling.model.CriticalSectionBlockNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.TypeInfoDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.TypeInfoDataTypeNode.__index = sling.model.TypeInfoDataTypeNode
_vm:set_metatable(sling.model.TypeInfoDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.TypeInfoDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.TypeInfoDataTypeNode)
	return v
end

function sling.model.TypeInfoDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TypeInfoDataTypeNode'
	self['_isType.sling.model.TypeInfoDataTypeNode'] = true
end

function sling.model.TypeInfoDataTypeNode:_construct0()
	sling.model.TypeInfoDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.TypeInfoDataTypeNode:getNodeTypeName()
	do return "TypeInfoDataTypeNode" end
end

function sling.model.TypeInfoDataTypeNode:createNew()
	do return _g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create()) end
end

function sling.model.TypeInfoDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TypeInfoDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.TypeInfoDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TypeInfoDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TypeInfoDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.FunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.FunctionDeclarationNode.__index = sling.model.FunctionDeclarationNode
_vm:set_metatable(sling.model.FunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.FunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDeclarationNode)
	return v
end

function sling.model.FunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDeclarationNode'
	self['_isType.sling.model.FunctionDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.returnType = nil
	self.name = nil
	self.baseClassDeclaration = nil
	self.implementedDeclarations = nil
	self.overridingDeclarations = nil
	self.baseClassDeclarationTypeMap = nil
end

function sling.model.FunctionDeclarationNode:_construct0()
	sling.model.FunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.FunctionDeclarationNode:forName(name, isPublic)
	local v = _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create())
	do v:setReturnType(_g.sling.model.VoidDataTypeNode._construct0(_g.sling.model.VoidDataTypeNode._create()), false) end
	do v:setName(name) end
	if isPublic then
		do v:addToModifiers(_g.sling.model.CommonModifierNode:forType(_g.sling.model.Modifier.PUBLIC)) end
	end
	do return v end
end

function sling.model.FunctionDeclarationNode:getBaseClassDeclaration()
	do return self.baseClassDeclaration end
end

function sling.model.FunctionDeclarationNode:setBaseClassDeclaration(v, typemap)
	self.baseClassDeclaration = v
	self.baseClassDeclarationTypeMap = typemap
end

function sling.model.FunctionDeclarationNode:getOverridingDeclarations()
	do return self.overridingDeclarations end
end

function sling.model.FunctionDeclarationNode:setOverridingDeclarations(decls)
	self.overridingDeclarations = decls
end

function sling.model.FunctionDeclarationNode:addToOverridingDeclarations(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.overridingDeclarations ~= nil) then
		self.overridingDeclarations = {}
	end
	do _g.jk.lang.Vector:append(self.overridingDeclarations, decl) end
end

function sling.model.FunctionDeclarationNode:getImplementedDeclarations()
	do return self.implementedDeclarations end
end

function sling.model.FunctionDeclarationNode:setImplementedDeclarations(decls)
	self.implementedDeclarations = decls
end

function sling.model.FunctionDeclarationNode:addToImplementedDeclarations(decl)
	if not (decl ~= nil) then
		do return end
	end
	if not (self.implementedDeclarations ~= nil) then
		self.implementedDeclarations = {}
	end
	do _g.jk.lang.Vector:append(self.implementedDeclarations, decl) end
end

function sling.model.FunctionDeclarationNode:getReturnType()
	local bc = self:getBaseClassDeclaration()
	if bc ~= nil then
		local v = bc:getReturnType()
		if v ~= nil then
			if not (self.baseClassDeclarationTypeMap ~= nil) then
				do return v end
			end
			do
				local ddt = self.baseClassDeclarationTypeMap:get(self:getReturnTypeQualifiedNameString(v))
				if ddt ~= nil then
					do return ddt end
				end
				do return v end
			end
		end
	end
	do return self.returnType end
end

function sling.model.FunctionDeclarationNode:getReturnTypeQualifiedNameString(baseReturnType)
	local bd = _vm:to_table_with_key(baseReturnType, '_isType.sling.model.ReferenceDataTypeNode')
	if not (bd ~= nil) then
		do return nil end
	end
	do
		local symbol = bd:getSymbol()
		if not (symbol ~= nil) then
			do return nil end
		end
		do
			local binding = _vm:to_table_with_key(symbol:getBinding(), '_isType.sling.model.EntityDeclarationNode')
			if not (binding ~= nil) then
				do return nil end
			end
			do
				local vv = {}
				local nn = binding
				while nn ~= nil do
					if not (nn ~= nil) then
						do break end
					end
					if (_vm:to_table_with_key(nn, '_isType.sling.common.NamedNode') ~= nil) then
						do _g.jk.lang.Vector:prepend(vv, nn:getNodeName()) end
					end
					do
						local pp = nn:getParent()
						nn = pp
					end
				end
				do
					local sb = _g.jk.lang.StringBuilder._construct0(_g.jk.lang.StringBuilder._create())
					if vv ~= nil then
						local n = 0
						local m = _g.jk.lang.Vector:getSize(vv)
						do
							n = 0
							while n < m do
								local comp = (function(o)
									if (_vm:get_variable_type(o) == 'string') then
										do return o end
									end
									do return nil end
								end)(vv[n + 1])
								if comp ~= nil then
									if sb:count() > 0 then
										do sb:appendCharacter(46) end
									end
									do sb:appendString(comp) end
								end
								do n = n + 1 end
							end
						end
					end
					do return sb:toString() end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationNode:getOwnReturnType()
	do return self.returnType end
end

function sling.model.FunctionDeclarationNode:dupDeclaration()
	local v = _vm:to_table_with_key(self:dup(), '_isType.sling.model.FunctionDeclarationNode')
	if not (v ~= nil) then
		do return nil end
	end
	do v:setBody(nil, false) end
	do return v end
end

function sling.model.FunctionDeclarationNode:getNodeName()
	local bc = self:getBaseClassDeclaration()
	if bc ~= nil then
		local v = bc:getNodeName()
		if v ~= nil then
			do return v end
		end
	end
	do return self:getName() end
end

function sling.model.FunctionDeclarationNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.FunctionDeclarationNode:setName(name)
	self.name = name
	do self:onIndexPropertiesChanged() end
end

function sling.model.FunctionDeclarationNode:getNodeTypeName()
	do return "FunctionDeclarationNode" end
end

function sling.model.FunctionDeclarationNode:createNew()
	do return _g.sling.model.FunctionDeclarationNode._construct0(_g.sling.model.FunctionDeclarationNode._create()) end
end

function sling.model.FunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.returnType ~= nil then
			do n.returnType:destroy() end
			n.returnType = nil
		end
		if self.returnType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.returnType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.returnType = pcp
			do n.returnType:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.FunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.returnType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.returnType:destroy() end
		end
		self.returnType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.returnType ~= nil then
			do self.returnType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.returnType ~= nil then
		if self.returnType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.FunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
	if self.returnType ~= nil then
		do self.returnType:destroy() end
		self.returnType = nil
	end
end

function sling.model.FunctionDeclarationNode:setReturnType(v, doExport)
	if self.returnType ~= nil and doExport == false then
		do self.returnType:destroy() end
	end
	self.returnType = v
	if self.returnType ~= nil then
		do self.returnType:setParent(self) end
	end
end

function sling.model.FunctionDeclarationNode:exportReturnType()
	local v = self.returnType
	self.returnType = nil
	do return v end
end

function sling.model.FunctionDeclarationNode:getName()
	do return self.name end
end

sling.model.FailureLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.FailureLiteralExpressionNode.__index = sling.model.FailureLiteralExpressionNode
_vm:set_metatable(sling.model.FailureLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.FailureLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FailureLiteralExpressionNode)
	return v
end

function sling.model.FailureLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FailureLiteralExpressionNode'
	self['_isType.sling.model.FailureLiteralExpressionNode'] = true
end

function sling.model.FailureLiteralExpressionNode:_construct0()
	sling.model.FailureLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	return self
end

function sling.model.FailureLiteralExpressionNode:getNodeTypeName()
	do return "FailureLiteralExpressionNode" end
end

function sling.model.FailureLiteralExpressionNode:createNew()
	do return _g.sling.model.FailureLiteralExpressionNode._construct0(_g.sling.model.FailureLiteralExpressionNode._create()) end
end

function sling.model.FailureLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FailureLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FailureLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FailureLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FailureLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

sling.model.DynamicAndExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.DynamicAndExpressionNode.__index = sling.model.DynamicAndExpressionNode
_vm:set_metatable(sling.model.DynamicAndExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.DynamicAndExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicAndExpressionNode)
	return v
end

function sling.model.DynamicAndExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicAndExpressionNode'
	self['_isType.sling.model.DynamicAndExpressionNode'] = true
end

function sling.model.DynamicAndExpressionNode:_construct0()
	sling.model.DynamicAndExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.DynamicAndExpressionNode:instance(left, right)
	local v = _g.sling.model.DynamicAndExpressionNode._construct0(_g.sling.model.DynamicAndExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.DynamicAndExpressionNode:getNodeTypeName()
	do return "DynamicAndExpressionNode" end
end

function sling.model.DynamicAndExpressionNode:createNew()
	do return _g.sling.model.DynamicAndExpressionNode._construct0(_g.sling.model.DynamicAndExpressionNode._create()) end
end

function sling.model.DynamicAndExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicAndExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicAndExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicAndExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicAndExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.ParentDataTypeNode = _g.sling.model.ReferenceDataTypeNode._create()
sling.model.ParentDataTypeNode.__index = sling.model.ParentDataTypeNode
_vm:set_metatable(sling.model.ParentDataTypeNode, {
	__index = _g.sling.model.ReferenceDataTypeNode
})

function sling.model.ParentDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ParentDataTypeNode)
	return v
end

function sling.model.ParentDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ParentDataTypeNode'
	self['_isType.sling.model.ParentDataTypeNode'] = true
end

function sling.model.ParentDataTypeNode:_construct0()
	sling.model.ParentDataTypeNode._init(self)
	do _g.sling.model.ReferenceDataTypeNode._construct0(self) end
	return self
end

function sling.model.ParentDataTypeNode:getNodeTypeName()
	do return "ParentDataTypeNode" end
end

function sling.model.ParentDataTypeNode:createNew()
	do return _g.sling.model.ParentDataTypeNode._construct0(_g.sling.model.ParentDataTypeNode._create()) end
end

function sling.model.ParentDataTypeNode:copyTo(o)
	if _g.sling.model.ReferenceDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ParentDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ParentDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ReferenceDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ParentDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.ReferenceDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ParentDataTypeNode:destroy()
	do _g.sling.model.ReferenceDataTypeNode.destroy(self) end
end

sling.model.FloatLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.FloatLiteralExpressionNode.__index = sling.model.FloatLiteralExpressionNode
_vm:set_metatable(sling.model.FloatLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

sling.model.FloatLiteralExpressionNode.FORMAT_DECIMAL = 0
sling.model.FloatLiteralExpressionNode.FORMAT_HEXADECIMAL = 1

function sling.model.FloatLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FloatLiteralExpressionNode)
	return v
end

function sling.model.FloatLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloatLiteralExpressionNode'
	self['_isType.sling.model.FloatLiteralExpressionNode'] = true
	self.value = 0.0
	self.format = 0
end

function sling.model.FloatLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.FloatLiteralExpressionNode._construct0(_g.sling.model.FloatLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.FloatLiteralExpressionNode:_construct0()
	sling.model.FloatLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.FloatDataTypeNode._construct0(_g.sling.model.FloatDataTypeNode._create()), false) end
	return self
end

function sling.model.FloatLiteralExpressionNode:getNodeTypeName()
	do return "FloatLiteralExpressionNode" end
end

function sling.model.FloatLiteralExpressionNode:createNew()
	do return _g.sling.model.FloatLiteralExpressionNode._construct0(_g.sling.model.FloatLiteralExpressionNode._create()) end
end

function sling.model.FloatLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloatLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		n.format = self.format
		do return true end
	end
end

function sling.model.FloatLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloatLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloatLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.FloatLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.FloatLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.FloatLiteralExpressionNode:setFormat(v)
	self.format = v
end

function sling.model.FloatLiteralExpressionNode:getFormat()
	do return self.format end
end

sling.model.LessThanExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.LessThanExpressionNode.__index = sling.model.LessThanExpressionNode
_vm:set_metatable(sling.model.LessThanExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.LessThanExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LessThanExpressionNode)
	return v
end

function sling.model.LessThanExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LessThanExpressionNode'
	self['_isType.sling.model.LessThanExpressionNode'] = true
end

function sling.model.LessThanExpressionNode:_construct0()
	sling.model.LessThanExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.LessThanExpressionNode:instance(left, right)
	local v = _g.sling.model.LessThanExpressionNode._construct0(_g.sling.model.LessThanExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LessThanExpressionNode:getNodeTypeName()
	do return "LessThanExpressionNode" end
end

function sling.model.LessThanExpressionNode:createNew()
	do return _g.sling.model.LessThanExpressionNode._construct0(_g.sling.model.LessThanExpressionNode._create()) end
end

function sling.model.LessThanExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LessThanExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LessThanExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LessThanExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LessThanExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.ForEachStatementNode = _g.sling.model.StatementNode._create()
sling.model.ForEachStatementNode.__index = sling.model.ForEachStatementNode
_vm:set_metatable(sling.model.ForEachStatementNode, {
	__index = _g.sling.model.StatementNode
})

function sling.model.ForEachStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ForEachStatementNode)
	return v
end

function sling.model.ForEachStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ForEachStatementNode'
	self['_isType.sling.model.ForEachStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.lefts = nil
	self.right = nil
	self.block = nil
	self.condition = nil
	self.elseBlock = nil
	self.defaultDataType = nil
	self.iterateKeys = false
end

function sling.model.ForEachStatementNode:_construct0()
	sling.model.ForEachStatementNode._init(self)
	do _g.sling.model.StatementNode._construct0(self) end
	return self
end

function sling.model.ForEachStatementNode:instance(left, right, block, elseBlock)
	local v = _g.sling.model.ForEachStatementNode._construct0(_g.sling.model.ForEachStatementNode._create())
	do v:setLeft(left) end
	do v:setRight(right, false) end
	do v:setBlock(block, false) end
	do v:setElseBlock(elseBlock, false) end
	do return v end
end

function sling.model.ForEachStatementNode:getLeft()
	if not (self.lefts ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.lefts, 0), '_isType.sling.common.NodeObject') end
end

function sling.model.ForEachStatementNode:getLeftCount()
	if not (self.lefts ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.lefts) end
end

function sling.model.ForEachStatementNode:setLeft(value)
	do self:setLefts(nil, false) end
	do self:addToLefts(value) end
	do return self end
end

function sling.model.ForEachStatementNode:exportLeft()
	local v = self:getLeft()
	self.lefts = nil
	do return v end
end

function sling.model.ForEachStatementNode:getNodeTypeName()
	do return "ForEachStatementNode" end
end

function sling.model.ForEachStatementNode:createNew()
	do return _g.sling.model.ForEachStatementNode._construct0(_g.sling.model.ForEachStatementNode._create()) end
end

function sling.model.ForEachStatementNode:copyTo(o)
	if _g.sling.model.StatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ForEachStatementNode')
		if n == nil then
			do return true end
		end
		if n.right ~= nil then
			do n.right:destroy() end
			n.right = nil
		end
		if self.right ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.right), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.right = pcp
			do n.right:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.elseBlock ~= nil then
			do n.elseBlock:destroy() end
			n.elseBlock = nil
		end
		if self.elseBlock ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.elseBlock), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.elseBlock = pcp
			do n.elseBlock:setParent(n) end
		end
		if n.defaultDataType ~= nil then
			do n.defaultDataType:destroy() end
			n.defaultDataType = nil
		end
		if self.defaultDataType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.defaultDataType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.defaultDataType = pcp
			do n.defaultDataType:setParent(n) end
		end
		n.iterateKeys = self.iterateKeys
		do
			local array = n.lefts
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.lefts = nil
			if self.lefts ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.lefts)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.lefts[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.lefts == nil then
								n.lefts = {}
							end
							do _g.jk.lang.Vector:append(n.lefts, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ForEachStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.right then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.right:destroy() end
		end
		self.right = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.right ~= nil then
			do self.right:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.elseBlock then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.elseBlock:destroy() end
		end
		self.elseBlock = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.elseBlock ~= nil then
			do self.elseBlock:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.defaultDataType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.defaultDataType:destroy() end
		end
		self.defaultDataType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.defaultDataType ~= nil then
			do self.defaultDataType:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.lefts, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.StatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ForEachStatementNode:acceptVisitor(visitor)
	if _g.sling.model.StatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.right ~= nil then
		if self.right:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.elseBlock ~= nil then
		if self.elseBlock:accept(visitor) == false then
			do return false end
		end
	end
	if self.defaultDataType ~= nil then
		if self.defaultDataType:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.lefts, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ForEachStatementNode:destroy()
	do _g.sling.model.StatementNode.destroy(self) end
	if self.right ~= nil then
		do self.right:destroy() end
		self.right = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.elseBlock ~= nil then
		do self.elseBlock:destroy() end
		self.elseBlock = nil
	end
	if self.defaultDataType ~= nil then
		do self.defaultDataType:destroy() end
		self.defaultDataType = nil
	end
	if self.lefts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.lefts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.lefts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.lefts = nil
end

function sling.model.ForEachStatementNode:setRight(v, doExport)
	if self.right ~= nil and doExport == false then
		do self.right:destroy() end
	end
	self.right = v
	if self.right ~= nil then
		do self.right:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getRight()
	do return self.right end
end

function sling.model.ForEachStatementNode:exportRight()
	local v = self.right
	self.right = nil
	do return v end
end

function sling.model.ForEachStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getBlock()
	do return self.block end
end

function sling.model.ForEachStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

function sling.model.ForEachStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getCondition()
	do return self.condition end
end

function sling.model.ForEachStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.ForEachStatementNode:setElseBlock(v, doExport)
	if self.elseBlock ~= nil and doExport == false then
		do self.elseBlock:destroy() end
	end
	self.elseBlock = v
	if self.elseBlock ~= nil then
		do self.elseBlock:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getElseBlock()
	do return self.elseBlock end
end

function sling.model.ForEachStatementNode:exportElseBlock()
	local v = self.elseBlock
	self.elseBlock = nil
	do return v end
end

function sling.model.ForEachStatementNode:setDefaultDataType(v, doExport)
	if self.defaultDataType ~= nil and doExport == false then
		do self.defaultDataType:destroy() end
	end
	self.defaultDataType = v
	if self.defaultDataType ~= nil then
		do self.defaultDataType:setParent(self) end
	end
end

function sling.model.ForEachStatementNode:getDefaultDataType()
	do return self.defaultDataType end
end

function sling.model.ForEachStatementNode:exportDefaultDataType()
	local v = self.defaultDataType
	self.defaultDataType = nil
	do return v end
end

function sling.model.ForEachStatementNode:setIterateKeys(v)
	self.iterateKeys = v
end

function sling.model.ForEachStatementNode:getIterateKeys()
	do return self.iterateKeys end
end

function sling.model.ForEachStatementNode:setLefts(v, doExport)
	if self.lefts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.lefts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.lefts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.lefts = nil
	else
		self.lefts = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.lefts, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ForEachStatementNode:getLefts()
	do return self.lefts end
end

function sling.model.ForEachStatementNode:exportLefts()
	local v = self.lefts
	self.lefts = nil
	do return v end
end

function sling.model.ForEachStatementNode:addToLefts(v)
	if v == nil then
		do return end
	end
	if self.lefts == nil then
		self.lefts = {}
	end
	do _g.jk.lang.Vector:append(self.lefts, v) end
	do v:setParent(self) end
end

function sling.model.ForEachStatementNode:clearLefts()
	if self.lefts ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.lefts)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.lefts[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.lefts = nil
end

sling.model.FunctionCallExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.FunctionCallExpressionNode.__index = sling.model.FunctionCallExpressionNode
_vm:set_metatable(sling.model.FunctionCallExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.FunctionCallExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionCallExpressionNode)
	return v
end

function sling.model.FunctionCallExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionCallExpressionNode'
	self['_isType.sling.model.FunctionCallExpressionNode'] = true
	self.expression = nil
	self.parameters = nil
	self.trailingParameter = nil
	self.isolated = false
end

function sling.model.FunctionCallExpressionNode:_construct0()
	sling.model.FunctionCallExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.FunctionCallExpressionNode:forName(name)
	do return _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forName(name)) end
end

function sling.model.FunctionCallExpressionNode:forNameWithParams(name, params)
	local v = _g.sling.model.FunctionCallExpressionNode:forName(name)
	if params ~= nil then
		local n = 0
		local m = #params
		do
			n = 0
			while n < m do
				local param = params[n + 1]
				if param ~= nil then
					do v:addToParameters(param) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.FunctionCallExpressionNode:forExpression(expr)
	local v = _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create())
	do v:setExpression(expr, false) end
	do return v end
end

function sling.model.FunctionCallExpressionNode:forMethod(parent, methodName, isStatic)
	if not _g.jk.lang.String:isNotEmpty(methodName) then
		do return nil end
	end
	if not (parent ~= nil) then
		do return _g.sling.model.FunctionCallExpressionNode:forName(methodName) end
	end
	do
		local xpr = _g.sling.model.MemberAccessExpressionNode:append(_g.sling.model.SymbolExpressionNode:forName(methodName), parent)
		if (_vm:to_table_with_key(xpr, '_isType.sling.model.MemberAccessExpressionNode') ~= nil) then
			if isStatic then
				do xpr:setAccessType(_g.sling.model.MemberAccessExpressionNode.TYPE_STATIC) end
			else
				do xpr:setAccessType(_g.sling.model.MemberAccessExpressionNode.TYPE_INSTANCE_FUNCTION) end
			end
		end
		do return _g.sling.model.FunctionCallExpressionNode:forExpression(xpr) end
	end
end

function sling.model.FunctionCallExpressionNode:forNames(names)
	do return _g.sling.model.FunctionCallExpressionNode:forExpression(_g.sling.model.SymbolExpressionNode:forArrayOfNames(names)) end
end

function sling.model.FunctionCallExpressionNode:getParameterCount()
	if not (self.parameters ~= nil) then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.parameters) end
end

function sling.model.FunctionCallExpressionNode:exportOneParameter()
	local params = self:getParameters()
	if not (params ~= nil) then
		do return nil end
	end
	if not (_g.jk.lang.Vector:getSize(params) == 1) then
		do return nil end
	end
	do
		local param = _vm:to_table_with_key(_g.jk.lang.Vector:get(params, 0), '_isType.sling.model.ExpressionNode')
		if not (param ~= nil) then
			do return nil end
		end
		do self:exportParameters() end
		do return param end
	end
end

function sling.model.FunctionCallExpressionNode:setParameter(index, node)
	if not (self.parameters ~= nil) then
		do return end
	end
	do
		local current = _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, index), '_isType.sling.model.ExpressionNode')
		if current ~= nil then
			do current:destroy() end
			do _g.jk.lang.Vector:set(self.parameters, index, node) end
			if node ~= nil then
				do node:setParent(self) end
			end
		end
	end
end

function sling.model.FunctionCallExpressionNode:addStringToParameters(value)
	do self:addToParameters(_g.sling.model.StringLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:addIntegerToParameters(value)
	do self:addToParameters(_g.sling.model.IntegerLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:addDoubleToParameters(value)
	do self:addToParameters(_g.sling.model.DoubleLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:addBooleanToParameters(value)
	do self:addToParameters(_g.sling.model.BooleanLiteralExpressionNode:forValue(value)) end
end

function sling.model.FunctionCallExpressionNode:prependParameter(param)
	if not (param ~= nil) then
		do return end
	end
	if self.parameters == nil then
		do self:addToParameters(param) end
		do return end
	end
	do _g.jk.lang.Vector:prepend(self.parameters, param) end
	do param:setParent(self) end
end

function sling.model.FunctionCallExpressionNode:getParameter(n)
	if not (self.parameters ~= nil) then
		do return nil end
	end
	do return _vm:to_table_with_key(_g.jk.lang.Vector:get(self.parameters, n), '_isType.sling.model.ExpressionNode') end
end

function sling.model.FunctionCallExpressionNode:getNodeTypeName()
	do return "FunctionCallExpressionNode" end
end

function sling.model.FunctionCallExpressionNode:createNew()
	do return _g.sling.model.FunctionCallExpressionNode._construct0(_g.sling.model.FunctionCallExpressionNode._create()) end
end

function sling.model.FunctionCallExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionCallExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		if n.trailingParameter ~= nil then
			do n.trailingParameter:destroy() end
			n.trailingParameter = nil
		end
		if self.trailingParameter ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.trailingParameter), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.trailingParameter = pcp
			do n.trailingParameter:setParent(n) end
		end
		n.isolated = self.isolated
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.FunctionCallExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.trailingParameter then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.trailingParameter:destroy() end
		end
		self.trailingParameter = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.trailingParameter ~= nil then
			do self.trailingParameter:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionCallExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	if self.trailingParameter ~= nil then
		if self.trailingParameter:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FunctionCallExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
	if self.trailingParameter ~= nil then
		do self.trailingParameter:destroy() end
		self.trailingParameter = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.FunctionCallExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.FunctionCallExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.FunctionCallExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

function sling.model.FunctionCallExpressionNode:setTrailingParameter(v, doExport)
	if self.trailingParameter ~= nil and doExport == false then
		do self.trailingParameter:destroy() end
	end
	self.trailingParameter = v
	if self.trailingParameter ~= nil then
		do self.trailingParameter:setParent(self) end
	end
end

function sling.model.FunctionCallExpressionNode:getTrailingParameter()
	do return self.trailingParameter end
end

function sling.model.FunctionCallExpressionNode:exportTrailingParameter()
	local v = self.trailingParameter
	self.trailingParameter = nil
	do return v end
end

function sling.model.FunctionCallExpressionNode:setIsolated(v)
	self.isolated = v
end

function sling.model.FunctionCallExpressionNode:getIsolated()
	do return self.isolated end
end

function sling.model.FunctionCallExpressionNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionCallExpressionNode:getParameters()
	do return self.parameters end
end

function sling.model.FunctionCallExpressionNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.FunctionCallExpressionNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.FunctionCallExpressionNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

sling.model.ThisDataTypeNode = _g.sling.model.ReferenceDataTypeNode._create()
sling.model.ThisDataTypeNode.__index = sling.model.ThisDataTypeNode
_vm:set_metatable(sling.model.ThisDataTypeNode, {
	__index = _g.sling.model.ReferenceDataTypeNode
})

function sling.model.ThisDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ThisDataTypeNode)
	return v
end

function sling.model.ThisDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ThisDataTypeNode'
	self['_isType.sling.model.ThisDataTypeNode'] = true
end

function sling.model.ThisDataTypeNode:_construct0()
	sling.model.ThisDataTypeNode._init(self)
	do _g.sling.model.ReferenceDataTypeNode._construct0(self) end
	return self
end

function sling.model.ThisDataTypeNode:getNodeTypeName()
	do return "ThisDataTypeNode" end
end

function sling.model.ThisDataTypeNode:createNew()
	do return _g.sling.model.ThisDataTypeNode._construct0(_g.sling.model.ThisDataTypeNode._create()) end
end

function sling.model.ThisDataTypeNode:copyTo(o)
	if _g.sling.model.ReferenceDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ThisDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ThisDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ReferenceDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ThisDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.ReferenceDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ThisDataTypeNode:destroy()
	do _g.sling.model.ReferenceDataTypeNode.destroy(self) end
end

sling.model.BreakLabelStatementNode = _g.sling.model.LabeledControlStatementNode._create()
sling.model.BreakLabelStatementNode.__index = sling.model.BreakLabelStatementNode
_vm:set_metatable(sling.model.BreakLabelStatementNode, {
	__index = _g.sling.model.LabeledControlStatementNode
})

function sling.model.BreakLabelStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.BreakLabelStatementNode)
	return v
end

function sling.model.BreakLabelStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BreakLabelStatementNode'
	self['_isType.sling.model.BreakLabelStatementNode'] = true
end

function sling.model.BreakLabelStatementNode:_construct0()
	sling.model.BreakLabelStatementNode._init(self)
	do _g.sling.model.LabeledControlStatementNode._construct0(self) end
	return self
end

function sling.model.BreakLabelStatementNode:forLabel(label)
	local v = _g.sling.model.BreakLabelStatementNode._construct0(_g.sling.model.BreakLabelStatementNode._create())
	do v:setLabel(label) end
	do return v end
end

function sling.model.BreakLabelStatementNode:getNodeTypeName()
	do return "BreakLabelStatementNode" end
end

function sling.model.BreakLabelStatementNode:createNew()
	do return _g.sling.model.BreakLabelStatementNode._construct0(_g.sling.model.BreakLabelStatementNode._create()) end
end

function sling.model.BreakLabelStatementNode:copyTo(o)
	if _g.sling.model.LabeledControlStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BreakLabelStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BreakLabelStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LabeledControlStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BreakLabelStatementNode:acceptVisitor(visitor)
	if _g.sling.model.LabeledControlStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BreakLabelStatementNode:destroy()
	do _g.sling.model.LabeledControlStatementNode.destroy(self) end
end

sling.model.ForStatementNode = _g.sling.model.StatementNode._create()
sling.model.ForStatementNode.__index = sling.model.ForStatementNode
_vm:set_metatable(sling.model.ForStatementNode, {
	__index = _g.sling.model.StatementNode
})

function sling.model.ForStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ForStatementNode)
	return v
end

function sling.model.ForStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ForStatementNode'
	self['_isType.sling.model.ForStatementNode'] = true
	self['_isType.sling.model.LoopStatementNode'] = true
	self.initializer = nil
	self.condition = nil
	self.finalizer = nil
	self.block = nil
end

function sling.model.ForStatementNode:_construct0()
	sling.model.ForStatementNode._init(self)
	do _g.sling.model.StatementNode._construct0(self) end
	return self
end

function sling.model.ForStatementNode:instance(initializer, condition, finalizer, block)
	local v = _g.sling.model.ForStatementNode._construct0(_g.sling.model.ForStatementNode._create())
	do v:setInitializer(initializer, false) end
	do v:setCondition(condition, false) end
	do v:setFinalizer(finalizer, false) end
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.ForStatementNode:addInitializer(node)
	if node ~= nil then
		if self.initializer == nil then
			do self:setInitializer(_g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()), false) end
		end
		do self.initializer:addNode(node) end
	end
	do return self end
end

function sling.model.ForStatementNode:addFinalizer(node)
	if node ~= nil then
		if self.finalizer == nil then
			do self:setFinalizer(_g.sling.model.FlatBlockNode._construct0(_g.sling.model.FlatBlockNode._create()), false) end
		end
		do self.finalizer:addNode(node) end
	end
	do return self end
end

function sling.model.ForStatementNode:getNodeTypeName()
	do return "ForStatementNode" end
end

function sling.model.ForStatementNode:createNew()
	do return _g.sling.model.ForStatementNode._construct0(_g.sling.model.ForStatementNode._create()) end
end

function sling.model.ForStatementNode:copyTo(o)
	if _g.sling.model.StatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ForStatementNode')
		if n == nil then
			do return true end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.finalizer ~= nil then
			do n.finalizer:destroy() end
			n.finalizer = nil
		end
		if self.finalizer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.finalizer), '_isType.sling.model.FlatBlockNode')
			if pcp == nil then
				do return false end
			end
			n.finalizer = pcp
			do n.finalizer:setParent(n) end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ForStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.finalizer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.finalizer:destroy() end
		end
		self.finalizer = _vm:to_table_with_key(newnode, '_isType.sling.model.FlatBlockNode')
		if self.finalizer ~= nil then
			do self.finalizer:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.StatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ForStatementNode:acceptVisitor(visitor)
	if _g.sling.model.StatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.finalizer ~= nil then
		if self.finalizer:accept(visitor) == false then
			do return false end
		end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ForStatementNode:destroy()
	do _g.sling.model.StatementNode.destroy(self) end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.finalizer ~= nil then
		do self.finalizer:destroy() end
		self.finalizer = nil
	end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.ForStatementNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.ForStatementNode:getInitializer()
	do return self.initializer end
end

function sling.model.ForStatementNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.ForStatementNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.ForStatementNode:getCondition()
	do return self.condition end
end

function sling.model.ForStatementNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.ForStatementNode:setFinalizer(v, doExport)
	if self.finalizer ~= nil and doExport == false then
		do self.finalizer:destroy() end
	end
	self.finalizer = v
	if self.finalizer ~= nil then
		do self.finalizer:setParent(self) end
	end
end

function sling.model.ForStatementNode:getFinalizer()
	do return self.finalizer end
end

function sling.model.ForStatementNode:exportFinalizer()
	local v = self.finalizer
	self.finalizer = nil
	do return v end
end

function sling.model.ForStatementNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.ForStatementNode:getBlock()
	do return self.block end
end

function sling.model.ForStatementNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end

sling.model.StyleSheetDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.StyleSheetDataTypeNode.__index = sling.model.StyleSheetDataTypeNode
_vm:set_metatable(sling.model.StyleSheetDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.StyleSheetDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.StyleSheetDataTypeNode)
	return v
end

function sling.model.StyleSheetDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StyleSheetDataTypeNode'
	self['_isType.sling.model.StyleSheetDataTypeNode'] = true
end

function sling.model.StyleSheetDataTypeNode:_construct0()
	sling.model.StyleSheetDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.StyleSheetDataTypeNode:getNodeTypeName()
	do return "StyleSheetDataTypeNode" end
end

function sling.model.StyleSheetDataTypeNode:createNew()
	do return _g.sling.model.StyleSheetDataTypeNode._construct0(_g.sling.model.StyleSheetDataTypeNode._create()) end
end

function sling.model.StyleSheetDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StyleSheetDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StyleSheetDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StyleSheetDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StyleSheetDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.AwaitExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.AwaitExpressionNode.__index = sling.model.AwaitExpressionNode
_vm:set_metatable(sling.model.AwaitExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.AwaitExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AwaitExpressionNode)
	return v
end

function sling.model.AwaitExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AwaitExpressionNode'
	self['_isType.sling.model.AwaitExpressionNode'] = true
end

function sling.model.AwaitExpressionNode:_construct0()
	sling.model.AwaitExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.AwaitExpressionNode:forExpression(expression)
	local v = _g.sling.model.AwaitExpressionNode._construct0(_g.sling.model.AwaitExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.AwaitExpressionNode:getNodeTypeName()
	do return "AwaitExpressionNode" end
end

function sling.model.AwaitExpressionNode:createNew()
	do return _g.sling.model.AwaitExpressionNode._construct0(_g.sling.model.AwaitExpressionNode._create()) end
end

function sling.model.AwaitExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AwaitExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AwaitExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AwaitExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AwaitExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ResourceFileNode = _g.sling.common.NodeObject._create()
sling.model.ResourceFileNode.__index = sling.model.ResourceFileNode
_vm:set_metatable(sling.model.ResourceFileNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ResourceFileNode._create()
	local v = _vm:set_metatable({}, sling.model.ResourceFileNode)
	return v
end

function sling.model.ResourceFileNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ResourceFileNode'
	self['_isType.sling.model.ResourceFileNode'] = true
	self.file = nil
	self.buffer = nil
	self.fileName = nil
	self.condition = nil
end

function sling.model.ResourceFileNode:_construct0()
	sling.model.ResourceFileNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ResourceFileNode:forFile(file)
	local v = _g.sling.model.ResourceFileNode._construct0(_g.sling.model.ResourceFileNode._create())
	do v:setFile(file) end
	do v:setSource(_g.sling.common.StaticSourceReference:forFile(file)) end
	do return v end
end

function sling.model.ResourceFileNode:getName()
	if self.fileName ~= nil then
		do return self.fileName end
	end
	if not (self.file ~= nil) then
		do return nil end
	end
	do return self.file:baseName() end
end

function sling.model.ResourceFileNode:getNameWithoutExtension()
	if self.fileName ~= nil then
		local dot = _g.jk.lang.String:getLastIndexOfCharacter(self.fileName, 46, -1)
		if dot < 1 then
			do return self.fileName end
		end
		do return _g.jk.lang.String:getSubString(self.fileName, 0, dot) end
	end
	if not (self.file ~= nil) then
		do return nil end
	end
	do return self.file:baseNameWithoutExtension() end
end

function sling.model.ResourceFileNode:getPath()
	if not (self.file ~= nil) then
		do return nil end
	end
	do return self.file:getPath() end
end

function sling.model.ResourceFileNode:getNodeTypeName()
	do return "ResourceFileNode" end
end

function sling.model.ResourceFileNode:createNew()
	do return _g.sling.model.ResourceFileNode._construct0(_g.sling.model.ResourceFileNode._create()) end
end

function sling.model.ResourceFileNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ResourceFileNode')
		if n == nil then
			do return true end
		end
		n.file = self.file
		n.buffer = self.buffer
		n.fileName = self.fileName
		n.condition = self.condition
		do return true end
	end
end

function sling.model.ResourceFileNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ResourceFileNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ResourceFileNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ResourceFileNode:setFile(v)
	self.file = v
end

function sling.model.ResourceFileNode:getFile()
	do return self.file end
end

function sling.model.ResourceFileNode:setBuffer(v)
	self.buffer = v
end

function sling.model.ResourceFileNode:getBuffer()
	do return self.buffer end
end

function sling.model.ResourceFileNode:setFileName(v)
	self.fileName = v
end

function sling.model.ResourceFileNode:getFileName()
	do return self.fileName end
end

function sling.model.ResourceFileNode:setCondition(v)
	self.condition = v
end

function sling.model.ResourceFileNode:getCondition()
	do return self.condition end
end

sling.model.GreaterOrEqualExpressionNode = _g.sling.model.ComparisonExpressionNode._create()
sling.model.GreaterOrEqualExpressionNode.__index = sling.model.GreaterOrEqualExpressionNode
_vm:set_metatable(sling.model.GreaterOrEqualExpressionNode, {
	__index = _g.sling.model.ComparisonExpressionNode
})

function sling.model.GreaterOrEqualExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GreaterOrEqualExpressionNode)
	return v
end

function sling.model.GreaterOrEqualExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GreaterOrEqualExpressionNode'
	self['_isType.sling.model.GreaterOrEqualExpressionNode'] = true
end

function sling.model.GreaterOrEqualExpressionNode:_construct0()
	sling.model.GreaterOrEqualExpressionNode._init(self)
	do _g.sling.model.ComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.GreaterOrEqualExpressionNode:instance(left, right)
	local v = _g.sling.model.GreaterOrEqualExpressionNode._construct0(_g.sling.model.GreaterOrEqualExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.GreaterOrEqualExpressionNode:getNodeTypeName()
	do return "GreaterOrEqualExpressionNode" end
end

function sling.model.GreaterOrEqualExpressionNode:createNew()
	do return _g.sling.model.GreaterOrEqualExpressionNode._construct0(_g.sling.model.GreaterOrEqualExpressionNode._create()) end
end

function sling.model.GreaterOrEqualExpressionNode:copyTo(o)
	if _g.sling.model.ComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GreaterOrEqualExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.GreaterOrEqualExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GreaterOrEqualExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.GreaterOrEqualExpressionNode:destroy()
	do _g.sling.model.ComparisonExpressionNode.destroy(self) end
end

sling.model.AllocateBufferExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.AllocateBufferExpressionNode.__index = sling.model.AllocateBufferExpressionNode
_vm:set_metatable(sling.model.AllocateBufferExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.AllocateBufferExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AllocateBufferExpressionNode)
	return v
end

function sling.model.AllocateBufferExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AllocateBufferExpressionNode'
	self['_isType.sling.model.AllocateBufferExpressionNode'] = true
end

function sling.model.AllocateBufferExpressionNode:forExpression(expression)
	local v = _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.AllocateBufferExpressionNode:_construct0()
	sling.model.AllocateBufferExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()), false) end
	return self
end

function sling.model.AllocateBufferExpressionNode:getNodeTypeName()
	do return "AllocateBufferExpressionNode" end
end

function sling.model.AllocateBufferExpressionNode:createNew()
	do return _g.sling.model.AllocateBufferExpressionNode._construct0(_g.sling.model.AllocateBufferExpressionNode._create()) end
end

function sling.model.AllocateBufferExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AllocateBufferExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AllocateBufferExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AllocateBufferExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AllocateBufferExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.BooleanLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.BooleanLiteralExpressionNode.__index = sling.model.BooleanLiteralExpressionNode
_vm:set_metatable(sling.model.BooleanLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.BooleanLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BooleanLiteralExpressionNode)
	return v
end

function sling.model.BooleanLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BooleanLiteralExpressionNode'
	self['_isType.sling.model.BooleanLiteralExpressionNode'] = true
	self.value = false
end

function sling.model.BooleanLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.BooleanLiteralExpressionNode._construct0(_g.sling.model.BooleanLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.BooleanLiteralExpressionNode:_construct0()
	sling.model.BooleanLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()), false) end
	return self
end

function sling.model.BooleanLiteralExpressionNode:getNodeTypeName()
	do return "BooleanLiteralExpressionNode" end
end

function sling.model.BooleanLiteralExpressionNode:createNew()
	do return _g.sling.model.BooleanLiteralExpressionNode._construct0(_g.sling.model.BooleanLiteralExpressionNode._create()) end
end

function sling.model.BooleanLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BooleanLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.BooleanLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BooleanLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BooleanLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.BooleanLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.BooleanLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.CaseGreaterOrEqualBlockNode = _g.sling.model.CaseBlockNode._create()
sling.model.CaseGreaterOrEqualBlockNode.__index = sling.model.CaseGreaterOrEqualBlockNode
_vm:set_metatable(sling.model.CaseGreaterOrEqualBlockNode, {
	__index = _g.sling.model.CaseBlockNode
})

function sling.model.CaseGreaterOrEqualBlockNode._create()
	local v = _vm:set_metatable({}, sling.model.CaseGreaterOrEqualBlockNode)
	return v
end

function sling.model.CaseGreaterOrEqualBlockNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CaseGreaterOrEqualBlockNode'
	self['_isType.sling.model.CaseGreaterOrEqualBlockNode'] = true
	self.expression = nil
end

function sling.model.CaseGreaterOrEqualBlockNode:_construct0()
	sling.model.CaseGreaterOrEqualBlockNode._init(self)
	do _g.sling.model.CaseBlockNode._construct0(self) end
	return self
end

function sling.model.CaseGreaterOrEqualBlockNode:instance(xp, bb)
	local v = _g.sling.model.CaseGreaterOrEqualBlockNode._construct0(_g.sling.model.CaseGreaterOrEqualBlockNode._create())
	do v:setExpression(xp, false) end
	do v:setBlock(bb, false) end
	do return v end
end

function sling.model.CaseGreaterOrEqualBlockNode:getNodeTypeName()
	do return "CaseGreaterOrEqualBlockNode" end
end

function sling.model.CaseGreaterOrEqualBlockNode:createNew()
	do return _g.sling.model.CaseGreaterOrEqualBlockNode._construct0(_g.sling.model.CaseGreaterOrEqualBlockNode._create()) end
end

function sling.model.CaseGreaterOrEqualBlockNode:copyTo(o)
	if _g.sling.model.CaseBlockNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CaseGreaterOrEqualBlockNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.CaseGreaterOrEqualBlockNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.CaseBlockNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CaseGreaterOrEqualBlockNode:acceptVisitor(visitor)
	if _g.sling.model.CaseBlockNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.CaseGreaterOrEqualBlockNode:destroy()
	do _g.sling.model.CaseBlockNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.CaseGreaterOrEqualBlockNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.CaseGreaterOrEqualBlockNode:getExpression()
	do return self.expression end
end

function sling.model.CaseGreaterOrEqualBlockNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.PropertyInitializeFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.PropertyInitializeFunctionDeclarationNode.__index = sling.model.PropertyInitializeFunctionDeclarationNode
_vm:set_metatable(sling.model.PropertyInitializeFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.PropertyInitializeFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyInitializeFunctionDeclarationNode)
	return v
end

function sling.model.PropertyInitializeFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyInitializeFunctionDeclarationNode'
	self['_isType.sling.model.PropertyInitializeFunctionDeclarationNode'] = true
end

function sling.model.PropertyInitializeFunctionDeclarationNode:_construct0()
	sling.model.PropertyInitializeFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.PropertyInitializeFunctionDeclarationNode:getNodeTypeName()
	do return "PropertyInitializeFunctionDeclarationNode" end
end

function sling.model.PropertyInitializeFunctionDeclarationNode:createNew()
	do return _g.sling.model.PropertyInitializeFunctionDeclarationNode._construct0(_g.sling.model.PropertyInitializeFunctionDeclarationNode._create()) end
end

function sling.model.PropertyInitializeFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyInitializeFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PropertyInitializeFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyInitializeFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertyInitializeFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.PointerDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.PointerDataTypeNode.__index = sling.model.PointerDataTypeNode
_vm:set_metatable(sling.model.PointerDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.PointerDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.PointerDataTypeNode)
	return v
end

function sling.model.PointerDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PointerDataTypeNode'
	self['_isType.sling.model.PointerDataTypeNode'] = true
end

function sling.model.PointerDataTypeNode:_construct0()
	sling.model.PointerDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.PointerDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.PointerDataTypeNode._construct0(_g.sling.model.PointerDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.PointerDataTypeNode:getNodeTypeName()
	do return "PointerDataTypeNode" end
end

function sling.model.PointerDataTypeNode:createNew()
	do return _g.sling.model.PointerDataTypeNode._construct0(_g.sling.model.PointerDataTypeNode._create()) end
end

function sling.model.PointerDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PointerDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PointerDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PointerDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PointerDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.FunctionDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.FunctionDataTypeNode.__index = sling.model.FunctionDataTypeNode
_vm:set_metatable(sling.model.FunctionDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.FunctionDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDataTypeNode)
	return v
end

function sling.model.FunctionDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDataTypeNode'
	self['_isType.sling.model.FunctionDataTypeNode'] = true
	self.declaration = nil
end

function sling.model.FunctionDataTypeNode:_construct0()
	sling.model.FunctionDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.FunctionDataTypeNode:forFunction(decl)
	local v = _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create())
	if decl ~= nil then
		local dd = _vm:to_table_with_key(decl:dup(), '_isType.sling.model.FunctionDeclarationNode')
		if dd ~= nil then
			do dd:setName(nil) end
			do dd:setBody(nil, false) end
			do
				local array = dd:getParameters()
				if array ~= nil then
					local n = 0
					local m = _g.jk.lang.Vector:getSize(array)
					do
						n = 0
						while n < m do
							local param = _vm:to_table_with_key(array[n + 1], '_isType.sling.model.VariableDeclarationNode')
							if param ~= nil then
								do param:setName(nil) end
							end
							do n = n + 1 end
						end
					end
				end
				do v:setDeclaration(dd, false) end
			end
		end
	end
	do return v end
end

function sling.model.FunctionDataTypeNode:getFunctionReturnType()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getReturnType() end
end

function sling.model.FunctionDataTypeNode:getFunctionParameters()
	if not (self.declaration ~= nil) then
		do return nil end
	end
	do return self.declaration:getParameters() end
end

function sling.model.FunctionDataTypeNode:getNodeTypeName()
	do return "FunctionDataTypeNode" end
end

function sling.model.FunctionDataTypeNode:createNew()
	do return _g.sling.model.FunctionDataTypeNode._construct0(_g.sling.model.FunctionDataTypeNode._create()) end
end

function sling.model.FunctionDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		do return true end
	end
end

function sling.model.FunctionDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.FunctionDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
end

function sling.model.FunctionDataTypeNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.FunctionDataTypeNode:getDeclaration()
	do return self.declaration end
end

function sling.model.FunctionDataTypeNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

sling.model.BooleanDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.BooleanDataTypeNode.__index = sling.model.BooleanDataTypeNode
_vm:set_metatable(sling.model.BooleanDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.BooleanDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.BooleanDataTypeNode)
	return v
end

function sling.model.BooleanDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BooleanDataTypeNode'
	self['_isType.sling.model.BooleanDataTypeNode'] = true
end

function sling.model.BooleanDataTypeNode:_construct0()
	sling.model.BooleanDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.BooleanDataTypeNode:getNodeTypeName()
	do return "BooleanDataTypeNode" end
end

function sling.model.BooleanDataTypeNode:createNew()
	do return _g.sling.model.BooleanDataTypeNode._construct0(_g.sling.model.BooleanDataTypeNode._create()) end
end

function sling.model.BooleanDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BooleanDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BooleanDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BooleanDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BooleanDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.MagicalClassDeclarationNode = _g.sling.model.ClassDeclarationNode._create()
sling.model.MagicalClassDeclarationNode.__index = sling.model.MagicalClassDeclarationNode
_vm:set_metatable(sling.model.MagicalClassDeclarationNode, {
	__index = _g.sling.model.ClassDeclarationNode
})

function sling.model.MagicalClassDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.MagicalClassDeclarationNode)
	return v
end

function sling.model.MagicalClassDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MagicalClassDeclarationNode'
	self['_isType.sling.model.MagicalClassDeclarationNode'] = true
	self.symbol = nil
end

function sling.model.MagicalClassDeclarationNode:_construct0()
	sling.model.MagicalClassDeclarationNode._init(self)
	do _g.sling.model.ClassDeclarationNode._construct0(self) end
	return self
end

function sling.model.MagicalClassDeclarationNode:getNodeTypeName()
	do return "MagicalClassDeclarationNode" end
end

function sling.model.MagicalClassDeclarationNode:createNew()
	do return _g.sling.model.MagicalClassDeclarationNode._construct0(_g.sling.model.MagicalClassDeclarationNode._create()) end
end

function sling.model.MagicalClassDeclarationNode:copyTo(o)
	if _g.sling.model.ClassDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MagicalClassDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.MagicalClassDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ClassDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MagicalClassDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.ClassDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.MagicalClassDeclarationNode:destroy()
	do _g.sling.model.ClassDeclarationNode.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.MagicalClassDeclarationNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.MagicalClassDeclarationNode:getSymbol()
	do return self.symbol end
end

function sling.model.MagicalClassDeclarationNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.PromiseDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.PromiseDataTypeNode.__index = sling.model.PromiseDataTypeNode
_vm:set_metatable(sling.model.PromiseDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.PromiseDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.PromiseDataTypeNode)
	return v
end

function sling.model.PromiseDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PromiseDataTypeNode'
	self['_isType.sling.model.PromiseDataTypeNode'] = true
end

function sling.model.PromiseDataTypeNode:_construct0()
	sling.model.PromiseDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.PromiseDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.PromiseDataTypeNode._construct0(_g.sling.model.PromiseDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.PromiseDataTypeNode:getNodeTypeName()
	do return "PromiseDataTypeNode" end
end

function sling.model.PromiseDataTypeNode:createNew()
	do return _g.sling.model.PromiseDataTypeNode._construct0(_g.sling.model.PromiseDataTypeNode._create()) end
end

function sling.model.PromiseDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PromiseDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PromiseDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PromiseDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PromiseDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.ContinueLabelStatementNode = _g.sling.model.LabeledControlStatementNode._create()
sling.model.ContinueLabelStatementNode.__index = sling.model.ContinueLabelStatementNode
_vm:set_metatable(sling.model.ContinueLabelStatementNode, {
	__index = _g.sling.model.LabeledControlStatementNode
})

function sling.model.ContinueLabelStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ContinueLabelStatementNode)
	return v
end

function sling.model.ContinueLabelStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ContinueLabelStatementNode'
	self['_isType.sling.model.ContinueLabelStatementNode'] = true
end

function sling.model.ContinueLabelStatementNode:_construct0()
	sling.model.ContinueLabelStatementNode._init(self)
	do _g.sling.model.LabeledControlStatementNode._construct0(self) end
	return self
end

function sling.model.ContinueLabelStatementNode:forLabel(label)
	local v = _g.sling.model.ContinueLabelStatementNode._construct0(_g.sling.model.ContinueLabelStatementNode._create())
	do v:setLabel(label) end
	do return v end
end

function sling.model.ContinueLabelStatementNode:getNodeTypeName()
	do return "ContinueLabelStatementNode" end
end

function sling.model.ContinueLabelStatementNode:createNew()
	do return _g.sling.model.ContinueLabelStatementNode._construct0(_g.sling.model.ContinueLabelStatementNode._create()) end
end

function sling.model.ContinueLabelStatementNode:copyTo(o)
	if _g.sling.model.LabeledControlStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ContinueLabelStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ContinueLabelStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LabeledControlStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ContinueLabelStatementNode:acceptVisitor(visitor)
	if _g.sling.model.LabeledControlStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ContinueLabelStatementNode:destroy()
	do _g.sling.model.LabeledControlStatementNode.destroy(self) end
end

sling.model.PropertyDeclarationNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.PropertyDeclarationNode.__index = sling.model.PropertyDeclarationNode
_vm:set_metatable(sling.model.PropertyDeclarationNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.PropertyDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyDeclarationNode)
	return v
end

function sling.model.PropertyDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyDeclarationNode'
	self['_isType.sling.model.PropertyDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.type = nil
	self.name = nil
	self.backingVariableName = nil
	self.description = nil
	self.body = nil
	self.initializer = nil
end

function sling.model.PropertyDeclarationNode:_construct0()
	sling.model.PropertyDeclarationNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.PropertyDeclarationNode:getNodeName()
	do return self.name end
end

function sling.model.PropertyDeclarationNode:getName()
	do return self:getNodeName() end
end

function sling.model.PropertyDeclarationNode:renameNode(name)
	do self:setName(name) end
end

function sling.model.PropertyDeclarationNode:addToBody(node)
	if not (node ~= nil) then
		do return end
	end
	if not (self.body ~= nil) then
		self.body = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	end
	do self.body:addNode(node) end
end

function sling.model.PropertyDeclarationNode:getNodeTypeName()
	do return "PropertyDeclarationNode" end
end

function sling.model.PropertyDeclarationNode:createNew()
	do return _g.sling.model.PropertyDeclarationNode._construct0(_g.sling.model.PropertyDeclarationNode._create()) end
end

function sling.model.PropertyDeclarationNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		if n.initializer ~= nil then
			do n.initializer:destroy() end
			n.initializer = nil
		end
		if self.initializer ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.initializer), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.initializer = pcp
			do n.initializer:setParent(n) end
		end
		n.name = self.name
		n.backingVariableName = self.backingVariableName
		n.description = self.description
		do return true end
	end
end

function sling.model.PropertyDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.initializer then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.initializer:destroy() end
		end
		self.initializer = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.initializer ~= nil then
			do self.initializer:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	if self.initializer ~= nil then
		if self.initializer:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PropertyDeclarationNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
	if self.initializer ~= nil then
		do self.initializer:destroy() end
		self.initializer = nil
	end
end

function sling.model.PropertyDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.PropertyDeclarationNode:getType()
	do return self.type end
end

function sling.model.PropertyDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.PropertyDeclarationNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.PropertyDeclarationNode:getBody()
	do return self.body end
end

function sling.model.PropertyDeclarationNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

function sling.model.PropertyDeclarationNode:setInitializer(v, doExport)
	if self.initializer ~= nil and doExport == false then
		do self.initializer:destroy() end
	end
	self.initializer = v
	if self.initializer ~= nil then
		do self.initializer:setParent(self) end
	end
end

function sling.model.PropertyDeclarationNode:getInitializer()
	do return self.initializer end
end

function sling.model.PropertyDeclarationNode:exportInitializer()
	local v = self.initializer
	self.initializer = nil
	do return v end
end

function sling.model.PropertyDeclarationNode:setName(v)
	self.name = v
end

function sling.model.PropertyDeclarationNode:setBackingVariableName(v)
	self.backingVariableName = v
end

function sling.model.PropertyDeclarationNode:getBackingVariableName()
	do return self.backingVariableName end
end

function sling.model.PropertyDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.PropertyDeclarationNode:getDescription()
	do return self.description end
end

sling.model.AnnotationModifierNode = _g.sling.common.NodeObject._create()
sling.model.AnnotationModifierNode.__index = sling.model.AnnotationModifierNode
_vm:set_metatable(sling.model.AnnotationModifierNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.AnnotationModifierNode._create()
	local v = _vm:set_metatable({}, sling.model.AnnotationModifierNode)
	return v
end

function sling.model.AnnotationModifierNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AnnotationModifierNode'
	self['_isType.sling.model.AnnotationModifierNode'] = true
	self.text = nil
	self.symbol = nil
	self.expressions = nil
end

function sling.model.AnnotationModifierNode:_construct0()
	sling.model.AnnotationModifierNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.AnnotationModifierNode:forText(text)
	local v = _g.sling.model.AnnotationModifierNode._construct0(_g.sling.model.AnnotationModifierNode._create())
	do v:setText(text) end
	do return v end
end

function sling.model.AnnotationModifierNode:getNodeTypeName()
	do return "AnnotationModifierNode" end
end

function sling.model.AnnotationModifierNode:createNew()
	do return _g.sling.model.AnnotationModifierNode._construct0(_g.sling.model.AnnotationModifierNode._create()) end
end

function sling.model.AnnotationModifierNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AnnotationModifierNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		n.text = self.text
		do
			local array = n.expressions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.expressions = nil
			if self.expressions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.expressions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.expressions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.expressions == nil then
								n.expressions = {}
							end
							do _g.jk.lang.Vector:append(n.expressions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.AnnotationModifierNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.expressions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AnnotationModifierNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.expressions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AnnotationModifierNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

function sling.model.AnnotationModifierNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.AnnotationModifierNode:getSymbol()
	do return self.symbol end
end

function sling.model.AnnotationModifierNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

function sling.model.AnnotationModifierNode:setText(v)
	self.text = v
end

function sling.model.AnnotationModifierNode:getText()
	do return self.text end
end

function sling.model.AnnotationModifierNode:setExpressions(v, doExport)
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.expressions = nil
	else
		self.expressions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.expressions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.AnnotationModifierNode:getExpressions()
	do return self.expressions end
end

function sling.model.AnnotationModifierNode:exportExpressions()
	local v = self.expressions
	self.expressions = nil
	do return v end
end

function sling.model.AnnotationModifierNode:addToExpressions(v)
	if v == nil then
		do return end
	end
	if self.expressions == nil then
		self.expressions = {}
	end
	do _g.jk.lang.Vector:append(self.expressions, v) end
	do v:setParent(self) end
end

function sling.model.AnnotationModifierNode:clearExpressions()
	if self.expressions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.expressions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.expressions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.expressions = nil
end

sling.model.PreprocessorValueExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.PreprocessorValueExpressionNode.__index = sling.model.PreprocessorValueExpressionNode
_vm:set_metatable(sling.model.PreprocessorValueExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.PreprocessorValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PreprocessorValueExpressionNode)
	return v
end

function sling.model.PreprocessorValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PreprocessorValueExpressionNode'
	self['_isType.sling.model.PreprocessorValueExpressionNode'] = true
	self.variable = nil
end

function sling.model.PreprocessorValueExpressionNode:_construct0()
	sling.model.PreprocessorValueExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.PreprocessorValueExpressionNode:forVariable(value)
	local v = _g.sling.model.PreprocessorValueExpressionNode._construct0(_g.sling.model.PreprocessorValueExpressionNode._create())
	do v:setVariable(value) end
	do return v end
end

function sling.model.PreprocessorValueExpressionNode:getNodeTypeName()
	do return "PreprocessorValueExpressionNode" end
end

function sling.model.PreprocessorValueExpressionNode:createNew()
	do return _g.sling.model.PreprocessorValueExpressionNode._construct0(_g.sling.model.PreprocessorValueExpressionNode._create()) end
end

function sling.model.PreprocessorValueExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PreprocessorValueExpressionNode')
		if n == nil then
			do return true end
		end
		n.variable = self.variable
		do return true end
	end
end

function sling.model.PreprocessorValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PreprocessorValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PreprocessorValueExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

function sling.model.PreprocessorValueExpressionNode:setVariable(v)
	self.variable = v
end

function sling.model.PreprocessorValueExpressionNode:getVariable()
	do return self.variable end
end

sling.model.NegativeNumberExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.NegativeNumberExpressionNode.__index = sling.model.NegativeNumberExpressionNode
_vm:set_metatable(sling.model.NegativeNumberExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.NegativeNumberExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NegativeNumberExpressionNode)
	return v
end

function sling.model.NegativeNumberExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NegativeNumberExpressionNode'
	self['_isType.sling.model.NegativeNumberExpressionNode'] = true
end

function sling.model.NegativeNumberExpressionNode:_construct0()
	sling.model.NegativeNumberExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.NegativeNumberExpressionNode:forExpression(expression)
	local v = _g.sling.model.NegativeNumberExpressionNode._construct0(_g.sling.model.NegativeNumberExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.NegativeNumberExpressionNode:getNodeTypeName()
	do return "NegativeNumberExpressionNode" end
end

function sling.model.NegativeNumberExpressionNode:createNew()
	do return _g.sling.model.NegativeNumberExpressionNode._construct0(_g.sling.model.NegativeNumberExpressionNode._create()) end
end

function sling.model.NegativeNumberExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NegativeNumberExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NegativeNumberExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NegativeNumberExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NegativeNumberExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.EventAddFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.EventAddFunctionDeclarationNode.__index = sling.model.EventAddFunctionDeclarationNode
_vm:set_metatable(sling.model.EventAddFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.EventAddFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EventAddFunctionDeclarationNode)
	return v
end

function sling.model.EventAddFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EventAddFunctionDeclarationNode'
	self['_isType.sling.model.EventAddFunctionDeclarationNode'] = true
end

function sling.model.EventAddFunctionDeclarationNode:_construct0()
	sling.model.EventAddFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.EventAddFunctionDeclarationNode:setParameter(dt, name)
	do self:clearParameters() end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, name, nil)) end
end

function sling.model.EventAddFunctionDeclarationNode:getNodeTypeName()
	do return "EventAddFunctionDeclarationNode" end
end

function sling.model.EventAddFunctionDeclarationNode:createNew()
	do return _g.sling.model.EventAddFunctionDeclarationNode._construct0(_g.sling.model.EventAddFunctionDeclarationNode._create()) end
end

function sling.model.EventAddFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EventAddFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.EventAddFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EventAddFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.EventAddFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.FunctionDeclarationExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.FunctionDeclarationExpressionNode.__index = sling.model.FunctionDeclarationExpressionNode
_vm:set_metatable(sling.model.FunctionDeclarationExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.FunctionDeclarationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FunctionDeclarationExpressionNode)
	return v
end

function sling.model.FunctionDeclarationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FunctionDeclarationExpressionNode'
	self['_isType.sling.model.FunctionDeclarationExpressionNode'] = true
	self.declaration = nil
	self.type = nil
	self.references = nil
end

function sling.model.FunctionDeclarationExpressionNode:_construct0()
	sling.model.FunctionDeclarationExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.FunctionDeclarationExpressionNode:forDeclaration(decl)
	local v = _g.sling.model.FunctionDeclarationExpressionNode._construct0(_g.sling.model.FunctionDeclarationExpressionNode._create())
	do v:setDeclaration(decl, false) end
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:getNodeTypeName()
	do return "FunctionDeclarationExpressionNode" end
end

function sling.model.FunctionDeclarationExpressionNode:createNew()
	do return _g.sling.model.FunctionDeclarationExpressionNode._construct0(_g.sling.model.FunctionDeclarationExpressionNode._create()) end
end

function sling.model.FunctionDeclarationExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FunctionDeclarationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.declaration ~= nil then
			do n.declaration:destroy() end
			n.declaration = nil
		end
		if self.declaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.declaration), '_isType.sling.model.FunctionDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.declaration = pcp
			do n.declaration:setParent(n) end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do
			local array = n.references
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.references = nil
			if self.references ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.references)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.references[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.references == nil then
								n.references = {}
							end
							do _g.jk.lang.Vector:append(n.references, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.FunctionDeclarationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.declaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.declaration:destroy() end
		end
		self.declaration = _vm:to_table_with_key(newnode, '_isType.sling.model.FunctionDeclarationNode')
		if self.declaration ~= nil then
			do self.declaration:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.references, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FunctionDeclarationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.declaration ~= nil then
		if self.declaration:accept(visitor) == false then
			do return false end
		end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.references, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FunctionDeclarationExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.declaration ~= nil then
		do self.declaration:destroy() end
		self.declaration = nil
	end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.references ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.references)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.references[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.references = nil
end

function sling.model.FunctionDeclarationExpressionNode:setDeclaration(v, doExport)
	if self.declaration ~= nil and doExport == false then
		do self.declaration:destroy() end
	end
	self.declaration = v
	if self.declaration ~= nil then
		do self.declaration:setParent(self) end
	end
end

function sling.model.FunctionDeclarationExpressionNode:getDeclaration()
	do return self.declaration end
end

function sling.model.FunctionDeclarationExpressionNode:exportDeclaration()
	local v = self.declaration
	self.declaration = nil
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.FunctionDeclarationExpressionNode:getType()
	do return self.type end
end

function sling.model.FunctionDeclarationExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:setReferences(v, doExport)
	if self.references ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.references)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.references[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.references = nil
	else
		self.references = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.references, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.FunctionDeclarationExpressionNode:getReferences()
	do return self.references end
end

function sling.model.FunctionDeclarationExpressionNode:exportReferences()
	local v = self.references
	self.references = nil
	do return v end
end

function sling.model.FunctionDeclarationExpressionNode:addToReferences(v)
	if v == nil then
		do return end
	end
	if self.references == nil then
		self.references = {}
	end
	do _g.jk.lang.Vector:append(self.references, v) end
	do v:setParent(self) end
end

function sling.model.FunctionDeclarationExpressionNode:clearReferences()
	if self.references ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.references)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.references[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.references = nil
end

sling.model.TreeExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.TreeExpressionNode.__index = sling.model.TreeExpressionNode
_vm:set_metatable(sling.model.TreeExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.TreeExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.TreeExpressionNode)
	return v
end

function sling.model.TreeExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TreeExpressionNode'
	self['_isType.sling.model.TreeExpressionNode'] = true
	self.root = nil
end

function sling.model.TreeExpressionNode:_construct0()
	sling.model.TreeExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.TreeDataTypeNode._construct0(_g.sling.model.TreeDataTypeNode._create()), false) end
	return self
end

function sling.model.TreeExpressionNode:getNodeTypeName()
	do return "TreeExpressionNode" end
end

function sling.model.TreeExpressionNode:createNew()
	do return _g.sling.model.TreeExpressionNode._construct0(_g.sling.model.TreeExpressionNode._create()) end
end

function sling.model.TreeExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TreeExpressionNode')
		if n == nil then
			do return true end
		end
		if n.root ~= nil then
			do n.root:destroy() end
			n.root = nil
		end
		if self.root ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.root), '_isType.sling.model.TreeElementNode')
			if pcp == nil then
				do return false end
			end
			n.root = pcp
			do n.root:setParent(n) end
		end
		do return true end
	end
end

function sling.model.TreeExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.root then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.TreeElementNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.root:destroy() end
		end
		self.root = _vm:to_table_with_key(newnode, '_isType.sling.model.TreeElementNode')
		if self.root ~= nil then
			do self.root:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TreeExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.root ~= nil then
		if self.root:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TreeExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.root ~= nil then
		do self.root:destroy() end
		self.root = nil
	end
end

function sling.model.TreeExpressionNode:setRoot(v, doExport)
	if self.root ~= nil and doExport == false then
		do self.root:destroy() end
	end
	self.root = v
	if self.root ~= nil then
		do self.root:setParent(self) end
	end
end

function sling.model.TreeExpressionNode:getRoot()
	do return self.root end
end

function sling.model.TreeExpressionNode:exportRoot()
	local v = self.root
	self.root = nil
	do return v end
end

sling.model.TupleDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.TupleDataTypeNode.__index = sling.model.TupleDataTypeNode
_vm:set_metatable(sling.model.TupleDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.TupleDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.TupleDataTypeNode)
	return v
end

function sling.model.TupleDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TupleDataTypeNode'
	self['_isType.sling.model.TupleDataTypeNode'] = true
	self.types = nil
end

function sling.model.TupleDataTypeNode:_construct0()
	sling.model.TupleDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.TupleDataTypeNode:forTypes(types)
	local v = _g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create())
	do v:setTypes(types, false) end
	do return v end
end

function sling.model.TupleDataTypeNode:getNodeTypeName()
	do return "TupleDataTypeNode" end
end

function sling.model.TupleDataTypeNode:createNew()
	do return _g.sling.model.TupleDataTypeNode._construct0(_g.sling.model.TupleDataTypeNode._create()) end
end

function sling.model.TupleDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TupleDataTypeNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.types
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.types = nil
			if self.types ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.types)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.types[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.types == nil then
								n.types = {}
							end
							do _g.jk.lang.Vector:append(n.types, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.TupleDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.types, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TupleDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.types, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TupleDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

function sling.model.TupleDataTypeNode:setTypes(v, doExport)
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.types = nil
	else
		self.types = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.types, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.TupleDataTypeNode:getTypes()
	do return self.types end
end

function sling.model.TupleDataTypeNode:exportTypes()
	local v = self.types
	self.types = nil
	do return v end
end

function sling.model.TupleDataTypeNode:addToTypes(v)
	if v == nil then
		do return end
	end
	if self.types == nil then
		self.types = {}
	end
	do _g.jk.lang.Vector:append(self.types, v) end
	do v:setParent(self) end
end

function sling.model.TupleDataTypeNode:clearTypes()
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

sling.model.HandlesModifierNode = _g.sling.common.NodeObject._create()
sling.model.HandlesModifierNode.__index = sling.model.HandlesModifierNode
_vm:set_metatable(sling.model.HandlesModifierNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.HandlesModifierNode._create()
	local v = _vm:set_metatable({}, sling.model.HandlesModifierNode)
	return v
end

function sling.model.HandlesModifierNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.HandlesModifierNode'
	self['_isType.sling.model.HandlesModifierNode'] = true
	self.symbol = nil
end

function sling.model.HandlesModifierNode:_construct0()
	sling.model.HandlesModifierNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.HandlesModifierNode:getNodeTypeName()
	do return "HandlesModifierNode" end
end

function sling.model.HandlesModifierNode:createNew()
	do return _g.sling.model.HandlesModifierNode._construct0(_g.sling.model.HandlesModifierNode._create()) end
end

function sling.model.HandlesModifierNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.HandlesModifierNode')
		if n == nil then
			do return true end
		end
		if n.symbol ~= nil then
			do n.symbol:destroy() end
			n.symbol = nil
		end
		if self.symbol ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.symbol), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.symbol = pcp
			do n.symbol:setParent(n) end
		end
		do return true end
	end
end

function sling.model.HandlesModifierNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.symbol then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.symbol:destroy() end
		end
		self.symbol = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.symbol ~= nil then
			do self.symbol:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.HandlesModifierNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.symbol ~= nil then
		if self.symbol:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.HandlesModifierNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.symbol ~= nil then
		do self.symbol:destroy() end
		self.symbol = nil
	end
end

function sling.model.HandlesModifierNode:setSymbol(v, doExport)
	if self.symbol ~= nil and doExport == false then
		do self.symbol:destroy() end
	end
	self.symbol = v
	if self.symbol ~= nil then
		do self.symbol:setParent(self) end
	end
end

function sling.model.HandlesModifierNode:getSymbol()
	do return self.symbol end
end

function sling.model.HandlesModifierNode:exportSymbol()
	local v = self.symbol
	self.symbol = nil
	do return v end
end

sling.model.ExpressionDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.ExpressionDataTypeNode.__index = sling.model.ExpressionDataTypeNode
_vm:set_metatable(sling.model.ExpressionDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.ExpressionDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.ExpressionDataTypeNode)
	return v
end

function sling.model.ExpressionDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExpressionDataTypeNode'
	self['_isType.sling.model.ExpressionDataTypeNode'] = true
	self.expression = nil
end

function sling.model.ExpressionDataTypeNode:_construct0()
	sling.model.ExpressionDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.ExpressionDataTypeNode:getNodeTypeName()
	do return "ExpressionDataTypeNode" end
end

function sling.model.ExpressionDataTypeNode:createNew()
	do return _g.sling.model.ExpressionDataTypeNode._construct0(_g.sling.model.ExpressionDataTypeNode._create()) end
end

function sling.model.ExpressionDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExpressionDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ExpressionDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExpressionDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ExpressionDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ExpressionDataTypeNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ExpressionDataTypeNode:getExpression()
	do return self.expression end
end

function sling.model.ExpressionDataTypeNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.ModuloExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.ModuloExpressionNode.__index = sling.model.ModuloExpressionNode
_vm:set_metatable(sling.model.ModuloExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.ModuloExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ModuloExpressionNode)
	return v
end

function sling.model.ModuloExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ModuloExpressionNode'
	self['_isType.sling.model.ModuloExpressionNode'] = true
end

function sling.model.ModuloExpressionNode:_construct0()
	sling.model.ModuloExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.ModuloExpressionNode:instance(left, right)
	local v = _g.sling.model.ModuloExpressionNode._construct0(_g.sling.model.ModuloExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ModuloExpressionNode:getNodeTypeName()
	do return "ModuloExpressionNode" end
end

function sling.model.ModuloExpressionNode:createNew()
	do return _g.sling.model.ModuloExpressionNode._construct0(_g.sling.model.ModuloExpressionNode._create()) end
end

function sling.model.ModuloExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ModuloExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ModuloExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ModuloExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ModuloExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.AssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.AssignmentExpressionNode.__index = sling.model.AssignmentExpressionNode
_vm:set_metatable(sling.model.AssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.AssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AssignmentExpressionNode)
	return v
end

function sling.model.AssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AssignmentExpressionNode'
	self['_isType.sling.model.AssignmentExpressionNode'] = true
	self.expectedType = nil
end

function sling.model.AssignmentExpressionNode:_construct0()
	sling.model.AssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.AssignmentExpressionNode:forNodes(left, right)
	local v = _g.sling.model.AssignmentExpressionNode._construct0(_g.sling.model.AssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.AssignmentExpressionNode:getNodeTypeName()
	do return "AssignmentExpressionNode" end
end

function sling.model.AssignmentExpressionNode:createNew()
	do return _g.sling.model.AssignmentExpressionNode._construct0(_g.sling.model.AssignmentExpressionNode._create()) end
end

function sling.model.AssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expectedType ~= nil then
			do n.expectedType:destroy() end
			n.expectedType = nil
		end
		if self.expectedType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expectedType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.expectedType = pcp
			do n.expectedType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.AssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expectedType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expectedType:destroy() end
		end
		self.expectedType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.expectedType ~= nil then
			do self.expectedType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expectedType ~= nil then
		if self.expectedType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.AssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
	if self.expectedType ~= nil then
		do self.expectedType:destroy() end
		self.expectedType = nil
	end
end

function sling.model.AssignmentExpressionNode:setExpectedType(v, doExport)
	if self.expectedType ~= nil and doExport == false then
		do self.expectedType:destroy() end
	end
	self.expectedType = v
	if self.expectedType ~= nil then
		do self.expectedType:setParent(self) end
	end
end

function sling.model.AssignmentExpressionNode:getExpectedType()
	do return self.expectedType end
end

function sling.model.AssignmentExpressionNode:exportExpectedType()
	local v = self.expectedType
	self.expectedType = nil
	do return v end
end

sling.model.DefaultValueExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.DefaultValueExpressionNode.__index = sling.model.DefaultValueExpressionNode
_vm:set_metatable(sling.model.DefaultValueExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.DefaultValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DefaultValueExpressionNode)
	return v
end

function sling.model.DefaultValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DefaultValueExpressionNode'
	self['_isType.sling.model.DefaultValueExpressionNode'] = true
end

function sling.model.DefaultValueExpressionNode:_construct0()
	sling.model.DefaultValueExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.DefaultValueExpressionNode:getNodeTypeName()
	do return "DefaultValueExpressionNode" end
end

function sling.model.DefaultValueExpressionNode:createNew()
	do return _g.sling.model.DefaultValueExpressionNode._construct0(_g.sling.model.DefaultValueExpressionNode._create()) end
end

function sling.model.DefaultValueExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DefaultValueExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DefaultValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DefaultValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DefaultValueExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.NamespaceNode = _g.sling.common.NamedContainerNode._create()
sling.model.NamespaceNode.__index = sling.model.NamespaceNode
_vm:set_metatable(sling.model.NamespaceNode, {
	__index = _g.sling.common.NamedContainerNode
})

function sling.model.NamespaceNode._create()
	local v = _vm:set_metatable({}, sling.model.NamespaceNode)
	return v
end

function sling.model.NamespaceNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NamespaceNode'
	self['_isType.sling.model.NamespaceNode'] = true
	self['_isType.sling.model.NodeWithModifiers'] = true
	self.modifiers = nil
end

function sling.model.NamespaceNode:_construct0()
	sling.model.NamespaceNode._init(self)
	do _g.sling.common.NamedContainerNode._construct0(self) end
	return self
end

function sling.model.NamespaceNode:forName(name)
	local v = _g.sling.model.NamespaceNode._construct0(_g.sling.model.NamespaceNode._create())
	do v:setName(name) end
	do return v end
end

function sling.model.NamespaceNode:getNodeTypeName()
	do return "NamespaceNode" end
end

function sling.model.NamespaceNode:createNew()
	do return _g.sling.model.NamespaceNode._construct0(_g.sling.model.NamespaceNode._create()) end
end

function sling.model.NamespaceNode:copyTo(o)
	if _g.sling.common.NamedContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NamespaceNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.modifiers
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.modifiers = nil
			if self.modifiers ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.modifiers)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.modifiers[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.modifiers == nil then
								n.modifiers = {}
							end
							do _g.jk.lang.Vector:append(n.modifiers, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.NamespaceNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.modifiers, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.NamedContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NamespaceNode:acceptVisitor(visitor)
	if _g.sling.common.NamedContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.modifiers, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NamespaceNode:destroy()
	do _g.sling.common.NamedContainerNode.destroy(self) end
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

function sling.model.NamespaceNode:setModifiers(v, doExport)
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.modifiers = nil
	else
		self.modifiers = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.modifiers, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.NamespaceNode:getModifiers()
	do return self.modifiers end
end

function sling.model.NamespaceNode:exportModifiers()
	local v = self.modifiers
	self.modifiers = nil
	do return v end
end

function sling.model.NamespaceNode:addToModifiers(v)
	if v == nil then
		do return end
	end
	if self.modifiers == nil then
		self.modifiers = {}
	end
	do _g.jk.lang.Vector:append(self.modifiers, v) end
	do v:setParent(self) end
end

function sling.model.NamespaceNode:clearModifiers()
	if self.modifiers ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.modifiers)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.modifiers[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.modifiers = nil
end

sling.model.BufferLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.BufferLiteralExpressionNode.__index = sling.model.BufferLiteralExpressionNode
_vm:set_metatable(sling.model.BufferLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.BufferLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BufferLiteralExpressionNode)
	return v
end

function sling.model.BufferLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BufferLiteralExpressionNode'
	self['_isType.sling.model.BufferLiteralExpressionNode'] = true
	self.value = nil
	self.type = nil
end

function sling.model.BufferLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.BufferLiteralExpressionNode._construct0(_g.sling.model.BufferLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.BufferLiteralExpressionNode:_construct0()
	sling.model.BufferLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.BufferDataTypeNode._construct0(_g.sling.model.BufferDataTypeNode._create()), false) end
	return self
end

function sling.model.BufferLiteralExpressionNode:getNodeTypeName()
	do return "BufferLiteralExpressionNode" end
end

function sling.model.BufferLiteralExpressionNode:createNew()
	do return _g.sling.model.BufferLiteralExpressionNode._construct0(_g.sling.model.BufferLiteralExpressionNode._create()) end
end

function sling.model.BufferLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BufferLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.BufferLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BufferLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.BufferLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.BufferLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.BufferLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.BufferLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.BufferLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.BufferLiteralExpressionNode:getValue()
	do return self.value end
end

sling.model.PropertyGetFunctionDeclarationNode = _g.sling.model.FunctionDeclarationNode._create()
sling.model.PropertyGetFunctionDeclarationNode.__index = sling.model.PropertyGetFunctionDeclarationNode
_vm:set_metatable(sling.model.PropertyGetFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationNode
})

function sling.model.PropertyGetFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyGetFunctionDeclarationNode)
	return v
end

function sling.model.PropertyGetFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyGetFunctionDeclarationNode'
	self['_isType.sling.model.PropertyGetFunctionDeclarationNode'] = true
end

function sling.model.PropertyGetFunctionDeclarationNode:_construct0()
	sling.model.PropertyGetFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationNode._construct0(self) end
	return self
end

function sling.model.PropertyGetFunctionDeclarationNode:getNodeTypeName()
	do return "PropertyGetFunctionDeclarationNode" end
end

function sling.model.PropertyGetFunctionDeclarationNode:createNew()
	do return _g.sling.model.PropertyGetFunctionDeclarationNode._construct0(_g.sling.model.PropertyGetFunctionDeclarationNode._create()) end
end

function sling.model.PropertyGetFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyGetFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PropertyGetFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyGetFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertyGetFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationNode.destroy(self) end
end

sling.model.ConditionalExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.ConditionalExpressionNode.__index = sling.model.ConditionalExpressionNode
_vm:set_metatable(sling.model.ConditionalExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.ConditionalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ConditionalExpressionNode)
	return v
end

function sling.model.ConditionalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ConditionalExpressionNode'
	self['_isType.sling.model.ConditionalExpressionNode'] = true
	self.condition = nil
	self.trueExpr = nil
	self.falseExpr = nil
end

function sling.model.ConditionalExpressionNode:_construct0()
	sling.model.ConditionalExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.ConditionalExpressionNode:instance(condition, trueExpr, falseExpr)
	local v = _g.sling.model.ConditionalExpressionNode._construct0(_g.sling.model.ConditionalExpressionNode._create())
	do v:setCondition(condition, false) end
	do v:setTrueExpr(trueExpr, false) end
	do v:setFalseExpr(falseExpr, false) end
	do return v end
end

function sling.model.ConditionalExpressionNode:getNodeTypeName()
	do return "ConditionalExpressionNode" end
end

function sling.model.ConditionalExpressionNode:createNew()
	do return _g.sling.model.ConditionalExpressionNode._construct0(_g.sling.model.ConditionalExpressionNode._create()) end
end

function sling.model.ConditionalExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ConditionalExpressionNode')
		if n == nil then
			do return true end
		end
		if n.condition ~= nil then
			do n.condition:destroy() end
			n.condition = nil
		end
		if self.condition ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.condition), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.condition = pcp
			do n.condition:setParent(n) end
		end
		if n.trueExpr ~= nil then
			do n.trueExpr:destroy() end
			n.trueExpr = nil
		end
		if self.trueExpr ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.trueExpr), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.trueExpr = pcp
			do n.trueExpr:setParent(n) end
		end
		if n.falseExpr ~= nil then
			do n.falseExpr:destroy() end
			n.falseExpr = nil
		end
		if self.falseExpr ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.falseExpr), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.falseExpr = pcp
			do n.falseExpr:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ConditionalExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.condition then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.condition:destroy() end
		end
		self.condition = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.condition ~= nil then
			do self.condition:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.trueExpr then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.trueExpr:destroy() end
		end
		self.trueExpr = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.trueExpr ~= nil then
			do self.trueExpr:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.falseExpr then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.falseExpr:destroy() end
		end
		self.falseExpr = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.falseExpr ~= nil then
			do self.falseExpr:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ConditionalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.condition ~= nil then
		if self.condition:accept(visitor) == false then
			do return false end
		end
	end
	if self.trueExpr ~= nil then
		if self.trueExpr:accept(visitor) == false then
			do return false end
		end
	end
	if self.falseExpr ~= nil then
		if self.falseExpr:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ConditionalExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.condition ~= nil then
		do self.condition:destroy() end
		self.condition = nil
	end
	if self.trueExpr ~= nil then
		do self.trueExpr:destroy() end
		self.trueExpr = nil
	end
	if self.falseExpr ~= nil then
		do self.falseExpr:destroy() end
		self.falseExpr = nil
	end
end

function sling.model.ConditionalExpressionNode:setCondition(v, doExport)
	if self.condition ~= nil and doExport == false then
		do self.condition:destroy() end
	end
	self.condition = v
	if self.condition ~= nil then
		do self.condition:setParent(self) end
	end
end

function sling.model.ConditionalExpressionNode:getCondition()
	do return self.condition end
end

function sling.model.ConditionalExpressionNode:exportCondition()
	local v = self.condition
	self.condition = nil
	do return v end
end

function sling.model.ConditionalExpressionNode:setTrueExpr(v, doExport)
	if self.trueExpr ~= nil and doExport == false then
		do self.trueExpr:destroy() end
	end
	self.trueExpr = v
	if self.trueExpr ~= nil then
		do self.trueExpr:setParent(self) end
	end
end

function sling.model.ConditionalExpressionNode:getTrueExpr()
	do return self.trueExpr end
end

function sling.model.ConditionalExpressionNode:exportTrueExpr()
	local v = self.trueExpr
	self.trueExpr = nil
	do return v end
end

function sling.model.ConditionalExpressionNode:setFalseExpr(v, doExport)
	if self.falseExpr ~= nil and doExport == false then
		do self.falseExpr:destroy() end
	end
	self.falseExpr = v
	if self.falseExpr ~= nil then
		do self.falseExpr:setParent(self) end
	end
end

function sling.model.ConditionalExpressionNode:getFalseExpr()
	do return self.falseExpr end
end

function sling.model.ConditionalExpressionNode:exportFalseExpr()
	local v = self.falseExpr
	self.falseExpr = nil
	do return v end
end

sling.model.BaseClassAccessExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.BaseClassAccessExpressionNode.__index = sling.model.BaseClassAccessExpressionNode
_vm:set_metatable(sling.model.BaseClassAccessExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.BaseClassAccessExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BaseClassAccessExpressionNode)
	return v
end

function sling.model.BaseClassAccessExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BaseClassAccessExpressionNode'
	self['_isType.sling.model.BaseClassAccessExpressionNode'] = true
end

function sling.model.BaseClassAccessExpressionNode:_construct0()
	sling.model.BaseClassAccessExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.BaseClassAccessExpressionNode:getNodeTypeName()
	do return "BaseClassAccessExpressionNode" end
end

function sling.model.BaseClassAccessExpressionNode:createNew()
	do return _g.sling.model.BaseClassAccessExpressionNode._construct0(_g.sling.model.BaseClassAccessExpressionNode._create()) end
end

function sling.model.BaseClassAccessExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BaseClassAccessExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BaseClassAccessExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BaseClassAccessExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BaseClassAccessExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.PromiseLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.PromiseLiteralExpressionNode.__index = sling.model.PromiseLiteralExpressionNode
_vm:set_metatable(sling.model.PromiseLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.PromiseLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PromiseLiteralExpressionNode)
	return v
end

function sling.model.PromiseLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PromiseLiteralExpressionNode'
	self['_isType.sling.model.PromiseLiteralExpressionNode'] = true
	self.type = nil
	self.body = nil
end

function sling.model.PromiseLiteralExpressionNode:_construct0()
	sling.model.PromiseLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	return self
end

function sling.model.PromiseLiteralExpressionNode:getNodeTypeName()
	do return "PromiseLiteralExpressionNode" end
end

function sling.model.PromiseLiteralExpressionNode:createNew()
	do return _g.sling.model.PromiseLiteralExpressionNode._construct0(_g.sling.model.PromiseLiteralExpressionNode._create()) end
end

function sling.model.PromiseLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PromiseLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		do return true end
	end
end

function sling.model.PromiseLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PromiseLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.PromiseLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
end

function sling.model.PromiseLiteralExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.PromiseLiteralExpressionNode:getType()
	do return self.type end
end

function sling.model.PromiseLiteralExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.PromiseLiteralExpressionNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.PromiseLiteralExpressionNode:getBody()
	do return self.body end
end

function sling.model.PromiseLiteralExpressionNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

sling.model.MapDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.MapDataTypeNode.__index = sling.model.MapDataTypeNode
_vm:set_metatable(sling.model.MapDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.MapDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.MapDataTypeNode)
	return v
end

function sling.model.MapDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MapDataTypeNode'
	self['_isType.sling.model.MapDataTypeNode'] = true
	self.keyType = nil
	self.valueType = nil
end

function sling.model.MapDataTypeNode:_construct0()
	sling.model.MapDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.MapDataTypeNode:forTypes(key, value)
	local v = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do v:setKeyType(key, false) end
	do v:setValueType(value, false) end
	do return v end
end

function sling.model.MapDataTypeNode:getNodeTypeName()
	do return "MapDataTypeNode" end
end

function sling.model.MapDataTypeNode:createNew()
	do return _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create()) end
end

function sling.model.MapDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MapDataTypeNode')
		if n == nil then
			do return true end
		end
		if n.keyType ~= nil then
			do n.keyType:destroy() end
			n.keyType = nil
		end
		if self.keyType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.keyType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.keyType = pcp
			do n.keyType:setParent(n) end
		end
		if n.valueType ~= nil then
			do n.valueType:destroy() end
			n.valueType = nil
		end
		if self.valueType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.valueType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.valueType = pcp
			do n.valueType:setParent(n) end
		end
		do return true end
	end
end

function sling.model.MapDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.keyType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.keyType:destroy() end
		end
		self.keyType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.keyType ~= nil then
			do self.keyType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.valueType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.valueType:destroy() end
		end
		self.valueType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.valueType ~= nil then
			do self.valueType:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MapDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.keyType ~= nil then
		if self.keyType:accept(visitor) == false then
			do return false end
		end
	end
	if self.valueType ~= nil then
		if self.valueType:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.MapDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.keyType ~= nil then
		do self.keyType:destroy() end
		self.keyType = nil
	end
	if self.valueType ~= nil then
		do self.valueType:destroy() end
		self.valueType = nil
	end
end

function sling.model.MapDataTypeNode:setKeyType(v, doExport)
	if self.keyType ~= nil and doExport == false then
		do self.keyType:destroy() end
	end
	self.keyType = v
	if self.keyType ~= nil then
		do self.keyType:setParent(self) end
	end
end

function sling.model.MapDataTypeNode:getKeyType()
	do return self.keyType end
end

function sling.model.MapDataTypeNode:exportKeyType()
	local v = self.keyType
	self.keyType = nil
	do return v end
end

function sling.model.MapDataTypeNode:setValueType(v, doExport)
	if self.valueType ~= nil and doExport == false then
		do self.valueType:destroy() end
	end
	self.valueType = v
	if self.valueType ~= nil then
		do self.valueType:setParent(self) end
	end
end

function sling.model.MapDataTypeNode:getValueType()
	do return self.valueType end
end

function sling.model.MapDataTypeNode:exportValueType()
	local v = self.valueType
	self.valueType = nil
	do return v end
end

sling.model.MultiDimensionalArrayDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.MultiDimensionalArrayDataTypeNode.__index = sling.model.MultiDimensionalArrayDataTypeNode
_vm:set_metatable(sling.model.MultiDimensionalArrayDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.MultiDimensionalArrayDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.MultiDimensionalArrayDataTypeNode)
	return v
end

function sling.model.MultiDimensionalArrayDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultiDimensionalArrayDataTypeNode'
	self['_isType.sling.model.MultiDimensionalArrayDataTypeNode'] = true
	self.dimensions = 0
end

function sling.model.MultiDimensionalArrayDataTypeNode:_construct0()
	sling.model.MultiDimensionalArrayDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.MultiDimensionalArrayDataTypeNode:forDimensions(type, dimensions)
	local v = _g.sling.model.MultiDimensionalArrayDataTypeNode._construct0(_g.sling.model.MultiDimensionalArrayDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do v:setDimensions(dimensions) end
	do return v end
end

function sling.model.MultiDimensionalArrayDataTypeNode:getNodeTypeName()
	do return "MultiDimensionalArrayDataTypeNode" end
end

function sling.model.MultiDimensionalArrayDataTypeNode:createNew()
	do return _g.sling.model.MultiDimensionalArrayDataTypeNode._construct0(_g.sling.model.MultiDimensionalArrayDataTypeNode._create()) end
end

function sling.model.MultiDimensionalArrayDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultiDimensionalArrayDataTypeNode')
		if n == nil then
			do return true end
		end
		n.dimensions = self.dimensions
		do return true end
	end
end

function sling.model.MultiDimensionalArrayDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultiDimensionalArrayDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultiDimensionalArrayDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

function sling.model.MultiDimensionalArrayDataTypeNode:setDimensions(v)
	self.dimensions = v
end

function sling.model.MultiDimensionalArrayDataTypeNode:getDimensions()
	do return self.dimensions end
end

sling.model.ExpressionContainerNode = _g.sling.common.NodeObject._create()
sling.model.ExpressionContainerNode.__index = sling.model.ExpressionContainerNode
_vm:set_metatable(sling.model.ExpressionContainerNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ExpressionContainerNode._create()
	local v = _vm:set_metatable({}, sling.model.ExpressionContainerNode)
	return v
end

function sling.model.ExpressionContainerNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExpressionContainerNode'
	self['_isType.sling.model.ExpressionContainerNode'] = true
	self.expression = nil
end

function sling.model.ExpressionContainerNode:_construct0()
	sling.model.ExpressionContainerNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ExpressionContainerNode:getNodeTypeName()
	do return "ExpressionContainerNode" end
end

function sling.model.ExpressionContainerNode:createNew()
	do return _g.sling.model.ExpressionContainerNode._construct0(_g.sling.model.ExpressionContainerNode._create()) end
end

function sling.model.ExpressionContainerNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExpressionContainerNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.ExpressionContainerNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExpressionContainerNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ExpressionContainerNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.ExpressionContainerNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.ExpressionContainerNode:getExpression()
	do return self.expression end
end

function sling.model.ExpressionContainerNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.ImportStaticMemberStatementNode = _g.sling.model.ImportStatementNode._create()
sling.model.ImportStaticMemberStatementNode.__index = sling.model.ImportStaticMemberStatementNode
_vm:set_metatable(sling.model.ImportStaticMemberStatementNode, {
	__index = _g.sling.model.ImportStatementNode
})

function sling.model.ImportStaticMemberStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportStaticMemberStatementNode)
	return v
end

function sling.model.ImportStaticMemberStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportStaticMemberStatementNode'
	self['_isType.sling.model.ImportStaticMemberStatementNode'] = true
	self.member = nil
	self.container = nil
	self.allMembers = false
end

function sling.model.ImportStaticMemberStatementNode:_construct0()
	sling.model.ImportStaticMemberStatementNode._init(self)
	do _g.sling.model.ImportStatementNode._construct0(self) end
	return self
end

function sling.model.ImportStaticMemberStatementNode:getNodeTypeName()
	do return "ImportStaticMemberStatementNode" end
end

function sling.model.ImportStaticMemberStatementNode:createNew()
	do return _g.sling.model.ImportStaticMemberStatementNode._construct0(_g.sling.model.ImportStaticMemberStatementNode._create()) end
end

function sling.model.ImportStaticMemberStatementNode:copyTo(o)
	if _g.sling.model.ImportStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportStaticMemberStatementNode')
		if n == nil then
			do return true end
		end
		if n.member ~= nil then
			do n.member:destroy() end
			n.member = nil
		end
		if self.member ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.member), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.member = pcp
			do n.member:setParent(n) end
		end
		if n.container ~= nil then
			do n.container:destroy() end
			n.container = nil
		end
		if self.container ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.container), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.container = pcp
			do n.container:setParent(n) end
		end
		n.allMembers = self.allMembers
		do return true end
	end
end

function sling.model.ImportStaticMemberStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.member then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.member:destroy() end
		end
		self.member = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.member ~= nil then
			do self.member:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.container then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.container:destroy() end
		end
		self.container = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.container ~= nil then
			do self.container:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ImportStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportStaticMemberStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ImportStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.member ~= nil then
		if self.member:accept(visitor) == false then
			do return false end
		end
	end
	if self.container ~= nil then
		if self.container:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImportStaticMemberStatementNode:destroy()
	do _g.sling.model.ImportStatementNode.destroy(self) end
	if self.member ~= nil then
		do self.member:destroy() end
		self.member = nil
	end
	if self.container ~= nil then
		do self.container:destroy() end
		self.container = nil
	end
end

function sling.model.ImportStaticMemberStatementNode:setMember(v, doExport)
	if self.member ~= nil and doExport == false then
		do self.member:destroy() end
	end
	self.member = v
	if self.member ~= nil then
		do self.member:setParent(self) end
	end
end

function sling.model.ImportStaticMemberStatementNode:getMember()
	do return self.member end
end

function sling.model.ImportStaticMemberStatementNode:exportMember()
	local v = self.member
	self.member = nil
	do return v end
end

function sling.model.ImportStaticMemberStatementNode:setContainer(v, doExport)
	if self.container ~= nil and doExport == false then
		do self.container:destroy() end
	end
	self.container = v
	if self.container ~= nil then
		do self.container:setParent(self) end
	end
end

function sling.model.ImportStaticMemberStatementNode:getContainer()
	do return self.container end
end

function sling.model.ImportStaticMemberStatementNode:exportContainer()
	local v = self.container
	self.container = nil
	do return v end
end

function sling.model.ImportStaticMemberStatementNode:setAllMembers(v)
	self.allMembers = v
end

function sling.model.ImportStaticMemberStatementNode:getAllMembers()
	do return self.allMembers end
end

sling.model.CommonModifierNode = _g.sling.common.NodeObject._create()
sling.model.CommonModifierNode.__index = sling.model.CommonModifierNode
_vm:set_metatable(sling.model.CommonModifierNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.CommonModifierNode._create()
	local v = _vm:set_metatable({}, sling.model.CommonModifierNode)
	return v
end

function sling.model.CommonModifierNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CommonModifierNode'
	self['_isType.sling.model.CommonModifierNode'] = true
	self.type = nil
end

function sling.model.CommonModifierNode:_construct0()
	sling.model.CommonModifierNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.CommonModifierNode:forType(type)
	local v = _g.sling.model.CommonModifierNode._construct0(_g.sling.model.CommonModifierNode._create())
	do v:setType(type) end
	do return v end
end

function sling.model.CommonModifierNode:getNodeTypeName()
	do return "CommonModifierNode" end
end

function sling.model.CommonModifierNode:createNew()
	do return _g.sling.model.CommonModifierNode._construct0(_g.sling.model.CommonModifierNode._create()) end
end

function sling.model.CommonModifierNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CommonModifierNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.CommonModifierNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CommonModifierNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CommonModifierNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.CommonModifierNode:setType(v)
	self.type = v
end

function sling.model.CommonModifierNode:getType()
	do return self.type end
end

sling.model.NullLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.NullLiteralExpressionNode.__index = sling.model.NullLiteralExpressionNode
_vm:set_metatable(sling.model.NullLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.NullLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NullLiteralExpressionNode)
	return v
end

function sling.model.NullLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NullLiteralExpressionNode'
	self['_isType.sling.model.NullLiteralExpressionNode'] = true
end

function sling.model.NullLiteralExpressionNode:_construct0()
	sling.model.NullLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.NullDataTypeNode._construct0(_g.sling.model.NullDataTypeNode._create()), false) end
	return self
end

function sling.model.NullLiteralExpressionNode:getNodeTypeName()
	do return "NullLiteralExpressionNode" end
end

function sling.model.NullLiteralExpressionNode:createNew()
	do return _g.sling.model.NullLiteralExpressionNode._construct0(_g.sling.model.NullLiteralExpressionNode._create()) end
end

function sling.model.NullLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NullLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NullLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NullLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NullLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

sling.model.CurrentObjectExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.CurrentObjectExpressionNode.__index = sling.model.CurrentObjectExpressionNode
_vm:set_metatable(sling.model.CurrentObjectExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.CurrentObjectExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.CurrentObjectExpressionNode)
	return v
end

function sling.model.CurrentObjectExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.CurrentObjectExpressionNode'
	self['_isType.sling.model.CurrentObjectExpressionNode'] = true
end

function sling.model.CurrentObjectExpressionNode:_construct0()
	sling.model.CurrentObjectExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.CurrentObjectExpressionNode:getNodeTypeName()
	do return "CurrentObjectExpressionNode" end
end

function sling.model.CurrentObjectExpressionNode:createNew()
	do return _g.sling.model.CurrentObjectExpressionNode._construct0(_g.sling.model.CurrentObjectExpressionNode._create()) end
end

function sling.model.CurrentObjectExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.CurrentObjectExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.CurrentObjectExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.CurrentObjectExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.CurrentObjectExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.VectorDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.VectorDataTypeNode.__index = sling.model.VectorDataTypeNode
_vm:set_metatable(sling.model.VectorDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

function sling.model.VectorDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.VectorDataTypeNode)
	return v
end

function sling.model.VectorDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.VectorDataTypeNode'
	self['_isType.sling.model.VectorDataTypeNode'] = true
end

function sling.model.VectorDataTypeNode:_construct0()
	sling.model.VectorDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.VectorDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.VectorDataTypeNode._construct0(_g.sling.model.VectorDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.VectorDataTypeNode:getNodeTypeName()
	do return "VectorDataTypeNode" end
end

function sling.model.VectorDataTypeNode:createNew()
	do return _g.sling.model.VectorDataTypeNode._construct0(_g.sling.model.VectorDataTypeNode._create()) end
end

function sling.model.VectorDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.VectorDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.VectorDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.VectorDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.VectorDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

sling.model.ArrayCreationExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.ArrayCreationExpressionNode.__index = sling.model.ArrayCreationExpressionNode
_vm:set_metatable(sling.model.ArrayCreationExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.ArrayCreationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ArrayCreationExpressionNode)
	return v
end

function sling.model.ArrayCreationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ArrayCreationExpressionNode'
	self['_isType.sling.model.ArrayCreationExpressionNode'] = true
	self.dimensions = nil
	self.arrayLiteral = nil
	self.primaryType = nil
	self.expressionType = nil
end

function sling.model.ArrayCreationExpressionNode:_construct0()
	sling.model.ArrayCreationExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.ArrayCreationExpressionNode:forPrimaryType(type)
	local v = _g.sling.model.ArrayCreationExpressionNode._construct0(_g.sling.model.ArrayCreationExpressionNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.ArrayCreationExpressionNode:forLiteral(literal)
	local v = _g.sling.model.ArrayCreationExpressionNode._construct0(_g.sling.model.ArrayCreationExpressionNode._create())
	do v:setArrayLiteral(literal, false) end
	do v:addToDimensions(_g.sling.model.EmptyExpressionNode._construct0(_g.sling.model.EmptyExpressionNode._create())) end
	do return v end
end

function sling.model.ArrayCreationExpressionNode:getDimensionCount()
	if self.dimensions == nil then
		do return 0 end
	end
	do return _g.jk.lang.Vector:getSize(self.dimensions) end
end

function sling.model.ArrayCreationExpressionNode:getPrimaryType()
	if self.primaryType ~= nil then
		do return self.primaryType end
	end
	if self.arrayLiteral ~= nil then
		do return self.arrayLiteral:getType() end
	end
	do return nil end
end

function sling.model.ArrayCreationExpressionNode:getNodeTypeName()
	do return "ArrayCreationExpressionNode" end
end

function sling.model.ArrayCreationExpressionNode:createNew()
	do return _g.sling.model.ArrayCreationExpressionNode._construct0(_g.sling.model.ArrayCreationExpressionNode._create()) end
end

function sling.model.ArrayCreationExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ArrayCreationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.arrayLiteral ~= nil then
			do n.arrayLiteral:destroy() end
			n.arrayLiteral = nil
		end
		if self.arrayLiteral ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.arrayLiteral), '_isType.sling.model.ArrayLiteralExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.arrayLiteral = pcp
			do n.arrayLiteral:setParent(n) end
		end
		if n.primaryType ~= nil then
			do n.primaryType:destroy() end
			n.primaryType = nil
		end
		if self.primaryType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.primaryType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.primaryType = pcp
			do n.primaryType:setParent(n) end
		end
		if n.expressionType ~= nil then
			do n.expressionType:destroy() end
			n.expressionType = nil
		end
		if self.expressionType ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expressionType), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.expressionType = pcp
			do n.expressionType:setParent(n) end
		end
		do
			local array = n.dimensions
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.dimensions = nil
			if self.dimensions ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.dimensions)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.dimensions[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.dimensions == nil then
								n.dimensions = {}
							end
							do _g.jk.lang.Vector:append(n.dimensions, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ArrayCreationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.arrayLiteral then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ArrayLiteralExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.arrayLiteral:destroy() end
		end
		self.arrayLiteral = _vm:to_table_with_key(newnode, '_isType.sling.model.ArrayLiteralExpressionNode')
		if self.arrayLiteral ~= nil then
			do self.arrayLiteral:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.primaryType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.primaryType:destroy() end
		end
		self.primaryType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.primaryType ~= nil then
			do self.primaryType:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.expressionType then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expressionType:destroy() end
		end
		self.expressionType = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.expressionType ~= nil then
			do self.expressionType:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.dimensions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ArrayCreationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.arrayLiteral ~= nil then
		if self.arrayLiteral:accept(visitor) == false then
			do return false end
		end
	end
	if self.primaryType ~= nil then
		if self.primaryType:accept(visitor) == false then
			do return false end
		end
	end
	if self.expressionType ~= nil then
		if self.expressionType:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.dimensions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ArrayCreationExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.arrayLiteral ~= nil then
		do self.arrayLiteral:destroy() end
		self.arrayLiteral = nil
	end
	if self.primaryType ~= nil then
		do self.primaryType:destroy() end
		self.primaryType = nil
	end
	if self.expressionType ~= nil then
		do self.expressionType:destroy() end
		self.expressionType = nil
	end
	if self.dimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.dimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.dimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.dimensions = nil
end

function sling.model.ArrayCreationExpressionNode:setArrayLiteral(v, doExport)
	if self.arrayLiteral ~= nil and doExport == false then
		do self.arrayLiteral:destroy() end
	end
	self.arrayLiteral = v
	if self.arrayLiteral ~= nil then
		do self.arrayLiteral:setParent(self) end
	end
end

function sling.model.ArrayCreationExpressionNode:getArrayLiteral()
	do return self.arrayLiteral end
end

function sling.model.ArrayCreationExpressionNode:exportArrayLiteral()
	local v = self.arrayLiteral
	self.arrayLiteral = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:setPrimaryType(v, doExport)
	if self.primaryType ~= nil and doExport == false then
		do self.primaryType:destroy() end
	end
	self.primaryType = v
	if self.primaryType ~= nil then
		do self.primaryType:setParent(self) end
	end
end

function sling.model.ArrayCreationExpressionNode:exportPrimaryType()
	local v = self.primaryType
	self.primaryType = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:setExpressionType(v, doExport)
	if self.expressionType ~= nil and doExport == false then
		do self.expressionType:destroy() end
	end
	self.expressionType = v
	if self.expressionType ~= nil then
		do self.expressionType:setParent(self) end
	end
end

function sling.model.ArrayCreationExpressionNode:getExpressionType()
	do return self.expressionType end
end

function sling.model.ArrayCreationExpressionNode:exportExpressionType()
	local v = self.expressionType
	self.expressionType = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:setDimensions(v, doExport)
	if self.dimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.dimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.dimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.dimensions = nil
	else
		self.dimensions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.dimensions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ArrayCreationExpressionNode:getDimensions()
	do return self.dimensions end
end

function sling.model.ArrayCreationExpressionNode:exportDimensions()
	local v = self.dimensions
	self.dimensions = nil
	do return v end
end

function sling.model.ArrayCreationExpressionNode:addToDimensions(v)
	if v == nil then
		do return end
	end
	if self.dimensions == nil then
		self.dimensions = {}
	end
	do _g.jk.lang.Vector:append(self.dimensions, v) end
	do v:setParent(self) end
end

function sling.model.ArrayCreationExpressionNode:clearDimensions()
	if self.dimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.dimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.dimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.dimensions = nil
end

sling.model.ClassDeclarationInstantiationExpressionNode = _g.sling.model.ExpressionNode._create()
sling.model.ClassDeclarationInstantiationExpressionNode.__index = sling.model.ClassDeclarationInstantiationExpressionNode
_vm:set_metatable(sling.model.ClassDeclarationInstantiationExpressionNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.ClassDeclarationInstantiationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ClassDeclarationInstantiationExpressionNode)
	return v
end

function sling.model.ClassDeclarationInstantiationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ClassDeclarationInstantiationExpressionNode'
	self['_isType.sling.model.ClassDeclarationInstantiationExpressionNode'] = true
	self.parameters = nil
	self.classDeclaration = nil
end

function sling.model.ClassDeclarationInstantiationExpressionNode:_construct0()
	sling.model.ClassDeclarationInstantiationExpressionNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.ClassDeclarationInstantiationExpressionNode:forDeclaration(cdecl)
	local v = _g.sling.model.ClassDeclarationInstantiationExpressionNode._construct0(_g.sling.model.ClassDeclarationInstantiationExpressionNode._create())
	do v:setClassDeclaration(cdecl, false) end
	do return v end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:getNodeTypeName()
	do return "ClassDeclarationInstantiationExpressionNode" end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:createNew()
	do return _g.sling.model.ClassDeclarationInstantiationExpressionNode._construct0(_g.sling.model.ClassDeclarationInstantiationExpressionNode._create()) end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ClassDeclarationInstantiationExpressionNode')
		if n == nil then
			do return true end
		end
		if n.classDeclaration ~= nil then
			do n.classDeclaration:destroy() end
			n.classDeclaration = nil
		end
		if self.classDeclaration ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.classDeclaration), '_isType.sling.model.ClassDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.classDeclaration = pcp
			do n.classDeclaration:setParent(n) end
		end
		do
			local array = n.parameters
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.parameters = nil
			if self.parameters ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.parameters)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.parameters[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.parameters == nil then
								n.parameters = {}
							end
							do _g.jk.lang.Vector:append(n.parameters, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.classDeclaration then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ClassDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.classDeclaration:destroy() end
		end
		self.classDeclaration = _vm:to_table_with_key(newnode, '_isType.sling.model.ClassDeclarationNode')
		if self.classDeclaration ~= nil then
			do self.classDeclaration:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.parameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.classDeclaration ~= nil then
		if self.classDeclaration:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.parameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.classDeclaration ~= nil then
		do self.classDeclaration:destroy() end
		self.classDeclaration = nil
	end
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

function sling.model.ClassDeclarationInstantiationExpressionNode:setClassDeclaration(v, doExport)
	if self.classDeclaration ~= nil and doExport == false then
		do self.classDeclaration:destroy() end
	end
	self.classDeclaration = v
	if self.classDeclaration ~= nil then
		do self.classDeclaration:setParent(self) end
	end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:getClassDeclaration()
	do return self.classDeclaration end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:exportClassDeclaration()
	local v = self.classDeclaration
	self.classDeclaration = nil
	do return v end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:setParameters(v, doExport)
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.parameters = nil
	else
		self.parameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.parameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:getParameters()
	do return self.parameters end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:exportParameters()
	local v = self.parameters
	self.parameters = nil
	do return v end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:addToParameters(v)
	if v == nil then
		do return end
	end
	if self.parameters == nil then
		self.parameters = {}
	end
	do _g.jk.lang.Vector:append(self.parameters, v) end
	do v:setParent(self) end
end

function sling.model.ClassDeclarationInstantiationExpressionNode:clearParameters()
	if self.parameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.parameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.parameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.parameters = nil
end

sling.model.GetExpressionTypeinfoExpressionNode = _g.sling.model.GetTypeinfoExpressionNode._create()
sling.model.GetExpressionTypeinfoExpressionNode.__index = sling.model.GetExpressionTypeinfoExpressionNode
_vm:set_metatable(sling.model.GetExpressionTypeinfoExpressionNode, {
	__index = _g.sling.model.GetTypeinfoExpressionNode
})

function sling.model.GetExpressionTypeinfoExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetExpressionTypeinfoExpressionNode)
	return v
end

function sling.model.GetExpressionTypeinfoExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetExpressionTypeinfoExpressionNode'
	self['_isType.sling.model.GetExpressionTypeinfoExpressionNode'] = true
	self.expression = nil
end

function sling.model.GetExpressionTypeinfoExpressionNode:forExpression(xpr)
	local v = _g.sling.model.GetExpressionTypeinfoExpressionNode._construct0(_g.sling.model.GetExpressionTypeinfoExpressionNode._create())
	do v:setExpression(xpr, false) end
	do return v end
end

function sling.model.GetExpressionTypeinfoExpressionNode:_construct0()
	sling.model.GetExpressionTypeinfoExpressionNode._init(self)
	do _g.sling.model.GetTypeinfoExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create()), false) end
	return self
end

function sling.model.GetExpressionTypeinfoExpressionNode:getNodeTypeName()
	do return "GetExpressionTypeinfoExpressionNode" end
end

function sling.model.GetExpressionTypeinfoExpressionNode:createNew()
	do return _g.sling.model.GetExpressionTypeinfoExpressionNode._construct0(_g.sling.model.GetExpressionTypeinfoExpressionNode._create()) end
end

function sling.model.GetExpressionTypeinfoExpressionNode:copyTo(o)
	if _g.sling.model.GetTypeinfoExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetExpressionTypeinfoExpressionNode')
		if n == nil then
			do return true end
		end
		if n.expression ~= nil then
			do n.expression:destroy() end
			n.expression = nil
		end
		if self.expression ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.expression), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.expression = pcp
			do n.expression:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetExpressionTypeinfoExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.expression then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.expression:destroy() end
		end
		self.expression = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.expression ~= nil then
			do self.expression:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.GetTypeinfoExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetExpressionTypeinfoExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.GetTypeinfoExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.expression ~= nil then
		if self.expression:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetExpressionTypeinfoExpressionNode:destroy()
	do _g.sling.model.GetTypeinfoExpressionNode.destroy(self) end
	if self.expression ~= nil then
		do self.expression:destroy() end
		self.expression = nil
	end
end

function sling.model.GetExpressionTypeinfoExpressionNode:setExpression(v, doExport)
	if self.expression ~= nil and doExport == false then
		do self.expression:destroy() end
	end
	self.expression = v
	if self.expression ~= nil then
		do self.expression:setParent(self) end
	end
end

function sling.model.GetExpressionTypeinfoExpressionNode:getExpression()
	do return self.expression end
end

function sling.model.GetExpressionTypeinfoExpressionNode:exportExpression()
	local v = self.expression
	self.expression = nil
	do return v end
end

sling.model.FloatDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.FloatDataTypeNode.__index = sling.model.FloatDataTypeNode
_vm:set_metatable(sling.model.FloatDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

function sling.model.FloatDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.FloatDataTypeNode)
	return v
end

function sling.model.FloatDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FloatDataTypeNode'
	self['_isType.sling.model.FloatDataTypeNode'] = true
end

function sling.model.FloatDataTypeNode:_construct0()
	sling.model.FloatDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.FloatDataTypeNode:getNodeTypeName()
	do return "FloatDataTypeNode" end
end

function sling.model.FloatDataTypeNode:createNew()
	do return _g.sling.model.FloatDataTypeNode._construct0(_g.sling.model.FloatDataTypeNode._create()) end
end

function sling.model.FloatDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FloatDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FloatDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FloatDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FloatDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

sling.model.GetDatatypeTypeinfoExpressionNode = _g.sling.model.GetTypeinfoExpressionNode._create()
sling.model.GetDatatypeTypeinfoExpressionNode.__index = sling.model.GetDatatypeTypeinfoExpressionNode
_vm:set_metatable(sling.model.GetDatatypeTypeinfoExpressionNode, {
	__index = _g.sling.model.GetTypeinfoExpressionNode
})

function sling.model.GetDatatypeTypeinfoExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.GetDatatypeTypeinfoExpressionNode)
	return v
end

function sling.model.GetDatatypeTypeinfoExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.GetDatatypeTypeinfoExpressionNode'
	self['_isType.sling.model.GetDatatypeTypeinfoExpressionNode'] = true
	self.type = nil
end

function sling.model.GetDatatypeTypeinfoExpressionNode:forDatatype(type)
	local v = _g.sling.model.GetDatatypeTypeinfoExpressionNode._construct0(_g.sling.model.GetDatatypeTypeinfoExpressionNode._create())
	do v:setType(type, false) end
	do return v end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:_construct0()
	sling.model.GetDatatypeTypeinfoExpressionNode._init(self)
	do _g.sling.model.GetTypeinfoExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.TypeInfoDataTypeNode._construct0(_g.sling.model.TypeInfoDataTypeNode._create()), false) end
	return self
end

function sling.model.GetDatatypeTypeinfoExpressionNode:getNodeTypeName()
	do return "GetDatatypeTypeinfoExpressionNode" end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:createNew()
	do return _g.sling.model.GetDatatypeTypeinfoExpressionNode._construct0(_g.sling.model.GetDatatypeTypeinfoExpressionNode._create()) end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:copyTo(o)
	if _g.sling.model.GetTypeinfoExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.GetDatatypeTypeinfoExpressionNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		do return true end
	end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.GetTypeinfoExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.GetTypeinfoExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:destroy()
	do _g.sling.model.GetTypeinfoExpressionNode.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:getType()
	do return self.type end
end

function sling.model.GetDatatypeTypeinfoExpressionNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

sling.model.ExponentAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.ExponentAssignmentExpressionNode.__index = sling.model.ExponentAssignmentExpressionNode
_vm:set_metatable(sling.model.ExponentAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.ExponentAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.ExponentAssignmentExpressionNode)
	return v
end

function sling.model.ExponentAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ExponentAssignmentExpressionNode'
	self['_isType.sling.model.ExponentAssignmentExpressionNode'] = true
end

function sling.model.ExponentAssignmentExpressionNode:_construct0()
	sling.model.ExponentAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.ExponentAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.ExponentAssignmentExpressionNode._construct0(_g.sling.model.ExponentAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.ExponentAssignmentExpressionNode:getNodeTypeName()
	do return "ExponentAssignmentExpressionNode" end
end

function sling.model.ExponentAssignmentExpressionNode:createNew()
	do return _g.sling.model.ExponentAssignmentExpressionNode._construct0(_g.sling.model.ExponentAssignmentExpressionNode._create()) end
end

function sling.model.ExponentAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ExponentAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ExponentAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ExponentAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ExponentAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.PropertyValueDeclarationNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.PropertyValueDeclarationNode.__index = sling.model.PropertyValueDeclarationNode
_vm:set_metatable(sling.model.PropertyValueDeclarationNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.PropertyValueDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyValueDeclarationNode)
	return v
end

function sling.model.PropertyValueDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyValueDeclarationNode'
	self['_isType.sling.model.PropertyValueDeclarationNode'] = true
	self.key = nil
	self.index = nil
	self.keyParams = nil
	self.keyDimensions = nil
	self.value = nil
	self.comment = nil
	self.objectFlag = false
end

function sling.model.PropertyValueDeclarationNode:_construct0()
	sling.model.PropertyValueDeclarationNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.PropertyValueDeclarationNode:forName(name, value)
	local v = _g.sling.model.PropertyValueDeclarationNode._construct0(_g.sling.model.PropertyValueDeclarationNode._create())
	do v:setKey(name) end
	do v:setValue(value, false) end
	do return v end
end

function sling.model.PropertyValueDeclarationNode:hasName(value)
	if value == self.key then
		do return true end
	end
	do return false end
end

function sling.model.PropertyValueDeclarationNode:getValueString()
	local ss = _vm:to_table_with_key(self.value, '_isType.sling.model.StringLiteralExpressionNode')
	if ss ~= nil then
		do return ss:getValue() end
	end
	do
		local ii = _vm:to_table_with_key(self.value, '_isType.sling.model.IntegerLiteralExpressionNode')
		if ii ~= nil then
			do return _g.jk.lang.String:forInteger(ii:getValue()) end
		end
		do
			local dd = _vm:to_table_with_key(self.value, '_isType.sling.model.DoubleLiteralExpressionNode')
			if dd ~= nil then
				do return _g.jk.lang.String:forDouble(dd:getValue()) end
			end
			do
				local bb = _vm:to_table_with_key(self.value, '_isType.sling.model.BooleanLiteralExpressionNode')
				if bb ~= nil then
					do return _g.jk.lang.String:forBoolean(bb:getValue()) end
				end
				do return nil end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getValueInteger()
	local ss = _vm:to_table_with_key(self.value, '_isType.sling.model.StringLiteralExpressionNode')
	if ss ~= nil then
		do return _g.jk.lang.String:toInteger(ss:getValue()) end
	end
	do
		local ii = _vm:to_table_with_key(self.value, '_isType.sling.model.IntegerLiteralExpressionNode')
		if ii ~= nil then
			do return ii:getValue() end
		end
		do
			local dd = _vm:to_table_with_key(self.value, '_isType.sling.model.DoubleLiteralExpressionNode')
			if dd ~= nil then
				do return _util:convert_to_integer(dd:getValue()) end
			end
			do
				local bb = _vm:to_table_with_key(self.value, '_isType.sling.model.BooleanLiteralExpressionNode')
				if bb ~= nil then
					if bb:getValue() then
						do return 1 end
					end
					do return 0 end
				end
				do return 0 end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getValueDouble()
	local ss = _vm:to_table_with_key(self.value, '_isType.sling.model.StringLiteralExpressionNode')
	if ss ~= nil then
		do return _g.jk.lang.String:toDouble(ss:getValue()) end
	end
	do
		local ii = _vm:to_table_with_key(self.value, '_isType.sling.model.IntegerLiteralExpressionNode')
		if ii ~= nil then
			do return ii:getValue() end
		end
		do
			local dd = _vm:to_table_with_key(self.value, '_isType.sling.model.DoubleLiteralExpressionNode')
			if dd ~= nil then
				do return dd:getValue() end
			end
			do
				local bb = _vm:to_table_with_key(self.value, '_isType.sling.model.BooleanLiteralExpressionNode')
				if bb ~= nil then
					if bb:getValue() then
						do return 1.0 end
					end
					do return 0.0 end
				end
				do return 0.0 end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getValueBuffer()
	local xpr = _vm:to_table_with_key(self.value, '_isType.sling.model.BufferLiteralExpressionNode')
	if not (xpr ~= nil) then
		do return nil end
	end
	do return xpr:getValue() end
end

function sling.model.PropertyValueDeclarationNode:getNodeTypeName()
	do return "PropertyValueDeclarationNode" end
end

function sling.model.PropertyValueDeclarationNode:createNew()
	do return _g.sling.model.PropertyValueDeclarationNode._construct0(_g.sling.model.PropertyValueDeclarationNode._create()) end
end

function sling.model.PropertyValueDeclarationNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyValueDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.index ~= nil then
			do n.index:destroy() end
			n.index = nil
		end
		if self.index ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.index), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.index = pcp
			do n.index:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.key = self.key
		n.comment = self.comment
		n.objectFlag = self.objectFlag
		do
			local array = n.keyParams
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.keyParams = nil
			if self.keyParams ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.keyParams)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.keyParams[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.keyParams == nil then
								n.keyParams = {}
							end
							do _g.jk.lang.Vector:append(n.keyParams, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.keyDimensions
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.keyDimensions = nil
				if self.keyDimensions ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.keyDimensions)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.keyDimensions[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.keyDimensions == nil then
									n.keyDimensions = {}
								end
								do _g.jk.lang.Vector:append(n.keyDimensions, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.index then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.index:destroy() end
		end
		self.index = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.index ~= nil then
			do self.index:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	if self:replaceNodeInVector(self.keyParams, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.keyDimensions, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyValueDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.index ~= nil then
		if self.index:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	if self:visitVector(self.keyParams, visitor) == false then
		do return false end
	end
	if self:visitVector(self.keyDimensions, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertyValueDeclarationNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.index ~= nil then
		do self.index:destroy() end
		self.index = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
	if self.keyParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.keyParams = nil
	if self.keyDimensions ~= nil then
		local n2 = 0
		local m2 = _g.jk.lang.Vector:getSize(self.keyDimensions)
		do
			n2 = 0
			while n2 < m2 do
				local nx = _vm:to_table_with_key(self.keyDimensions[n2 + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n2 = n2 + 1 end
			end
		end
	end
	self.keyDimensions = nil
end

function sling.model.PropertyValueDeclarationNode:setIndex(v, doExport)
	if self.index ~= nil and doExport == false then
		do self.index:destroy() end
	end
	self.index = v
	if self.index ~= nil then
		do self.index:setParent(self) end
	end
end

function sling.model.PropertyValueDeclarationNode:getIndex()
	do return self.index end
end

function sling.model.PropertyValueDeclarationNode:exportIndex()
	local v = self.index
	self.index = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.PropertyValueDeclarationNode:getValue()
	do return self.value end
end

function sling.model.PropertyValueDeclarationNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:setKey(v)
	self.key = v
end

function sling.model.PropertyValueDeclarationNode:getKey()
	do return self.key end
end

function sling.model.PropertyValueDeclarationNode:setComment(v)
	self.comment = v
end

function sling.model.PropertyValueDeclarationNode:getComment()
	do return self.comment end
end

function sling.model.PropertyValueDeclarationNode:setObjectFlag(v)
	self.objectFlag = v
end

function sling.model.PropertyValueDeclarationNode:getObjectFlag()
	do return self.objectFlag end
end

function sling.model.PropertyValueDeclarationNode:setKeyParams(v, doExport)
	if self.keyParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.keyParams = nil
	else
		self.keyParams = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.keyParams, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getKeyParams()
	do return self.keyParams end
end

function sling.model.PropertyValueDeclarationNode:exportKeyParams()
	local v = self.keyParams
	self.keyParams = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:addToKeyParams(v)
	if v == nil then
		do return end
	end
	if self.keyParams == nil then
		self.keyParams = {}
	end
	do _g.jk.lang.Vector:append(self.keyParams, v) end
	do v:setParent(self) end
end

function sling.model.PropertyValueDeclarationNode:clearKeyParams()
	if self.keyParams ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyParams)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyParams[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.keyParams = nil
end

function sling.model.PropertyValueDeclarationNode:setKeyDimensions(v, doExport)
	if self.keyDimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyDimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyDimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.keyDimensions = nil
	else
		self.keyDimensions = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.keyDimensions, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.PropertyValueDeclarationNode:getKeyDimensions()
	do return self.keyDimensions end
end

function sling.model.PropertyValueDeclarationNode:exportKeyDimensions()
	local v = self.keyDimensions
	self.keyDimensions = nil
	do return v end
end

function sling.model.PropertyValueDeclarationNode:addToKeyDimensions(v)
	if v == nil then
		do return end
	end
	if self.keyDimensions == nil then
		self.keyDimensions = {}
	end
	do _g.jk.lang.Vector:append(self.keyDimensions, v) end
	do v:setParent(self) end
end

function sling.model.PropertyValueDeclarationNode:clearKeyDimensions()
	if self.keyDimensions ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.keyDimensions)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.keyDimensions[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.keyDimensions = nil
end

sling.model.MembershipCheckExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.MembershipCheckExpressionNode.__index = sling.model.MembershipCheckExpressionNode
_vm:set_metatable(sling.model.MembershipCheckExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.MembershipCheckExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MembershipCheckExpressionNode)
	return v
end

function sling.model.MembershipCheckExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MembershipCheckExpressionNode'
	self['_isType.sling.model.MembershipCheckExpressionNode'] = true
end

function sling.model.MembershipCheckExpressionNode:_construct0()
	sling.model.MembershipCheckExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.MembershipCheckExpressionNode:instance(left, right)
	local v = _g.sling.model.MembershipCheckExpressionNode._construct0(_g.sling.model.MembershipCheckExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.MembershipCheckExpressionNode:getNodeTypeName()
	do return "MembershipCheckExpressionNode" end
end

function sling.model.MembershipCheckExpressionNode:createNew()
	do return _g.sling.model.MembershipCheckExpressionNode._construct0(_g.sling.model.MembershipCheckExpressionNode._create()) end
end

function sling.model.MembershipCheckExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MembershipCheckExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MembershipCheckExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MembershipCheckExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MembershipCheckExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.KeyValueVariableDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.KeyValueVariableDeclarationNode.__index = sling.model.KeyValueVariableDeclarationNode
_vm:set_metatable(sling.model.KeyValueVariableDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.KeyValueVariableDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.KeyValueVariableDeclarationNode)
	return v
end

function sling.model.KeyValueVariableDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.KeyValueVariableDeclarationNode'
	self['_isType.sling.model.KeyValueVariableDeclarationNode'] = true
	self.key = nil
	self.value = nil
end

function sling.model.KeyValueVariableDeclarationNode:_construct0()
	sling.model.KeyValueVariableDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.KeyValueVariableDeclarationNode:forVariables(key, value)
	local v = _g.sling.model.KeyValueVariableDeclarationNode._construct0(_g.sling.model.KeyValueVariableDeclarationNode._create())
	do v:setKey(key, false) end
	do v:setValue(value, false) end
	do return v end
end

function sling.model.KeyValueVariableDeclarationNode:getNodeTypeName()
	do return "KeyValueVariableDeclarationNode" end
end

function sling.model.KeyValueVariableDeclarationNode:createNew()
	do return _g.sling.model.KeyValueVariableDeclarationNode._construct0(_g.sling.model.KeyValueVariableDeclarationNode._create()) end
end

function sling.model.KeyValueVariableDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.KeyValueVariableDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.key ~= nil then
			do n.key:destroy() end
			n.key = nil
		end
		if self.key ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.key), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.key = pcp
			do n.key:setParent(n) end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		do return true end
	end
end

function sling.model.KeyValueVariableDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.key then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.key:destroy() end
		end
		self.key = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.key ~= nil then
			do self.key:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.KeyValueVariableDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.key ~= nil then
		if self.key:accept(visitor) == false then
			do return false end
		end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.KeyValueVariableDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.key ~= nil then
		do self.key:destroy() end
		self.key = nil
	end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.KeyValueVariableDeclarationNode:setKey(v, doExport)
	if self.key ~= nil and doExport == false then
		do self.key:destroy() end
	end
	self.key = v
	if self.key ~= nil then
		do self.key:setParent(self) end
	end
end

function sling.model.KeyValueVariableDeclarationNode:getKey()
	do return self.key end
end

function sling.model.KeyValueVariableDeclarationNode:exportKey()
	local v = self.key
	self.key = nil
	do return v end
end

function sling.model.KeyValueVariableDeclarationNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.KeyValueVariableDeclarationNode:getValue()
	do return self.value end
end

function sling.model.KeyValueVariableDeclarationNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

sling.model.DoubleLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.DoubleLiteralExpressionNode.__index = sling.model.DoubleLiteralExpressionNode
_vm:set_metatable(sling.model.DoubleLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

sling.model.DoubleLiteralExpressionNode.FORMAT_DECIMAL = 0
sling.model.DoubleLiteralExpressionNode.FORMAT_HEXADECIMAL = 1

function sling.model.DoubleLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DoubleLiteralExpressionNode)
	return v
end

function sling.model.DoubleLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DoubleLiteralExpressionNode'
	self['_isType.sling.model.DoubleLiteralExpressionNode'] = true
	self.value = 0.0
	self.format = 0
end

function sling.model.DoubleLiteralExpressionNode:forValue(value)
	local v = _g.sling.model.DoubleLiteralExpressionNode._construct0(_g.sling.model.DoubleLiteralExpressionNode._create())
	do v:setValue(value) end
	do return v end
end

function sling.model.DoubleLiteralExpressionNode:_construct0()
	sling.model.DoubleLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.DoubleDataTypeNode._construct0(_g.sling.model.DoubleDataTypeNode._create()), false) end
	return self
end

function sling.model.DoubleLiteralExpressionNode:getNodeTypeName()
	do return "DoubleLiteralExpressionNode" end
end

function sling.model.DoubleLiteralExpressionNode:createNew()
	do return _g.sling.model.DoubleLiteralExpressionNode._construct0(_g.sling.model.DoubleLiteralExpressionNode._create()) end
end

function sling.model.DoubleLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DoubleLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		n.format = self.format
		do return true end
	end
end

function sling.model.DoubleLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DoubleLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DoubleLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
end

function sling.model.DoubleLiteralExpressionNode:setValue(v)
	self.value = v
end

function sling.model.DoubleLiteralExpressionNode:getValue()
	do return self.value end
end

function sling.model.DoubleLiteralExpressionNode:setFormat(v)
	self.format = v
end

function sling.model.DoubleLiteralExpressionNode:getFormat()
	do return self.format end
end

sling.model.ContinueStatementNode = _g.sling.common.NodeObject._create()
sling.model.ContinueStatementNode.__index = sling.model.ContinueStatementNode
_vm:set_metatable(sling.model.ContinueStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ContinueStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ContinueStatementNode)
	return v
end

function sling.model.ContinueStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ContinueStatementNode'
	self['_isType.sling.model.ContinueStatementNode'] = true
	self.level = 0
end

function sling.model.ContinueStatementNode:_construct0()
	sling.model.ContinueStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ContinueStatementNode:getNodeTypeName()
	do return "ContinueStatementNode" end
end

function sling.model.ContinueStatementNode:createNew()
	do return _g.sling.model.ContinueStatementNode._construct0(_g.sling.model.ContinueStatementNode._create()) end
end

function sling.model.ContinueStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ContinueStatementNode')
		if n == nil then
			do return true end
		end
		n.level = self.level
		do return true end
	end
end

function sling.model.ContinueStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ContinueStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ContinueStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ContinueStatementNode:setLevel(v)
	self.level = v
end

function sling.model.ContinueStatementNode:getLevel()
	do return self.level end
end

sling.model.ErrorStatementNode = _g.sling.common.NodeObject._create()
sling.model.ErrorStatementNode.__index = sling.model.ErrorStatementNode
_vm:set_metatable(sling.model.ErrorStatementNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.ErrorStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ErrorStatementNode)
	return v
end

function sling.model.ErrorStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ErrorStatementNode'
	self['_isType.sling.model.ErrorStatementNode'] = true
	self.message = nil
end

function sling.model.ErrorStatementNode:_construct0()
	sling.model.ErrorStatementNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.ErrorStatementNode:forText(text)
	local v = _g.sling.model.ErrorStatementNode._construct0(_g.sling.model.ErrorStatementNode._create())
	do v:setMessage(text) end
	do return v end
end

function sling.model.ErrorStatementNode:getNodeTypeName()
	do return "ErrorStatementNode" end
end

function sling.model.ErrorStatementNode:createNew()
	do return _g.sling.model.ErrorStatementNode._construct0(_g.sling.model.ErrorStatementNode._create()) end
end

function sling.model.ErrorStatementNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ErrorStatementNode')
		if n == nil then
			do return true end
		end
		n.message = self.message
		do return true end
	end
end

function sling.model.ErrorStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ErrorStatementNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ErrorStatementNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.ErrorStatementNode:setMessage(v)
	self.message = v
end

function sling.model.ErrorStatementNode:getMessage()
	do return self.message end
end

sling.model.MultiplicationExpressionNode = _g.sling.model.ArithmeticExpressionNode._create()
sling.model.MultiplicationExpressionNode.__index = sling.model.MultiplicationExpressionNode
_vm:set_metatable(sling.model.MultiplicationExpressionNode, {
	__index = _g.sling.model.ArithmeticExpressionNode
})

function sling.model.MultiplicationExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MultiplicationExpressionNode)
	return v
end

function sling.model.MultiplicationExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultiplicationExpressionNode'
	self['_isType.sling.model.MultiplicationExpressionNode'] = true
end

function sling.model.MultiplicationExpressionNode:_construct0()
	sling.model.MultiplicationExpressionNode._init(self)
	do _g.sling.model.ArithmeticExpressionNode._construct0(self) end
	return self
end

function sling.model.MultiplicationExpressionNode:instance(left, right)
	local v = _g.sling.model.MultiplicationExpressionNode._construct0(_g.sling.model.MultiplicationExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.MultiplicationExpressionNode:getNodeTypeName()
	do return "MultiplicationExpressionNode" end
end

function sling.model.MultiplicationExpressionNode:createNew()
	do return _g.sling.model.MultiplicationExpressionNode._construct0(_g.sling.model.MultiplicationExpressionNode._create()) end
end

function sling.model.MultiplicationExpressionNode:copyTo(o)
	if _g.sling.model.ArithmeticExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultiplicationExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MultiplicationExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ArithmeticExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultiplicationExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.ArithmeticExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultiplicationExpressionNode:destroy()
	do _g.sling.model.ArithmeticExpressionNode.destroy(self) end
end

sling.model.EventDeclarationNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.EventDeclarationNode.__index = sling.model.EventDeclarationNode
_vm:set_metatable(sling.model.EventDeclarationNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.EventDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.EventDeclarationNode)
	return v
end

function sling.model.EventDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.EventDeclarationNode'
	self['_isType.sling.model.EventDeclarationNode'] = true
	self['_isType.sling.common.NamedNode'] = true
	self.name = nil
	self.type = nil
	self.body = nil
	self.description = nil
end

function sling.model.EventDeclarationNode:_construct0()
	sling.model.EventDeclarationNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.EventDeclarationNode:getNodeName()
	do return self.name end
end

function sling.model.EventDeclarationNode:renameNode(v)
	self.name = v
	do self:onIndexPropertiesChanged() end
end

function sling.model.EventDeclarationNode:addToBody(node)
	if not (node ~= nil) then
		do return end
	end
	if not (self.body ~= nil) then
		self.body = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	end
	do self.body:addNode(node) end
end

function sling.model.EventDeclarationNode:getNodeTypeName()
	do return "EventDeclarationNode" end
end

function sling.model.EventDeclarationNode:createNew()
	do return _g.sling.model.EventDeclarationNode._construct0(_g.sling.model.EventDeclarationNode._create()) end
end

function sling.model.EventDeclarationNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.EventDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.type ~= nil then
			do n.type:destroy() end
			n.type = nil
		end
		if self.type ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.type), '_isType.sling.common.DataTypeNode')
			if pcp == nil then
				do return false end
			end
			n.type = pcp
			do n.type:setParent(n) end
		end
		if n.body ~= nil then
			do n.body:destroy() end
			n.body = nil
		end
		if self.body ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.body), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.body = pcp
			do n.body:setParent(n) end
		end
		n.name = self.name
		n.description = self.description
		do return true end
	end
end

function sling.model.EventDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.type then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.type:destroy() end
		end
		self.type = _vm:to_table_with_key(newnode, '_isType.sling.common.DataTypeNode')
		if self.type ~= nil then
			do self.type:setParent(self) end
		end
		do return true end
	end
	if oldnode == self.body then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.body:destroy() end
		end
		self.body = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.body ~= nil then
			do self.body:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.EventDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.type ~= nil then
		if self.type:accept(visitor) == false then
			do return false end
		end
	end
	if self.body ~= nil then
		if self.body:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.EventDeclarationNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	if self.type ~= nil then
		do self.type:destroy() end
		self.type = nil
	end
	if self.body ~= nil then
		do self.body:destroy() end
		self.body = nil
	end
end

function sling.model.EventDeclarationNode:setType(v, doExport)
	if self.type ~= nil and doExport == false then
		do self.type:destroy() end
	end
	self.type = v
	if self.type ~= nil then
		do self.type:setParent(self) end
	end
end

function sling.model.EventDeclarationNode:getType()
	do return self.type end
end

function sling.model.EventDeclarationNode:exportType()
	local v = self.type
	self.type = nil
	do return v end
end

function sling.model.EventDeclarationNode:setBody(v, doExport)
	if self.body ~= nil and doExport == false then
		do self.body:destroy() end
	end
	self.body = v
	if self.body ~= nil then
		do self.body:setParent(self) end
	end
end

function sling.model.EventDeclarationNode:getBody()
	do return self.body end
end

function sling.model.EventDeclarationNode:exportBody()
	local v = self.body
	self.body = nil
	do return v end
end

function sling.model.EventDeclarationNode:setName(v)
	self.name = v
end

function sling.model.EventDeclarationNode:getName()
	do return self.name end
end

function sling.model.EventDeclarationNode:setDescription(v)
	self.description = v
end

function sling.model.EventDeclarationNode:getDescription()
	do return self.description end
end

sling.model.PostIncrementExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PostIncrementExpressionNode.__index = sling.model.PostIncrementExpressionNode
_vm:set_metatable(sling.model.PostIncrementExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PostIncrementExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PostIncrementExpressionNode)
	return v
end

function sling.model.PostIncrementExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PostIncrementExpressionNode'
	self['_isType.sling.model.PostIncrementExpressionNode'] = true
end

function sling.model.PostIncrementExpressionNode:_construct0()
	sling.model.PostIncrementExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PostIncrementExpressionNode:forExpression(expression)
	local v = _g.sling.model.PostIncrementExpressionNode._construct0(_g.sling.model.PostIncrementExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PostIncrementExpressionNode:getNodeTypeName()
	do return "PostIncrementExpressionNode" end
end

function sling.model.PostIncrementExpressionNode:createNew()
	do return _g.sling.model.PostIncrementExpressionNode._construct0(_g.sling.model.PostIncrementExpressionNode._create()) end
end

function sling.model.PostIncrementExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PostIncrementExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PostIncrementExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PostIncrementExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PostIncrementExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.ImportPackageStatementNode = _g.sling.model.ImportStatementNode._create()
sling.model.ImportPackageStatementNode.__index = sling.model.ImportPackageStatementNode
_vm:set_metatable(sling.model.ImportPackageStatementNode, {
	__index = _g.sling.model.ImportStatementNode
})

function sling.model.ImportPackageStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ImportPackageStatementNode)
	return v
end

function sling.model.ImportPackageStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ImportPackageStatementNode'
	self['_isType.sling.model.ImportPackageStatementNode'] = true
	self.package = nil
	self.defaultExport = nil
end

function sling.model.ImportPackageStatementNode:_construct0()
	sling.model.ImportPackageStatementNode._init(self)
	do _g.sling.model.ImportStatementNode._construct0(self) end
	return self
end

function sling.model.ImportPackageStatementNode:getNodeTypeName()
	do return "ImportPackageStatementNode" end
end

function sling.model.ImportPackageStatementNode:createNew()
	do return _g.sling.model.ImportPackageStatementNode._construct0(_g.sling.model.ImportPackageStatementNode._create()) end
end

function sling.model.ImportPackageStatementNode:copyTo(o)
	if _g.sling.model.ImportStatementNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ImportPackageStatementNode')
		if n == nil then
			do return true end
		end
		if n.package ~= nil then
			do n.package:destroy() end
			n.package = nil
		end
		if self.package ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.package), '_isType.sling.model.SymbolNode')
			if pcp == nil then
				do return false end
			end
			n.package = pcp
			do n.package:setParent(n) end
		end
		n.defaultExport = self.defaultExport
		do return true end
	end
end

function sling.model.ImportPackageStatementNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.package then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.package:destroy() end
		end
		self.package = _vm:to_table_with_key(newnode, '_isType.sling.model.SymbolNode')
		if self.package ~= nil then
			do self.package:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ImportStatementNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ImportPackageStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ImportStatementNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.package ~= nil then
		if self.package:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.ImportPackageStatementNode:destroy()
	do _g.sling.model.ImportStatementNode.destroy(self) end
	if self.package ~= nil then
		do self.package:destroy() end
		self.package = nil
	end
end

function sling.model.ImportPackageStatementNode:setPackage(v, doExport)
	if self.package ~= nil and doExport == false then
		do self.package:destroy() end
	end
	self.package = v
	if self.package ~= nil then
		do self.package:setParent(self) end
	end
end

function sling.model.ImportPackageStatementNode:getPackage()
	do return self.package end
end

function sling.model.ImportPackageStatementNode:exportPackage()
	local v = self.package
	self.package = nil
	do return v end
end

function sling.model.ImportPackageStatementNode:setDefaultExport(v)
	self.defaultExport = v
end

function sling.model.ImportPackageStatementNode:getDefaultExport()
	do return self.defaultExport end
end

sling.model.NamedParameterDeclarationNode = _g.sling.model.ExpressionNode._create()
sling.model.NamedParameterDeclarationNode.__index = sling.model.NamedParameterDeclarationNode
_vm:set_metatable(sling.model.NamedParameterDeclarationNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.NamedParameterDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.NamedParameterDeclarationNode)
	return v
end

function sling.model.NamedParameterDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NamedParameterDeclarationNode'
	self['_isType.sling.model.NamedParameterDeclarationNode'] = true
	self.name = nil
	self.variable = nil
end

function sling.model.NamedParameterDeclarationNode:_construct0()
	sling.model.NamedParameterDeclarationNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.NamedParameterDeclarationNode:getNodeTypeName()
	do return "NamedParameterDeclarationNode" end
end

function sling.model.NamedParameterDeclarationNode:createNew()
	do return _g.sling.model.NamedParameterDeclarationNode._construct0(_g.sling.model.NamedParameterDeclarationNode._create()) end
end

function sling.model.NamedParameterDeclarationNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NamedParameterDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.variable ~= nil then
			do n.variable:destroy() end
			n.variable = nil
		end
		if self.variable ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.variable), '_isType.sling.model.VariableDeclarationNode')
			if pcp == nil then
				do return false end
			end
			n.variable = pcp
			do n.variable:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.NamedParameterDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.variable then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.variable:destroy() end
		end
		self.variable = _vm:to_table_with_key(newnode, '_isType.sling.model.VariableDeclarationNode')
		if self.variable ~= nil then
			do self.variable:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NamedParameterDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.variable ~= nil then
		if self.variable:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.NamedParameterDeclarationNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
	if self.variable ~= nil then
		do self.variable:destroy() end
		self.variable = nil
	end
end

function sling.model.NamedParameterDeclarationNode:setVariable(v, doExport)
	if self.variable ~= nil and doExport == false then
		do self.variable:destroy() end
	end
	self.variable = v
	if self.variable ~= nil then
		do self.variable:setParent(self) end
	end
end

function sling.model.NamedParameterDeclarationNode:getVariable()
	do return self.variable end
end

function sling.model.NamedParameterDeclarationNode:exportVariable()
	local v = self.variable
	self.variable = nil
	do return v end
end

function sling.model.NamedParameterDeclarationNode:setName(v)
	self.name = v
end

function sling.model.NamedParameterDeclarationNode:getName()
	do return self.name end
end

sling.model.WithStatementExpressionReferenceNode = _g.sling.model.ExpressionNode._create()
sling.model.WithStatementExpressionReferenceNode.__index = sling.model.WithStatementExpressionReferenceNode
_vm:set_metatable(sling.model.WithStatementExpressionReferenceNode, {
	__index = _g.sling.model.ExpressionNode
})

function sling.model.WithStatementExpressionReferenceNode._create()
	local v = _vm:set_metatable({}, sling.model.WithStatementExpressionReferenceNode)
	return v
end

function sling.model.WithStatementExpressionReferenceNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.WithStatementExpressionReferenceNode'
	self['_isType.sling.model.WithStatementExpressionReferenceNode'] = true
end

function sling.model.WithStatementExpressionReferenceNode:_construct0()
	sling.model.WithStatementExpressionReferenceNode._init(self)
	do _g.sling.model.ExpressionNode._construct0(self) end
	return self
end

function sling.model.WithStatementExpressionReferenceNode:getNodeTypeName()
	do return "WithStatementExpressionReferenceNode" end
end

function sling.model.WithStatementExpressionReferenceNode:createNew()
	do return _g.sling.model.WithStatementExpressionReferenceNode._construct0(_g.sling.model.WithStatementExpressionReferenceNode._create()) end
end

function sling.model.WithStatementExpressionReferenceNode:copyTo(o)
	if _g.sling.model.ExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.WithStatementExpressionReferenceNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.WithStatementExpressionReferenceNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.WithStatementExpressionReferenceNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.WithStatementExpressionReferenceNode:destroy()
	do _g.sling.model.ExpressionNode.destroy(self) end
end

sling.model.MultipleDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.MultipleDataTypeNode.__index = sling.model.MultipleDataTypeNode
_vm:set_metatable(sling.model.MultipleDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.MultipleDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.MultipleDataTypeNode)
	return v
end

function sling.model.MultipleDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MultipleDataTypeNode'
	self['_isType.sling.model.MultipleDataTypeNode'] = true
	self.types = nil
end

function sling.model.MultipleDataTypeNode:_construct0()
	sling.model.MultipleDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.MultipleDataTypeNode:getNodeTypeName()
	do return "MultipleDataTypeNode" end
end

function sling.model.MultipleDataTypeNode:createNew()
	do return _g.sling.model.MultipleDataTypeNode._construct0(_g.sling.model.MultipleDataTypeNode._create()) end
end

function sling.model.MultipleDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MultipleDataTypeNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.types
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.types = nil
			if self.types ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.types)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.types[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.types == nil then
								n.types = {}
							end
							do _g.jk.lang.Vector:append(n.types, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MultipleDataTypeNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.types, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MultipleDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.types, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MultipleDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

function sling.model.MultipleDataTypeNode:setTypes(v, doExport)
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.types = nil
	else
		self.types = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.types, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MultipleDataTypeNode:getTypes()
	do return self.types end
end

function sling.model.MultipleDataTypeNode:exportTypes()
	local v = self.types
	self.types = nil
	do return v end
end

function sling.model.MultipleDataTypeNode:addToTypes(v)
	if v == nil then
		do return end
	end
	if self.types == nil then
		self.types = {}
	end
	do _g.jk.lang.Vector:append(self.types, v) end
	do v:setParent(self) end
end

function sling.model.MultipleDataTypeNode:clearTypes()
	if self.types ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.types)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.types[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.types = nil
end

sling.model.DynamicCastExpressionNode = _g.sling.model.TypeCastExpressionNode._create()
sling.model.DynamicCastExpressionNode.__index = sling.model.DynamicCastExpressionNode
_vm:set_metatable(sling.model.DynamicCastExpressionNode, {
	__index = _g.sling.model.TypeCastExpressionNode
})

function sling.model.DynamicCastExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.DynamicCastExpressionNode)
	return v
end

function sling.model.DynamicCastExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DynamicCastExpressionNode'
	self['_isType.sling.model.DynamicCastExpressionNode'] = true
end

function sling.model.DynamicCastExpressionNode:_construct0()
	sling.model.DynamicCastExpressionNode._init(self)
	do _g.sling.model.TypeCastExpressionNode._construct0(self) end
	return self
end

function sling.model.DynamicCastExpressionNode:instance(type, expression)
	local v = _g.sling.model.DynamicCastExpressionNode._construct0(_g.sling.model.DynamicCastExpressionNode._create())
	do v:setType(type, false) end
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.DynamicCastExpressionNode:getNodeTypeName()
	do return "DynamicCastExpressionNode" end
end

function sling.model.DynamicCastExpressionNode:createNew()
	do return _g.sling.model.DynamicCastExpressionNode._construct0(_g.sling.model.DynamicCastExpressionNode._create()) end
end

function sling.model.DynamicCastExpressionNode:copyTo(o)
	if _g.sling.model.TypeCastExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DynamicCastExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.DynamicCastExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.TypeCastExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DynamicCastExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.TypeCastExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DynamicCastExpressionNode:destroy()
	do _g.sling.model.TypeCastExpressionNode.destroy(self) end
end

sling.model.PropertyWillSetFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.PropertyWillSetFunctionDeclarationNode.__index = sling.model.PropertyWillSetFunctionDeclarationNode
_vm:set_metatable(sling.model.PropertyWillSetFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.PropertyWillSetFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.PropertyWillSetFunctionDeclarationNode)
	return v
end

function sling.model.PropertyWillSetFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PropertyWillSetFunctionDeclarationNode'
	self['_isType.sling.model.PropertyWillSetFunctionDeclarationNode'] = true
end

function sling.model.PropertyWillSetFunctionDeclarationNode:_construct0()
	sling.model.PropertyWillSetFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.PropertyWillSetFunctionDeclarationNode:setParameter(dt, name)
	do self:clearParameters() end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(dt, name, nil)) end
end

function sling.model.PropertyWillSetFunctionDeclarationNode:getNodeTypeName()
	do return "PropertyWillSetFunctionDeclarationNode" end
end

function sling.model.PropertyWillSetFunctionDeclarationNode:createNew()
	do return _g.sling.model.PropertyWillSetFunctionDeclarationNode._construct0(_g.sling.model.PropertyWillSetFunctionDeclarationNode._create()) end
end

function sling.model.PropertyWillSetFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PropertyWillSetFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PropertyWillSetFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PropertyWillSetFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PropertyWillSetFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.TreeDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.TreeDataTypeNode.__index = sling.model.TreeDataTypeNode
_vm:set_metatable(sling.model.TreeDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.TreeDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.TreeDataTypeNode)
	return v
end

function sling.model.TreeDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TreeDataTypeNode'
	self['_isType.sling.model.TreeDataTypeNode'] = true
end

function sling.model.TreeDataTypeNode:_construct0()
	sling.model.TreeDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.TreeDataTypeNode:getNodeTypeName()
	do return "TreeDataTypeNode" end
end

function sling.model.TreeDataTypeNode:createNew()
	do return _g.sling.model.TreeDataTypeNode._construct0(_g.sling.model.TreeDataTypeNode._create()) end
end

function sling.model.TreeDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TreeDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.TreeDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TreeDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.TreeDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.SetLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.SetLiteralExpressionNode.__index = sling.model.SetLiteralExpressionNode
_vm:set_metatable(sling.model.SetLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.SetLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SetLiteralExpressionNode)
	return v
end

function sling.model.SetLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SetLiteralExpressionNode'
	self['_isType.sling.model.SetLiteralExpressionNode'] = true
	self.values = nil
end

function sling.model.SetLiteralExpressionNode:_construct0()
	sling.model.SetLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	do self:setDefaultDataType(_g.sling.model.SetDataTypeNode._construct0(_g.sling.model.SetDataTypeNode._create()), false) end
	return self
end

function sling.model.SetLiteralExpressionNode:getNodeTypeName()
	do return "SetLiteralExpressionNode" end
end

function sling.model.SetLiteralExpressionNode:createNew()
	do return _g.sling.model.SetLiteralExpressionNode._construct0(_g.sling.model.SetLiteralExpressionNode._create()) end
end

function sling.model.SetLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SetLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.values
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.values = nil
			if self.values ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.values)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.values[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.values == nil then
								n.values = {}
							end
							do _g.jk.lang.Vector:append(n.values, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.SetLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.values, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SetLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.values, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SetLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

function sling.model.SetLiteralExpressionNode:setValues(v, doExport)
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.values = nil
	else
		self.values = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.values, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SetLiteralExpressionNode:getValues()
	do return self.values end
end

function sling.model.SetLiteralExpressionNode:exportValues()
	local v = self.values
	self.values = nil
	do return v end
end

function sling.model.SetLiteralExpressionNode:addToValues(v)
	if v == nil then
		do return end
	end
	if self.values == nil then
		self.values = {}
	end
	do _g.jk.lang.Vector:append(self.values, v) end
	do v:setParent(self) end
end

function sling.model.SetLiteralExpressionNode:clearValues()
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

sling.model.AppendToVectorExpressionNode = _g.sling.model.BinaryExpressionNode._create()
sling.model.AppendToVectorExpressionNode.__index = sling.model.AppendToVectorExpressionNode
_vm:set_metatable(sling.model.AppendToVectorExpressionNode, {
	__index = _g.sling.model.BinaryExpressionNode
})

function sling.model.AppendToVectorExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.AppendToVectorExpressionNode)
	return v
end

function sling.model.AppendToVectorExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.AppendToVectorExpressionNode'
	self['_isType.sling.model.AppendToVectorExpressionNode'] = true
end

function sling.model.AppendToVectorExpressionNode:_construct0()
	sling.model.AppendToVectorExpressionNode._init(self)
	do _g.sling.model.BinaryExpressionNode._construct0(self) end
	return self
end

function sling.model.AppendToVectorExpressionNode:getNodeTypeName()
	do return "AppendToVectorExpressionNode" end
end

function sling.model.AppendToVectorExpressionNode:createNew()
	do return _g.sling.model.AppendToVectorExpressionNode._construct0(_g.sling.model.AppendToVectorExpressionNode._create()) end
end

function sling.model.AppendToVectorExpressionNode:copyTo(o)
	if _g.sling.model.BinaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.AppendToVectorExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.AppendToVectorExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.BinaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.AppendToVectorExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.BinaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.AppendToVectorExpressionNode:destroy()
	do _g.sling.model.BinaryExpressionNode.destroy(self) end
end

sling.model.SafeUnwrapOptionalExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.SafeUnwrapOptionalExpressionNode.__index = sling.model.SafeUnwrapOptionalExpressionNode
_vm:set_metatable(sling.model.SafeUnwrapOptionalExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.SafeUnwrapOptionalExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.SafeUnwrapOptionalExpressionNode)
	return v
end

function sling.model.SafeUnwrapOptionalExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SafeUnwrapOptionalExpressionNode'
	self['_isType.sling.model.SafeUnwrapOptionalExpressionNode'] = true
end

function sling.model.SafeUnwrapOptionalExpressionNode:_construct0()
	sling.model.SafeUnwrapOptionalExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.SafeUnwrapOptionalExpressionNode:forExpression(expression)
	local v = _g.sling.model.SafeUnwrapOptionalExpressionNode._construct0(_g.sling.model.SafeUnwrapOptionalExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.SafeUnwrapOptionalExpressionNode:getNodeTypeName()
	do return "SafeUnwrapOptionalExpressionNode" end
end

function sling.model.SafeUnwrapOptionalExpressionNode:createNew()
	do return _g.sling.model.SafeUnwrapOptionalExpressionNode._construct0(_g.sling.model.SafeUnwrapOptionalExpressionNode._create()) end
end

function sling.model.SafeUnwrapOptionalExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SafeUnwrapOptionalExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.SafeUnwrapOptionalExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SafeUnwrapOptionalExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SafeUnwrapOptionalExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.MapLiteralExpressionNode = _g.sling.model.LiteralExpressionNode._create()
sling.model.MapLiteralExpressionNode.__index = sling.model.MapLiteralExpressionNode
_vm:set_metatable(sling.model.MapLiteralExpressionNode, {
	__index = _g.sling.model.LiteralExpressionNode
})

function sling.model.MapLiteralExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.MapLiteralExpressionNode)
	return v
end

function sling.model.MapLiteralExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MapLiteralExpressionNode'
	self['_isType.sling.model.MapLiteralExpressionNode'] = true
	self.values = nil
end

function sling.model.MapLiteralExpressionNode:_construct0()
	sling.model.MapLiteralExpressionNode._init(self)
	do _g.sling.model.LiteralExpressionNode._construct0(self) end
	return self
end

function sling.model.MapLiteralExpressionNode:forObjects()
	local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
	local ddt = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do ddt:setKeyType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
	do ddt:setValueType(_g.sling.model.ObjectDataTypeNode._construct0(_g.sling.model.ObjectDataTypeNode._create()), false) end
	do v:setDefaultDataType(ddt, false) end
	do return v end
end

function sling.model.MapLiteralExpressionNode:forDynamics()
	local v = _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create())
	local ddt = _g.sling.model.MapDataTypeNode._construct0(_g.sling.model.MapDataTypeNode._create())
	do ddt:setKeyType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	do ddt:setValueType(_g.sling.model.DynamicDataTypeNode._construct0(_g.sling.model.DynamicDataTypeNode._create()), false) end
	do v:setDefaultDataType(ddt, false) end
	do return v end
end

function sling.model.MapLiteralExpressionNode:getNodeTypeName()
	do return "MapLiteralExpressionNode" end
end

function sling.model.MapLiteralExpressionNode:createNew()
	do return _g.sling.model.MapLiteralExpressionNode._construct0(_g.sling.model.MapLiteralExpressionNode._create()) end
end

function sling.model.MapLiteralExpressionNode:copyTo(o)
	if _g.sling.model.LiteralExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MapLiteralExpressionNode')
		if n == nil then
			do return true end
		end
		do
			local array = n.values
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.values = nil
			if self.values ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.values)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.values[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.values == nil then
								n.values = {}
							end
							do _g.jk.lang.Vector:append(n.values, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do return true end
		end
	end
end

function sling.model.MapLiteralExpressionNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.values, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.LiteralExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MapLiteralExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LiteralExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.values, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MapLiteralExpressionNode:destroy()
	do _g.sling.model.LiteralExpressionNode.destroy(self) end
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

function sling.model.MapLiteralExpressionNode:setValues(v, doExport)
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.values = nil
	else
		self.values = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.values, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.MapLiteralExpressionNode:getValues()
	do return self.values end
end

function sling.model.MapLiteralExpressionNode:exportValues()
	local v = self.values
	self.values = nil
	do return v end
end

function sling.model.MapLiteralExpressionNode:addToValues(v)
	if v == nil then
		do return end
	end
	if self.values == nil then
		self.values = {}
	end
	do _g.jk.lang.Vector:append(self.values, v) end
	do v:setParent(self) end
end

function sling.model.MapLiteralExpressionNode:clearValues()
	if self.values ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.values)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.values[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.values = nil
end

sling.model.YieldValueExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.YieldValueExpressionNode.__index = sling.model.YieldValueExpressionNode
_vm:set_metatable(sling.model.YieldValueExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.YieldValueExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.YieldValueExpressionNode)
	return v
end

function sling.model.YieldValueExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.YieldValueExpressionNode'
	self['_isType.sling.model.YieldValueExpressionNode'] = true
end

function sling.model.YieldValueExpressionNode:_construct0()
	sling.model.YieldValueExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.YieldValueExpressionNode:getNodeTypeName()
	do return "YieldValueExpressionNode" end
end

function sling.model.YieldValueExpressionNode:createNew()
	do return _g.sling.model.YieldValueExpressionNode._construct0(_g.sling.model.YieldValueExpressionNode._create()) end
end

function sling.model.YieldValueExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.YieldValueExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.YieldValueExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.YieldValueExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.YieldValueExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.TreeDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.TreeDeclarationNode.__index = sling.model.TreeDeclarationNode
_vm:set_metatable(sling.model.TreeDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.TreeDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.TreeDeclarationNode)
	return v
end

function sling.model.TreeDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.TreeDeclarationNode'
	self['_isType.sling.model.TreeDeclarationNode'] = true
	self.name = nil
	self.root = nil
end

function sling.model.TreeDeclarationNode:_construct0()
	sling.model.TreeDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.TreeDeclarationNode:getNodeTypeName()
	do return "TreeDeclarationNode" end
end

function sling.model.TreeDeclarationNode:createNew()
	do return _g.sling.model.TreeDeclarationNode._construct0(_g.sling.model.TreeDeclarationNode._create()) end
end

function sling.model.TreeDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.TreeDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.root ~= nil then
			do n.root:destroy() end
			n.root = nil
		end
		if self.root ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.root), '_isType.sling.model.TreeElementNode')
			if pcp == nil then
				do return false end
			end
			n.root = pcp
			do n.root:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.TreeDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.root then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.TreeElementNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.root:destroy() end
		end
		self.root = _vm:to_table_with_key(newnode, '_isType.sling.model.TreeElementNode')
		if self.root ~= nil then
			do self.root:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.TreeDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.root ~= nil then
		if self.root:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.TreeDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.root ~= nil then
		do self.root:destroy() end
		self.root = nil
	end
end

function sling.model.TreeDeclarationNode:setRoot(v, doExport)
	if self.root ~= nil and doExport == false then
		do self.root:destroy() end
	end
	self.root = v
	if self.root ~= nil then
		do self.root:setParent(self) end
	end
end

function sling.model.TreeDeclarationNode:getRoot()
	do return self.root end
end

function sling.model.TreeDeclarationNode:exportRoot()
	local v = self.root
	self.root = nil
	do return v end
end

function sling.model.TreeDeclarationNode:setName(v)
	self.name = v
end

function sling.model.TreeDeclarationNode:getName()
	do return self.name end
end

sling.model.BitwiseNotExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.BitwiseNotExpressionNode.__index = sling.model.BitwiseNotExpressionNode
_vm:set_metatable(sling.model.BitwiseNotExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.BitwiseNotExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseNotExpressionNode)
	return v
end

function sling.model.BitwiseNotExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseNotExpressionNode'
	self['_isType.sling.model.BitwiseNotExpressionNode'] = true
end

function sling.model.BitwiseNotExpressionNode:_construct0()
	sling.model.BitwiseNotExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.BitwiseNotExpressionNode:forExpression(expression)
	local v = _g.sling.model.BitwiseNotExpressionNode._construct0(_g.sling.model.BitwiseNotExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.BitwiseNotExpressionNode:getNodeTypeName()
	do return "BitwiseNotExpressionNode" end
end

function sling.model.BitwiseNotExpressionNode:createNew()
	do return _g.sling.model.BitwiseNotExpressionNode._construct0(_g.sling.model.BitwiseNotExpressionNode._create()) end
end

function sling.model.BitwiseNotExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseNotExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseNotExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseNotExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseNotExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.NullCoalescingAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.NullCoalescingAssignmentExpressionNode.__index = sling.model.NullCoalescingAssignmentExpressionNode
_vm:set_metatable(sling.model.NullCoalescingAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.NullCoalescingAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.NullCoalescingAssignmentExpressionNode)
	return v
end

function sling.model.NullCoalescingAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.NullCoalescingAssignmentExpressionNode'
	self['_isType.sling.model.NullCoalescingAssignmentExpressionNode'] = true
end

function sling.model.NullCoalescingAssignmentExpressionNode:_construct0()
	sling.model.NullCoalescingAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.NullCoalescingAssignmentExpressionNode:forExpressions(left, right)
	local v = _g.sling.model.NullCoalescingAssignmentExpressionNode._construct0(_g.sling.model.NullCoalescingAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.NullCoalescingAssignmentExpressionNode:getNodeTypeName()
	do return "NullCoalescingAssignmentExpressionNode" end
end

function sling.model.NullCoalescingAssignmentExpressionNode:createNew()
	do return _g.sling.model.NullCoalescingAssignmentExpressionNode._construct0(_g.sling.model.NullCoalescingAssignmentExpressionNode._create()) end
end

function sling.model.NullCoalescingAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.NullCoalescingAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.NullCoalescingAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.NullCoalescingAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.NullCoalescingAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.SymbolNode = _g.sling.model.NodeObjectWithModifiers._create()
sling.model.SymbolNode.__index = sling.model.SymbolNode
_vm:set_metatable(sling.model.SymbolNode, {
	__index = _g.sling.model.NodeObjectWithModifiers
})

function sling.model.SymbolNode._create()
	local v = _vm:set_metatable({}, sling.model.SymbolNode)
	return v
end

function sling.model.SymbolNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.SymbolNode'
	self['_isType.sling.model.SymbolNode'] = true
	self.components = nil
	self.magical = false
	self.typeParameters = nil
	self.binding = nil
	self.bindingTypemap = nil
end

function sling.model.SymbolNode:_construct0()
	sling.model.SymbolNode._init(self)
	do _g.sling.model.NodeObjectWithModifiers._construct0(self) end
	return self
end

function sling.model.SymbolNode:forBinding(node, typemap)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	do v:setBinding(node, typemap) end
	do return v end
end

function sling.model.SymbolNode:forName(name)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	do v:addToComponents(_g.sling.model.SymbolNameComponentNode:forName(name)) end
	do return v end
end

function sling.model.SymbolNode:forArrayOfNames(names)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	if names ~= nil then
		local n = 0
		local m = #names
		do
			n = 0
			while n < m do
				local name = names[n + 1]
				if name ~= nil then
					do v:addObjectToComponents(name) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.SymbolNode:forVectorOfNames(names)
	local v = _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create())
	if names ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(names)
		do
			n = 0
			while n < m do
				local name = names[n + 1]
				if name ~= nil then
					do v:addObjectToComponents(name) end
				end
				do n = n + 1 end
			end
		end
	end
	do return v end
end

function sling.model.SymbolNode:getBinding()
	do return self.binding end
end

function sling.model.SymbolNode:getBindingTypemap()
	do return self.bindingTypemap end
end

function sling.model.SymbolNode:destroy()
	do _g.sling.model.NodeObjectWithModifiers.destroy(self) end
	do self:setBinding(nil, nil) end
end

function sling.model.SymbolNode:setBinding(binding, typemap)
	self.binding = binding
	if self.bindingTypemap ~= nil then
		do self.bindingTypemap:clear() end
	end
	self.bindingTypemap = (function(a, b, c)
		if a then
			do return b() end
		end
		do return c() end
	end)(typemap, function()
		do return typemap:dup() end
	end, function()
		do return nil end
	end)
end

function sling.model.SymbolNode:copyCustomTo(node)
	do _g.sling.model.NodeObjectWithModifiers.copyCustomTo(self, node) end
	do
		local noth = _vm:to_table_with_key(node, '_isType.sling.model.SymbolNode')
		if noth ~= nil then
			do noth:setBinding(self.binding, self.bindingTypemap) end
		end
		do return true end
	end
end

function sling.model.SymbolNode:addObjectToComponents(obj)
	do self:addToComponents(_g.sling.model.SymbolNameComponentNode:forObject(obj)) end
end

function sling.model.SymbolNode:addNameToComponents(name)
	do self:addToComponents(_g.sling.model.SymbolNameComponentNode:forName(name)) end
end

function sling.model.SymbolNode:getNodeTypeName()
	do return "SymbolNode" end
end

function sling.model.SymbolNode:createNew()
	do return _g.sling.model.SymbolNode._construct0(_g.sling.model.SymbolNode._create()) end
end

function sling.model.SymbolNode:copyTo(o)
	if _g.sling.model.NodeObjectWithModifiers.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.SymbolNode')
		if n == nil then
			do return true end
		end
		n.magical = self.magical
		do
			local array = n.components
			if array ~= nil then
				local n2 = 0
				local m = _g.jk.lang.Vector:getSize(array)
				do
					n2 = 0
					while n2 < m do
						local xx = _vm:to_table_with_key(array[n2 + 1], '_isType.sling.common.NodeObject')
						if xx ~= nil then
							do xx:destroy() end
						end
						do n2 = n2 + 1 end
					end
				end
			end
			n.components = nil
			if self.components ~= nil then
				local n3 = 0
				local m2 = _g.jk.lang.Vector:getSize(self.components)
				do
					n3 = 0
					while n3 < m2 do
						local nod = _vm:to_table_with_key(self.components[n3 + 1], '_isType.sling.common.NodeObject')
						if nod ~= nil then
							local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
							if ndup == nil then
								do return false end
							end
							if n.components == nil then
								n.components = {}
							end
							do _g.jk.lang.Vector:append(n.components, ndup) end
							do ndup:setParent(n) end
						end
						do n3 = n3 + 1 end
					end
				end
			end
			do
				local array2 = n.typeParameters
				if array2 ~= nil then
					local n4 = 0
					local m3 = _g.jk.lang.Vector:getSize(array2)
					do
						n4 = 0
						while n4 < m3 do
							local xx = _vm:to_table_with_key(array2[n4 + 1], '_isType.sling.common.NodeObject')
							if xx ~= nil then
								do xx:destroy() end
							end
							do n4 = n4 + 1 end
						end
					end
				end
				n.typeParameters = nil
				if self.typeParameters ~= nil then
					local n5 = 0
					local m4 = _g.jk.lang.Vector:getSize(self.typeParameters)
					do
						n5 = 0
						while n5 < m4 do
							local nod = _vm:to_table_with_key(self.typeParameters[n5 + 1], '_isType.sling.common.NodeObject')
							if nod ~= nil then
								local ndup = _vm:to_table_with_key(nod:dup(), '_isType.sling.common.NodeObject')
								if ndup == nil then
									do return false end
								end
								if n.typeParameters == nil then
									n.typeParameters = {}
								end
								do _g.jk.lang.Vector:append(n.typeParameters, ndup) end
								do ndup:setParent(n) end
							end
							do n5 = n5 + 1 end
						end
					end
				end
				do return true end
			end
		end
	end
end

function sling.model.SymbolNode:replaceChild(oldnode, newnode, doExport)
	if self:replaceNodeInVector(self.components, oldnode, newnode, doExport) then
		do return true end
	end
	if self:replaceNodeInVector(self.typeParameters, oldnode, newnode, doExport) then
		do return true end
	end
	do return _g.sling.model.NodeObjectWithModifiers.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.SymbolNode:acceptVisitor(visitor)
	if _g.sling.model.NodeObjectWithModifiers.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self:visitVector(self.components, visitor) == false then
		do return false end
	end
	if self:visitVector(self.typeParameters, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.SymbolNode:setMagical(v)
	self.magical = v
end

function sling.model.SymbolNode:getMagical()
	do return self.magical end
end

function sling.model.SymbolNode:setComponents(v, doExport)
	if self.components ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.components)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.components[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.components = nil
	else
		self.components = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.components, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SymbolNode:getComponents()
	do return self.components end
end

function sling.model.SymbolNode:exportComponents()
	local v = self.components
	self.components = nil
	do return v end
end

function sling.model.SymbolNode:addToComponents(v)
	if v == nil then
		do return end
	end
	if self.components == nil then
		self.components = {}
	end
	do _g.jk.lang.Vector:append(self.components, v) end
	do v:setParent(self) end
end

function sling.model.SymbolNode:clearComponents()
	if self.components ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.components)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.components[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.components = nil
end

function sling.model.SymbolNode:setTypeParameters(v, doExport)
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	if v == nil then
		self.typeParameters = nil
	else
		self.typeParameters = {}
		if v ~= nil then
			local n2 = 0
			local m2 = _g.jk.lang.Vector:getSize(v)
			do
				n2 = 0
				while n2 < m2 do
					local vv = _vm:to_table_with_key(v[n2 + 1], '_isType.sling.common.NodeObject')
					if vv ~= nil then
						do _g.jk.lang.Vector:append(self.typeParameters, vv) end
						do vv:setParent(self) end
					end
					do n2 = n2 + 1 end
				end
			end
		end
	end
end

function sling.model.SymbolNode:getTypeParameters()
	do return self.typeParameters end
end

function sling.model.SymbolNode:exportTypeParameters()
	local v = self.typeParameters
	self.typeParameters = nil
	do return v end
end

function sling.model.SymbolNode:addToTypeParameters(v)
	if v == nil then
		do return end
	end
	if self.typeParameters == nil then
		self.typeParameters = {}
	end
	do _g.jk.lang.Vector:append(self.typeParameters, v) end
	do v:setParent(self) end
end

function sling.model.SymbolNode:clearTypeParameters()
	if self.typeParameters ~= nil then
		local n = 0
		local m = _g.jk.lang.Vector:getSize(self.typeParameters)
		do
			n = 0
			while n < m do
				local nx = _vm:to_table_with_key(self.typeParameters[n + 1], '_isType.sling.common.NodeObject')
				if nx ~= nil then
					do nx:destroy() end
				end
				do n = n + 1 end
			end
		end
	end
	self.typeParameters = nil
end

sling.model.ReturnStatementNode = _g.sling.model.ExpressionContainerNode._create()
sling.model.ReturnStatementNode.__index = sling.model.ReturnStatementNode
_vm:set_metatable(sling.model.ReturnStatementNode, {
	__index = _g.sling.model.ExpressionContainerNode
})

function sling.model.ReturnStatementNode._create()
	local v = _vm:set_metatable({}, sling.model.ReturnStatementNode)
	return v
end

function sling.model.ReturnStatementNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.ReturnStatementNode'
	self['_isType.sling.model.ReturnStatementNode'] = true
end

function sling.model.ReturnStatementNode:_construct0()
	sling.model.ReturnStatementNode._init(self)
	do _g.sling.model.ExpressionContainerNode._construct0(self) end
	return self
end

function sling.model.ReturnStatementNode:ifEquals(left, right, rval)
	local eqs = _g.sling.model.EqualsExpressionNode:instance(left, right)
	local block = _g.sling.model.BlockNode._construct0(_g.sling.model.BlockNode._create())
	do block:addNode(_g.sling.model.ReturnStatementNode:forExpression(rval)) end
	do
		local ifs = _g.sling.model.IfStatementNode:instance(eqs, block, nil)
		do return ifs end
	end
end

function sling.model.ReturnStatementNode:forExpression(expression)
	local v = _g.sling.model.ReturnStatementNode._construct0(_g.sling.model.ReturnStatementNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.ReturnStatementNode:getNodeTypeName()
	do return "ReturnStatementNode" end
end

function sling.model.ReturnStatementNode:createNew()
	do return _g.sling.model.ReturnStatementNode._construct0(_g.sling.model.ReturnStatementNode._create()) end
end

function sling.model.ReturnStatementNode:copyTo(o)
	if _g.sling.model.ExpressionContainerNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.ReturnStatementNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.ReturnStatementNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.ExpressionContainerNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.ReturnStatementNode:acceptVisitor(visitor)
	if _g.sling.model.ExpressionContainerNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.ReturnStatementNode:destroy()
	do _g.sling.model.ExpressionContainerNode.destroy(self) end
end

sling.model.LogicalAndExpressionNode = _g.sling.model.LogicalExpressionNode._create()
sling.model.LogicalAndExpressionNode.__index = sling.model.LogicalAndExpressionNode
_vm:set_metatable(sling.model.LogicalAndExpressionNode, {
	__index = _g.sling.model.LogicalExpressionNode
})

function sling.model.LogicalAndExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.LogicalAndExpressionNode)
	return v
end

function sling.model.LogicalAndExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.LogicalAndExpressionNode'
	self['_isType.sling.model.LogicalAndExpressionNode'] = true
end

function sling.model.LogicalAndExpressionNode:_construct0()
	sling.model.LogicalAndExpressionNode._init(self)
	do _g.sling.model.LogicalExpressionNode._construct0(self) end
	return self
end

function sling.model.LogicalAndExpressionNode:instance(left, right)
	local v = _g.sling.model.LogicalAndExpressionNode._construct0(_g.sling.model.LogicalAndExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.LogicalAndExpressionNode:forExpressions(expressions)
	local cs = _g.jk.lang.Vector:getSize(expressions)
	if not (cs > 0) then
		do return nil end
	end
	if cs == 1 then
		do return _vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, 0), '_isType.sling.model.ExpressionNode') end
	end
	do
		local v = _g.sling.model.LogicalAndExpressionNode:instance(_vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, 0), '_isType.sling.model.ExpressionNode'), _vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, 1), '_isType.sling.model.ExpressionNode'))
		do
			local n = 2
			while n < cs do
				v = _g.sling.model.LogicalAndExpressionNode:instance(v, _vm:to_table_with_key(_g.jk.lang.Vector:get(expressions, n), '_isType.sling.model.ExpressionNode'))
				do n = n + 1 end
			end
		end
		do return v end
	end
end

function sling.model.LogicalAndExpressionNode:getNodeTypeName()
	do return "LogicalAndExpressionNode" end
end

function sling.model.LogicalAndExpressionNode:createNew()
	do return _g.sling.model.LogicalAndExpressionNode._construct0(_g.sling.model.LogicalAndExpressionNode._create()) end
end

function sling.model.LogicalAndExpressionNode:copyTo(o)
	if _g.sling.model.LogicalExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.LogicalAndExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.LogicalAndExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.LogicalExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.LogicalAndExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.LogicalExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.LogicalAndExpressionNode:destroy()
	do _g.sling.model.LogicalExpressionNode.destroy(self) end
end

sling.model.PromiseExpressionNode = _g.sling.model.UnaryExpressionNode._create()
sling.model.PromiseExpressionNode.__index = sling.model.PromiseExpressionNode
_vm:set_metatable(sling.model.PromiseExpressionNode, {
	__index = _g.sling.model.UnaryExpressionNode
})

function sling.model.PromiseExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.PromiseExpressionNode)
	return v
end

function sling.model.PromiseExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.PromiseExpressionNode'
	self['_isType.sling.model.PromiseExpressionNode'] = true
end

function sling.model.PromiseExpressionNode:_construct0()
	sling.model.PromiseExpressionNode._init(self)
	do _g.sling.model.UnaryExpressionNode._construct0(self) end
	return self
end

function sling.model.PromiseExpressionNode:forExpression(expression)
	local v = _g.sling.model.PromiseExpressionNode._construct0(_g.sling.model.PromiseExpressionNode._create())
	do v:setExpression(expression, false) end
	do return v end
end

function sling.model.PromiseExpressionNode:getNodeTypeName()
	do return "PromiseExpressionNode" end
end

function sling.model.PromiseExpressionNode:createNew()
	do return _g.sling.model.PromiseExpressionNode._construct0(_g.sling.model.PromiseExpressionNode._create()) end
end

function sling.model.PromiseExpressionNode:copyTo(o)
	if _g.sling.model.UnaryExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.PromiseExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.PromiseExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.UnaryExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.PromiseExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.UnaryExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.PromiseExpressionNode:destroy()
	do _g.sling.model.UnaryExpressionNode.destroy(self) end
end

sling.model.BitwiseOrAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.BitwiseOrAssignmentExpressionNode.__index = sling.model.BitwiseOrAssignmentExpressionNode
_vm:set_metatable(sling.model.BitwiseOrAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.BitwiseOrAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseOrAssignmentExpressionNode)
	return v
end

function sling.model.BitwiseOrAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseOrAssignmentExpressionNode'
	self['_isType.sling.model.BitwiseOrAssignmentExpressionNode'] = true
end

function sling.model.BitwiseOrAssignmentExpressionNode:_construct0()
	sling.model.BitwiseOrAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.BitwiseOrAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseOrAssignmentExpressionNode._construct0(_g.sling.model.BitwiseOrAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseOrAssignmentExpressionNode:getNodeTypeName()
	do return "BitwiseOrAssignmentExpressionNode" end
end

function sling.model.BitwiseOrAssignmentExpressionNode:createNew()
	do return _g.sling.model.BitwiseOrAssignmentExpressionNode._construct0(_g.sling.model.BitwiseOrAssignmentExpressionNode._create()) end
end

function sling.model.BitwiseOrAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseOrAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseOrAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseOrAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseOrAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.MainFunctionDeclarationNode = _g.sling.model.FunctionDeclarationBaseNode._create()
sling.model.MainFunctionDeclarationNode.__index = sling.model.MainFunctionDeclarationNode
_vm:set_metatable(sling.model.MainFunctionDeclarationNode, {
	__index = _g.sling.model.FunctionDeclarationBaseNode
})

function sling.model.MainFunctionDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.MainFunctionDeclarationNode)
	return v
end

function sling.model.MainFunctionDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.MainFunctionDeclarationNode'
	self['_isType.sling.model.MainFunctionDeclarationNode'] = true
end

function sling.model.MainFunctionDeclarationNode:_construct0()
	sling.model.MainFunctionDeclarationNode._init(self)
	do _g.sling.model.FunctionDeclarationBaseNode._construct0(self) end
	return self
end

function sling.model.MainFunctionDeclarationNode:setArgumentArrayName(varName)
	do self:setParameters(nil, false) end
	do self:addToParameters(_g.sling.model.VariableDeclarationNode:instance(_g.sling.model.StaticArrayDataTypeNode:forPrimaryType(_g.sling.model.StringDataTypeNode._construct0(_g.sling.model.StringDataTypeNode._create()), nil), varName, nil)) end
end

function sling.model.MainFunctionDeclarationNode:getArgumentArrayName()
	local pp = _vm:to_table_with_key(self:getParameter(0), '_isType.sling.model.VariableDeclarationNode')
	if not (pp ~= nil) then
		do return nil end
	end
	do return pp:getNodeName() end
end

function sling.model.MainFunctionDeclarationNode:getNodeTypeName()
	do return "MainFunctionDeclarationNode" end
end

function sling.model.MainFunctionDeclarationNode:createNew()
	do return _g.sling.model.MainFunctionDeclarationNode._construct0(_g.sling.model.MainFunctionDeclarationNode._create()) end
end

function sling.model.MainFunctionDeclarationNode:copyTo(o)
	if _g.sling.model.FunctionDeclarationBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.MainFunctionDeclarationNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.MainFunctionDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FunctionDeclarationBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.MainFunctionDeclarationNode:acceptVisitor(visitor)
	if _g.sling.model.FunctionDeclarationBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.MainFunctionDeclarationNode:destroy()
	do _g.sling.model.FunctionDeclarationBaseNode.destroy(self) end
end

sling.model.IntegerDataTypeNode = _g.sling.model.PrimitiveDataTypeNode._create()
sling.model.IntegerDataTypeNode.__index = sling.model.IntegerDataTypeNode
_vm:set_metatable(sling.model.IntegerDataTypeNode, {
	__index = _g.sling.model.PrimitiveDataTypeNode
})

sling.model.IntegerDataTypeNode.TYPE_INT32 = 0
sling.model.IntegerDataTypeNode.TYPE_UINT32 = 1
sling.model.IntegerDataTypeNode.TYPE_INT8 = 2
sling.model.IntegerDataTypeNode.TYPE_UINT8 = 3
sling.model.IntegerDataTypeNode.TYPE_INT16 = 4
sling.model.IntegerDataTypeNode.TYPE_UINT16 = 5
sling.model.IntegerDataTypeNode.TYPE_INT64 = 6
sling.model.IntegerDataTypeNode.TYPE_UINT64 = 7
sling.model.IntegerDataTypeNode.TYPE_ANY = 99

function sling.model.IntegerDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.IntegerDataTypeNode)
	return v
end

function sling.model.IntegerDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.IntegerDataTypeNode'
	self['_isType.sling.model.IntegerDataTypeNode'] = true
	self.type = 0
end

function sling.model.IntegerDataTypeNode:_construct0()
	sling.model.IntegerDataTypeNode._init(self)
	do _g.sling.model.PrimitiveDataTypeNode._construct0(self) end
	return self
end

function sling.model.IntegerDataTypeNode:forType(type)
	local v = _g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create())
	do v:setType(type) end
	do return v end
end

function sling.model.IntegerDataTypeNode:getNodeTypeName()
	do return "IntegerDataTypeNode" end
end

function sling.model.IntegerDataTypeNode:createNew()
	do return _g.sling.model.IntegerDataTypeNode._construct0(_g.sling.model.IntegerDataTypeNode._create()) end
end

function sling.model.IntegerDataTypeNode:copyTo(o)
	if _g.sling.model.PrimitiveDataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.IntegerDataTypeNode')
		if n == nil then
			do return true end
		end
		n.type = self.type
		do return true end
	end
end

function sling.model.IntegerDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.PrimitiveDataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.IntegerDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.PrimitiveDataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.IntegerDataTypeNode:destroy()
	do _g.sling.model.PrimitiveDataTypeNode.destroy(self) end
end

function sling.model.IntegerDataTypeNode:setType(v)
	self.type = v
end

function sling.model.IntegerDataTypeNode:getType()
	do return self.type end
end

sling.model.BitwiseXorAssignmentExpressionNode = _g.sling.model.AssignmentExpressionBaseNode._create()
sling.model.BitwiseXorAssignmentExpressionNode.__index = sling.model.BitwiseXorAssignmentExpressionNode
_vm:set_metatable(sling.model.BitwiseXorAssignmentExpressionNode, {
	__index = _g.sling.model.AssignmentExpressionBaseNode
})

function sling.model.BitwiseXorAssignmentExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.BitwiseXorAssignmentExpressionNode)
	return v
end

function sling.model.BitwiseXorAssignmentExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.BitwiseXorAssignmentExpressionNode'
	self['_isType.sling.model.BitwiseXorAssignmentExpressionNode'] = true
end

function sling.model.BitwiseXorAssignmentExpressionNode:_construct0()
	sling.model.BitwiseXorAssignmentExpressionNode._init(self)
	do _g.sling.model.AssignmentExpressionBaseNode._construct0(self) end
	return self
end

function sling.model.BitwiseXorAssignmentExpressionNode:instance(left, right)
	local v = _g.sling.model.BitwiseXorAssignmentExpressionNode._construct0(_g.sling.model.BitwiseXorAssignmentExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.BitwiseXorAssignmentExpressionNode:getNodeTypeName()
	do return "BitwiseXorAssignmentExpressionNode" end
end

function sling.model.BitwiseXorAssignmentExpressionNode:createNew()
	do return _g.sling.model.BitwiseXorAssignmentExpressionNode._construct0(_g.sling.model.BitwiseXorAssignmentExpressionNode._create()) end
end

function sling.model.BitwiseXorAssignmentExpressionNode:copyTo(o)
	if _g.sling.model.AssignmentExpressionBaseNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.BitwiseXorAssignmentExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.BitwiseXorAssignmentExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.AssignmentExpressionBaseNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.BitwiseXorAssignmentExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.AssignmentExpressionBaseNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.BitwiseXorAssignmentExpressionNode:destroy()
	do _g.sling.model.AssignmentExpressionBaseNode.destroy(self) end
end

sling.model.UnknownDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.UnknownDataTypeNode.__index = sling.model.UnknownDataTypeNode
_vm:set_metatable(sling.model.UnknownDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.UnknownDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.UnknownDataTypeNode)
	return v
end

function sling.model.UnknownDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.UnknownDataTypeNode'
	self['_isType.sling.model.UnknownDataTypeNode'] = true
end

function sling.model.UnknownDataTypeNode:_construct0()
	sling.model.UnknownDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.UnknownDataTypeNode:getNodeTypeName()
	do return "UnknownDataTypeNode" end
end

function sling.model.UnknownDataTypeNode:createNew()
	do return _g.sling.model.UnknownDataTypeNode._construct0(_g.sling.model.UnknownDataTypeNode._create()) end
end

function sling.model.UnknownDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.UnknownDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.UnknownDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.UnknownDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.UnknownDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.DependencyDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.DependencyDeclarationNode.__index = sling.model.DependencyDeclarationNode
_vm:set_metatable(sling.model.DependencyDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.DependencyDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.DependencyDeclarationNode)
	return v
end

function sling.model.DependencyDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.DependencyDeclarationNode'
	self['_isType.sling.model.DependencyDeclarationNode'] = true
	self.value = nil
end

function sling.model.DependencyDeclarationNode:_construct0()
	sling.model.DependencyDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.DependencyDeclarationNode:getNodeTypeName()
	do return "DependencyDeclarationNode" end
end

function sling.model.DependencyDeclarationNode:createNew()
	do return _g.sling.model.DependencyDeclarationNode._construct0(_g.sling.model.DependencyDeclarationNode._create()) end
end

function sling.model.DependencyDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.DependencyDeclarationNode')
		if n == nil then
			do return true end
		end
		n.value = self.value
		do return true end
	end
end

function sling.model.DependencyDeclarationNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.DependencyDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.DependencyDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
end

function sling.model.DependencyDeclarationNode:setValue(v)
	self.value = v
end

function sling.model.DependencyDeclarationNode:getValue()
	do return self.value end
end

sling.model.FileSystemBinaryFileReferenceExpressionNode = _g.sling.model.FileSystemReferenceExpressionNode._create()
sling.model.FileSystemBinaryFileReferenceExpressionNode.__index = sling.model.FileSystemBinaryFileReferenceExpressionNode
_vm:set_metatable(sling.model.FileSystemBinaryFileReferenceExpressionNode, {
	__index = _g.sling.model.FileSystemReferenceExpressionNode
})

function sling.model.FileSystemBinaryFileReferenceExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.FileSystemBinaryFileReferenceExpressionNode)
	return v
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.FileSystemBinaryFileReferenceExpressionNode'
	self['_isType.sling.model.FileSystemBinaryFileReferenceExpressionNode'] = true
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:_construct0()
	sling.model.FileSystemBinaryFileReferenceExpressionNode._init(self)
	do _g.sling.model.FileSystemReferenceExpressionNode._construct0(self) end
	return self
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:getNodeTypeName()
	do return "FileSystemBinaryFileReferenceExpressionNode" end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:createNew()
	do return _g.sling.model.FileSystemBinaryFileReferenceExpressionNode._construct0(_g.sling.model.FileSystemBinaryFileReferenceExpressionNode._create()) end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:copyTo(o)
	if _g.sling.model.FileSystemReferenceExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.FileSystemBinaryFileReferenceExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.FileSystemReferenceExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.FileSystemReferenceExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.FileSystemBinaryFileReferenceExpressionNode:destroy()
	do _g.sling.model.FileSystemReferenceExpressionNode.destroy(self) end
end

sling.model.OptionalDataTypeNode = _g.sling.model.DataTypeExtenderNode._create()
sling.model.OptionalDataTypeNode.__index = sling.model.OptionalDataTypeNode
_vm:set_metatable(sling.model.OptionalDataTypeNode, {
	__index = _g.sling.model.DataTypeExtenderNode
})

sling.model.OptionalDataTypeNode.EXPLICIT_UNWRAPPING = 0
sling.model.OptionalDataTypeNode.IMPLICIT_UNWRAPPING = 1

function sling.model.OptionalDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.OptionalDataTypeNode)
	return v
end

function sling.model.OptionalDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.OptionalDataTypeNode'
	self['_isType.sling.model.OptionalDataTypeNode'] = true
	self.unwrappingMethod = 0
end

function sling.model.OptionalDataTypeNode:_construct0()
	sling.model.OptionalDataTypeNode._init(self)
	do _g.sling.model.DataTypeExtenderNode._construct0(self) end
	return self
end

function sling.model.OptionalDataTypeNode:forPrimaryType(type)
	local v = _g.sling.model.OptionalDataTypeNode._construct0(_g.sling.model.OptionalDataTypeNode._create())
	do v:setPrimaryType(type, false) end
	do return v end
end

function sling.model.OptionalDataTypeNode:getNodeTypeName()
	do return "OptionalDataTypeNode" end
end

function sling.model.OptionalDataTypeNode:createNew()
	do return _g.sling.model.OptionalDataTypeNode._construct0(_g.sling.model.OptionalDataTypeNode._create()) end
end

function sling.model.OptionalDataTypeNode:copyTo(o)
	if _g.sling.model.DataTypeExtenderNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.OptionalDataTypeNode')
		if n == nil then
			do return true end
		end
		n.unwrappingMethod = self.unwrappingMethod
		do return true end
	end
end

function sling.model.OptionalDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.DataTypeExtenderNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.OptionalDataTypeNode:acceptVisitor(visitor)
	if _g.sling.model.DataTypeExtenderNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.OptionalDataTypeNode:destroy()
	do _g.sling.model.DataTypeExtenderNode.destroy(self) end
end

function sling.model.OptionalDataTypeNode:setUnwrappingMethod(v)
	self.unwrappingMethod = v
end

function sling.model.OptionalDataTypeNode:getUnwrappingMethod()
	do return self.unwrappingMethod end
end

sling.model.StyleSheetRulePropertyNode = _g.sling.common.NodeObject._create()
sling.model.StyleSheetRulePropertyNode.__index = sling.model.StyleSheetRulePropertyNode
_vm:set_metatable(sling.model.StyleSheetRulePropertyNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.StyleSheetRulePropertyNode._create()
	local v = _vm:set_metatable({}, sling.model.StyleSheetRulePropertyNode)
	return v
end

function sling.model.StyleSheetRulePropertyNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StyleSheetRulePropertyNode'
	self['_isType.sling.model.StyleSheetRulePropertyNode'] = true
	self.name = nil
	self.value = nil
end

function sling.model.StyleSheetRulePropertyNode:_construct0()
	sling.model.StyleSheetRulePropertyNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.StyleSheetRulePropertyNode:instance(name, value)
	local v = _g.sling.model.StyleSheetRulePropertyNode._construct0(_g.sling.model.StyleSheetRulePropertyNode._create())
	do v:setName(name) end
	do v:setValue(value, false) end
	do return v end
end

function sling.model.StyleSheetRulePropertyNode:getNodeTypeName()
	do return "StyleSheetRulePropertyNode" end
end

function sling.model.StyleSheetRulePropertyNode:createNew()
	do return _g.sling.model.StyleSheetRulePropertyNode._construct0(_g.sling.model.StyleSheetRulePropertyNode._create()) end
end

function sling.model.StyleSheetRulePropertyNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StyleSheetRulePropertyNode')
		if n == nil then
			do return true end
		end
		if n.value ~= nil then
			do n.value:destroy() end
			n.value = nil
		end
		if self.value ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.value), '_isType.sling.model.ExpressionNode')
			if pcp == nil then
				do return false end
			end
			n.value = pcp
			do n.value:setParent(n) end
		end
		n.name = self.name
		do return true end
	end
end

function sling.model.StyleSheetRulePropertyNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.value then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.value:destroy() end
		end
		self.value = _vm:to_table_with_key(newnode, '_isType.sling.model.ExpressionNode')
		if self.value ~= nil then
			do self.value:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StyleSheetRulePropertyNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.value ~= nil then
		if self.value:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.StyleSheetRulePropertyNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.value ~= nil then
		do self.value:destroy() end
		self.value = nil
	end
end

function sling.model.StyleSheetRulePropertyNode:setValue(v, doExport)
	if self.value ~= nil and doExport == false then
		do self.value:destroy() end
	end
	self.value = v
	if self.value ~= nil then
		do self.value:setParent(self) end
	end
end

function sling.model.StyleSheetRulePropertyNode:getValue()
	do return self.value end
end

function sling.model.StyleSheetRulePropertyNode:exportValue()
	local v = self.value
	self.value = nil
	do return v end
end

function sling.model.StyleSheetRulePropertyNode:setName(v)
	self.name = v
end

function sling.model.StyleSheetRulePropertyNode:getName()
	do return self.name end
end

sling.model.RangeDataTypeNode = _g.sling.common.DataTypeNode._create()
sling.model.RangeDataTypeNode.__index = sling.model.RangeDataTypeNode
_vm:set_metatable(sling.model.RangeDataTypeNode, {
	__index = _g.sling.common.DataTypeNode
})

function sling.model.RangeDataTypeNode._create()
	local v = _vm:set_metatable({}, sling.model.RangeDataTypeNode)
	return v
end

function sling.model.RangeDataTypeNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.RangeDataTypeNode'
	self['_isType.sling.model.RangeDataTypeNode'] = true
end

function sling.model.RangeDataTypeNode:_construct0()
	sling.model.RangeDataTypeNode._init(self)
	do _g.sling.common.DataTypeNode._construct0(self) end
	return self
end

function sling.model.RangeDataTypeNode:getNodeTypeName()
	do return "RangeDataTypeNode" end
end

function sling.model.RangeDataTypeNode:createNew()
	do return _g.sling.model.RangeDataTypeNode._construct0(_g.sling.model.RangeDataTypeNode._create()) end
end

function sling.model.RangeDataTypeNode:copyTo(o)
	if _g.sling.common.DataTypeNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.RangeDataTypeNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.RangeDataTypeNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.common.DataTypeNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.RangeDataTypeNode:acceptVisitor(visitor)
	if _g.sling.common.DataTypeNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.RangeDataTypeNode:destroy()
	do _g.sling.common.DataTypeNode.destroy(self) end
end

sling.model.StrictEqualsExpressionNode = _g.sling.model.EqualityComparisonExpressionNode._create()
sling.model.StrictEqualsExpressionNode.__index = sling.model.StrictEqualsExpressionNode
_vm:set_metatable(sling.model.StrictEqualsExpressionNode, {
	__index = _g.sling.model.EqualityComparisonExpressionNode
})

function sling.model.StrictEqualsExpressionNode._create()
	local v = _vm:set_metatable({}, sling.model.StrictEqualsExpressionNode)
	return v
end

function sling.model.StrictEqualsExpressionNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.StrictEqualsExpressionNode'
	self['_isType.sling.model.StrictEqualsExpressionNode'] = true
end

function sling.model.StrictEqualsExpressionNode:_construct0()
	sling.model.StrictEqualsExpressionNode._init(self)
	do _g.sling.model.EqualityComparisonExpressionNode._construct0(self) end
	return self
end

function sling.model.StrictEqualsExpressionNode:instance(left, right)
	local v = _g.sling.model.StrictEqualsExpressionNode._construct0(_g.sling.model.StrictEqualsExpressionNode._create())
	do v:setLeft(left, false) end
	do v:setRight(right, false) end
	do return v end
end

function sling.model.StrictEqualsExpressionNode:getNodeTypeName()
	do return "StrictEqualsExpressionNode" end
end

function sling.model.StrictEqualsExpressionNode:createNew()
	do return _g.sling.model.StrictEqualsExpressionNode._construct0(_g.sling.model.StrictEqualsExpressionNode._create()) end
end

function sling.model.StrictEqualsExpressionNode:copyTo(o)
	if _g.sling.model.EqualityComparisonExpressionNode.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.StrictEqualsExpressionNode')
		if n == nil then
			do return true end
		end
		do return true end
	end
end

function sling.model.StrictEqualsExpressionNode:replaceChild(oldnode, newnode, doExport)
	do return _g.sling.model.EqualityComparisonExpressionNode.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.StrictEqualsExpressionNode:acceptVisitor(visitor)
	if _g.sling.model.EqualityComparisonExpressionNode.acceptVisitor(self, visitor) == false then
		do return false end
	end
	do return true end
end

function sling.model.StrictEqualsExpressionNode:destroy()
	do _g.sling.model.EqualityComparisonExpressionNode.destroy(self) end
end

sling.model.InitializerBlockDeclarationNode = _g.sling.common.NodeObject._create()
sling.model.InitializerBlockDeclarationNode.__index = sling.model.InitializerBlockDeclarationNode
_vm:set_metatable(sling.model.InitializerBlockDeclarationNode, {
	__index = _g.sling.common.NodeObject
})

function sling.model.InitializerBlockDeclarationNode._create()
	local v = _vm:set_metatable({}, sling.model.InitializerBlockDeclarationNode)
	return v
end

function sling.model.InitializerBlockDeclarationNode:_init()
	self._isClassInstance = true
	self._qualifiedClassName = self._qualifiedClassName or 'sling.model.InitializerBlockDeclarationNode'
	self['_isType.sling.model.InitializerBlockDeclarationNode'] = true
	self.block = nil
end

function sling.model.InitializerBlockDeclarationNode:_construct0()
	sling.model.InitializerBlockDeclarationNode._init(self)
	do _g.sling.common.NodeObject._construct0(self) end
	return self
end

function sling.model.InitializerBlockDeclarationNode:forBlock(block)
	local v = _g.sling.model.InitializerBlockDeclarationNode._construct0(_g.sling.model.InitializerBlockDeclarationNode._create())
	do v:setBlock(block, false) end
	do return v end
end

function sling.model.InitializerBlockDeclarationNode:getNodeTypeName()
	do return "InitializerBlockDeclarationNode" end
end

function sling.model.InitializerBlockDeclarationNode:createNew()
	do return _g.sling.model.InitializerBlockDeclarationNode._construct0(_g.sling.model.InitializerBlockDeclarationNode._create()) end
end

function sling.model.InitializerBlockDeclarationNode:copyTo(o)
	if _g.sling.common.NodeObject.copyTo(self, o) == false then
		do return false end
	end
	do
		local n = _vm:to_table_with_key(o, '_isType.sling.model.InitializerBlockDeclarationNode')
		if n == nil then
			do return true end
		end
		if n.block ~= nil then
			do n.block:destroy() end
			n.block = nil
		end
		if self.block ~= nil then
			local pcp = _vm:to_table_with_key(_g.sling.common.NodeObject:dupNode(self.block), '_isType.sling.model.BlockNode')
			if pcp == nil then
				do return false end
			end
			n.block = pcp
			do n.block:setParent(n) end
		end
		do return true end
	end
end

function sling.model.InitializerBlockDeclarationNode:replaceChild(oldnode, newnode, doExport)
	if oldnode == self.block then
		if newnode ~= nil and (_vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode') ~= nil) == false then
			do return false end
		end
		if doExport == false then
			do self.block:destroy() end
		end
		self.block = _vm:to_table_with_key(newnode, '_isType.sling.model.BlockNode')
		if self.block ~= nil then
			do self.block:setParent(self) end
		end
		do return true end
	end
	do return _g.sling.common.NodeObject.replaceChild(self, oldnode, newnode, doExport) end
end

function sling.model.InitializerBlockDeclarationNode:acceptVisitor(visitor)
	if _g.sling.common.NodeObject.acceptVisitor(self, visitor) == false then
		do return false end
	end
	if self.block ~= nil then
		if self.block:accept(visitor) == false then
			do return false end
		end
	end
	do return true end
end

function sling.model.InitializerBlockDeclarationNode:destroy()
	do _g.sling.common.NodeObject.destroy(self) end
	if self.block ~= nil then
		do self.block:destroy() end
		self.block = nil
	end
end

function sling.model.InitializerBlockDeclarationNode:setBlock(v, doExport)
	if self.block ~= nil and doExport == false then
		do self.block:destroy() end
	end
	self.block = v
	if self.block ~= nil then
		do self.block:setParent(self) end
	end
end

function sling.model.InitializerBlockDeclarationNode:getBlock()
	do return self.block end
end

function sling.model.InitializerBlockDeclarationNode:exportBlock()
	local v = self.block
	self.block = nil
	do return v end
end
